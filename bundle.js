require=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// TODO remove me when babel-plugin-add-module-exports works right
module.exports = require('./sequins').default;

},{"./sequins":2}],2:[function(require,module,exports){
(function (global){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Seq = Seq;
exports.isCollection = isMutableCollection;
exports.isKeyed = isMutableKeyed;
exports.isIndexed = isMutableIndexed;
exports.isAssociative = isMutableAssociative;
exports.isSeq = isMutableSeq;
exports.isList = isMutableList;
exports.isMap = isMutableMap;
exports.isSet = isMutableSet;
exports.Range = Range;
exports.Repeat = Repeat;
exports.get = get;
exports.set = set;
exports.has = has;
exports.keys = keys$1;
exports.values = values;
exports.entries = entries$1;
exports.NativeSet = exports.NativeMap = exports.Set = exports.Map = exports.List = exports.SetSequence = exports.KeyedSequence = exports.IndexedSequence = exports.default = void 0;

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _invariant = _interopRequireDefault(require("invariant"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _concat2 = _interopRequireDefault(require("iter-tools/es5/concat"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _reduce = _interopRequireDefault(require("iter-tools/es5/reduce"));

var _stable = _interopRequireDefault(require("stable"));

var _zipAll = _interopRequireDefault(require("iter-tools/es5/zip-all"));

var _zip = _interopRequireDefault(require("iter-tools/es5/zip"));

var _size = _interopRequireDefault(require("iter-tools/es5/size"));

var _filter2 = _interopRequireDefault(require("iter-tools/es5/filter"));

var _keys = _interopRequireDefault(require("iter-tools/es5/keys"));

var _slice2 = _interopRequireDefault(require("iter-tools/es5/slice"));

require("iter-tools/es5/compose");

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _map2 = _interopRequireDefault(require("iter-tools/es5/map"));

var _tap2 = _interopRequireDefault(require("iter-tools/es5/tap"));

var _interpose2 = _interopRequireDefault(require("iter-tools/es5/interpose"));

var _range = _interopRequireDefault(require("iter-tools/es5/range"));

var _entries = _interopRequireDefault(require("iter-tools/es5/entries"));

var _flat = _interopRequireDefault(require("iter-tools/es5/flat"));

var _repeat = _interopRequireDefault(require("iter-tools/es5/repeat"));

function isImmutableCollection(shape) {
  return !!shape['@@__IMMUTABLE_ITERABLE__@@'];
}

function isImmutableRecord(shape) {
  return !!shape['@@__IMMUTABLE_RECORD__@@'];
}

function isImmutable(shape) {
  return isImmutableCollection(shape) || isImmutableRecord(shape);
}

function isMutableCollection(shape) {
  return !!shape['@@__MUTABLE_COLLECTION__@@'];
}

function isMutableSeq(shape) {
  return !!shape['@@__MUTABLE_SEQUENCE__@@'];
}

function isCollection(shape) {
  return isImmutableCollection(shape) || isMutableCollection(shape);
}

function isNative(shape) {
  return isNativeKeyed(shape) || isNativeSet(shape);
} // Impl. borrowed from immutable, Copyright (c) 2014-present, Facebook, Inc.


function isPlainObj(shape) {
  return !shape[Symbol.iterator] && shape.constructor === Object || shape.constructor === undefined;
}

function isDataStructure(shape) {
  return isFancyDataStructure(shape) || isNative(shape) || Array.isArray(shape) || isPlainObj(shape);
}

function isFancyDataStructure(shape) {
  return isMutableCollection(shape) || isImmutable(shape);
}

function isModernDataStructure(shape) {
  return isFancyDataStructure(shape) || isNative(shape);
}

function isMutableConcreteish(shape) {
  return !!shape['@@__MUTABLE_COLLECTION__@@'] && !shape['@@__MUTABLE_SEQUENCE__@@'];
}

function isMutableList(shape) {
  return isMutableConcreteish(shape) && isMutableIndexed(shape);
}

function isMutableMap(shape) {
  return isMutableConcreteish(shape) && isMutableKeyed(shape);
}

function isMutableSet(shape) {
  return isMutableConcreteish(shape) && !isMutableAssociative(shape);
}

function isImmutableIndexed(shape) {
  return !!shape['@@__IMMUTABLE_INDEXED__@@'];
}

function isImmutableKeyed(shape) {
  return !!shape['@@__IMMUTABLE_KEYED__@@'];
}

function isNativeSet(shape) {
  return shape instanceof Set;
}

function isNativeKeyed(shape) {
  return shape instanceof Map;
}

function isMutableIndexed(shape) {
  return !!shape['@@__MUTABLE_INDEXED__@@'];
}

function isMutableKeyed(shape) {
  return !!shape['@@__MUTABLE_KEYED__@@'];
}

function isMutableAssociative(shape) {
  return isMutableIndexed(shape) || isMutableKeyed(shape);
}

function isIndexed(shape) {
  return Array.isArray(shape) || isMutableIndexed(shape) || isImmutableIndexed(shape);
}

function isKeyed(shape) {
  return isNativeKeyed(shape) || isMutableKeyed(shape) || isImmutableKeyed(shape);
}

var Namespace =
/*#__PURE__*/
function () {
  function Namespace() {
    (0, _classCallCheck2.default)(this, Namespace);
  }

  (0, _createClass2.default)(Namespace, [{
    key: "__get",
    value: function __get(key) {
      var _key = "_".concat(key);

      (0, _invariant.default)(this.hasOwnProperty(_key), 'Tried to access member %s of %s, but no such member was registered yet. The module include order was likely wrong.', key, this.__description);
      return this[_key];
    }
  }, {
    key: "__description",
    get: function get() {
      return 'namespace';
    }
  }]);
  return Namespace;
}();

var RootNamespace =
/*#__PURE__*/
function (_Namespace) {
  (0, _inherits2.default)(RootNamespace, _Namespace);

  function RootNamespace() {
    (0, _classCallCheck2.default)(this, RootNamespace);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(RootNamespace).apply(this, arguments));
  }

  (0, _createClass2.default)(RootNamespace, [{
    key: "__register",
    value: function __register(collectionType, NestedNamespace) {
      return this["_".concat(collectionType)] = NestedNamespace;
    }
  }, {
    key: "__description",
    get: function get() {
      return 'the root namespace';
    }
  }, {
    key: "Concrete",
    get: function get() {
      return this.__get('Concrete');
    }
  }, {
    key: "Sequence",
    get: function get() {
      return this.__get('Sequence');
    }
  }]);
  return RootNamespace;
}(Namespace);

var SubtypeNamespace =
/*#__PURE__*/
function (_Namespace2) {
  (0, _inherits2.default)(SubtypeNamespace, _Namespace2);

  function SubtypeNamespace() {
    (0, _classCallCheck2.default)(this, SubtypeNamespace);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(SubtypeNamespace).apply(this, arguments));
  }

  (0, _createClass2.default)(SubtypeNamespace, [{
    key: "__register",
    value: function __register(collectionSubtype, CollectionConstructor) {
      return this["_".concat(collectionSubtype)] = CollectionConstructor;
    }
  }, {
    key: "Duplicated",
    get: function get() {
      return this.__get('Duplicated');
    }
  }, {
    key: "Indexed",
    get: function get() {
      return this.__get('Indexed');
    }
  }, {
    key: "Keyed",
    get: function get() {
      return this.__get('Keyed');
    }
  }]);
  return SubtypeNamespace;
}(Namespace);

function makeKey(collectionSubtype, collectionType) {
  return "".concat(collectionSubtype, "__").concat(collectionType);
}

function memoizeFactory(factory) {
  var results = Object.create(null);
  return function memoizedFactory(Collection) {
    for (var _len = arguments.length, dynamicArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      dynamicArgs[_key - 1] = arguments[_key];
    }

    var key = makeKey.apply(void 0, dynamicArgs);

    if (!results[key]) {
      results[key] = factory.apply(void 0, [Collection].concat(dynamicArgs));
    }

    return results[key];
  };
}

function makeConcat(Collection, collectionType, collectionSubtype) {
  var SequenceConstructor = Collection.Sequence[collectionSubtype];
  return function concat(iterable) {
    for (var _len = arguments.length, iterables = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      iterables[_key - 1] = arguments[_key];
    }

    return _concat2.default.apply(void 0, [iterable].concat((0, _toConsumableArray2.default)(iterables.map(function (iterable) {
      return new SequenceConstructor(iterable);
    }))));
  };
}

var concat$1 = memoizeFactory(makeConcat);
var reflect = Object.freeze({
  Duplicated: {
    NativeConstructor: Set,
    itemValue: function itemValue(item) {
      return item;
    },
    primitiveIterator: function primitiveIterator(collection) {
      return collection.values();
    }
  },
  Indexed: {
    NativeConstructor: Array,
    itemValue: function itemValue(item) {
      return item;
    },
    primitiveIterator: function primitiveIterator(collection) {
      return collection.values();
    }
  },
  Keyed: {
    NativeConstructor: Map,
    itemValue: function itemValue(item) {
      return item[1];
    },
    primitiveIterator: function primitiveIterator(collection) {
      return collection.entries();
    }
  }
});

function makeFlatten(Collection, collectionType$$1, collectionSubtype) {
  var _reflect$collectionSu = reflect[collectionSubtype],
      itemValue = _reflect$collectionSu.itemValue,
      primitiveIterator = _reflect$collectionSu.primitiveIterator;
  return (
    /*#__PURE__*/
    _regenerator.default.mark(function flatten(iterable) {
      var shallowOrDepth,
          depth,
          _iteratorNormalCompletion,
          _didIteratorError,
          _iteratorError,
          _iterator,
          _step,
          item,
          value,
          _args = arguments;

      return _regenerator.default.wrap(function flatten$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              shallowOrDepth = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;
              depth = Number(shallowOrDepth);
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              _context.prev = 5;
              _iterator = iterable[Symbol.iterator]();

            case 7:
              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                _context.next = 23;
                break;
              }

              item = _step.value;
              value = itemValue(item);

              if (!(!value || !isMutableCollection(value))) {
                _context.next = 15;
                break;
              }

              _context.next = 13;
              return item;

            case 13:
              _context.next = 20;
              break;

            case 15:
              if (!(depth !== 1)) {
                _context.next = 19;
                break;
              }

              return _context.delegateYield(flatten(primitiveIterator(value), depth === 0 ? 0 : depth - 1), "t0", 17);

            case 17:
              _context.next = 20;
              break;

            case 19:
              return _context.delegateYield(primitiveIterator(value), "t1", 20);

            case 20:
              _iteratorNormalCompletion = true;
              _context.next = 7;
              break;

            case 23:
              _context.next = 29;
              break;

            case 25:
              _context.prev = 25;
              _context.t2 = _context["catch"](5);
              _didIteratorError = true;
              _iteratorError = _context.t2;

            case 29:
              _context.prev = 29;
              _context.prev = 30;

              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }

            case 32:
              _context.prev = 32;

              if (!_didIteratorError) {
                _context.next = 35;
                break;
              }

              throw _iteratorError;

            case 35:
              return _context.finish(32);

            case 36:
              return _context.finish(29);

            case 37:
            case "end":
              return _context.stop();
          }
        }
      }, flatten, this, [[5, 25, 29, 37], [30,, 32, 36]]);
    })
  );
}

var flatten = memoizeFactory(makeFlatten);

function makePush(Collection, collectionType, collectionSubtype) {
  if (collectionSubtype === 'Indexed') {
    return function (collection, _, value) {
      return collection.push(value);
    };
  } else if (collectionSubtype === 'Keyed') {
    return function (collection, key, value) {
      return collection.set(key, value);
    };
  } else {
    return function (collection, _, value) {
      return collection.add(value);
    };
  }
}

var makePush$1 = memoizeFactory(makePush);
var reduceByType = {
  Duplicated: function reduce(iterable, reducer, initial) {
    var setReducer = function setReducer(acc, item) {
      return reducer(acc, item, item);
    };

    var reduced;

    if (arguments.length > 2) {
      reduced = (0, _reduce.default)(initial, setReducer, iterable);
    } else {
      reduced = (0, _reduce.default)(setReducer, iterable);
    }

    return reduced;
  },
  Indexed: function reduce(iterable, reducer, initial) {
    var reduced;

    if (arguments.length > 2) {
      reduced = (0, _reduce.default)(initial, reducer, iterable);
    } else {
      reduced = (0, _reduce.default)(reducer, iterable);
    }

    return reduced;
  },
  Keyed: function reduce(iterable, reducer, initial) {
    var invocations = 0;
    var hasInitial = arguments.length > 2;
    var reduced;

    var keyedReducer = function keyedReducer(acc, _ref) {
      var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
          key = _ref2[0],
          value = _ref2[1];

      if (invocations++ === 0 && !hasInitial) {
        acc = acc[1];
      }

      return reducer(acc, value, key);
    };

    if (hasInitial) {
      reduced = (0, _reduce.default)(initial, keyedReducer, iterable);
    } else {
      reduced = (0, _reduce.default)(keyedReducer, iterable);
    }

    return reduced;
  }
};

function makeReduce(Collection, collectionType, collectionSubtype) {
  return reduceByType[collectionSubtype];
}

function makeGroupBy(Collection, collectionType, collectionSubtype) {
  var concreteType = collectionType === 'Sequence' ? 'Concrete' : collectionType;
  var CollectionConstructor = Collection[collectionType][collectionSubtype];
  var ConcreteCollectionConstructor = Collection[concreteType][collectionSubtype];
  var Map = Collection.Concrete.Keyed;
  var push = makePush$1.apply(void 0, arguments);
  var reduce = makeReduce.apply(void 0, arguments);
  return function groupBy(collection, grouper) {
    var map = reduce(collection, function (result, value, key) {
      var groupKey = grouper(value, key);

      if (!result.get(groupKey)) {
        var concrete = new ConcreteCollectionConstructor();
        result.set(groupKey, concrete);
      }

      push(result.get(groupKey), key, value);
      return result;
    }, new Map());
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = map.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var key = _step.value;
        map.set(key, new CollectionConstructor(map.get(key)));
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return map;
  };
}

var groupBy = memoizeFactory(makeGroupBy);

function ensureArray(iterable) {
  return Array.isArray(iterable) ? iterable : Array.from(iterable);
}

var defaultComparator = function defaultComparator(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
};

function makeSort(Collection, collectionType, collectionSubtype) {
  var _reflect$collectionSu = reflect[collectionSubtype],
      itemValue = _reflect$collectionSu.itemValue,
      NativeConstructor = _reflect$collectionSu.NativeConstructor;
  return function sort(inPlace, iterable, selector) {
    var comparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultComparator;
    var array = ensureArray(iterable);
    var wrappedComparator = selector ? function (a, b) {
      return comparator(selector(itemValue(a)), selector(itemValue(b)));
    } : function (a, b) {
      return comparator(itemValue(a), itemValue(b));
    };

    if (inPlace) {
      _stable.default.inplace(array, wrappedComparator);
    } else {
      array = (0, _stable.default)(array, wrappedComparator);
    }

    if (collectionType === 'Sequence' || collectionSubtype === 'Indexed') {
      return array;
    }

    return new NativeConstructor(array);
  };
}

var sort = memoizeFactory(makeSort);

function makeToConcrete(Collection, collectionType, collectionSubtype) {
  var ConcreteConstructor = Collection.Concrete[collectionSubtype];
  return function toNative(value) {
    return new ConcreteConstructor(value);
  };
}

var toConcrete = memoizeFactory(makeToConcrete);

function makeToJS(Collection) {
  return function toJS(value) {
    return isDataStructure(value) ? Collection.Sequence.from(value).map(toJS).toJSON() : value;
  };
}

var toJs = memoizeFactory(makeToJS);

function makeZipAll(Collection, collectionType, collectionSubtype) {
  var SequenceConstructor = Collection.Sequence[collectionSubtype];
  return function zipAll(iterable) {
    for (var _len = arguments.length, iterables = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      iterables[_key - 1] = arguments[_key];
    }

    return _zipAll.default.apply(void 0, [iterable].concat((0, _toConsumableArray2.default)(iterables.map(function (iterable) {
      return new SequenceConstructor(iterable);
    }))));
  };
}

var zipAll = memoizeFactory(makeZipAll);

function makeZip(Collection, collectionType, collectionSubtype) {
  var SequenceConstructor = Collection.Sequence[collectionSubtype];
  return function zip(iterable) {
    for (var _len = arguments.length, iterables = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      iterables[_key - 1] = arguments[_key];
    }

    return _zip.default.apply(void 0, [iterable].concat((0, _toConsumableArray2.default)(iterables.map(function (iterable) {
      return new SequenceConstructor(iterable);
    }))));
  };
}

var zip = memoizeFactory(makeZip);
var factories =
/*#__PURE__*/
Object.freeze({
  concat: concat$1,
  flatten: flatten,
  groupBy: groupBy,
  reduce: makeReduce,
  sort: sort,
  toConcrete: toConcrete,
  toJS: toJs,
  zipAll: zipAll,
  zip: zip
});
var Namespace$1 = new RootNamespace();
var Collection = Namespace$1;
var emptyArray = [];

var MethodFactory = function MethodFactory(collectionType, collectionSubtype) {
  (0, _classCallCheck2.default)(this, MethodFactory);
  this._collectionType = collectionType;
  this._collectionSubtype = collectionSubtype;
};

var nativeFactories = new Map([[Map, function (coll) {
  return new Map(new Collection.Sequence.Keyed(coll));
}], [Set, function (coll) {
  return new Set(new Collection.Sequence.Duplicated(coll));
}], [Array, function (coll) {
  return Array.from(new Collection.Sequence.Indexed(coll));
}], [Object, // TODO use Object.fromEntries here when it is ready.
function (coll) {
  return new Collection.Sequence.Keyed(coll).reduce(function (obj, value, key) {
    obj[key] = value;
    return obj;
  }, {});
}]]);
var _iteratorNormalCompletion = true;
var _didIteratorError = false;
var _iteratorError = undefined;

try {
  var _loop = function _loop() {
    var name = _step.value;
    Object.defineProperty(MethodFactory.prototype, name, {
      get: function get() {
        return factories[name](Collection, this._collectionType, this._collectionSubtype);
      }
    });
  };

  for (var _iterator = (0, _keys.default)(factories)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    _loop();
  }
} catch (err) {
  _didIteratorError = true;
  _iteratorError = err;
} finally {
  try {
    if (!_iteratorNormalCompletion && _iterator.return != null) {
      _iterator.return();
    }
  } finally {
    if (_didIteratorError) {
      throw _iteratorError;
    }
  }
}

var CollectionMixin = function CollectionMixin(Base) {
  var CollectionMixin =
  /*#__PURE__*/
  function (_Base) {
    (0, _inherits2.default)(CollectionMixin, _Base);

    function CollectionMixin(iterable, collectionType, collectionSubtype) {
      var _this;

      (0, _classCallCheck2.default)(this, CollectionMixin);
      _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(CollectionMixin).call(this, iterable, collectionSubtype));
      _this.__selfParam = emptyArray;
      _this.__dynamicMethods = new MethodFactory(collectionType, collectionSubtype);
      return _this;
    }

    (0, _createClass2.default)(CollectionMixin, [{
      key: "slice",
      value: function slice() {
        var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
        return this.__doCollectionTransform((0, _slice2.default)({
          start: start,
          end: end
        }));
      }
    }, {
      key: "concat",
      value: function concat() {
        var _this2 = this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return this.__doCollectionTransform(function (iterable) {
          var _this2$__dynamicMetho;

          return (_this2$__dynamicMetho = _this2.__dynamicMethods).concat.apply(_this2$__dynamicMetho, [iterable].concat(args));
        });
      }
    }, {
      key: "flatten",
      value: function flatten$$1() {
        var _this3 = this;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return this.__doCollectionTransform(function (iterable) {
          var _this3$__dynamicMetho;

          return (_this3$__dynamicMetho = _this3.__dynamicMethods).flatten.apply(_this3$__dynamicMetho, [iterable].concat(args));
        });
      }
    }, {
      key: "groupBy",
      value: function groupBy$$1(grouper) {
        var _this4 = this;

        return this.__doCollectionTransform(function (iterable) {
          return _this4.__dynamicMethods.groupBy(iterable, grouper);
        });
      }
    }, {
      key: "flatMap",
      value: function flatMap(mapFn) {
        return this.map(mapFn).flatten(true);
      }
    }, {
      key: "sort",
      value: function sort$$1() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        return this.sortBy.apply(this, [null].concat(args));
      }
    }, {
      key: "count",
      value: function count(predicate) {
        return (0, _size.default)(predicate ? this.filter(predicate) : this);
      } // Reductive functions

    }, {
      key: "reduce",
      value: function reduce(reducer) {
        var _this5 = this;

        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }

        return this.__doReductiveTransform(function (iterable) {
          var _this5$__dynamicMetho;

          return (_this5$__dynamicMetho = _this5.__dynamicMethods).reduce.apply(_this5$__dynamicMetho, [iterable, function (acc, value, index) {
            return reducer.apply(void 0, [acc, value, index].concat((0, _toConsumableArray2.default)(_this5.__selfParam)));
          }].concat(args));
        });
      } // Deep conversions

    }, {
      key: "toJS",
      value: function toJS() {
        return this.__dynamicMethods.toJS(this);
      } // Shallow conversions

    }, {
      key: "toSeq",
      value: function toSeq() {
        return new Collection.Sequence.from(this);
      }
    }, {
      key: "toConcrete",
      value: function toConcrete$$1() {
        return this.__dynamicMethods.toConcrete(this);
      }
    }, {
      key: "to",
      value: function to(CollectionConstructor) {
        if (nativeFactories.has(CollectionConstructor)) {
          return nativeFactories.get(CollectionConstructor)(this);
        } else {
          return this instanceof CollectionConstructor ? this : new CollectionConstructor(this);
        }
      }
    }]);
    return CollectionMixin;
  }(Base);

  Object.defineProperty(CollectionMixin.prototype, '@@__MUTABLE_COLLECTION__@@', {
    value: true
  });
  return CollectionMixin;
};

var Collection$1 = CollectionMixin(function SequinsBase() {
  (0, _classCallCheck2.default)(this, SequinsBase);
});
var emptyArray$1 = [];

function makeFrom(Collection, collectionType$$1) {
  var TypedCollection = Collection[collectionType$$1];
  return function from(initial) {
    if (initial == null) {
      return new TypedCollection.Indexed(emptyArray$1);
    } else if (isCollection(initial) || isNative(initial)) {
      if (isIndexed(initial)) {
        return new TypedCollection.Indexed(initial);
      } else if (isKeyed(initial)) {
        return new TypedCollection.Keyed(initial);
      } else {
        return new TypedCollection.Duplicated(initial);
      }
    } else if (typeof initial[Symbol.iterator] === 'function') {
      return new TypedCollection.Indexed(initial);
    } else if (isPlainObj(initial)) {
      return new TypedCollection.Keyed(initial);
    }

    return null;
  };
}

var makeFrom$1 = memoizeFactory(makeFrom);

var SequenceNamespace =
/*#__PURE__*/
function (_SubtypeNamespace) {
  (0, _inherits2.default)(SequenceNamespace, _SubtypeNamespace);

  function SequenceNamespace() {
    (0, _classCallCheck2.default)(this, SequenceNamespace);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(SequenceNamespace).apply(this, arguments));
  }

  (0, _createClass2.default)(SequenceNamespace, [{
    key: "from",
    value: function from(initial) {
      return sequenceFrom(initial);
    }
  }]);
  return SequenceNamespace;
}(SubtypeNamespace);

var Namespace$2 = Namespace$1.__register('Sequence', new SequenceNamespace());

var sequenceFrom = makeFrom$1(Namespace$1, 'Sequence');

var identityFn = function identityFn(_) {
  return _;
};

var Sequence =
/*#__PURE__*/
function (_Collection) {
  (0, _inherits2.default)(Sequence, _Collection);
  (0, _createClass2.default)(Sequence, null, [{
    key: "from",
    value: function from(initial) {
      return sequenceFrom(initial);
    }
  }]);

  function Sequence(iterable, collectionSubtype) {
    var _this;

    (0, _classCallCheck2.default)(this, Sequence);
    iterable = iterable || [];
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Sequence).call(this, iterable, 'Sequence', collectionSubtype));
    _this.__iterable = iterable;
    _this.__transform = null;
    _this.__constructorTransform = null;
    return _this;
  }

  (0, _createClass2.default)(Sequence, [{
    key: "__doCollectionTransform",
    value: function __doCollectionTransform(transform) {
      var Sequence = this[Symbol.species]();
      var result = new Sequence(this);
      result.__transform = transform;
      return result;
    }
  }, {
    key: "__doReductiveTransform",
    value: function __doReductiveTransform(transform) {
      return transform(this._transform());
    }
  }, {
    key: "_transform",
    value: function _transform() {
      var constructorTransform = this.__constructorTransform || identityFn;
      var transform = this.__transform || identityFn;
      return transform(constructorTransform(this.__iterable));
    }
  }, {
    key: Symbol.iterator,
    value: function value() {
      return this._transform()[Symbol.iterator]();
    }
  }, {
    key: "set",
    value: function set(key, newValue) {
      return this.map(function (value, key) {
        return key === key ? newValue : value;
      });
    }
  }, {
    key: "push",
    value: function push(key, newValue) {
      return this.concat([newValue]);
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      return this.filter(function (_, key) {
        return key !== key;
      });
    }
  }, {
    key: "groupBy",
    value: function groupBy(grouper) {
      var _this2 = this;

      var concrete = this.toConcrete();
      var keyed = new Namespace$2.Keyed(concrete);

      keyed.__transform = function () {
        return _this2.__dynamicMethods.groupBy(concrete, grouper);
      };

      return keyed;
    }
  }, {
    key: "reverse",
    value: function reverse() {
      return this.__doCollectionTransform(function (iterable) {
        return Array.from(iterable).reverse();
      });
    }
  }, {
    key: "sortBy",
    value: function sortBy() {
      var _this3 = this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return this.__doCollectionTransform(function (iterable) {
        var _this3$__dynamicMetho;

        return (_this3$__dynamicMetho = _this3.__dynamicMethods).sort.apply(_this3$__dynamicMetho, [false, iterable].concat(args));
      });
    }
  }]);
  return Sequence;
}(Collection$1);

Object.defineProperty(Sequence.prototype, '@@__MUTABLE_SEQUENCE__@@', {
  value: true
});

var Namespace$3 = Namespace$1.__register('Concrete', new SubtypeNamespace());

var concreteFrom = makeFrom$1(Collection$1, 'Concrete');

var ConcreteCollection =
/*#__PURE__*/
function (_Collection) {
  (0, _inherits2.default)(ConcreteCollection, _Collection);

  function ConcreteCollection(iterable, collectionSubtype) {
    var _this;

    (0, _classCallCheck2.default)(this, ConcreteCollection);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ConcreteCollection).call(this, iterable, 'Concrete', collectionSubtype));
    _this.__selfParam = [(0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this))];
    return _this;
  }

  (0, _createClass2.default)(ConcreteCollection, [{
    key: "__doCollectionTransform",
    value: function __doCollectionTransform(transform) {
      var CollectionConstructor = this.constructor;
      var transformed = transform(this.__native);

      if (transformed instanceof ConcreteCollection) {
        return transformed;
      } else {
        var coll = new CollectionConstructor();
        coll.__native = this.__constructNative(transformed);
        return coll;
      }
    }
  }, {
    key: "__constructNative",
    value: function __constructNative(iterable) {
      var NativeConstructor = this.__native.constructor;
      return new NativeConstructor(iterable);
    }
  }, {
    key: "__doReductiveTransform",
    value: function __doReductiveTransform(transform) {
      return transform(this.__native);
    }
  }, {
    key: "count",
    value: function count(predicate) {
      return predicate ? (0, _get2.default)((0, _getPrototypeOf2.default)(ConcreteCollection.prototype), "count", this).call(this, predicate) : this.size;
    }
  }, {
    key: "get",
    value: function get(key, defaultValue) {
      return this.has(key) ? this.__native.get(key) : defaultValue;
    }
  }, {
    key: "has",
    value: function has(key) {
      return this.__native.has(key);
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      return this.__native.delete(key);
    }
  }, {
    key: "clear",
    value: function clear() {
      var NativeConstructor = this.__native.constructor;
      this.__native = new NativeConstructor();
      return this;
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.size === 0;
    }
  }, {
    key: "concat",
    value: function (_concat) {
      function concat() {
        return _concat.apply(this, arguments);
      }

      concat.toString = function () {
        return _concat.toString();
      };

      return concat;
    }(function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return this.__doCollectionTransform(function (iterable) {
        return concat.apply(void 0, [iterable].concat(args));
      });
    })
  }, {
    key: "__reverse",
    value: function __reverse() {
      var reversedSeq = Namespace$1.Sequence.from(this).reverse().toConcrete();
      this.clear();
      return reversedSeq;
    }
  }, {
    key: "toConcrete",
    value: function toConcrete() {
      return this;
    } // Iterators

  }, {
    key: "keys",
    value: function keys$$1() {
      return new Namespace$1.Sequence.Duplicated(this.__native.keys());
    }
  }, {
    key: "values",
    value: function values() {
      return new Namespace$1.Sequence.Duplicated(this.__native.values());
    }
  }, {
    key: "entries",
    value: function entries$$1() {
      return new Namespace$1.Sequence.Duplicated(this.__native.entries());
    }
  }, {
    key: Symbol.iterator,
    value: function value() {
      return this.__native[Symbol.iterator]();
    }
  }, {
    key: "size",
    get: function get() {
      return this.__native.size;
    }
  }], [{
    key: "from",
    value: function from(initial) {
      return concreteFrom(initial);
    }
  }]);
  return ConcreteCollection;
}(Collection$1);

function forEach(func, iterable) {
  var c = 0;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var item = _step.value;
      func(item, c++);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return iterable;
}

function forSome(func, iterable) {
  var c = 0;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var item = _step.value;
      var ret = func(item, c++);

      if (ret === false) {
        break;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return c;
}

var DuplicatedMixin = function DuplicatedMixin(Base) {
  return (
    /*#__PURE__*/
    function (_Base) {
      (0, _inherits2.default)(SetCollection, _Base);

      function SetCollection(iterable) {
        (0, _classCallCheck2.default)(this, SetCollection);
        return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(SetCollection).call(this, iterable, 'Duplicated'));
      } // Collection functions


      (0, _createClass2.default)(SetCollection, [{
        key: "map",
        value: function map(mapFn) {
          var _this = this;

          return this.__doCollectionTransform((0, _map2.default)(function (item) {
            return mapFn.apply(void 0, [item, item].concat((0, _toConsumableArray2.default)(_this.__selfParam)));
          }));
        }
      }, {
        key: "tap",
        value: function tap(tapFn) {
          var _this2 = this;

          return this.__doCollectionTransform((0, _tap2.default)(function (item) {
            return tapFn.apply(void 0, [item, item].concat((0, _toConsumableArray2.default)(_this2.__selfParam)));
          }));
        }
      }, {
        key: "filter",
        value: function filter(filterFn) {
          var _this3 = this;

          return this.__doCollectionTransform((0, _filter2.default)(function (item) {
            return filterFn.apply(void 0, [item, item].concat((0, _toConsumableArray2.default)(_this3.__selfParam)));
          }));
        }
      }, {
        key: "filterNot",
        value: function filterNot(filterFn) {
          var _this4 = this;

          return this.__doCollectionTransform((0, _filter2.default)(function (item) {
            return !filterFn.apply(void 0, [item, item].concat((0, _toConsumableArray2.default)(_this4.__selfParam)));
          }));
        } // Reductive functions

      }, {
        key: "forEach",
        value: function forEach$$1(eachFn) {
          var _this5 = this;

          forEach(function (item) {
            return eachFn.apply(void 0, [item, item].concat((0, _toConsumableArray2.default)(_this5.__selfParam)));
          }, this);
        }
      }, {
        key: "forSome",
        value: function forSome$$1(eachFn) {
          var _this6 = this;

          return forSome(function (item) {
            return eachFn.apply(void 0, [item, item].concat((0, _toConsumableArray2.default)(_this6.__selfParam)));
          }, this);
        } // Conversions

      }, {
        key: "toJSON",
        value: function toJSON() {
          return this.to(Array);
        }
      }]);
      return SetCollection;
    }(Base)
  );
};

var IndexedMixin = function IndexedMixin(Base) {
  var IndexedCollection =
  /*#__PURE__*/
  function (_Base) {
    (0, _inherits2.default)(IndexedCollection, _Base);

    function IndexedCollection(iterable) {
      (0, _classCallCheck2.default)(this, IndexedCollection);
      return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(IndexedCollection).call(this, iterable, 'Indexed'));
    } // prettier-ignore


    (0, _createClass2.default)(IndexedCollection, [{
      key: "zip",
      value: function zip() {
        var _this = this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return this.__doCollectionTransform(function (iterable) {
          var _this$__dynamicMethod;

          return (_this$__dynamicMethod = _this.__dynamicMethods).zip.apply(_this$__dynamicMethod, [iterable].concat(args));
        });
      }
    }, {
      key: "zipAll",
      value: function zipAll() {
        var _this2 = this;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return this.__doCollectionTransform(function (iterable) {
          var _this2$__dynamicMetho;

          return (_this2$__dynamicMetho = _this2.__dynamicMethods).zipAll.apply(_this2$__dynamicMetho, [iterable].concat(args));
        });
      }
    }, {
      key: "zipWith",
      value: function zipWith(zipper) {
        var _this3 = this;

        for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }

        return this.__doCollectionTransform(function (iterable) {
          var _this3$__dynamicMetho;

          return (0, _map2.default)(function (items) {
            return zipper.apply(void 0, (0, _toConsumableArray2.default)(items));
          }, (_this3$__dynamicMetho = _this3.__dynamicMethods).zip.apply(_this3$__dynamicMetho, [iterable].concat(args)));
        });
      }
    }, {
      key: "interpose",
      value: function interpose(separator) {
        return this.__doCollectionTransform((0, _interpose2.default)(separator));
      } // Collection functions

    }, {
      key: "map",
      value: function map(mapFn) {
        var _this4 = this;

        return this.__doCollectionTransform((0, _map2.default)(function (value, i) {
          return mapFn.apply(void 0, [value, i].concat((0, _toConsumableArray2.default)(_this4.__selfParam)));
        }));
      }
    }, {
      key: "tap",
      value: function tap(tapFn) {
        var _this5 = this;

        return this.__doCollectionTransform((0, _tap2.default)(function (value, i) {
          return tapFn.apply(void 0, [value, i].concat((0, _toConsumableArray2.default)(_this5.__selfParam)));
        }));
      }
    }, {
      key: "filter",
      value: function filter(filterFn) {
        var _this6 = this;

        return this.__doCollectionTransform((0, _filter2.default)(function (value, i) {
          return filterFn.apply(void 0, [value, i].concat((0, _toConsumableArray2.default)(_this6.__selfParam)));
        }));
      }
    }, {
      key: "filterNot",
      value: function filterNot(filterFn) {
        var _this7 = this;

        return this.__doCollectionTransform((0, _filter2.default)(function (value, i) {
          return !filterFn.apply(void 0, [value, i].concat((0, _toConsumableArray2.default)(_this7.__selfParam)));
        }));
      } // Reductive functions

    }, {
      key: "forEach",
      value: function forEach$$1(eachFn) {
        var _this8 = this;

        forEach(function (value, i) {
          return eachFn.apply(void 0, [value, i].concat((0, _toConsumableArray2.default)(_this8.__selfParam)));
        }, this);
      }
    }, {
      key: "forSome",
      value: function forSome$$1(eachFn) {
        var _this9 = this;

        return forSome(function (value, i) {
          return eachFn.apply(void 0, [value, i].concat((0, _toConsumableArray2.default)(_this9.__selfParam)));
        }, this);
      } // Conversions

    }, {
      key: "toJSON",
      value: function toJSON() {
        return this.to(Array);
      }
    }]);
    return IndexedCollection;
  }(Base);

  Object.defineProperty(IndexedCollection.prototype, '@@__MUTABLE_INDEXED__@@', {
    value: true
  });
  return IndexedCollection;
};

var KeyedMixin = function KeyedMixin(Base) {
  var KeyedCollection =
  /*#__PURE__*/
  function (_Base) {
    (0, _inherits2.default)(KeyedCollection, _Base);

    function KeyedCollection(iterable) {
      (0, _classCallCheck2.default)(this, KeyedCollection);
      return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KeyedCollection).call(this, iterable, 'Keyed'));
    }

    (0, _createClass2.default)(KeyedCollection, [{
      key: "flip",
      value: function flip() {
        return this.__doCollectionTransform((0, _map2.default)(function (_ref) {
          var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
              key = _ref2[0],
              value = _ref2[1];

          return [value, key];
        }));
      } // Collection functions

    }, {
      key: "map",
      value: function map(mapFn) {
        var _this = this;

        return this.__doCollectionTransform((0, _map2.default)(function (_ref3) {
          var _ref4 = (0, _slicedToArray2.default)(_ref3, 2),
              key = _ref4[0],
              value = _ref4[1];

          return [key, mapFn.apply(void 0, [value, key].concat((0, _toConsumableArray2.default)(_this.__selfParam)))];
        }));
      }
    }, {
      key: "mapKeys",
      value: function mapKeys(mapFn) {
        var _this2 = this;

        return this.__doCollectionTransform((0, _map2.default)(function (_ref5) {
          var _ref6 = (0, _slicedToArray2.default)(_ref5, 2),
              key = _ref6[0],
              value = _ref6[1];

          return [mapFn.apply(void 0, [key, value].concat((0, _toConsumableArray2.default)(_this2.__selfParam))), value];
        }));
      }
    }, {
      key: "mapEntries",
      value: function mapEntries(mapFn) {
        var _this3 = this;

        return this.__doCollectionTransform((0, _map2.default)(function (entry, i) {
          return mapFn.apply(void 0, [entry, i].concat((0, _toConsumableArray2.default)(_this3.__selfParam)));
        }));
      }
    }, {
      key: "tap",
      value: function tap(tapFn) {
        var _this4 = this;

        return this.__doCollectionTransform((0, _tap2.default)(function (_ref7) {
          var _ref8 = (0, _slicedToArray2.default)(_ref7, 2),
              key = _ref8[0],
              value = _ref8[1];

          return tapFn.apply(void 0, [value, key].concat((0, _toConsumableArray2.default)(_this4.__selfParam)));
        }));
      }
    }, {
      key: "filter",
      value: function filter(filterFn) {
        var _this5 = this;

        return this.__doCollectionTransform((0, _filter2.default)(function (_ref9) {
          var _ref10 = (0, _slicedToArray2.default)(_ref9, 2),
              key = _ref10[0],
              value = _ref10[1];

          return filterFn.apply(void 0, [value, key].concat((0, _toConsumableArray2.default)(_this5.__selfParam)));
        }));
      }
    }, {
      key: "filterNot",
      value: function filterNot(filterFn) {
        var _this6 = this;

        return this.__doCollectionTransform((0, _filter2.default)(function (_ref11) {
          var _ref12 = (0, _slicedToArray2.default)(_ref11, 2),
              key = _ref12[0],
              value = _ref12[1];

          return !filterFn.apply(void 0, [value, key].concat((0, _toConsumableArray2.default)(_this6.__selfParam)));
        }));
      } // Reductive functions

    }, {
      key: "forEach",
      value: function forEach$$1(eachFn) {
        var _this7 = this;

        forEach(function (_ref13) {
          var _ref14 = (0, _slicedToArray2.default)(_ref13, 2),
              key = _ref14[0],
              value = _ref14[1];

          return eachFn.apply(void 0, [value, key].concat((0, _toConsumableArray2.default)(_this7.__selfParam)));
        }, this);
      }
    }, {
      key: "forSome",
      value: function forSome$$1(eachFn) {
        var _this8 = this;

        return forSome(function (_ref15) {
          var _ref16 = (0, _slicedToArray2.default)(_ref15, 2),
              key = _ref16[0],
              value = _ref16[1];

          return eachFn.apply(void 0, [value, key].concat((0, _toConsumableArray2.default)(_this8.__selfParam)));
        }, this);
      } // Conversions

    }, {
      key: "toJSON",
      value: function toJSON() {
        return this.to(Object);
      }
    }]);
    return KeyedCollection;
  }(Base);

  Object.defineProperty(KeyedCollection.prototype, '@@__MUTABLE_KEYED__@@', {
    value: true
  });
  return KeyedCollection;
};

var _marked =
/*#__PURE__*/
_regenerator.default.mark(arrayEntries);

function arrayEntries(array) {
  var i;
  return _regenerator.default.wrap(function arrayEntries$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          i = 0;

        case 1:
          if (!(i < array.length)) {
            _context.next = 7;
            break;
          }

          _context.next = 4;
          return [i, array[i]];

        case 4:
          i++;
          _context.next = 1;
          break;

        case 7:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this);
}

var List =
/*#__PURE__*/
function (_IndexedMixin) {
  (0, _inherits2.default)(List, _IndexedMixin);
  (0, _createClass2.default)(List, null, [{
    key: "isList",
    value: function isList(shape) {
      return isMutableList(shape);
    }
  }, {
    key: "of",
    value: function of() {
      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }

      return new List(values);
    }
  }]);

  function List(iterable) {
    var _this;

    (0, _classCallCheck2.default)(this, List);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(List).call(this, iterable));
    _this.__native = iterable == null ? [] : Array.from(isKeyed(iterable) ? iterable.values() : iterable);
    return _this;
  }

  (0, _createClass2.default)(List, [{
    key: "__constructNative",
    value: function __constructNative(iterable) {
      return Array.from(iterable);
    }
  }, {
    key: "get",
    value: function get(idx) {
      return this.__native[idx];
    }
  }, {
    key: "set",
    value: function set(idx, value) {
      this.__native[idx] = value;
      return this;
    }
  }, {
    key: "has",
    value: function has(idx) {
      return idx < this.__native.length;
    }
  }, {
    key: "push",
    value: function push() {
      var _this$__native;

      (_this$__native = this.__native).push.apply(_this$__native, arguments);

      return this;
    }
  }, {
    key: "pop",
    value: function pop() {
      return this.__native.pop();
    }
  }, {
    key: "shift",
    value: function shift() {
      return this.__native.shift();
    }
  }, {
    key: "unshift",
    value: function unshift(value) {
      this.__native.unshift(value);

      return this;
    }
  }, {
    key: "first",
    value: function first() {
      return this.__native[0];
    }
  }, {
    key: "last",
    value: function last() {
      return this.__native[this.__native.length];
    }
  }, {
    key: "sortBy",
    value: function sortBy() {
      var _this$__dynamicMethod;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      (_this$__dynamicMethod = this.__dynamicMethods).sort.apply(_this$__dynamicMethod, [true, this.__native].concat(args));

      return this;
    }
  }, {
    key: "fill",
    value: function fill() {
      var _this$__native2;

      (_this$__native2 = this.__native).fill.apply(_this$__native2, arguments);

      return this;
    }
  }, {
    key: "includes",
    value: function includes(value) {
      return this.__native.includes(value);
    }
  }, {
    key: "map",
    value: function map(mapFn) {
      var _this2 = this;

      return this.__doCollectionTransform(function () {
        return _this2.__native.map(function (value, index) {
          return mapFn(value, index, _this2);
        });
      });
    }
  }, {
    key: "filter",
    value: function filter(filterFn) {
      var _this3 = this;

      return this.__doCollectionTransform(function () {
        return _this3.__native.filter(function (value, index) {
          return filterFn(value, index, _this3);
        });
      });
    }
  }, {
    key: "filterNot",
    value: function filterNot(filterFn) {
      var _this4 = this;

      return this.__doCollectionTransform(function () {
        return _this4.__native.filter(function (value, index) {
          return !filterFn(value, index, _this4);
        });
      });
    }
  }, {
    key: "slice",
    value: function slice() {
      var _this5 = this;

      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return this.__doCollectionTransform(function () {
        var _this5$__native;

        return (_this5$__native = _this5.__native).slice.apply(_this5$__native, args);
      });
    }
  }, {
    key: "concat",
    value: function concat() {
      var _this6 = this;

      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return this.__doCollectionTransform(function () {
        var _this6$__native;

        return (_this6$__native = _this6.__native).concat.apply(_this6$__native, args);
      });
    }
  }, {
    key: "reverse",
    value: function reverse() {
      this.__native.reverse();

      return this;
    }
  }, {
    key: "reduce",
    value: function reduce(reducer) {
      var _this$__native3,
          _this7 = this;

      for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        args[_key5 - 1] = arguments[_key5];
      }

      return (_this$__native3 = this.__native).reduce.apply(_this$__native3, [function (acc, value, index) {
        return reducer(acc, value, index, _this7);
      }].concat(args));
    }
  }, {
    key: "join",
    value: function join(separator) {
      return this.__native.join(separator);
    }
  }, {
    key: "has",
    value: function has(idx) {
      return idx < this.size();
    }
  }, {
    key: "delete",
    value: function _delete(idx) {
      var hasIdx = this.has(idx);

      if (hasIdx) {
        this.__native[idx] = undefined;
      }

      return hasIdx;
    } // Iterators

  }, {
    key: "keys",
    value: function keys$$1() {
      return new Namespace$1.Sequence.Duplicated((0, _range.default)(this.__native.length));
    }
  }, {
    key: "values",
    value: function values() {
      return new Namespace$1.Sequence.Duplicated(this);
    }
  }, {
    key: "entries",
    value: function entries$$1() {
      return new Namespace$1.Sequence.Duplicated(arrayEntries(this.__native));
    }
  }, {
    key: Symbol.species,
    value: function value() {
      return List;
    }
  }, {
    key: "size",
    get: function get() {
      return this.__native.length;
    }
  }]);
  return List;
}(IndexedMixin(ConcreteCollection));

var List$1 = Namespace$3.__register('Indexed', List);

exports.List = List$1;

var SequinsMap =
/*#__PURE__*/
function (_KeyedMixin) {
  (0, _inherits2.default)(SequinsMap, _KeyedMixin);
  (0, _createClass2.default)(SequinsMap, null, [{
    key: "isMap",
    value: function isMap(shape) {
      return isMutableMap(shape);
    }
  }]);

  function SequinsMap(iterable) {
    var _this;

    (0, _classCallCheck2.default)(this, SequinsMap);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(SequinsMap).call(this, iterable)); // prettier-ignore

    _this.__native = new Map(iterable == null ? [] : isCollection(iterable) || isNative(iterable) ? iterable.entries() : isPlainObj(iterable) ? (0, _entries.default)(iterable) : iterable);
    return _this;
  }

  (0, _createClass2.default)(SequinsMap, [{
    key: "set",
    value: function set(key, value) {
      this.__native.set(key, value);

      return this;
    }
  }, {
    key: "sortBy",
    value: function sortBy() {
      var _this$__dynamicMethod;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      this.__native = new Map((_this$__dynamicMethod = this.__dynamicMethods).sort.apply(_this$__dynamicMethod, [true, Array.from(this.__native)].concat(args)));
      return this;
    }
  }, {
    key: "reverse",
    value: function reverse() {
      var reversedSeq = this.__reverse();

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = reversedSeq[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = (0, _slicedToArray2.default)(_step.value, 2),
              key = _step$value[0],
              value = _step$value[1];

          this.set(key, value);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return this;
    } // Conversions

  }, {
    key: Symbol.species,
    value: function value() {
      return SequinsMap;
    }
  }]);
  return SequinsMap;
}(KeyedMixin(ConcreteCollection));

var Map$1 = Namespace$3.__register('Keyed', SequinsMap);

exports.Map = Map$1;

var SequinsSet =
/*#__PURE__*/
function (_DuplicatedMixin) {
  (0, _inherits2.default)(SequinsSet, _DuplicatedMixin);
  (0, _createClass2.default)(SequinsSet, null, [{
    key: "isSet",
    value: function isSet(shape) {
      return isMutableSet(shape);
    }
  }, {
    key: "of",
    value: function of() {
      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }

      return new SequinsSet(values);
    }
  }, {
    key: "fromKeys",
    value: function fromKeys(shape) {
      return makeFrom$1(Namespace$1, 'Sequence')(shape).keys().to(SequinsSet);
    }
  }, {
    key: "union",
    value: function union() {
      for (var _len2 = arguments.length, iterables = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        iterables[_key2] = arguments[_key2];
      }

      return new SequinsSet((0, _flat.default)(1, (0, _map2.default)(function (iterable) {
        return new Namespace$1.Sequence.Duplicated(iterable);
      }, iterables)));
    }
  }, {
    key: "intersect",
    value: function intersect() {
      for (var _len3 = arguments.length, iterables = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        iterables[_key3] = arguments[_key3];
      }

      var countMap = new Namespace$3.Keyed();

      for (var _i = 0; _i < iterables.length; _i++) {
        var iterable = iterables[_i];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = new Namespace$1.Sequence.Duplicated(iterable)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var value = _step.value;
            countMap.set(value, (countMap.get(value) || 0) + 1);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      return new Namespace$1.Sequence.Keyed(countMap).filter(function (count) {
        return count === iterables.length;
      }).keys().to(SequinsSet);
    }
  }]);

  function SequinsSet(iterable) {
    var _this;

    (0, _classCallCheck2.default)(this, SequinsSet);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(SequinsSet).call(this, iterable));
    _this.__native = new Set(iterable == null ? [] : isKeyed(iterable) ? iterable.values() : iterable);
    return _this;
  }

  (0, _createClass2.default)(SequinsSet, [{
    key: "add",
    value: function add(key, value) {
      this.__native.add(key, value);

      return this;
    }
  }, {
    key: "sortBy",
    value: function sortBy() {
      var _this$__dynamicMethod;

      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      this.__native = new Set((_this$__dynamicMethod = this.__dynamicMethods).sort.apply(_this$__dynamicMethod, [true, Array.from(this.__native)].concat(args)));
      return this;
    }
  }, {
    key: "reverse",
    value: function reverse() {
      var reversedSeq = this.__reverse();

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = reversedSeq[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var value = _step2.value;
          this.add(value);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return this;
    }
  }, {
    key: "union",
    value: function union() {
      for (var _len5 = arguments.length, iterables = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        iterables[_key5] = arguments[_key5];
      }

      return SequinsSet.union.apply(SequinsSet, [this].concat(iterables));
    }
  }, {
    key: "intersect",
    value: function intersect() {
      for (var _len6 = arguments.length, iterables = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        iterables[_key6] = arguments[_key6];
      }

      return SequinsSet.intersect.apply(SequinsSet, [this].concat(iterables));
    } // Conversions

  }, {
    key: Symbol.species,
    value: function value() {
      return SequinsSet;
    }
  }]);
  return SequinsSet;
}(DuplicatedMixin(ConcreteCollection));

var Set$1 = Namespace$3.__register('Duplicated', SequinsSet);

exports.Set = Set$1;

var IndexedSequence =
/*#__PURE__*/
function (_IndexedMixin) {
  (0, _inherits2.default)(IndexedSequence, _IndexedMixin);
  (0, _createClass2.default)(IndexedSequence, null, [{
    key: "of",
    value: function of() {
      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }

      return new IndexedSequence(values);
    }
  }]);

  function IndexedSequence(iterable) {
    var _this;

    (0, _classCallCheck2.default)(this, IndexedSequence);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(IndexedSequence).call(this, iterable));

    if (isKeyed(_this.__iterable)) {
      _this.__constructorTransform = function (iterable) {
        return iterable.values();
      };
    }

    return _this;
  } // Iterators


  (0, _createClass2.default)(IndexedSequence, [{
    key: "keys",
    value: function keys$$1() {
      return new Namespace$2.Duplicated((0, _map2.default)(function (_, i) {
        return i;
      }, this));
    }
  }, {
    key: "values",
    value: function values() {
      return new Namespace$2.Duplicated(this);
    }
  }, {
    key: "entries",
    value: function entries$$1() {
      return new Namespace$2.Duplicated((0, _map2.default)(function (value, i) {
        return [i, value];
      }, this));
    }
  }, {
    key: Symbol.species,
    value: function value() {
      return IndexedSequence;
    }
  }]);
  return IndexedSequence;
}(IndexedMixin(Sequence));

exports.IndexedSequence = IndexedSequence;

Namespace$2.__register('Indexed', IndexedSequence);

var KeyedSequence =
/*#__PURE__*/
function (_KeyedMixin) {
  (0, _inherits2.default)(KeyedSequence, _KeyedMixin);

  function KeyedSequence(iterable) {
    var _this;

    (0, _classCallCheck2.default)(this, KeyedSequence);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(KeyedSequence).call(this, iterable));

    if (isMutableCollection(_this.__iterable) && !isKeyed(_this.__iterable)) {
      _this.__constructorTransform = function (iterable) {
        return iterable.entries();
      };
    } else if (isPlainObj(_this.__iterable)) {
      _this.__constructorTransform = function (obj) {
        return (0, _entries.default)(obj);
      };
    }

    return _this;
  } // Iterators


  (0, _createClass2.default)(KeyedSequence, [{
    key: "keys",
    value: function keys$$1() {
      return new Namespace$2.Duplicated((0, _map2.default)(function (_ref) {
        var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
            key = _ref2[0],
            _ = _ref2[1];

        return key;
      }, this));
    }
  }, {
    key: "values",
    value: function values() {
      return new Namespace$2.Duplicated((0, _map2.default)(function (_ref3) {
        var _ref4 = (0, _slicedToArray2.default)(_ref3, 2),
            _ = _ref4[0],
            value = _ref4[1];

        return value;
      }, this));
    }
  }, {
    key: "entries",
    value: function entries$$1() {
      return new Namespace$2.Duplicated((0, _map2.default)(function (_) {
        return _;
      }, this));
    }
  }, {
    key: Symbol.species,
    value: function value() {
      return KeyedSequence;
    }
  }]);
  return KeyedSequence;
}(KeyedMixin(Sequence));

exports.KeyedSequence = KeyedSequence;

Namespace$2.__register('Keyed', KeyedSequence);

var SetSequence =
/*#__PURE__*/
function (_DuplicatedMixin) {
  (0, _inherits2.default)(SetSequence, _DuplicatedMixin);
  (0, _createClass2.default)(SetSequence, null, [{
    key: "of",
    value: function of() {
      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }

      return new SetSequence(values);
    }
  }]);

  function SetSequence(iterable) {
    var _this;

    (0, _classCallCheck2.default)(this, SetSequence);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(SetSequence).call(this, iterable));

    if (isKeyed(_this.__iterable)) {
      _this.__constructorTransform = function (iterable) {
        return iterable.values();
      };
    }

    return _this;
  } // Iterators


  (0, _createClass2.default)(SetSequence, [{
    key: "keys",
    value: function keys$$1() {
      return this;
    }
  }, {
    key: "values",
    value: function values() {
      return this;
    }
  }, {
    key: "entries",
    value: function entries$$1() {
      return new Namespace$2.Duplicated((0, _map2.default)(function (value) {
        return [value, value];
      }, this));
    }
  }, {
    key: Symbol.species,
    value: function value() {
      return SetSequence;
    }
  }]);
  return SetSequence;
}(DuplicatedMixin(Sequence));

exports.SetSequence = SetSequence;

Namespace$2.__register('Duplicated', SetSequence);

var _global = typeof window !== 'undefined' ? window : global;

var Map$2 = _global.Map;
exports.NativeMap = Map$2;
var Set$2 = _global.Set;
exports.NativeSet = Set$2;

function has(shape, key) {
  if (shape == null) {
    return false;
  } else if (isModernDataStructure(shape)) {
    return shape.has(key);
  } else if (Array.isArray(shape)) {
    return key < shape.length;
  }

  return Object.prototype.hasOwnProperty.call(shape, key);
}

function get(shape, key, defaultValue) {
  if (shape == null) {
    return false;
  } else if (isModernDataStructure(shape)) {
    return shape.get(key, defaultValue);
  }

  return !has(shape, key) ? defaultValue : shape[key];
}

function set(shape, key, value) {
  if (isMutableCollection(shape) || isNativeKeyed(map)) {
    return shape.set(key, value);
  } else if (isImmutable(shape)) {
    // Reasoning: Immutable's set does not have the same contract as this function:
    // it requires you to use the returned reference.
    throw new TypeError('Sequins.set cannot set on Immutable data structures.');
  } else if (isNativeSet(shape)) {
    throw new TypeError('Sets do not support the set method.');
  }

  shape[key] = value;
  return shape;
}

function keys$1(shape) {
  return makeFrom$1(Namespace$1, 'Sequence')(shape).keys();
}

function values(shape) {
  return makeFrom$1(Namespace$1, 'Sequence')(shape).values();
}

function entries$1(shape) {
  return makeFrom$1(Namespace$1, 'Sequence')(shape).entries();
}

function Range() {
  var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  return new IndexedSequence((0, _range.default)({
    start: start,
    step: step,
    end: end
  }));
}

function Repeat(value) {
  var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
  return new IndexedSequence((0, _repeat.default)(value, times));
}

function Seq(initial) {
  var seq = Sequence.from(initial);

  if (!seq) {
    throw new Error("Could not create a sequence out of ".concat(initial, "."));
  }

  return seq;
}

function IndexedSequenceFactory(iterable) {
  return new IndexedSequence(iterable);
}

Object.assign(IndexedSequenceFactory, IndexedSequence);

function KeyedSequenceFactory(iterable) {
  return new KeyedSequence(iterable);
}

Object.assign(KeyedSequenceFactory, KeyedSequence);

function SetSequenceFactory(iterable) {
  return new SetSequence(iterable);
}

Object.assign(SetSequenceFactory, SetSequence);
Seq.Indexed = IndexedSequenceFactory;
Seq.Keyed = KeyedSequenceFactory;
Seq.Set = SetSequenceFactory;
var index = {
  Seq: Seq,
  IndexedSequence: IndexedSequence,
  KeyedSequence: KeyedSequence,
  SetSequence: SetSequence,
  List: List$1,
  Map: Map$1,
  Set: Set$1,
  NativeMap: Map$2,
  NativeSet: Set$2,
  isCollection: isMutableCollection,
  isKeyed: isMutableKeyed,
  isIndexed: isMutableIndexed,
  isAssociative: isMutableAssociative,
  isSeq: isMutableSeq,
  isList: isMutableList,
  isMap: isMutableMap,
  isSet: isMutableSet,
  Range: Range,
  Repeat: Repeat,
  get: get,
  set: set,
  has: has,
  keys: keys$1,
  values: values,
  entries: entries$1
};
var _default = index;
exports.default = _default;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@babel/runtime/helpers/assertThisInitialized":14,"@babel/runtime/helpers/classCallCheck":15,"@babel/runtime/helpers/createClass":16,"@babel/runtime/helpers/get":17,"@babel/runtime/helpers/getPrototypeOf":18,"@babel/runtime/helpers/inherits":19,"@babel/runtime/helpers/interopRequireDefault":20,"@babel/runtime/helpers/possibleConstructorReturn":25,"@babel/runtime/helpers/slicedToArray":27,"@babel/runtime/helpers/toConsumableArray":29,"@babel/runtime/regenerator":31,"invariant":106,"iter-tools/es5/compose":108,"iter-tools/es5/concat":109,"iter-tools/es5/entries":110,"iter-tools/es5/filter":111,"iter-tools/es5/flat":112,"iter-tools/es5/interpose":115,"iter-tools/es5/keys":116,"iter-tools/es5/map":117,"iter-tools/es5/range":118,"iter-tools/es5/reduce":119,"iter-tools/es5/repeat":120,"iter-tools/es5/size":121,"iter-tools/es5/slice":122,"iter-tools/es5/tap":123,"iter-tools/es5/zip":126,"iter-tools/es5/zip-all":124,"stable":177}],3:[function(require,module,exports){
module.exports = require("core-js/library/fn/get-iterator");
},{"core-js/library/fn/get-iterator":34}],4:[function(require,module,exports){
module.exports = require("core-js/library/fn/object/define-property");
},{"core-js/library/fn/object/define-property":35}],5:[function(require,module,exports){
module.exports = require("core-js/library/fn/symbol");
},{"core-js/library/fn/symbol":36}],6:[function(require,module,exports){
module.exports = require("core-js/library/fn/symbol/iterator");
},{"core-js/library/fn/symbol/iterator":37}],7:[function(require,module,exports){
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;
},{}],8:[function(require,module,exports){
var _Object$defineProperty = require("../core-js/object/define-property");

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;

    _Object$defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;
},{"../core-js/object/define-property":4}],9:[function(require,module,exports){
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

module.exports = _interopRequireDefault;
},{}],10:[function(require,module,exports){
var _Symbol$iterator = require("../core-js/symbol/iterator");

var _Symbol = require("../core-js/symbol");

function _typeof2(obj) { if (typeof _Symbol === "function" && typeof _Symbol$iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof _Symbol === "function" && obj.constructor === _Symbol && obj !== _Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof _Symbol === "function" && _typeof2(_Symbol$iterator) === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof _Symbol === "function" && obj.constructor === _Symbol && obj !== _Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;
},{"../core-js/symbol":5,"../core-js/symbol/iterator":6}],11:[function(require,module,exports){
module.exports = require("regenerator-runtime");

},{"regenerator-runtime":175}],12:[function(require,module,exports){
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;
},{}],13:[function(require,module,exports){
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

module.exports = _arrayWithoutHoles;
},{}],14:[function(require,module,exports){
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;
},{}],15:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],16:[function(require,module,exports){
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;
},{}],17:[function(require,module,exports){
var getPrototypeOf = require("./getPrototypeOf");

var superPropBase = require("./superPropBase");

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

module.exports = _get;
},{"./getPrototypeOf":18,"./superPropBase":28}],18:[function(require,module,exports){
function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
},{}],19:[function(require,module,exports){
var setPrototypeOf = require("./setPrototypeOf");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;
},{"./setPrototypeOf":26}],20:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"dup":9}],21:[function(require,module,exports){
function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

module.exports = _iterableToArray;
},{}],22:[function(require,module,exports){
function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;
},{}],23:[function(require,module,exports){
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

module.exports = _nonIterableRest;
},{}],24:[function(require,module,exports){
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

module.exports = _nonIterableSpread;
},{}],25:[function(require,module,exports){
var _typeof = require("../helpers/typeof");

var assertThisInitialized = require("./assertThisInitialized");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;
},{"../helpers/typeof":30,"./assertThisInitialized":14}],26:[function(require,module,exports){
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
},{}],27:[function(require,module,exports){
var arrayWithHoles = require("./arrayWithHoles");

var iterableToArrayLimit = require("./iterableToArrayLimit");

var nonIterableRest = require("./nonIterableRest");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;
},{"./arrayWithHoles":12,"./iterableToArrayLimit":22,"./nonIterableRest":23}],28:[function(require,module,exports){
var getPrototypeOf = require("./getPrototypeOf");

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

module.exports = _superPropBase;
},{"./getPrototypeOf":18}],29:[function(require,module,exports){
var arrayWithoutHoles = require("./arrayWithoutHoles");

var iterableToArray = require("./iterableToArray");

var nonIterableSpread = require("./nonIterableSpread");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;
},{"./arrayWithoutHoles":13,"./iterableToArray":21,"./nonIterableSpread":24}],30:[function(require,module,exports){
function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;
},{}],31:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11,"regenerator-runtime":175}],32:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],33:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":32,"ieee754":104}],34:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.get-iterator');

},{"../modules/core.get-iterator":95,"../modules/es6.string.iterator":99,"../modules/web.dom.iterable":103}],35:[function(require,module,exports){
require('../../modules/es6.object.define-property');
var $Object = require('../../modules/_core').Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};

},{"../../modules/_core":44,"../../modules/es6.object.define-property":97}],36:[function(require,module,exports){
require('../../modules/es6.symbol');
require('../../modules/es6.object.to-string');
require('../../modules/es7.symbol.async-iterator');
require('../../modules/es7.symbol.observable');
module.exports = require('../../modules/_core').Symbol;

},{"../../modules/_core":44,"../../modules/es6.object.to-string":98,"../../modules/es6.symbol":100,"../../modules/es7.symbol.async-iterator":101,"../../modules/es7.symbol.observable":102}],37:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/web.dom.iterable');
module.exports = require('../../modules/_wks-ext').f('iterator');

},{"../../modules/_wks-ext":92,"../../modules/es6.string.iterator":99,"../../modules/web.dom.iterable":103}],38:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],39:[function(require,module,exports){
module.exports = function () { /* empty */ };

},{}],40:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":60}],41:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":84,"./_to-iobject":86,"./_to-length":87}],42:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":43,"./_wks":93}],43:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],44:[function(require,module,exports){
var core = module.exports = { version: '2.6.0' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],45:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":38}],46:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],47:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":52}],48:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":53,"./_is-object":60}],49:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],50:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-gops":73,"./_object-keys":76,"./_object-pie":77}],51:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var ctx = require('./_ctx');
var hide = require('./_hide');
var has = require('./_has');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":44,"./_ctx":45,"./_global":53,"./_has":54,"./_hide":55}],52:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],53:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],54:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],55:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":47,"./_object-dp":68,"./_property-desc":78}],56:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":53}],57:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":47,"./_dom-create":48,"./_fails":52}],58:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":43}],59:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":43}],60:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],61:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":55,"./_object-create":67,"./_property-desc":78,"./_set-to-string-tag":80,"./_wks":93}],62:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":51,"./_hide":55,"./_iter-create":61,"./_iterators":64,"./_library":65,"./_object-gpo":74,"./_redefine":79,"./_set-to-string-tag":80,"./_wks":93}],63:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],64:[function(require,module,exports){
module.exports = {};

},{}],65:[function(require,module,exports){
module.exports = true;

},{}],66:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":52,"./_has":54,"./_is-object":60,"./_object-dp":68,"./_uid":90}],67:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":40,"./_dom-create":48,"./_enum-bug-keys":49,"./_html":56,"./_object-dps":69,"./_shared-key":81}],68:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":40,"./_descriptors":47,"./_ie8-dom-define":57,"./_to-primitive":89}],69:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":40,"./_descriptors":47,"./_object-dp":68,"./_object-keys":76}],70:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":47,"./_has":54,"./_ie8-dom-define":57,"./_object-pie":77,"./_property-desc":78,"./_to-iobject":86,"./_to-primitive":89}],71:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":72,"./_to-iobject":86}],72:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_enum-bug-keys":49,"./_object-keys-internal":75}],73:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],74:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":54,"./_shared-key":81,"./_to-object":88}],75:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":41,"./_has":54,"./_shared-key":81,"./_to-iobject":86}],76:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":49,"./_object-keys-internal":75}],77:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],78:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],79:[function(require,module,exports){
module.exports = require('./_hide');

},{"./_hide":55}],80:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":54,"./_object-dp":68,"./_wks":93}],81:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":82,"./_uid":90}],82:[function(require,module,exports){
var core = require('./_core');
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: require('./_library') ? 'pure' : 'global',
  copyright: '© 2018 Denis Pushkarev (zloirock.ru)'
});

},{"./_core":44,"./_global":53,"./_library":65}],83:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":46,"./_to-integer":85}],84:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":85}],85:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],86:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":46,"./_iobject":58}],87:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":85}],88:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":46}],89:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":60}],90:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],91:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_core":44,"./_global":53,"./_library":65,"./_object-dp":68,"./_wks-ext":92}],92:[function(require,module,exports){
exports.f = require('./_wks');

},{"./_wks":93}],93:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":53,"./_shared":82,"./_uid":90}],94:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":42,"./_core":44,"./_iterators":64,"./_wks":93}],95:[function(require,module,exports){
var anObject = require('./_an-object');
var get = require('./core.get-iterator-method');
module.exports = require('./_core').getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};

},{"./_an-object":40,"./_core":44,"./core.get-iterator-method":94}],96:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":39,"./_iter-define":62,"./_iter-step":63,"./_iterators":64,"./_to-iobject":86}],97:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

},{"./_descriptors":47,"./_export":51,"./_object-dp":68}],98:[function(require,module,exports){

},{}],99:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":62,"./_string-at":83}],100:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_an-object":40,"./_descriptors":47,"./_enum-keys":50,"./_export":51,"./_fails":52,"./_global":53,"./_has":54,"./_hide":55,"./_is-array":59,"./_is-object":60,"./_library":65,"./_meta":66,"./_object-create":67,"./_object-dp":68,"./_object-gopd":70,"./_object-gopn":72,"./_object-gopn-ext":71,"./_object-gops":73,"./_object-keys":76,"./_object-pie":77,"./_property-desc":78,"./_redefine":79,"./_set-to-string-tag":80,"./_shared":82,"./_to-iobject":86,"./_to-primitive":89,"./_uid":90,"./_wks":93,"./_wks-define":91,"./_wks-ext":92}],101:[function(require,module,exports){
require('./_wks-define')('asyncIterator');

},{"./_wks-define":91}],102:[function(require,module,exports){
require('./_wks-define')('observable');

},{"./_wks-define":91}],103:[function(require,module,exports){
require('./es6.array.iterator');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var TO_STRING_TAG = require('./_wks')('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}

},{"./_global":53,"./_hide":55,"./_iterators":64,"./_wks":93,"./es6.array.iterator":96}],104:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],105:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.Immutable = {})));
}(this, (function (exports) { 'use strict';

  // Used for setting prototype methods that IE8 chokes on.
  var DELETE = 'delete';

  // Constants describing the size of trie nodes.
  var SHIFT = 5; // Resulted in best performance after ______?
  var SIZE = 1 << SHIFT;
  var MASK = SIZE - 1;

  // A consistent shared value representing "not set" which equals nothing other
  // than itself, and nothing that could be provided externally.
  var NOT_SET = {};

  // Boolean references, Rough equivalent of `bool &`.
  function MakeRef() {
    return { value: false };
  }

  function SetRef(ref) {
    if (ref) {
      ref.value = true;
    }
  }

  // A function which returns a value representing an "owner" for transient writes
  // to tries. The return value will only ever equal itself, and will not equal
  // the return of any subsequent call of this function.
  function OwnerID() {}

  function ensureSize(iter) {
    if (iter.size === undefined) {
      iter.size = iter.__iterate(returnTrue);
    }
    return iter.size;
  }

  function wrapIndex(iter, index) {
    // This implements "is array index" which the ECMAString spec defines as:
    //
    //     A String property name P is an array index if and only if
    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
    //     to 2^32−1.
    //
    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
    if (typeof index !== 'number') {
      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
      if ('' + uint32Index !== index || uint32Index === 4294967295) {
        return NaN;
      }
      index = uint32Index;
    }
    return index < 0 ? ensureSize(iter) + index : index;
  }

  function returnTrue() {
    return true;
  }

  function wholeSlice(begin, end, size) {
    return (
      ((begin === 0 && !isNeg(begin)) ||
        (size !== undefined && begin <= -size)) &&
      (end === undefined || (size !== undefined && end >= size))
    );
  }

  function resolveBegin(begin, size) {
    return resolveIndex(begin, size, 0);
  }

  function resolveEnd(end, size) {
    return resolveIndex(end, size, size);
  }

  function resolveIndex(index, size, defaultIndex) {
    // Sanitize indices using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
    return index === undefined
      ? defaultIndex
      : isNeg(index)
        ? size === Infinity
          ? size
          : Math.max(0, size + index) | 0
        : size === undefined || size === index
          ? index
          : Math.min(size, index) | 0;
  }

  function isNeg(value) {
    // Account for -0 which is negative, but not less than 0.
    return value < 0 || (value === 0 && 1 / value === -Infinity);
  }

  // Note: value is unchanged to not break immutable-devtools.
  var IS_COLLECTION_SYMBOL = '@@__IMMUTABLE_ITERABLE__@@';

  function isCollection(maybeCollection) {
    return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);
  }

  var IS_KEYED_SYMBOL = '@@__IMMUTABLE_KEYED__@@';

  function isKeyed(maybeKeyed) {
    return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);
  }

  var IS_INDEXED_SYMBOL = '@@__IMMUTABLE_INDEXED__@@';

  function isIndexed(maybeIndexed) {
    return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);
  }

  function isAssociative(maybeAssociative) {
    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
  }

  var Collection = function Collection(value) {
    return isCollection(value) ? value : Seq(value);
  };

  var KeyedCollection = (function (Collection) {
    function KeyedCollection(value) {
      return isKeyed(value) ? value : KeyedSeq(value);
    }

    if ( Collection ) KeyedCollection.__proto__ = Collection;
    KeyedCollection.prototype = Object.create( Collection && Collection.prototype );
    KeyedCollection.prototype.constructor = KeyedCollection;

    return KeyedCollection;
  }(Collection));

  var IndexedCollection = (function (Collection) {
    function IndexedCollection(value) {
      return isIndexed(value) ? value : IndexedSeq(value);
    }

    if ( Collection ) IndexedCollection.__proto__ = Collection;
    IndexedCollection.prototype = Object.create( Collection && Collection.prototype );
    IndexedCollection.prototype.constructor = IndexedCollection;

    return IndexedCollection;
  }(Collection));

  var SetCollection = (function (Collection) {
    function SetCollection(value) {
      return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);
    }

    if ( Collection ) SetCollection.__proto__ = Collection;
    SetCollection.prototype = Object.create( Collection && Collection.prototype );
    SetCollection.prototype.constructor = SetCollection;

    return SetCollection;
  }(Collection));

  Collection.Keyed = KeyedCollection;
  Collection.Indexed = IndexedCollection;
  Collection.Set = SetCollection;

  var IS_SEQ_SYMBOL = '@@__IMMUTABLE_SEQ__@@';

  function isSeq(maybeSeq) {
    return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);
  }

  var IS_RECORD_SYMBOL = '@@__IMMUTABLE_RECORD__@@';

  function isRecord(maybeRecord) {
    return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);
  }

  function isImmutable(maybeImmutable) {
    return isCollection(maybeImmutable) || isRecord(maybeImmutable);
  }

  var IS_ORDERED_SYMBOL = '@@__IMMUTABLE_ORDERED__@@';

  function isOrdered(maybeOrdered) {
    return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);
  }

  var ITERATE_KEYS = 0;
  var ITERATE_VALUES = 1;
  var ITERATE_ENTRIES = 2;

  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator';

  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;

  var Iterator = function Iterator(next) {
    this.next = next;
  };

  Iterator.prototype.toString = function toString () {
    return '[Iterator]';
  };

  Iterator.KEYS = ITERATE_KEYS;
  Iterator.VALUES = ITERATE_VALUES;
  Iterator.ENTRIES = ITERATE_ENTRIES;

  Iterator.prototype.inspect = Iterator.prototype.toSource = function() {
    return this.toString();
  };
  Iterator.prototype[ITERATOR_SYMBOL] = function() {
    return this;
  };

  function iteratorValue(type, k, v, iteratorResult) {
    var value = type === 0 ? k : type === 1 ? v : [k, v];
    iteratorResult
      ? (iteratorResult.value = value)
      : (iteratorResult = {
          value: value,
          done: false,
        });
    return iteratorResult;
  }

  function iteratorDone() {
    return { value: undefined, done: true };
  }

  function hasIterator(maybeIterable) {
    return !!getIteratorFn(maybeIterable);
  }

  function isIterator(maybeIterator) {
    return maybeIterator && typeof maybeIterator.next === 'function';
  }

  function getIterator(iterable) {
    var iteratorFn = getIteratorFn(iterable);
    return iteratorFn && iteratorFn.call(iterable);
  }

  function getIteratorFn(iterable) {
    var iteratorFn =
      iterable &&
      ((REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
        iterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  function isArrayLike(value) {
    if (Array.isArray(value) || typeof value === 'string') {
      return true;
    }

    return (
      value &&
      typeof value === 'object' &&
      Number.isInteger(value.length) &&
      value.length >= 0 &&
      (value.length === 0
        ? // Only {length: 0} is considered Array-like.
          Object.keys(value).length === 1
        : // An object is only Array-like if it has a property where the last value
          // in the array-like may be found (which could be undefined).
          value.hasOwnProperty(value.length - 1))
    );
  }

  var Seq = (function (Collection$$1) {
    function Seq(value) {
      return value === null || value === undefined
        ? emptySequence()
        : isImmutable(value)
          ? value.toSeq()
          : seqFromValue(value);
    }

    if ( Collection$$1 ) Seq.__proto__ = Collection$$1;
    Seq.prototype = Object.create( Collection$$1 && Collection$$1.prototype );
    Seq.prototype.constructor = Seq;

    Seq.prototype.toSeq = function toSeq () {
      return this;
    };

    Seq.prototype.toString = function toString () {
      return this.__toString('Seq {', '}');
    };

    Seq.prototype.cacheResult = function cacheResult () {
      if (!this._cache && this.__iterateUncached) {
        this._cache = this.entrySeq().toArray();
        this.size = this._cache.length;
      }
      return this;
    };

    // abstract __iterateUncached(fn, reverse)

    Seq.prototype.__iterate = function __iterate (fn, reverse) {
      var this$1 = this;

      var cache = this._cache;
      if (cache) {
        var size = cache.length;
        var i = 0;
        while (i !== size) {
          var entry = cache[reverse ? size - ++i : i++];
          if (fn(entry[1], entry[0], this$1) === false) {
            break;
          }
        }
        return i;
      }
      return this.__iterateUncached(fn, reverse);
    };

    // abstract __iteratorUncached(type, reverse)

    Seq.prototype.__iterator = function __iterator (type, reverse) {
      var cache = this._cache;
      if (cache) {
        var size = cache.length;
        var i = 0;
        return new Iterator(function () {
          if (i === size) {
            return iteratorDone();
          }
          var entry = cache[reverse ? size - ++i : i++];
          return iteratorValue(type, entry[0], entry[1]);
        });
      }
      return this.__iteratorUncached(type, reverse);
    };

    return Seq;
  }(Collection));

  var KeyedSeq = (function (Seq) {
    function KeyedSeq(value) {
      return value === null || value === undefined
        ? emptySequence().toKeyedSeq()
        : isCollection(value)
          ? isKeyed(value)
            ? value.toSeq()
            : value.fromEntrySeq()
          : isRecord(value)
            ? value.toSeq()
            : keyedSeqFromValue(value);
    }

    if ( Seq ) KeyedSeq.__proto__ = Seq;
    KeyedSeq.prototype = Object.create( Seq && Seq.prototype );
    KeyedSeq.prototype.constructor = KeyedSeq;

    KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq () {
      return this;
    };

    return KeyedSeq;
  }(Seq));

  var IndexedSeq = (function (Seq) {
    function IndexedSeq(value) {
      return value === null || value === undefined
        ? emptySequence()
        : isCollection(value)
          ? isKeyed(value)
            ? value.entrySeq()
            : value.toIndexedSeq()
          : isRecord(value)
            ? value.toSeq().entrySeq()
            : indexedSeqFromValue(value);
    }

    if ( Seq ) IndexedSeq.__proto__ = Seq;
    IndexedSeq.prototype = Object.create( Seq && Seq.prototype );
    IndexedSeq.prototype.constructor = IndexedSeq;

    IndexedSeq.of = function of (/*...values*/) {
      return IndexedSeq(arguments);
    };

    IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq () {
      return this;
    };

    IndexedSeq.prototype.toString = function toString () {
      return this.__toString('Seq [', ']');
    };

    return IndexedSeq;
  }(Seq));

  var SetSeq = (function (Seq) {
    function SetSeq(value) {
      return (isCollection(value) && !isAssociative(value)
        ? value
        : IndexedSeq(value)
      ).toSetSeq();
    }

    if ( Seq ) SetSeq.__proto__ = Seq;
    SetSeq.prototype = Object.create( Seq && Seq.prototype );
    SetSeq.prototype.constructor = SetSeq;

    SetSeq.of = function of (/*...values*/) {
      return SetSeq(arguments);
    };

    SetSeq.prototype.toSetSeq = function toSetSeq () {
      return this;
    };

    return SetSeq;
  }(Seq));

  Seq.isSeq = isSeq;
  Seq.Keyed = KeyedSeq;
  Seq.Set = SetSeq;
  Seq.Indexed = IndexedSeq;

  Seq.prototype[IS_SEQ_SYMBOL] = true;

  // #pragma Root Sequences

  var ArraySeq = (function (IndexedSeq) {
    function ArraySeq(array) {
      this._array = array;
      this.size = array.length;
    }

    if ( IndexedSeq ) ArraySeq.__proto__ = IndexedSeq;
    ArraySeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );
    ArraySeq.prototype.constructor = ArraySeq;

    ArraySeq.prototype.get = function get (index, notSetValue) {
      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
    };

    ArraySeq.prototype.__iterate = function __iterate (fn, reverse) {
      var this$1 = this;

      var array = this._array;
      var size = array.length;
      var i = 0;
      while (i !== size) {
        var ii = reverse ? size - ++i : i++;
        if (fn(array[ii], ii, this$1) === false) {
          break;
        }
      }
      return i;
    };

    ArraySeq.prototype.__iterator = function __iterator (type, reverse) {
      var array = this._array;
      var size = array.length;
      var i = 0;
      return new Iterator(function () {
        if (i === size) {
          return iteratorDone();
        }
        var ii = reverse ? size - ++i : i++;
        return iteratorValue(type, ii, array[ii]);
      });
    };

    return ArraySeq;
  }(IndexedSeq));

  var ObjectSeq = (function (KeyedSeq) {
    function ObjectSeq(object) {
      var keys = Object.keys(object);
      this._object = object;
      this._keys = keys;
      this.size = keys.length;
    }

    if ( KeyedSeq ) ObjectSeq.__proto__ = KeyedSeq;
    ObjectSeq.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );
    ObjectSeq.prototype.constructor = ObjectSeq;

    ObjectSeq.prototype.get = function get (key, notSetValue) {
      if (notSetValue !== undefined && !this.has(key)) {
        return notSetValue;
      }
      return this._object[key];
    };

    ObjectSeq.prototype.has = function has (key) {
      return hasOwnProperty.call(this._object, key);
    };

    ObjectSeq.prototype.__iterate = function __iterate (fn, reverse) {
      var this$1 = this;

      var object = this._object;
      var keys = this._keys;
      var size = keys.length;
      var i = 0;
      while (i !== size) {
        var key = keys[reverse ? size - ++i : i++];
        if (fn(object[key], key, this$1) === false) {
          break;
        }
      }
      return i;
    };

    ObjectSeq.prototype.__iterator = function __iterator (type, reverse) {
      var object = this._object;
      var keys = this._keys;
      var size = keys.length;
      var i = 0;
      return new Iterator(function () {
        if (i === size) {
          return iteratorDone();
        }
        var key = keys[reverse ? size - ++i : i++];
        return iteratorValue(type, key, object[key]);
      });
    };

    return ObjectSeq;
  }(KeyedSeq));
  ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;

  var CollectionSeq = (function (IndexedSeq) {
    function CollectionSeq(collection) {
      this._collection = collection;
      this.size = collection.length || collection.size;
    }

    if ( IndexedSeq ) CollectionSeq.__proto__ = IndexedSeq;
    CollectionSeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );
    CollectionSeq.prototype.constructor = CollectionSeq;

    CollectionSeq.prototype.__iterateUncached = function __iterateUncached (fn, reverse) {
      var this$1 = this;

      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var collection = this._collection;
      var iterator = getIterator(collection);
      var iterations = 0;
      if (isIterator(iterator)) {
        var step;
        while (!(step = iterator.next()).done) {
          if (fn(step.value, iterations++, this$1) === false) {
            break;
          }
        }
      }
      return iterations;
    };

    CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached (type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var collection = this._collection;
      var iterator = getIterator(collection);
      if (!isIterator(iterator)) {
        return new Iterator(iteratorDone);
      }
      var iterations = 0;
      return new Iterator(function () {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type, iterations++, step.value);
      });
    };

    return CollectionSeq;
  }(IndexedSeq));

  // # pragma Helper functions

  var EMPTY_SEQ;

  function emptySequence() {
    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
  }

  function keyedSeqFromValue(value) {
    var seq = Array.isArray(value)
      ? new ArraySeq(value)
      : hasIterator(value)
        ? new CollectionSeq(value)
        : undefined;
    if (seq) {
      return seq.fromEntrySeq();
    }
    if (typeof value === 'object') {
      return new ObjectSeq(value);
    }
    throw new TypeError(
      'Expected Array or collection object of [k, v] entries, or keyed object: ' +
        value
    );
  }

  function indexedSeqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value);
    if (seq) {
      return seq;
    }
    throw new TypeError(
      'Expected Array or collection object of values: ' + value
    );
  }

  function seqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value);
    if (seq) {
      return seq;
    }
    if (typeof value === 'object') {
      return new ObjectSeq(value);
    }
    throw new TypeError(
      'Expected Array or collection object of values, or keyed object: ' + value
    );
  }

  function maybeIndexedSeqFromValue(value) {
    return isArrayLike(value)
      ? new ArraySeq(value)
      : hasIterator(value)
        ? new CollectionSeq(value)
        : undefined;
  }

  var IS_MAP_SYMBOL = '@@__IMMUTABLE_MAP__@@';

  function isMap(maybeMap) {
    return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);
  }

  function isOrderedMap(maybeOrderedMap) {
    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
  }

  function isValueObject(maybeValue) {
    return Boolean(
      maybeValue &&
        typeof maybeValue.equals === 'function' &&
        typeof maybeValue.hashCode === 'function'
    );
  }

  /**
   * An extension of the "same-value" algorithm as [described for use by ES6 Map
   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
   *
   * NaN is considered the same as NaN, however -0 and 0 are considered the same
   * value, which is different from the algorithm described by
   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
   *
   * This is extended further to allow Objects to describe the values they
   * represent, by way of `valueOf` or `equals` (and `hashCode`).
   *
   * Note: because of this extension, the key equality of Immutable.Map and the
   * value equality of Immutable.Set will differ from ES6 Map and Set.
   *
   * ### Defining custom values
   *
   * The easiest way to describe the value an object represents is by implementing
   * `valueOf`. For example, `Date` represents a value by returning a unix
   * timestamp for `valueOf`:
   *
   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
   *     var date2 = new Date(1234567890000);
   *     date1.valueOf(); // 1234567890000
   *     assert( date1 !== date2 );
   *     assert( Immutable.is( date1, date2 ) );
   *
   * Note: overriding `valueOf` may have other implications if you use this object
   * where JavaScript expects a primitive, such as implicit string coercion.
   *
   * For more complex types, especially collections, implementing `valueOf` may
   * not be performant. An alternative is to implement `equals` and `hashCode`.
   *
   * `equals` takes another object, presumably of similar type, and returns true
   * if it is equal. Equality is symmetrical, so the same result should be
   * returned if this and the argument are flipped.
   *
   *     assert( a.equals(b) === b.equals(a) );
   *
   * `hashCode` returns a 32bit integer number representing the object which will
   * be used to determine how to store the value object in a Map or Set. You must
   * provide both or neither methods, one must not exist without the other.
   *
   * Also, an important relationship between these methods must be upheld: if two
   * values are equal, they *must* return the same hashCode. If the values are not
   * equal, they might have the same hashCode; this is called a hash collision,
   * and while undesirable for performance reasons, it is acceptable.
   *
   *     if (a.equals(b)) {
   *       assert( a.hashCode() === b.hashCode() );
   *     }
   *
   * All Immutable collections are Value Objects: they implement `equals()`
   * and `hashCode()`.
   */
  function is(valueA, valueB) {
    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
      return true;
    }
    if (!valueA || !valueB) {
      return false;
    }
    if (
      typeof valueA.valueOf === 'function' &&
      typeof valueB.valueOf === 'function'
    ) {
      valueA = valueA.valueOf();
      valueB = valueB.valueOf();
      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
        return true;
      }
      if (!valueA || !valueB) {
        return false;
      }
    }
    return !!(
      isValueObject(valueA) &&
      isValueObject(valueB) &&
      valueA.equals(valueB)
    );
  }

  var imul =
    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2
      ? Math.imul
      : function imul(a, b) {
          a |= 0; // int
          b |= 0; // int
          var c = a & 0xffff;
          var d = b & 0xffff;
          // Shift by 0 fixes the sign on the high part.
          return (c * d + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0)) | 0; // int
        };

  // v8 has an optimization for storing 31-bit signed numbers.
  // Values which have either 00 or 11 as the high order bits qualify.
  // This function drops the highest order bit in a signed number, maintaining
  // the sign bit.
  function smi(i32) {
    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xbfffffff);
  }

  function hash(o) {
    if (o === false || o === null || o === undefined) {
      return 0;
    }
    if (typeof o.valueOf === 'function') {
      o = o.valueOf();
      if (o === false || o === null || o === undefined) {
        return 0;
      }
    }
    if (o === true) {
      return 1;
    }
    var type = typeof o;
    if (type === 'number') {
      if (o !== o || o === Infinity) {
        return 0;
      }
      var h = o | 0;
      if (h !== o) {
        h ^= o * 0xffffffff;
      }
      while (o > 0xffffffff) {
        o /= 0xffffffff;
        h ^= o;
      }
      return smi(h);
    }
    if (type === 'string') {
      return o.length > STRING_HASH_CACHE_MIN_STRLEN
        ? cachedHashString(o)
        : hashString(o);
    }
    if (typeof o.hashCode === 'function') {
      // Drop any high bits from accidentally long hash codes.
      return smi(o.hashCode());
    }
    if (type === 'object' || type === 'function') {
      return hashJSObj(o);
    }
    if (typeof o.toString === 'function') {
      return hashString(o.toString());
    }
    throw new Error('Value type ' + type + ' cannot be hashed.');
  }

  function cachedHashString(string) {
    var hashed = stringHashCache[string];
    if (hashed === undefined) {
      hashed = hashString(string);
      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
        STRING_HASH_CACHE_SIZE = 0;
        stringHashCache = {};
      }
      STRING_HASH_CACHE_SIZE++;
      stringHashCache[string] = hashed;
    }
    return hashed;
  }

  // http://jsperf.com/hashing-strings
  function hashString(string) {
    // This is the hash from JVM
    // The hash code for a string is computed as
    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
    // where s[i] is the ith character of the string and n is the length of
    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
    // (exclusive) by dropping high bits.
    var hashed = 0;
    for (var ii = 0; ii < string.length; ii++) {
      hashed = (31 * hashed + string.charCodeAt(ii)) | 0;
    }
    return smi(hashed);
  }

  function hashJSObj(obj) {
    var hashed;
    if (usingWeakMap) {
      hashed = weakMap.get(obj);
      if (hashed !== undefined) {
        return hashed;
      }
    }

    hashed = obj[UID_HASH_KEY];
    if (hashed !== undefined) {
      return hashed;
    }

    if (!canDefineProperty) {
      hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
      if (hashed !== undefined) {
        return hashed;
      }

      hashed = getIENodeHash(obj);
      if (hashed !== undefined) {
        return hashed;
      }
    }

    hashed = ++objHashUID;
    if (objHashUID & 0x40000000) {
      objHashUID = 0;
    }

    if (usingWeakMap) {
      weakMap.set(obj, hashed);
    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
      throw new Error('Non-extensible objects are not allowed as keys.');
    } else if (canDefineProperty) {
      Object.defineProperty(obj, UID_HASH_KEY, {
        enumerable: false,
        configurable: false,
        writable: false,
        value: hashed,
      });
    } else if (
      obj.propertyIsEnumerable !== undefined &&
      obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable
    ) {
      // Since we can't define a non-enumerable property on the object
      // we'll hijack one of the less-used non-enumerable properties to
      // save our hash on it. Since this is a function it will not show up in
      // `JSON.stringify` which is what we want.
      obj.propertyIsEnumerable = function() {
        return this.constructor.prototype.propertyIsEnumerable.apply(
          this,
          arguments
        );
      };
      obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;
    } else if (obj.nodeType !== undefined) {
      // At this point we couldn't get the IE `uniqueID` to use as a hash
      // and we couldn't use a non-enumerable property to exploit the
      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
      // itself.
      obj[UID_HASH_KEY] = hashed;
    } else {
      throw new Error('Unable to set a non-enumerable property on object.');
    }

    return hashed;
  }

  // Get references to ES5 object methods.
  var isExtensible = Object.isExtensible;

  // True if Object.defineProperty works as expected. IE8 fails this test.
  var canDefineProperty = (function() {
    try {
      Object.defineProperty({}, '@', {});
      return true;
    } catch (e) {
      return false;
    }
  })();

  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
  // and avoid memory leaks from the IE cloneNode bug.
  function getIENodeHash(node) {
    if (node && node.nodeType > 0) {
      switch (node.nodeType) {
        case 1: // Element
          return node.uniqueID;
        case 9: // Document
          return node.documentElement && node.documentElement.uniqueID;
      }
    }
  }

  // If possible, use a WeakMap.
  var usingWeakMap = typeof WeakMap === 'function';
  var weakMap;
  if (usingWeakMap) {
    weakMap = new WeakMap();
  }

  var objHashUID = 0;

  var UID_HASH_KEY = '__immutablehash__';
  if (typeof Symbol === 'function') {
    UID_HASH_KEY = Symbol(UID_HASH_KEY);
  }

  var STRING_HASH_CACHE_MIN_STRLEN = 16;
  var STRING_HASH_CACHE_MAX_SIZE = 255;
  var STRING_HASH_CACHE_SIZE = 0;
  var stringHashCache = {};

  var ToKeyedSequence = (function (KeyedSeq$$1) {
    function ToKeyedSequence(indexed, useKeys) {
      this._iter = indexed;
      this._useKeys = useKeys;
      this.size = indexed.size;
    }

    if ( KeyedSeq$$1 ) ToKeyedSequence.__proto__ = KeyedSeq$$1;
    ToKeyedSequence.prototype = Object.create( KeyedSeq$$1 && KeyedSeq$$1.prototype );
    ToKeyedSequence.prototype.constructor = ToKeyedSequence;

    ToKeyedSequence.prototype.get = function get (key, notSetValue) {
      return this._iter.get(key, notSetValue);
    };

    ToKeyedSequence.prototype.has = function has (key) {
      return this._iter.has(key);
    };

    ToKeyedSequence.prototype.valueSeq = function valueSeq () {
      return this._iter.valueSeq();
    };

    ToKeyedSequence.prototype.reverse = function reverse () {
      var this$1 = this;

      var reversedSequence = reverseFactory(this, true);
      if (!this._useKeys) {
        reversedSequence.valueSeq = function () { return this$1._iter.toSeq().reverse(); };
      }
      return reversedSequence;
    };

    ToKeyedSequence.prototype.map = function map (mapper, context) {
      var this$1 = this;

      var mappedSequence = mapFactory(this, mapper, context);
      if (!this._useKeys) {
        mappedSequence.valueSeq = function () { return this$1._iter.toSeq().map(mapper, context); };
      }
      return mappedSequence;
    };

    ToKeyedSequence.prototype.__iterate = function __iterate (fn, reverse) {
      var this$1 = this;

      return this._iter.__iterate(function (v, k) { return fn(v, k, this$1); }, reverse);
    };

    ToKeyedSequence.prototype.__iterator = function __iterator (type, reverse) {
      return this._iter.__iterator(type, reverse);
    };

    return ToKeyedSequence;
  }(KeyedSeq));
  ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;

  var ToIndexedSequence = (function (IndexedSeq$$1) {
    function ToIndexedSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }

    if ( IndexedSeq$$1 ) ToIndexedSequence.__proto__ = IndexedSeq$$1;
    ToIndexedSequence.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );
    ToIndexedSequence.prototype.constructor = ToIndexedSequence;

    ToIndexedSequence.prototype.includes = function includes (value) {
      return this._iter.includes(value);
    };

    ToIndexedSequence.prototype.__iterate = function __iterate (fn, reverse) {
      var this$1 = this;

      var i = 0;
      reverse && ensureSize(this);
      return this._iter.__iterate(
        function (v) { return fn(v, reverse ? this$1.size - ++i : i++, this$1); },
        reverse
      );
    };

    ToIndexedSequence.prototype.__iterator = function __iterator (type, reverse) {
      var this$1 = this;

      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var i = 0;
      reverse && ensureSize(this);
      return new Iterator(function () {
        var step = iterator.next();
        return step.done
          ? step
          : iteratorValue(
              type,
              reverse ? this$1.size - ++i : i++,
              step.value,
              step
            );
      });
    };

    return ToIndexedSequence;
  }(IndexedSeq));

  var ToSetSequence = (function (SetSeq$$1) {
    function ToSetSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }

    if ( SetSeq$$1 ) ToSetSequence.__proto__ = SetSeq$$1;
    ToSetSequence.prototype = Object.create( SetSeq$$1 && SetSeq$$1.prototype );
    ToSetSequence.prototype.constructor = ToSetSequence;

    ToSetSequence.prototype.has = function has (key) {
      return this._iter.includes(key);
    };

    ToSetSequence.prototype.__iterate = function __iterate (fn, reverse) {
      var this$1 = this;

      return this._iter.__iterate(function (v) { return fn(v, v, this$1); }, reverse);
    };

    ToSetSequence.prototype.__iterator = function __iterator (type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function () {
        var step = iterator.next();
        return step.done
          ? step
          : iteratorValue(type, step.value, step.value, step);
      });
    };

    return ToSetSequence;
  }(SetSeq));

  var FromEntriesSequence = (function (KeyedSeq$$1) {
    function FromEntriesSequence(entries) {
      this._iter = entries;
      this.size = entries.size;
    }

    if ( KeyedSeq$$1 ) FromEntriesSequence.__proto__ = KeyedSeq$$1;
    FromEntriesSequence.prototype = Object.create( KeyedSeq$$1 && KeyedSeq$$1.prototype );
    FromEntriesSequence.prototype.constructor = FromEntriesSequence;

    FromEntriesSequence.prototype.entrySeq = function entrySeq () {
      return this._iter.toSeq();
    };

    FromEntriesSequence.prototype.__iterate = function __iterate (fn, reverse) {
      var this$1 = this;

      return this._iter.__iterate(function (entry) {
        // Check if entry exists first so array access doesn't throw for holes
        // in the parent iteration.
        if (entry) {
          validateEntry(entry);
          var indexedCollection = isCollection(entry);
          return fn(
            indexedCollection ? entry.get(1) : entry[1],
            indexedCollection ? entry.get(0) : entry[0],
            this$1
          );
        }
      }, reverse);
    };

    FromEntriesSequence.prototype.__iterator = function __iterator (type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function () {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          // Check if entry exists first so array access doesn't throw for holes
          // in the parent iteration.
          if (entry) {
            validateEntry(entry);
            var indexedCollection = isCollection(entry);
            return iteratorValue(
              type,
              indexedCollection ? entry.get(0) : entry[0],
              indexedCollection ? entry.get(1) : entry[1],
              step
            );
          }
        }
      });
    };

    return FromEntriesSequence;
  }(KeyedSeq));

  ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;

  function flipFactory(collection) {
    var flipSequence = makeSequence(collection);
    flipSequence._iter = collection;
    flipSequence.size = collection.size;
    flipSequence.flip = function () { return collection; };
    flipSequence.reverse = function() {
      var reversedSequence = collection.reverse.apply(this); // super.reverse()
      reversedSequence.flip = function () { return collection.reverse(); };
      return reversedSequence;
    };
    flipSequence.has = function (key) { return collection.includes(key); };
    flipSequence.includes = function (key) { return collection.has(key); };
    flipSequence.cacheResult = cacheResultThrough;
    flipSequence.__iterateUncached = function(fn, reverse) {
      var this$1 = this;

      return collection.__iterate(function (v, k) { return fn(k, v, this$1) !== false; }, reverse);
    };
    flipSequence.__iteratorUncached = function(type, reverse) {
      if (type === ITERATE_ENTRIES) {
        var iterator = collection.__iterator(type, reverse);
        return new Iterator(function () {
          var step = iterator.next();
          if (!step.done) {
            var k = step.value[0];
            step.value[0] = step.value[1];
            step.value[1] = k;
          }
          return step;
        });
      }
      return collection.__iterator(
        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
        reverse
      );
    };
    return flipSequence;
  }

  function mapFactory(collection, mapper, context) {
    var mappedSequence = makeSequence(collection);
    mappedSequence.size = collection.size;
    mappedSequence.has = function (key) { return collection.has(key); };
    mappedSequence.get = function (key, notSetValue) {
      var v = collection.get(key, NOT_SET);
      return v === NOT_SET
        ? notSetValue
        : mapper.call(context, v, key, collection);
    };
    mappedSequence.__iterateUncached = function(fn, reverse) {
      var this$1 = this;

      return collection.__iterate(
        function (v, k, c) { return fn(mapper.call(context, v, k, c), k, this$1) !== false; },
        reverse
      );
    };
    mappedSequence.__iteratorUncached = function(type, reverse) {
      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
      return new Iterator(function () {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var key = entry[0];
        return iteratorValue(
          type,
          key,
          mapper.call(context, entry[1], key, collection),
          step
        );
      });
    };
    return mappedSequence;
  }

  function reverseFactory(collection, useKeys) {
    var this$1 = this;

    var reversedSequence = makeSequence(collection);
    reversedSequence._iter = collection;
    reversedSequence.size = collection.size;
    reversedSequence.reverse = function () { return collection; };
    if (collection.flip) {
      reversedSequence.flip = function() {
        var flipSequence = flipFactory(collection);
        flipSequence.reverse = function () { return collection.flip(); };
        return flipSequence;
      };
    }
    reversedSequence.get = function (key, notSetValue) { return collection.get(useKeys ? key : -1 - key, notSetValue); };
    reversedSequence.has = function (key) { return collection.has(useKeys ? key : -1 - key); };
    reversedSequence.includes = function (value) { return collection.includes(value); };
    reversedSequence.cacheResult = cacheResultThrough;
    reversedSequence.__iterate = function(fn, reverse) {
      var this$1 = this;

      var i = 0;
      reverse && ensureSize(collection);
      return collection.__iterate(
        function (v, k) { return fn(v, useKeys ? k : reverse ? this$1.size - ++i : i++, this$1); },
        !reverse
      );
    };
    reversedSequence.__iterator = function (type, reverse) {
      var i = 0;
      reverse && ensureSize(collection);
      var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);
      return new Iterator(function () {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        return iteratorValue(
          type,
          useKeys ? entry[0] : reverse ? this$1.size - ++i : i++,
          entry[1],
          step
        );
      });
    };
    return reversedSequence;
  }

  function filterFactory(collection, predicate, context, useKeys) {
    var filterSequence = makeSequence(collection);
    if (useKeys) {
      filterSequence.has = function (key) {
        var v = collection.get(key, NOT_SET);
        return v !== NOT_SET && !!predicate.call(context, v, key, collection);
      };
      filterSequence.get = function (key, notSetValue) {
        var v = collection.get(key, NOT_SET);
        return v !== NOT_SET && predicate.call(context, v, key, collection)
          ? v
          : notSetValue;
      };
    }
    filterSequence.__iterateUncached = function(fn, reverse) {
      var this$1 = this;

      var iterations = 0;
      collection.__iterate(function (v, k, c) {
        if (predicate.call(context, v, k, c)) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$1);
        }
      }, reverse);
      return iterations;
    };
    filterSequence.__iteratorUncached = function(type, reverse) {
      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
      var iterations = 0;
      return new Iterator(function () {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          var key = entry[0];
          var value = entry[1];
          if (predicate.call(context, value, key, collection)) {
            return iteratorValue(type, useKeys ? key : iterations++, value, step);
          }
        }
      });
    };
    return filterSequence;
  }

  function countByFactory(collection, grouper, context) {
    var groups = Map().asMutable();
    collection.__iterate(function (v, k) {
      groups.update(grouper.call(context, v, k, collection), 0, function (a) { return a + 1; });
    });
    return groups.asImmutable();
  }

  function groupByFactory(collection, grouper, context) {
    var isKeyedIter = isKeyed(collection);
    var groups = (isOrdered(collection) ? OrderedMap() : Map()).asMutable();
    collection.__iterate(function (v, k) {
      groups.update(
        grouper.call(context, v, k, collection),
        function (a) { return ((a = a || []), a.push(isKeyedIter ? [k, v] : v), a); }
      );
    });
    var coerce = collectionClass(collection);
    return groups.map(function (arr) { return reify(collection, coerce(arr)); }).asImmutable();
  }

  function sliceFactory(collection, begin, end, useKeys) {
    var originalSize = collection.size;

    if (wholeSlice(begin, end, originalSize)) {
      return collection;
    }

    var resolvedBegin = resolveBegin(begin, originalSize);
    var resolvedEnd = resolveEnd(end, originalSize);

    // begin or end will be NaN if they were provided as negative numbers and
    // this collection's size is unknown. In that case, cache first so there is
    // a known size and these do not resolve to NaN.
    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
      return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);
    }

    // Note: resolvedEnd is undefined when the original sequence's length is
    // unknown and this slice did not supply an end and should contain all
    // elements after resolvedBegin.
    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
    var resolvedSize = resolvedEnd - resolvedBegin;
    var sliceSize;
    if (resolvedSize === resolvedSize) {
      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
    }

    var sliceSeq = makeSequence(collection);

    // If collection.size is undefined, the size of the realized sliceSeq is
    // unknown at this point unless the number of items to slice is 0
    sliceSeq.size =
      sliceSize === 0 ? sliceSize : (collection.size && sliceSize) || undefined;

    if (!useKeys && isSeq(collection) && sliceSize >= 0) {
      sliceSeq.get = function(index, notSetValue) {
        index = wrapIndex(this, index);
        return index >= 0 && index < sliceSize
          ? collection.get(index + resolvedBegin, notSetValue)
          : notSetValue;
      };
    }

    sliceSeq.__iterateUncached = function(fn, reverse) {
      var this$1 = this;

      if (sliceSize === 0) {
        return 0;
      }
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var skipped = 0;
      var isSkipping = true;
      var iterations = 0;
      collection.__iterate(function (v, k) {
        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
          iterations++;
          return (
            fn(v, useKeys ? k : iterations - 1, this$1) !== false &&
            iterations !== sliceSize
          );
        }
      });
      return iterations;
    };

    sliceSeq.__iteratorUncached = function(type, reverse) {
      if (sliceSize !== 0 && reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      // Don't bother instantiating parent iterator if taking 0.
      if (sliceSize === 0) {
        return new Iterator(iteratorDone);
      }
      var iterator = collection.__iterator(type, reverse);
      var skipped = 0;
      var iterations = 0;
      return new Iterator(function () {
        while (skipped++ < resolvedBegin) {
          iterator.next();
        }
        if (++iterations > sliceSize) {
          return iteratorDone();
        }
        var step = iterator.next();
        if (useKeys || type === ITERATE_VALUES || step.done) {
          return step;
        }
        if (type === ITERATE_KEYS) {
          return iteratorValue(type, iterations - 1, undefined, step);
        }
        return iteratorValue(type, iterations - 1, step.value[1], step);
      });
    };

    return sliceSeq;
  }

  function takeWhileFactory(collection, predicate, context) {
    var takeSequence = makeSequence(collection);
    takeSequence.__iterateUncached = function(fn, reverse) {
      var this$1 = this;

      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterations = 0;
      collection.__iterate(
        function (v, k, c) { return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1); }
      );
      return iterations;
    };
    takeSequence.__iteratorUncached = function(type, reverse) {
      var this$1 = this;

      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
      var iterating = true;
      return new Iterator(function () {
        if (!iterating) {
          return iteratorDone();
        }
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var k = entry[0];
        var v = entry[1];
        if (!predicate.call(context, v, k, this$1)) {
          iterating = false;
          return iteratorDone();
        }
        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
      });
    };
    return takeSequence;
  }

  function skipWhileFactory(collection, predicate, context, useKeys) {
    var skipSequence = makeSequence(collection);
    skipSequence.__iterateUncached = function(fn, reverse) {
      var this$1 = this;

      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var isSkipping = true;
      var iterations = 0;
      collection.__iterate(function (v, k, c) {
        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$1);
        }
      });
      return iterations;
    };
    skipSequence.__iteratorUncached = function(type, reverse) {
      var this$1 = this;

      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
      var skipping = true;
      var iterations = 0;
      return new Iterator(function () {
        var step;
        var k;
        var v;
        do {
          step = iterator.next();
          if (step.done) {
            if (useKeys || type === ITERATE_VALUES) {
              return step;
            }
            if (type === ITERATE_KEYS) {
              return iteratorValue(type, iterations++, undefined, step);
            }
            return iteratorValue(type, iterations++, step.value[1], step);
          }
          var entry = step.value;
          k = entry[0];
          v = entry[1];
          skipping && (skipping = predicate.call(context, v, k, this$1));
        } while (skipping);
        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
      });
    };
    return skipSequence;
  }

  function concatFactory(collection, values) {
    var isKeyedCollection = isKeyed(collection);
    var iters = [collection]
      .concat(values)
      .map(function (v) {
        if (!isCollection(v)) {
          v = isKeyedCollection
            ? keyedSeqFromValue(v)
            : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
        } else if (isKeyedCollection) {
          v = KeyedCollection(v);
        }
        return v;
      })
      .filter(function (v) { return v.size !== 0; });

    if (iters.length === 0) {
      return collection;
    }

    if (iters.length === 1) {
      var singleton = iters[0];
      if (
        singleton === collection ||
        (isKeyedCollection && isKeyed(singleton)) ||
        (isIndexed(collection) && isIndexed(singleton))
      ) {
        return singleton;
      }
    }

    var concatSeq = new ArraySeq(iters);
    if (isKeyedCollection) {
      concatSeq = concatSeq.toKeyedSeq();
    } else if (!isIndexed(collection)) {
      concatSeq = concatSeq.toSetSeq();
    }
    concatSeq = concatSeq.flatten(true);
    concatSeq.size = iters.reduce(function (sum, seq) {
      if (sum !== undefined) {
        var size = seq.size;
        if (size !== undefined) {
          return sum + size;
        }
      }
    }, 0);
    return concatSeq;
  }

  function flattenFactory(collection, depth, useKeys) {
    var flatSequence = makeSequence(collection);
    flatSequence.__iterateUncached = function(fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterations = 0;
      var stopped = false;
      function flatDeep(iter, currentDepth) {
        iter.__iterate(function (v, k) {
          if ((!depth || currentDepth < depth) && isCollection(v)) {
            flatDeep(v, currentDepth + 1);
          } else {
            iterations++;
            if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {
              stopped = true;
            }
          }
          return !stopped;
        }, reverse);
      }
      flatDeep(collection, 0);
      return iterations;
    };
    flatSequence.__iteratorUncached = function(type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = collection.__iterator(type, reverse);
      var stack = [];
      var iterations = 0;
      return new Iterator(function () {
        while (iterator) {
          var step = iterator.next();
          if (step.done !== false) {
            iterator = stack.pop();
            continue;
          }
          var v = step.value;
          if (type === ITERATE_ENTRIES) {
            v = v[1];
          }
          if ((!depth || stack.length < depth) && isCollection(v)) {
            stack.push(iterator);
            iterator = v.__iterator(type, reverse);
          } else {
            return useKeys ? step : iteratorValue(type, iterations++, v, step);
          }
        }
        return iteratorDone();
      });
    };
    return flatSequence;
  }

  function flatMapFactory(collection, mapper, context) {
    var coerce = collectionClass(collection);
    return collection
      .toSeq()
      .map(function (v, k) { return coerce(mapper.call(context, v, k, collection)); })
      .flatten(true);
  }

  function interposeFactory(collection, separator) {
    var interposedSequence = makeSequence(collection);
    interposedSequence.size = collection.size && collection.size * 2 - 1;
    interposedSequence.__iterateUncached = function(fn, reverse) {
      var this$1 = this;

      var iterations = 0;
      collection.__iterate(
        function (v) { return (!iterations || fn(separator, iterations++, this$1) !== false) &&
          fn(v, iterations++, this$1) !== false; },
        reverse
      );
      return iterations;
    };
    interposedSequence.__iteratorUncached = function(type, reverse) {
      var iterator = collection.__iterator(ITERATE_VALUES, reverse);
      var iterations = 0;
      var step;
      return new Iterator(function () {
        if (!step || iterations % 2) {
          step = iterator.next();
          if (step.done) {
            return step;
          }
        }
        return iterations % 2
          ? iteratorValue(type, iterations++, separator)
          : iteratorValue(type, iterations++, step.value, step);
      });
    };
    return interposedSequence;
  }

  function sortFactory(collection, comparator, mapper) {
    if (!comparator) {
      comparator = defaultComparator;
    }
    var isKeyedCollection = isKeyed(collection);
    var index = 0;
    var entries = collection
      .toSeq()
      .map(function (v, k) { return [k, v, index++, mapper ? mapper(v, k, collection) : v]; })
      .valueSeq()
      .toArray();
    entries.sort(function (a, b) { return comparator(a[3], b[3]) || a[2] - b[2]; }).forEach(
      isKeyedCollection
        ? function (v, i) {
            entries[i].length = 2;
          }
        : function (v, i) {
            entries[i] = v[1];
          }
    );
    return isKeyedCollection
      ? KeyedSeq(entries)
      : isIndexed(collection)
        ? IndexedSeq(entries)
        : SetSeq(entries);
  }

  function maxFactory(collection, comparator, mapper) {
    if (!comparator) {
      comparator = defaultComparator;
    }
    if (mapper) {
      var entry = collection
        .toSeq()
        .map(function (v, k) { return [v, mapper(v, k, collection)]; })
        .reduce(function (a, b) { return (maxCompare(comparator, a[1], b[1]) ? b : a); });
      return entry && entry[0];
    }
    return collection.reduce(function (a, b) { return (maxCompare(comparator, a, b) ? b : a); });
  }

  function maxCompare(comparator, a, b) {
    var comp = comparator(b, a);
    // b is considered the new max if the comparator declares them equal, but
    // they are not equal and b is in fact a nullish value.
    return (
      (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) ||
      comp > 0
    );
  }

  function zipWithFactory(keyIter, zipper, iters, zipAll) {
    var zipSequence = makeSequence(keyIter);
    var sizes = new ArraySeq(iters).map(function (i) { return i.size; });
    zipSequence.size = zipAll ? sizes.max() : sizes.min();
    // Note: this a generic base implementation of __iterate in terms of
    // __iterator which may be more generically useful in the future.
    zipSequence.__iterate = function(fn, reverse) {
      var this$1 = this;

      /* generic:
      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
      var step;
      var iterations = 0;
      while (!(step = iterator.next()).done) {
        iterations++;
        if (fn(step.value[1], step.value[0], this) === false) {
          break;
        }
      }
      return iterations;
      */
      // indexed:
      var iterator = this.__iterator(ITERATE_VALUES, reverse);
      var step;
      var iterations = 0;
      while (!(step = iterator.next()).done) {
        if (fn(step.value, iterations++, this$1) === false) {
          break;
        }
      }
      return iterations;
    };
    zipSequence.__iteratorUncached = function(type, reverse) {
      var iterators = iters.map(
        function (i) { return ((i = Collection(i)), getIterator(reverse ? i.reverse() : i)); }
      );
      var iterations = 0;
      var isDone = false;
      return new Iterator(function () {
        var steps;
        if (!isDone) {
          steps = iterators.map(function (i) { return i.next(); });
          isDone = zipAll ? steps.every(function (s) { return s.done; }) : steps.some(function (s) { return s.done; });
        }
        if (isDone) {
          return iteratorDone();
        }
        return iteratorValue(
          type,
          iterations++,
          zipper.apply(null, steps.map(function (s) { return s.value; }))
        );
      });
    };
    return zipSequence;
  }

  // #pragma Helper Functions

  function reify(iter, seq) {
    return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);
  }

  function validateEntry(entry) {
    if (entry !== Object(entry)) {
      throw new TypeError('Expected [K, V] tuple: ' + entry);
    }
  }

  function collectionClass(collection) {
    return isKeyed(collection)
      ? KeyedCollection
      : isIndexed(collection)
        ? IndexedCollection
        : SetCollection;
  }

  function makeSequence(collection) {
    return Object.create(
      (isKeyed(collection)
        ? KeyedSeq
        : isIndexed(collection)
          ? IndexedSeq
          : SetSeq
      ).prototype
    );
  }

  function cacheResultThrough() {
    if (this._iter.cacheResult) {
      this._iter.cacheResult();
      this.size = this._iter.size;
      return this;
    }
    return Seq.prototype.cacheResult.call(this);
  }

  function defaultComparator(a, b) {
    if (a === undefined && b === undefined) {
      return 0;
    }

    if (a === undefined) {
      return 1;
    }

    if (b === undefined) {
      return -1;
    }

    return a > b ? 1 : a < b ? -1 : 0;
  }

  // http://jsperf.com/copy-array-inline
  function arrCopy(arr, offset) {
    offset = offset || 0;
    var len = Math.max(0, arr.length - offset);
    var newArr = new Array(len);
    for (var ii = 0; ii < len; ii++) {
      newArr[ii] = arr[ii + offset];
    }
    return newArr;
  }

  function invariant(condition, error) {
    if (!condition) { throw new Error(error); }
  }

  function assertNotInfinite(size) {
    invariant(
      size !== Infinity,
      'Cannot perform this action with an infinite size.'
    );
  }

  function coerceKeyPath(keyPath) {
    if (isArrayLike(keyPath) && typeof keyPath !== 'string') {
      return keyPath;
    }
    if (isOrdered(keyPath)) {
      return keyPath.toArray();
    }
    throw new TypeError(
      'Invalid keyPath: expected Ordered Collection or Array: ' + keyPath
    );
  }

  function isPlainObj(value) {
    return (
      value &&
      ((value.constructor && value.constructor.name === 'Object') ||
        value.constructor === undefined)
    );
  }

  /**
   * Returns true if the value is a potentially-persistent data structure, either
   * provided by Immutable.js or a plain Array or Object.
   */
  function isDataStructure(value) {
    return (
      typeof value === 'object' &&
      (isImmutable(value) || Array.isArray(value) || isPlainObj(value))
    );
  }

  /**
   * Converts a value to a string, adding quotes if a string was provided.
   */
  function quoteString(value) {
    try {
      return typeof value === 'string' ? JSON.stringify(value) : String(value);
    } catch (_ignoreError) {
      return JSON.stringify(value);
    }
  }

  function has(collection, key) {
    return isImmutable(collection)
      ? collection.has(key)
      : isDataStructure(collection) && hasOwnProperty.call(collection, key);
  }

  function get(collection, key, notSetValue) {
    return isImmutable(collection)
      ? collection.get(key, notSetValue)
      : !has(collection, key)
        ? notSetValue
        : typeof collection.get === 'function'
          ? collection.get(key)
          : collection[key];
  }

  function shallowCopy(from) {
    if (Array.isArray(from)) {
      return arrCopy(from);
    }
    var to = {};
    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
    return to;
  }

  function remove(collection, key) {
    if (!isDataStructure(collection)) {
      throw new TypeError(
        'Cannot update non-data-structure value: ' + collection
      );
    }
    if (isImmutable(collection)) {
      if (!collection.remove) {
        throw new TypeError(
          'Cannot update immutable value without .remove() method: ' + collection
        );
      }
      return collection.remove(key);
    }
    if (!hasOwnProperty.call(collection, key)) {
      return collection;
    }
    var collectionCopy = shallowCopy(collection);
    if (Array.isArray(collectionCopy)) {
      collectionCopy.splice(key, 1);
    } else {
      delete collectionCopy[key];
    }
    return collectionCopy;
  }

  function set(collection, key, value) {
    if (!isDataStructure(collection)) {
      throw new TypeError(
        'Cannot update non-data-structure value: ' + collection
      );
    }
    if (isImmutable(collection)) {
      if (!collection.set) {
        throw new TypeError(
          'Cannot update immutable value without .set() method: ' + collection
        );
      }
      return collection.set(key, value);
    }
    if (hasOwnProperty.call(collection, key) && value === collection[key]) {
      return collection;
    }
    var collectionCopy = shallowCopy(collection);
    collectionCopy[key] = value;
    return collectionCopy;
  }

  function updateIn(collection, keyPath, notSetValue, updater) {
    if (!updater) {
      updater = notSetValue;
      notSetValue = undefined;
    }
    var updatedValue = updateInDeeply(
      isImmutable(collection),
      collection,
      coerceKeyPath(keyPath),
      0,
      notSetValue,
      updater
    );
    return updatedValue === NOT_SET ? notSetValue : updatedValue;
  }

  function updateInDeeply(
    inImmutable,
    existing,
    keyPath,
    i,
    notSetValue,
    updater
  ) {
    var wasNotSet = existing === NOT_SET;
    if (i === keyPath.length) {
      var existingValue = wasNotSet ? notSetValue : existing;
      var newValue = updater(existingValue);
      return newValue === existingValue ? existing : newValue;
    }
    if (!wasNotSet && !isDataStructure(existing)) {
      throw new TypeError(
        'Cannot update within non-data-structure value in path [' +
          keyPath.slice(0, i).map(quoteString) +
          ']: ' +
          existing
      );
    }
    var key = keyPath[i];
    var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);
    var nextUpdated = updateInDeeply(
      nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting),
      nextExisting,
      keyPath,
      i + 1,
      notSetValue,
      updater
    );
    return nextUpdated === nextExisting
      ? existing
      : nextUpdated === NOT_SET
        ? remove(existing, key)
        : set(
            wasNotSet ? (inImmutable ? emptyMap() : {}) : existing,
            key,
            nextUpdated
          );
  }

  function setIn(collection, keyPath, value) {
    return updateIn(collection, keyPath, NOT_SET, function () { return value; });
  }

  function setIn$1(keyPath, v) {
    return setIn(this, keyPath, v);
  }

  function removeIn(collection, keyPath) {
    return updateIn(collection, keyPath, function () { return NOT_SET; });
  }

  function deleteIn(keyPath) {
    return removeIn(this, keyPath);
  }

  function update(collection, key, notSetValue, updater) {
    return updateIn(collection, [key], notSetValue, updater);
  }

  function update$1(key, notSetValue, updater) {
    return arguments.length === 1
      ? key(this)
      : update(this, key, notSetValue, updater);
  }

  function updateIn$1(keyPath, notSetValue, updater) {
    return updateIn(this, keyPath, notSetValue, updater);
  }

  function merge() {
    var iters = [], len = arguments.length;
    while ( len-- ) iters[ len ] = arguments[ len ];

    return mergeIntoKeyedWith(this, iters);
  }

  function mergeWith(merger) {
    var iters = [], len = arguments.length - 1;
    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];

    if (typeof merger !== 'function') {
      throw new TypeError('Invalid merger function: ' + merger);
    }
    return mergeIntoKeyedWith(this, iters, merger);
  }

  function mergeIntoKeyedWith(collection, collections, merger) {
    var iters = [];
    for (var ii = 0; ii < collections.length; ii++) {
      var collection$1 = KeyedCollection(collections[ii]);
      if (collection$1.size !== 0) {
        iters.push(collection$1);
      }
    }
    if (iters.length === 0) {
      return collection;
    }
    if (
      collection.toSeq().size === 0 &&
      !collection.__ownerID &&
      iters.length === 1
    ) {
      return collection.constructor(iters[0]);
    }
    return collection.withMutations(function (collection) {
      var mergeIntoCollection = merger
        ? function (value, key) {
            update(
              collection,
              key,
              NOT_SET,
              function (oldVal) { return (oldVal === NOT_SET ? value : merger(oldVal, value, key)); }
            );
          }
        : function (value, key) {
            collection.set(key, value);
          };
      for (var ii = 0; ii < iters.length; ii++) {
        iters[ii].forEach(mergeIntoCollection);
      }
    });
  }

  function merge$1(collection) {
    var sources = [], len = arguments.length - 1;
    while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];

    return mergeWithSources(collection, sources);
  }

  function mergeWith$1(merger, collection) {
    var sources = [], len = arguments.length - 2;
    while ( len-- > 0 ) sources[ len ] = arguments[ len + 2 ];

    return mergeWithSources(collection, sources, merger);
  }

  function mergeDeep(collection) {
    var sources = [], len = arguments.length - 1;
    while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];

    return mergeDeepWithSources(collection, sources);
  }

  function mergeDeepWith(merger, collection) {
    var sources = [], len = arguments.length - 2;
    while ( len-- > 0 ) sources[ len ] = arguments[ len + 2 ];

    return mergeDeepWithSources(collection, sources, merger);
  }

  function mergeDeepWithSources(collection, sources, merger) {
    return mergeWithSources(collection, sources, deepMergerWith(merger));
  }

  function mergeWithSources(collection, sources, merger) {
    if (!isDataStructure(collection)) {
      throw new TypeError(
        'Cannot merge into non-data-structure value: ' + collection
      );
    }
    if (isImmutable(collection)) {
      return typeof merger === 'function' && collection.mergeWith
        ? collection.mergeWith.apply(collection, [ merger ].concat( sources ))
        : collection.merge
          ? collection.merge.apply(collection, sources)
          : collection.concat.apply(collection, sources);
    }
    var isArray = Array.isArray(collection);
    var merged = collection;
    var Collection$$1 = isArray ? IndexedCollection : KeyedCollection;
    var mergeItem = isArray
      ? function (value) {
          // Copy on write
          if (merged === collection) {
            merged = shallowCopy(merged);
          }
          merged.push(value);
        }
      : function (value, key) {
          var hasVal = hasOwnProperty.call(merged, key);
          var nextVal =
            hasVal && merger ? merger(merged[key], value, key) : value;
          if (!hasVal || nextVal !== merged[key]) {
            // Copy on write
            if (merged === collection) {
              merged = shallowCopy(merged);
            }
            merged[key] = nextVal;
          }
        };
    for (var i = 0; i < sources.length; i++) {
      Collection$$1(sources[i]).forEach(mergeItem);
    }
    return merged;
  }

  function deepMergerWith(merger) {
    function deepMerger(oldValue, newValue, key) {
      return isDataStructure(oldValue) && isDataStructure(newValue)
        ? mergeWithSources(oldValue, [newValue], deepMerger)
        : merger
          ? merger(oldValue, newValue, key)
          : newValue;
    }
    return deepMerger;
  }

  function mergeDeep$1() {
    var iters = [], len = arguments.length;
    while ( len-- ) iters[ len ] = arguments[ len ];

    return mergeDeepWithSources(this, iters);
  }

  function mergeDeepWith$1(merger) {
    var iters = [], len = arguments.length - 1;
    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];

    return mergeDeepWithSources(this, iters, merger);
  }

  function mergeIn(keyPath) {
    var iters = [], len = arguments.length - 1;
    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];

    return updateIn(this, keyPath, emptyMap(), function (m) { return mergeWithSources(m, iters); });
  }

  function mergeDeepIn(keyPath) {
    var iters = [], len = arguments.length - 1;
    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];

    return updateIn(this, keyPath, emptyMap(), function (m) { return mergeDeepWithSources(m, iters); }
    );
  }

  function withMutations(fn) {
    var mutable = this.asMutable();
    fn(mutable);
    return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
  }

  function asMutable() {
    return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
  }

  function asImmutable() {
    return this.__ensureOwner();
  }

  function wasAltered() {
    return this.__altered;
  }

  var Map = (function (KeyedCollection$$1) {
    function Map(value) {
      return value === null || value === undefined
        ? emptyMap()
        : isMap(value) && !isOrdered(value)
          ? value
          : emptyMap().withMutations(function (map) {
              var iter = KeyedCollection$$1(value);
              assertNotInfinite(iter.size);
              iter.forEach(function (v, k) { return map.set(k, v); });
            });
    }

    if ( KeyedCollection$$1 ) Map.__proto__ = KeyedCollection$$1;
    Map.prototype = Object.create( KeyedCollection$$1 && KeyedCollection$$1.prototype );
    Map.prototype.constructor = Map;

    Map.of = function of () {
      var keyValues = [], len = arguments.length;
      while ( len-- ) keyValues[ len ] = arguments[ len ];

      return emptyMap().withMutations(function (map) {
        for (var i = 0; i < keyValues.length; i += 2) {
          if (i + 1 >= keyValues.length) {
            throw new Error('Missing value for key: ' + keyValues[i]);
          }
          map.set(keyValues[i], keyValues[i + 1]);
        }
      });
    };

    Map.prototype.toString = function toString () {
      return this.__toString('Map {', '}');
    };

    // @pragma Access

    Map.prototype.get = function get (k, notSetValue) {
      return this._root
        ? this._root.get(0, undefined, k, notSetValue)
        : notSetValue;
    };

    // @pragma Modification

    Map.prototype.set = function set (k, v) {
      return updateMap(this, k, v);
    };

    Map.prototype.remove = function remove (k) {
      return updateMap(this, k, NOT_SET);
    };

    Map.prototype.deleteAll = function deleteAll (keys) {
      var collection = Collection(keys);

      if (collection.size === 0) {
        return this;
      }

      return this.withMutations(function (map) {
        collection.forEach(function (key) { return map.remove(key); });
      });
    };

    Map.prototype.clear = function clear () {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._root = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyMap();
    };

    // @pragma Composition

    Map.prototype.sort = function sort (comparator) {
      // Late binding
      return OrderedMap(sortFactory(this, comparator));
    };

    Map.prototype.sortBy = function sortBy (mapper, comparator) {
      // Late binding
      return OrderedMap(sortFactory(this, comparator, mapper));
    };

    Map.prototype.map = function map (mapper, context) {
      return this.withMutations(function (map) {
        map.forEach(function (value, key) {
          map.set(key, mapper.call(context, value, key, map));
        });
      });
    };

    // @pragma Mutability

    Map.prototype.__iterator = function __iterator (type, reverse) {
      return new MapIterator(this, type, reverse);
    };

    Map.prototype.__iterate = function __iterate (fn, reverse) {
      var this$1 = this;

      var iterations = 0;
      this._root &&
        this._root.iterate(function (entry) {
          iterations++;
          return fn(entry[1], entry[0], this$1);
        }, reverse);
      return iterations;
    };

    Map.prototype.__ensureOwner = function __ensureOwner (ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        if (this.size === 0) {
          return emptyMap();
        }
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeMap(this.size, this._root, ownerID, this.__hash);
    };

    return Map;
  }(KeyedCollection));

  Map.isMap = isMap;

  var MapPrototype = Map.prototype;
  MapPrototype[IS_MAP_SYMBOL] = true;
  MapPrototype[DELETE] = MapPrototype.remove;
  MapPrototype.removeAll = MapPrototype.deleteAll;
  MapPrototype.setIn = setIn$1;
  MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;
  MapPrototype.update = update$1;
  MapPrototype.updateIn = updateIn$1;
  MapPrototype.merge = MapPrototype.concat = merge;
  MapPrototype.mergeWith = mergeWith;
  MapPrototype.mergeDeep = mergeDeep$1;
  MapPrototype.mergeDeepWith = mergeDeepWith$1;
  MapPrototype.mergeIn = mergeIn;
  MapPrototype.mergeDeepIn = mergeDeepIn;
  MapPrototype.withMutations = withMutations;
  MapPrototype.wasAltered = wasAltered;
  MapPrototype.asImmutable = asImmutable;
  MapPrototype['@@transducer/init'] = MapPrototype.asMutable = asMutable;
  MapPrototype['@@transducer/step'] = function(result, arr) {
    return result.set(arr[0], arr[1]);
  };
  MapPrototype['@@transducer/result'] = function(obj) {
    return obj.asImmutable();
  };

  // #pragma Trie Nodes

  var ArrayMapNode = function ArrayMapNode(ownerID, entries) {
    this.ownerID = ownerID;
    this.entries = entries;
  };

  ArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
    var entries = this.entries;
    for (var ii = 0, len = entries.length; ii < len; ii++) {
      if (is(key, entries[ii][0])) {
        return entries[ii][1];
      }
    }
    return notSetValue;
  };

  ArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    var removed = value === NOT_SET;

    var entries = this.entries;
    var idx = 0;
    var len = entries.length;
    for (; idx < len; idx++) {
      if (is(key, entries[idx][0])) {
        break;
      }
    }
    var exists = idx < len;

    if (exists ? entries[idx][1] === value : removed) {
      return this;
    }

    SetRef(didAlter);
    (removed || !exists) && SetRef(didChangeSize);

    if (removed && entries.length === 1) {
      return; // undefined
    }

    if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
      return createNodes(ownerID, entries, key, value);
    }

    var isEditable = ownerID && ownerID === this.ownerID;
    var newEntries = isEditable ? entries : arrCopy(entries);

    if (exists) {
      if (removed) {
        idx === len - 1
          ? newEntries.pop()
          : (newEntries[idx] = newEntries.pop());
      } else {
        newEntries[idx] = [key, value];
      }
    } else {
      newEntries.push([key, value]);
    }

    if (isEditable) {
      this.entries = newEntries;
      return this;
    }

    return new ArrayMapNode(ownerID, newEntries);
  };

  var BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {
    this.ownerID = ownerID;
    this.bitmap = bitmap;
    this.nodes = nodes;
  };

  BitmapIndexedNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
    if (keyHash === undefined) {
      keyHash = hash(key);
    }
    var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
    var bitmap = this.bitmap;
    return (bitmap & bit) === 0
      ? notSetValue
      : this.nodes[popCount(bitmap & (bit - 1))].get(
          shift + SHIFT,
          keyHash,
          key,
          notSetValue
        );
  };

  BitmapIndexedNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === undefined) {
      keyHash = hash(key);
    }
    var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
    var bit = 1 << keyHashFrag;
    var bitmap = this.bitmap;
    var exists = (bitmap & bit) !== 0;

    if (!exists && value === NOT_SET) {
      return this;
    }

    var idx = popCount(bitmap & (bit - 1));
    var nodes = this.nodes;
    var node = exists ? nodes[idx] : undefined;
    var newNode = updateNode(
      node,
      ownerID,
      shift + SHIFT,
      keyHash,
      key,
      value,
      didChangeSize,
      didAlter
    );

    if (newNode === node) {
      return this;
    }

    if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
      return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
    }

    if (
      exists &&
      !newNode &&
      nodes.length === 2 &&
      isLeafNode(nodes[idx ^ 1])
    ) {
      return nodes[idx ^ 1];
    }

    if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
      return newNode;
    }

    var isEditable = ownerID && ownerID === this.ownerID;
    var newBitmap = exists ? (newNode ? bitmap : bitmap ^ bit) : bitmap | bit;
    var newNodes = exists
      ? newNode
        ? setAt(nodes, idx, newNode, isEditable)
        : spliceOut(nodes, idx, isEditable)
      : spliceIn(nodes, idx, newNode, isEditable);

    if (isEditable) {
      this.bitmap = newBitmap;
      this.nodes = newNodes;
      return this;
    }

    return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
  };

  var HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {
    this.ownerID = ownerID;
    this.count = count;
    this.nodes = nodes;
  };

  HashArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
    if (keyHash === undefined) {
      keyHash = hash(key);
    }
    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
    var node = this.nodes[idx];
    return node
      ? node.get(shift + SHIFT, keyHash, key, notSetValue)
      : notSetValue;
  };

  HashArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === undefined) {
      keyHash = hash(key);
    }
    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
    var removed = value === NOT_SET;
    var nodes = this.nodes;
    var node = nodes[idx];

    if (removed && !node) {
      return this;
    }

    var newNode = updateNode(
      node,
      ownerID,
      shift + SHIFT,
      keyHash,
      key,
      value,
      didChangeSize,
      didAlter
    );
    if (newNode === node) {
      return this;
    }

    var newCount = this.count;
    if (!node) {
      newCount++;
    } else if (!newNode) {
      newCount--;
      if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
        return packNodes(ownerID, nodes, newCount, idx);
      }
    }

    var isEditable = ownerID && ownerID === this.ownerID;
    var newNodes = setAt(nodes, idx, newNode, isEditable);

    if (isEditable) {
      this.count = newCount;
      this.nodes = newNodes;
      return this;
    }

    return new HashArrayMapNode(ownerID, newCount, newNodes);
  };

  var HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {
    this.ownerID = ownerID;
    this.keyHash = keyHash;
    this.entries = entries;
  };

  HashCollisionNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
    var entries = this.entries;
    for (var ii = 0, len = entries.length; ii < len; ii++) {
      if (is(key, entries[ii][0])) {
        return entries[ii][1];
      }
    }
    return notSetValue;
  };

  HashCollisionNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === undefined) {
      keyHash = hash(key);
    }

    var removed = value === NOT_SET;

    if (keyHash !== this.keyHash) {
      if (removed) {
        return this;
      }
      SetRef(didAlter);
      SetRef(didChangeSize);
      return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
    }

    var entries = this.entries;
    var idx = 0;
    var len = entries.length;
    for (; idx < len; idx++) {
      if (is(key, entries[idx][0])) {
        break;
      }
    }
    var exists = idx < len;

    if (exists ? entries[idx][1] === value : removed) {
      return this;
    }

    SetRef(didAlter);
    (removed || !exists) && SetRef(didChangeSize);

    if (removed && len === 2) {
      return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
    }

    var isEditable = ownerID && ownerID === this.ownerID;
    var newEntries = isEditable ? entries : arrCopy(entries);

    if (exists) {
      if (removed) {
        idx === len - 1
          ? newEntries.pop()
          : (newEntries[idx] = newEntries.pop());
      } else {
        newEntries[idx] = [key, value];
      }
    } else {
      newEntries.push([key, value]);
    }

    if (isEditable) {
      this.entries = newEntries;
      return this;
    }

    return new HashCollisionNode(ownerID, this.keyHash, newEntries);
  };

  var ValueNode = function ValueNode(ownerID, keyHash, entry) {
    this.ownerID = ownerID;
    this.keyHash = keyHash;
    this.entry = entry;
  };

  ValueNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
    return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
  };

  ValueNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    var removed = value === NOT_SET;
    var keyMatch = is(key, this.entry[0]);
    if (keyMatch ? value === this.entry[1] : removed) {
      return this;
    }

    SetRef(didAlter);

    if (removed) {
      SetRef(didChangeSize);
      return; // undefined
    }

    if (keyMatch) {
      if (ownerID && ownerID === this.ownerID) {
        this.entry[1] = value;
        return this;
      }
      return new ValueNode(ownerID, this.keyHash, [key, value]);
    }

    SetRef(didChangeSize);
    return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
  };

  // #pragma Iterators

  ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function(
    fn,
    reverse
  ) {
    var entries = this.entries;
    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
        return false;
      }
    }
  };

  BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function(
    fn,
    reverse
  ) {
    var nodes = this.nodes;
    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
      var node = nodes[reverse ? maxIndex - ii : ii];
      if (node && node.iterate(fn, reverse) === false) {
        return false;
      }
    }
  };

  // eslint-disable-next-line no-unused-vars
  ValueNode.prototype.iterate = function(fn, reverse) {
    return fn(this.entry);
  };

  var MapIterator = (function (Iterator$$1) {
    function MapIterator(map, type, reverse) {
      this._type = type;
      this._reverse = reverse;
      this._stack = map._root && mapIteratorFrame(map._root);
    }

    if ( Iterator$$1 ) MapIterator.__proto__ = Iterator$$1;
    MapIterator.prototype = Object.create( Iterator$$1 && Iterator$$1.prototype );
    MapIterator.prototype.constructor = MapIterator;

    MapIterator.prototype.next = function next () {
      var this$1 = this;

      var type = this._type;
      var stack = this._stack;
      while (stack) {
        var node = stack.node;
        var index = stack.index++;
        var maxIndex = (void 0);
        if (node.entry) {
          if (index === 0) {
            return mapIteratorValue(type, node.entry);
          }
        } else if (node.entries) {
          maxIndex = node.entries.length - 1;
          if (index <= maxIndex) {
            return mapIteratorValue(
              type,
              node.entries[this$1._reverse ? maxIndex - index : index]
            );
          }
        } else {
          maxIndex = node.nodes.length - 1;
          if (index <= maxIndex) {
            var subNode = node.nodes[this$1._reverse ? maxIndex - index : index];
            if (subNode) {
              if (subNode.entry) {
                return mapIteratorValue(type, subNode.entry);
              }
              stack = this$1._stack = mapIteratorFrame(subNode, stack);
            }
            continue;
          }
        }
        stack = this$1._stack = this$1._stack.__prev;
      }
      return iteratorDone();
    };

    return MapIterator;
  }(Iterator));

  function mapIteratorValue(type, entry) {
    return iteratorValue(type, entry[0], entry[1]);
  }

  function mapIteratorFrame(node, prev) {
    return {
      node: node,
      index: 0,
      __prev: prev,
    };
  }

  function makeMap(size, root, ownerID, hash$$1) {
    var map = Object.create(MapPrototype);
    map.size = size;
    map._root = root;
    map.__ownerID = ownerID;
    map.__hash = hash$$1;
    map.__altered = false;
    return map;
  }

  var EMPTY_MAP;
  function emptyMap() {
    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
  }

  function updateMap(map, k, v) {
    var newRoot;
    var newSize;
    if (!map._root) {
      if (v === NOT_SET) {
        return map;
      }
      newSize = 1;
      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
    } else {
      var didChangeSize = MakeRef();
      var didAlter = MakeRef();
      newRoot = updateNode(
        map._root,
        map.__ownerID,
        0,
        undefined,
        k,
        v,
        didChangeSize,
        didAlter
      );
      if (!didAlter.value) {
        return map;
      }
      newSize = map.size + (didChangeSize.value ? (v === NOT_SET ? -1 : 1) : 0);
    }
    if (map.__ownerID) {
      map.size = newSize;
      map._root = newRoot;
      map.__hash = undefined;
      map.__altered = true;
      return map;
    }
    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
  }

  function updateNode(
    node,
    ownerID,
    shift,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  ) {
    if (!node) {
      if (value === NOT_SET) {
        return node;
      }
      SetRef(didAlter);
      SetRef(didChangeSize);
      return new ValueNode(ownerID, keyHash, [key, value]);
    }
    return node.update(
      ownerID,
      shift,
      keyHash,
      key,
      value,
      didChangeSize,
      didAlter
    );
  }

  function isLeafNode(node) {
    return (
      node.constructor === ValueNode || node.constructor === HashCollisionNode
    );
  }

  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
    if (node.keyHash === keyHash) {
      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
    }

    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

    var newNode;
    var nodes =
      idx1 === idx2
        ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)]
        : ((newNode = new ValueNode(ownerID, keyHash, entry)),
          idx1 < idx2 ? [node, newNode] : [newNode, node]);

    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
  }

  function createNodes(ownerID, entries, key, value) {
    if (!ownerID) {
      ownerID = new OwnerID();
    }
    var node = new ValueNode(ownerID, hash(key), [key, value]);
    for (var ii = 0; ii < entries.length; ii++) {
      var entry = entries[ii];
      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
    }
    return node;
  }

  function packNodes(ownerID, nodes, count, excluding) {
    var bitmap = 0;
    var packedII = 0;
    var packedNodes = new Array(count);
    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
      var node = nodes[ii];
      if (node !== undefined && ii !== excluding) {
        bitmap |= bit;
        packedNodes[packedII++] = node;
      }
    }
    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
  }

  function expandNodes(ownerID, nodes, bitmap, including, node) {
    var count = 0;
    var expandedNodes = new Array(SIZE);
    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
    }
    expandedNodes[including] = node;
    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
  }

  function popCount(x) {
    x -= (x >> 1) & 0x55555555;
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
    x = (x + (x >> 4)) & 0x0f0f0f0f;
    x += x >> 8;
    x += x >> 16;
    return x & 0x7f;
  }

  function setAt(array, idx, val, canEdit) {
    var newArray = canEdit ? array : arrCopy(array);
    newArray[idx] = val;
    return newArray;
  }

  function spliceIn(array, idx, val, canEdit) {
    var newLen = array.length + 1;
    if (canEdit && idx + 1 === newLen) {
      array[idx] = val;
      return array;
    }
    var newArray = new Array(newLen);
    var after = 0;
    for (var ii = 0; ii < newLen; ii++) {
      if (ii === idx) {
        newArray[ii] = val;
        after = -1;
      } else {
        newArray[ii] = array[ii + after];
      }
    }
    return newArray;
  }

  function spliceOut(array, idx, canEdit) {
    var newLen = array.length - 1;
    if (canEdit && idx === newLen) {
      array.pop();
      return array;
    }
    var newArray = new Array(newLen);
    var after = 0;
    for (var ii = 0; ii < newLen; ii++) {
      if (ii === idx) {
        after = 1;
      }
      newArray[ii] = array[ii + after];
    }
    return newArray;
  }

  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

  var IS_LIST_SYMBOL = '@@__IMMUTABLE_LIST__@@';

  function isList(maybeList) {
    return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);
  }

  var List = (function (IndexedCollection$$1) {
    function List(value) {
      var empty = emptyList();
      if (value === null || value === undefined) {
        return empty;
      }
      if (isList(value)) {
        return value;
      }
      var iter = IndexedCollection$$1(value);
      var size = iter.size;
      if (size === 0) {
        return empty;
      }
      assertNotInfinite(size);
      if (size > 0 && size < SIZE) {
        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
      }
      return empty.withMutations(function (list) {
        list.setSize(size);
        iter.forEach(function (v, i) { return list.set(i, v); });
      });
    }

    if ( IndexedCollection$$1 ) List.__proto__ = IndexedCollection$$1;
    List.prototype = Object.create( IndexedCollection$$1 && IndexedCollection$$1.prototype );
    List.prototype.constructor = List;

    List.of = function of (/*...values*/) {
      return this(arguments);
    };

    List.prototype.toString = function toString () {
      return this.__toString('List [', ']');
    };

    // @pragma Access

    List.prototype.get = function get (index, notSetValue) {
      index = wrapIndex(this, index);
      if (index >= 0 && index < this.size) {
        index += this._origin;
        var node = listNodeFor(this, index);
        return node && node.array[index & MASK];
      }
      return notSetValue;
    };

    // @pragma Modification

    List.prototype.set = function set (index, value) {
      return updateList(this, index, value);
    };

    List.prototype.remove = function remove (index) {
      return !this.has(index)
        ? this
        : index === 0
          ? this.shift()
          : index === this.size - 1
            ? this.pop()
            : this.splice(index, 1);
    };

    List.prototype.insert = function insert (index, value) {
      return this.splice(index, 0, value);
    };

    List.prototype.clear = function clear () {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = this._origin = this._capacity = 0;
        this._level = SHIFT;
        this._root = this._tail = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyList();
    };

    List.prototype.push = function push (/*...values*/) {
      var values = arguments;
      var oldSize = this.size;
      return this.withMutations(function (list) {
        setListBounds(list, 0, oldSize + values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(oldSize + ii, values[ii]);
        }
      });
    };

    List.prototype.pop = function pop () {
      return setListBounds(this, 0, -1);
    };

    List.prototype.unshift = function unshift (/*...values*/) {
      var values = arguments;
      return this.withMutations(function (list) {
        setListBounds(list, -values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(ii, values[ii]);
        }
      });
    };

    List.prototype.shift = function shift () {
      return setListBounds(this, 1);
    };

    // @pragma Composition

    List.prototype.concat = function concat (/*...collections*/) {
      var arguments$1 = arguments;

      var seqs = [];
      for (var i = 0; i < arguments.length; i++) {
        var argument = arguments$1[i];
        var seq = IndexedCollection$$1(
          typeof argument !== 'string' && hasIterator(argument)
            ? argument
            : [argument]
        );
        if (seq.size !== 0) {
          seqs.push(seq);
        }
      }
      if (seqs.length === 0) {
        return this;
      }
      if (this.size === 0 && !this.__ownerID && seqs.length === 1) {
        return this.constructor(seqs[0]);
      }
      return this.withMutations(function (list) {
        seqs.forEach(function (seq) { return seq.forEach(function (value) { return list.push(value); }); });
      });
    };

    List.prototype.setSize = function setSize (size) {
      return setListBounds(this, 0, size);
    };

    List.prototype.map = function map (mapper, context) {
      var this$1 = this;

      return this.withMutations(function (list) {
        for (var i = 0; i < this$1.size; i++) {
          list.set(i, mapper.call(context, list.get(i), i, list));
        }
      });
    };

    // @pragma Iteration

    List.prototype.slice = function slice (begin, end) {
      var size = this.size;
      if (wholeSlice(begin, end, size)) {
        return this;
      }
      return setListBounds(
        this,
        resolveBegin(begin, size),
        resolveEnd(end, size)
      );
    };

    List.prototype.__iterator = function __iterator (type, reverse) {
      var index = reverse ? this.size : 0;
      var values = iterateList(this, reverse);
      return new Iterator(function () {
        var value = values();
        return value === DONE
          ? iteratorDone()
          : iteratorValue(type, reverse ? --index : index++, value);
      });
    };

    List.prototype.__iterate = function __iterate (fn, reverse) {
      var this$1 = this;

      var index = reverse ? this.size : 0;
      var values = iterateList(this, reverse);
      var value;
      while ((value = values()) !== DONE) {
        if (fn(value, reverse ? --index : index++, this$1) === false) {
          break;
        }
      }
      return index;
    };

    List.prototype.__ensureOwner = function __ensureOwner (ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        if (this.size === 0) {
          return emptyList();
        }
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeList(
        this._origin,
        this._capacity,
        this._level,
        this._root,
        this._tail,
        ownerID,
        this.__hash
      );
    };

    return List;
  }(IndexedCollection));

  List.isList = isList;

  var ListPrototype = List.prototype;
  ListPrototype[IS_LIST_SYMBOL] = true;
  ListPrototype[DELETE] = ListPrototype.remove;
  ListPrototype.merge = ListPrototype.concat;
  ListPrototype.setIn = setIn$1;
  ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;
  ListPrototype.update = update$1;
  ListPrototype.updateIn = updateIn$1;
  ListPrototype.mergeIn = mergeIn;
  ListPrototype.mergeDeepIn = mergeDeepIn;
  ListPrototype.withMutations = withMutations;
  ListPrototype.wasAltered = wasAltered;
  ListPrototype.asImmutable = asImmutable;
  ListPrototype['@@transducer/init'] = ListPrototype.asMutable = asMutable;
  ListPrototype['@@transducer/step'] = function(result, arr) {
    return result.push(arr);
  };
  ListPrototype['@@transducer/result'] = function(obj) {
    return obj.asImmutable();
  };

  var VNode = function VNode(array, ownerID) {
    this.array = array;
    this.ownerID = ownerID;
  };

  // TODO: seems like these methods are very similar

  VNode.prototype.removeBefore = function removeBefore (ownerID, level, index) {
    if (index === level ? 1 << level : this.array.length === 0) {
      return this;
    }
    var originIndex = (index >>> level) & MASK;
    if (originIndex >= this.array.length) {
      return new VNode([], ownerID);
    }
    var removingFirst = originIndex === 0;
    var newChild;
    if (level > 0) {
      var oldChild = this.array[originIndex];
      newChild =
        oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
      if (newChild === oldChild && removingFirst) {
        return this;
      }
    }
    if (removingFirst && !newChild) {
      return this;
    }
    var editable = editableVNode(this, ownerID);
    if (!removingFirst) {
      for (var ii = 0; ii < originIndex; ii++) {
        editable.array[ii] = undefined;
      }
    }
    if (newChild) {
      editable.array[originIndex] = newChild;
    }
    return editable;
  };

  VNode.prototype.removeAfter = function removeAfter (ownerID, level, index) {
    if (index === (level ? 1 << level : 0) || this.array.length === 0) {
      return this;
    }
    var sizeIndex = ((index - 1) >>> level) & MASK;
    if (sizeIndex >= this.array.length) {
      return this;
    }

    var newChild;
    if (level > 0) {
      var oldChild = this.array[sizeIndex];
      newChild =
        oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
      if (newChild === oldChild && sizeIndex === this.array.length - 1) {
        return this;
      }
    }

    var editable = editableVNode(this, ownerID);
    editable.array.splice(sizeIndex + 1);
    if (newChild) {
      editable.array[sizeIndex] = newChild;
    }
    return editable;
  };

  var DONE = {};

  function iterateList(list, reverse) {
    var left = list._origin;
    var right = list._capacity;
    var tailPos = getTailOffset(right);
    var tail = list._tail;

    return iterateNodeOrLeaf(list._root, list._level, 0);

    function iterateNodeOrLeaf(node, level, offset) {
      return level === 0
        ? iterateLeaf(node, offset)
        : iterateNode(node, level, offset);
    }

    function iterateLeaf(node, offset) {
      var array = offset === tailPos ? tail && tail.array : node && node.array;
      var from = offset > left ? 0 : left - offset;
      var to = right - offset;
      if (to > SIZE) {
        to = SIZE;
      }
      return function () {
        if (from === to) {
          return DONE;
        }
        var idx = reverse ? --to : from++;
        return array && array[idx];
      };
    }

    function iterateNode(node, level, offset) {
      var values;
      var array = node && node.array;
      var from = offset > left ? 0 : (left - offset) >> level;
      var to = ((right - offset) >> level) + 1;
      if (to > SIZE) {
        to = SIZE;
      }
      return function () {
        while (true) {
          if (values) {
            var value = values();
            if (value !== DONE) {
              return value;
            }
            values = null;
          }
          if (from === to) {
            return DONE;
          }
          var idx = reverse ? --to : from++;
          values = iterateNodeOrLeaf(
            array && array[idx],
            level - SHIFT,
            offset + (idx << level)
          );
        }
      };
    }
  }

  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
    var list = Object.create(ListPrototype);
    list.size = capacity - origin;
    list._origin = origin;
    list._capacity = capacity;
    list._level = level;
    list._root = root;
    list._tail = tail;
    list.__ownerID = ownerID;
    list.__hash = hash;
    list.__altered = false;
    return list;
  }

  var EMPTY_LIST;
  function emptyList() {
    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
  }

  function updateList(list, index, value) {
    index = wrapIndex(list, index);

    if (index !== index) {
      return list;
    }

    if (index >= list.size || index < 0) {
      return list.withMutations(function (list) {
        index < 0
          ? setListBounds(list, index).set(0, value)
          : setListBounds(list, 0, index + 1).set(index, value);
      });
    }

    index += list._origin;

    var newTail = list._tail;
    var newRoot = list._root;
    var didAlter = MakeRef();
    if (index >= getTailOffset(list._capacity)) {
      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
    } else {
      newRoot = updateVNode(
        newRoot,
        list.__ownerID,
        list._level,
        index,
        value,
        didAlter
      );
    }

    if (!didAlter.value) {
      return list;
    }

    if (list.__ownerID) {
      list._root = newRoot;
      list._tail = newTail;
      list.__hash = undefined;
      list.__altered = true;
      return list;
    }
    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
  }

  function updateVNode(node, ownerID, level, index, value, didAlter) {
    var idx = (index >>> level) & MASK;
    var nodeHas = node && idx < node.array.length;
    if (!nodeHas && value === undefined) {
      return node;
    }

    var newNode;

    if (level > 0) {
      var lowerNode = node && node.array[idx];
      var newLowerNode = updateVNode(
        lowerNode,
        ownerID,
        level - SHIFT,
        index,
        value,
        didAlter
      );
      if (newLowerNode === lowerNode) {
        return node;
      }
      newNode = editableVNode(node, ownerID);
      newNode.array[idx] = newLowerNode;
      return newNode;
    }

    if (nodeHas && node.array[idx] === value) {
      return node;
    }

    if (didAlter) {
      SetRef(didAlter);
    }

    newNode = editableVNode(node, ownerID);
    if (value === undefined && idx === newNode.array.length - 1) {
      newNode.array.pop();
    } else {
      newNode.array[idx] = value;
    }
    return newNode;
  }

  function editableVNode(node, ownerID) {
    if (ownerID && node && ownerID === node.ownerID) {
      return node;
    }
    return new VNode(node ? node.array.slice() : [], ownerID);
  }

  function listNodeFor(list, rawIndex) {
    if (rawIndex >= getTailOffset(list._capacity)) {
      return list._tail;
    }
    if (rawIndex < 1 << (list._level + SHIFT)) {
      var node = list._root;
      var level = list._level;
      while (node && level > 0) {
        node = node.array[(rawIndex >>> level) & MASK];
        level -= SHIFT;
      }
      return node;
    }
  }

  function setListBounds(list, begin, end) {
    // Sanitize begin & end using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
    if (begin !== undefined) {
      begin |= 0;
    }
    if (end !== undefined) {
      end |= 0;
    }
    var owner = list.__ownerID || new OwnerID();
    var oldOrigin = list._origin;
    var oldCapacity = list._capacity;
    var newOrigin = oldOrigin + begin;
    var newCapacity =
      end === undefined
        ? oldCapacity
        : end < 0
          ? oldCapacity + end
          : oldOrigin + end;
    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
      return list;
    }

    // If it's going to end after it starts, it's empty.
    if (newOrigin >= newCapacity) {
      return list.clear();
    }

    var newLevel = list._level;
    var newRoot = list._root;

    // New origin might need creating a higher root.
    var offsetShift = 0;
    while (newOrigin + offsetShift < 0) {
      newRoot = new VNode(
        newRoot && newRoot.array.length ? [undefined, newRoot] : [],
        owner
      );
      newLevel += SHIFT;
      offsetShift += 1 << newLevel;
    }
    if (offsetShift) {
      newOrigin += offsetShift;
      oldOrigin += offsetShift;
      newCapacity += offsetShift;
      oldCapacity += offsetShift;
    }

    var oldTailOffset = getTailOffset(oldCapacity);
    var newTailOffset = getTailOffset(newCapacity);

    // New size might need creating a higher root.
    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
      newRoot = new VNode(
        newRoot && newRoot.array.length ? [newRoot] : [],
        owner
      );
      newLevel += SHIFT;
    }

    // Locate or create the new tail.
    var oldTail = list._tail;
    var newTail =
      newTailOffset < oldTailOffset
        ? listNodeFor(list, newCapacity - 1)
        : newTailOffset > oldTailOffset
          ? new VNode([], owner)
          : oldTail;

    // Merge Tail into tree.
    if (
      oldTail &&
      newTailOffset > oldTailOffset &&
      newOrigin < oldCapacity &&
      oldTail.array.length
    ) {
      newRoot = editableVNode(newRoot, owner);
      var node = newRoot;
      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
        var idx = (oldTailOffset >>> level) & MASK;
        node = node.array[idx] = editableVNode(node.array[idx], owner);
      }
      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
    }

    // If the size has been reduced, there's a chance the tail needs to be trimmed.
    if (newCapacity < oldCapacity) {
      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
    }

    // If the new origin is within the tail, then we do not need a root.
    if (newOrigin >= newTailOffset) {
      newOrigin -= newTailOffset;
      newCapacity -= newTailOffset;
      newLevel = SHIFT;
      newRoot = null;
      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

      // Otherwise, if the root has been trimmed, garbage collect.
    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
      offsetShift = 0;

      // Identify the new top root node of the subtree of the old root.
      while (newRoot) {
        var beginIndex = (newOrigin >>> newLevel) & MASK;
        if ((beginIndex !== newTailOffset >>> newLevel) & MASK) {
          break;
        }
        if (beginIndex) {
          offsetShift += (1 << newLevel) * beginIndex;
        }
        newLevel -= SHIFT;
        newRoot = newRoot.array[beginIndex];
      }

      // Trim the new sides of the new root.
      if (newRoot && newOrigin > oldOrigin) {
        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
      }
      if (newRoot && newTailOffset < oldTailOffset) {
        newRoot = newRoot.removeAfter(
          owner,
          newLevel,
          newTailOffset - offsetShift
        );
      }
      if (offsetShift) {
        newOrigin -= offsetShift;
        newCapacity -= offsetShift;
      }
    }

    if (list.__ownerID) {
      list.size = newCapacity - newOrigin;
      list._origin = newOrigin;
      list._capacity = newCapacity;
      list._level = newLevel;
      list._root = newRoot;
      list._tail = newTail;
      list.__hash = undefined;
      list.__altered = true;
      return list;
    }
    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
  }

  function getTailOffset(size) {
    return size < SIZE ? 0 : ((size - 1) >>> SHIFT) << SHIFT;
  }

  var OrderedMap = (function (Map$$1) {
    function OrderedMap(value) {
      return value === null || value === undefined
        ? emptyOrderedMap()
        : isOrderedMap(value)
          ? value
          : emptyOrderedMap().withMutations(function (map) {
              var iter = KeyedCollection(value);
              assertNotInfinite(iter.size);
              iter.forEach(function (v, k) { return map.set(k, v); });
            });
    }

    if ( Map$$1 ) OrderedMap.__proto__ = Map$$1;
    OrderedMap.prototype = Object.create( Map$$1 && Map$$1.prototype );
    OrderedMap.prototype.constructor = OrderedMap;

    OrderedMap.of = function of (/*...values*/) {
      return this(arguments);
    };

    OrderedMap.prototype.toString = function toString () {
      return this.__toString('OrderedMap {', '}');
    };

    // @pragma Access

    OrderedMap.prototype.get = function get (k, notSetValue) {
      var index = this._map.get(k);
      return index !== undefined ? this._list.get(index)[1] : notSetValue;
    };

    // @pragma Modification

    OrderedMap.prototype.clear = function clear () {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._map.clear();
        this._list.clear();
        return this;
      }
      return emptyOrderedMap();
    };

    OrderedMap.prototype.set = function set (k, v) {
      return updateOrderedMap(this, k, v);
    };

    OrderedMap.prototype.remove = function remove (k) {
      return updateOrderedMap(this, k, NOT_SET);
    };

    OrderedMap.prototype.wasAltered = function wasAltered () {
      return this._map.wasAltered() || this._list.wasAltered();
    };

    OrderedMap.prototype.__iterate = function __iterate (fn, reverse) {
      var this$1 = this;

      return this._list.__iterate(
        function (entry) { return entry && fn(entry[1], entry[0], this$1); },
        reverse
      );
    };

    OrderedMap.prototype.__iterator = function __iterator (type, reverse) {
      return this._list.fromEntrySeq().__iterator(type, reverse);
    };

    OrderedMap.prototype.__ensureOwner = function __ensureOwner (ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      var newList = this._list.__ensureOwner(ownerID);
      if (!ownerID) {
        if (this.size === 0) {
          return emptyOrderedMap();
        }
        this.__ownerID = ownerID;
        this._map = newMap;
        this._list = newList;
        return this;
      }
      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
    };

    return OrderedMap;
  }(Map));

  OrderedMap.isOrderedMap = isOrderedMap;

  OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;
  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;

  function makeOrderedMap(map, list, ownerID, hash) {
    var omap = Object.create(OrderedMap.prototype);
    omap.size = map ? map.size : 0;
    omap._map = map;
    omap._list = list;
    omap.__ownerID = ownerID;
    omap.__hash = hash;
    return omap;
  }

  var EMPTY_ORDERED_MAP;
  function emptyOrderedMap() {
    return (
      EMPTY_ORDERED_MAP ||
      (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()))
    );
  }

  function updateOrderedMap(omap, k, v) {
    var map = omap._map;
    var list = omap._list;
    var i = map.get(k);
    var has = i !== undefined;
    var newMap;
    var newList;
    if (v === NOT_SET) {
      // removed
      if (!has) {
        return omap;
      }
      if (list.size >= SIZE && list.size >= map.size * 2) {
        newList = list.filter(function (entry, idx) { return entry !== undefined && i !== idx; });
        newMap = newList
          .toKeyedSeq()
          .map(function (entry) { return entry[0]; })
          .flip()
          .toMap();
        if (omap.__ownerID) {
          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
        }
      } else {
        newMap = map.remove(k);
        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
      }
    } else if (has) {
      if (v === list.get(i)[1]) {
        return omap;
      }
      newMap = map;
      newList = list.set(i, [k, v]);
    } else {
      newMap = map.set(k, list.size);
      newList = list.set(list.size, [k, v]);
    }
    if (omap.__ownerID) {
      omap.size = newMap.size;
      omap._map = newMap;
      omap._list = newList;
      omap.__hash = undefined;
      return omap;
    }
    return makeOrderedMap(newMap, newList);
  }

  var IS_STACK_SYMBOL = '@@__IMMUTABLE_STACK__@@';

  function isStack(maybeStack) {
    return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);
  }

  var Stack = (function (IndexedCollection$$1) {
    function Stack(value) {
      return value === null || value === undefined
        ? emptyStack()
        : isStack(value)
          ? value
          : emptyStack().pushAll(value);
    }

    if ( IndexedCollection$$1 ) Stack.__proto__ = IndexedCollection$$1;
    Stack.prototype = Object.create( IndexedCollection$$1 && IndexedCollection$$1.prototype );
    Stack.prototype.constructor = Stack;

    Stack.of = function of (/*...values*/) {
      return this(arguments);
    };

    Stack.prototype.toString = function toString () {
      return this.__toString('Stack [', ']');
    };

    // @pragma Access

    Stack.prototype.get = function get (index, notSetValue) {
      var head = this._head;
      index = wrapIndex(this, index);
      while (head && index--) {
        head = head.next;
      }
      return head ? head.value : notSetValue;
    };

    Stack.prototype.peek = function peek () {
      return this._head && this._head.value;
    };

    // @pragma Modification

    Stack.prototype.push = function push (/*...values*/) {
      var arguments$1 = arguments;

      if (arguments.length === 0) {
        return this;
      }
      var newSize = this.size + arguments.length;
      var head = this._head;
      for (var ii = arguments.length - 1; ii >= 0; ii--) {
        head = {
          value: arguments$1[ii],
          next: head,
        };
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    Stack.prototype.pushAll = function pushAll (iter) {
      iter = IndexedCollection$$1(iter);
      if (iter.size === 0) {
        return this;
      }
      if (this.size === 0 && isStack(iter)) {
        return iter;
      }
      assertNotInfinite(iter.size);
      var newSize = this.size;
      var head = this._head;
      iter.__iterate(function (value) {
        newSize++;
        head = {
          value: value,
          next: head,
        };
      }, /* reverse */ true);
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    Stack.prototype.pop = function pop () {
      return this.slice(1);
    };

    Stack.prototype.clear = function clear () {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._head = undefined;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyStack();
    };

    Stack.prototype.slice = function slice (begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      var resolvedBegin = resolveBegin(begin, this.size);
      var resolvedEnd = resolveEnd(end, this.size);
      if (resolvedEnd !== this.size) {
        // super.slice(begin, end);
        return IndexedCollection$$1.prototype.slice.call(this, begin, end);
      }
      var newSize = this.size - resolvedBegin;
      var head = this._head;
      while (resolvedBegin--) {
        head = head.next;
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    // @pragma Mutability

    Stack.prototype.__ensureOwner = function __ensureOwner (ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        if (this.size === 0) {
          return emptyStack();
        }
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeStack(this.size, this._head, ownerID, this.__hash);
    };

    // @pragma Iteration

    Stack.prototype.__iterate = function __iterate (fn, reverse) {
      var this$1 = this;

      if (reverse) {
        return new ArraySeq(this.toArray()).__iterate(
          function (v, k) { return fn(v, k, this$1); },
          reverse
        );
      }
      var iterations = 0;
      var node = this._head;
      while (node) {
        if (fn(node.value, iterations++, this$1) === false) {
          break;
        }
        node = node.next;
      }
      return iterations;
    };

    Stack.prototype.__iterator = function __iterator (type, reverse) {
      if (reverse) {
        return new ArraySeq(this.toArray()).__iterator(type, reverse);
      }
      var iterations = 0;
      var node = this._head;
      return new Iterator(function () {
        if (node) {
          var value = node.value;
          node = node.next;
          return iteratorValue(type, iterations++, value);
        }
        return iteratorDone();
      });
    };

    return Stack;
  }(IndexedCollection));

  Stack.isStack = isStack;

  var StackPrototype = Stack.prototype;
  StackPrototype[IS_STACK_SYMBOL] = true;
  StackPrototype.shift = StackPrototype.pop;
  StackPrototype.unshift = StackPrototype.push;
  StackPrototype.unshiftAll = StackPrototype.pushAll;
  StackPrototype.withMutations = withMutations;
  StackPrototype.wasAltered = wasAltered;
  StackPrototype.asImmutable = asImmutable;
  StackPrototype['@@transducer/init'] = StackPrototype.asMutable = asMutable;
  StackPrototype['@@transducer/step'] = function(result, arr) {
    return result.unshift(arr);
  };
  StackPrototype['@@transducer/result'] = function(obj) {
    return obj.asImmutable();
  };

  function makeStack(size, head, ownerID, hash) {
    var map = Object.create(StackPrototype);
    map.size = size;
    map._head = head;
    map.__ownerID = ownerID;
    map.__hash = hash;
    map.__altered = false;
    return map;
  }

  var EMPTY_STACK;
  function emptyStack() {
    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
  }

  var IS_SET_SYMBOL = '@@__IMMUTABLE_SET__@@';

  function isSet(maybeSet) {
    return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);
  }

  function isOrderedSet(maybeOrderedSet) {
    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
  }

  function deepEqual(a, b) {
    if (a === b) {
      return true;
    }

    if (
      !isCollection(b) ||
      (a.size !== undefined && b.size !== undefined && a.size !== b.size) ||
      (a.__hash !== undefined &&
        b.__hash !== undefined &&
        a.__hash !== b.__hash) ||
      isKeyed(a) !== isKeyed(b) ||
      isIndexed(a) !== isIndexed(b) ||
      isOrdered(a) !== isOrdered(b)
    ) {
      return false;
    }

    if (a.size === 0 && b.size === 0) {
      return true;
    }

    var notAssociative = !isAssociative(a);

    if (isOrdered(a)) {
      var entries = a.entries();
      return (
        b.every(function (v, k) {
          var entry = entries.next().value;
          return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
        }) && entries.next().done
      );
    }

    var flipped = false;

    if (a.size === undefined) {
      if (b.size === undefined) {
        if (typeof a.cacheResult === 'function') {
          a.cacheResult();
        }
      } else {
        flipped = true;
        var _ = a;
        a = b;
        b = _;
      }
    }

    var allEqual = true;
    var bSize = b.__iterate(function (v, k) {
      if (
        notAssociative
          ? !a.has(v)
          : flipped
            ? !is(v, a.get(k, NOT_SET))
            : !is(a.get(k, NOT_SET), v)
      ) {
        allEqual = false;
        return false;
      }
    });

    return allEqual && a.size === bSize;
  }

  /**
   * Contributes additional methods to a constructor
   */
  function mixin(ctor, methods) {
    var keyCopier = function (key) {
      ctor.prototype[key] = methods[key];
    };
    Object.keys(methods).forEach(keyCopier);
    Object.getOwnPropertySymbols &&
      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
    return ctor;
  }

  function toJS(value) {
    if (!value || typeof value !== 'object') {
      return value;
    }
    if (!isCollection(value)) {
      if (!isDataStructure(value)) {
        return value;
      }
      value = Seq(value);
    }
    if (isKeyed(value)) {
      var result$1 = {};
      value.__iterate(function (v, k) {
        result$1[k] = toJS(v);
      });
      return result$1;
    }
    var result = [];
    value.__iterate(function (v) {
      result.push(toJS(v));
    });
    return result;
  }

  var Set = (function (SetCollection$$1) {
    function Set(value) {
      return value === null || value === undefined
        ? emptySet()
        : isSet(value) && !isOrdered(value)
          ? value
          : emptySet().withMutations(function (set) {
              var iter = SetCollection$$1(value);
              assertNotInfinite(iter.size);
              iter.forEach(function (v) { return set.add(v); });
            });
    }

    if ( SetCollection$$1 ) Set.__proto__ = SetCollection$$1;
    Set.prototype = Object.create( SetCollection$$1 && SetCollection$$1.prototype );
    Set.prototype.constructor = Set;

    Set.of = function of (/*...values*/) {
      return this(arguments);
    };

    Set.fromKeys = function fromKeys (value) {
      return this(KeyedCollection(value).keySeq());
    };

    Set.intersect = function intersect (sets) {
      sets = Collection(sets).toArray();
      return sets.length
        ? SetPrototype.intersect.apply(Set(sets.pop()), sets)
        : emptySet();
    };

    Set.union = function union (sets) {
      sets = Collection(sets).toArray();
      return sets.length
        ? SetPrototype.union.apply(Set(sets.pop()), sets)
        : emptySet();
    };

    Set.prototype.toString = function toString () {
      return this.__toString('Set {', '}');
    };

    // @pragma Access

    Set.prototype.has = function has (value) {
      return this._map.has(value);
    };

    // @pragma Modification

    Set.prototype.add = function add (value) {
      return updateSet(this, this._map.set(value, value));
    };

    Set.prototype.remove = function remove (value) {
      return updateSet(this, this._map.remove(value));
    };

    Set.prototype.clear = function clear () {
      return updateSet(this, this._map.clear());
    };

    // @pragma Composition

    Set.prototype.map = function map (mapper, context) {
      var this$1 = this;

      return updateSet(this, this._map.map(function (v) { return mapper(v, v, this$1); }, context));
    };

    Set.prototype.union = function union () {
      var iters = [], len = arguments.length;
      while ( len-- ) iters[ len ] = arguments[ len ];

      iters = iters.filter(function (x) { return x.size !== 0; });
      if (iters.length === 0) {
        return this;
      }
      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
        return this.constructor(iters[0]);
      }
      return this.withMutations(function (set) {
        for (var ii = 0; ii < iters.length; ii++) {
          SetCollection$$1(iters[ii]).forEach(function (value) { return set.add(value); });
        }
      });
    };

    Set.prototype.intersect = function intersect () {
      var iters = [], len = arguments.length;
      while ( len-- ) iters[ len ] = arguments[ len ];

      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function (iter) { return SetCollection$$1(iter); });
      var toRemove = [];
      this.forEach(function (value) {
        if (!iters.every(function (iter) { return iter.includes(value); })) {
          toRemove.push(value);
        }
      });
      return this.withMutations(function (set) {
        toRemove.forEach(function (value) {
          set.remove(value);
        });
      });
    };

    Set.prototype.subtract = function subtract () {
      var iters = [], len = arguments.length;
      while ( len-- ) iters[ len ] = arguments[ len ];

      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function (iter) { return SetCollection$$1(iter); });
      var toRemove = [];
      this.forEach(function (value) {
        if (iters.some(function (iter) { return iter.includes(value); })) {
          toRemove.push(value);
        }
      });
      return this.withMutations(function (set) {
        toRemove.forEach(function (value) {
          set.remove(value);
        });
      });
    };

    Set.prototype.sort = function sort (comparator) {
      // Late binding
      return OrderedSet(sortFactory(this, comparator));
    };

    Set.prototype.sortBy = function sortBy (mapper, comparator) {
      // Late binding
      return OrderedSet(sortFactory(this, comparator, mapper));
    };

    Set.prototype.wasAltered = function wasAltered () {
      return this._map.wasAltered();
    };

    Set.prototype.__iterate = function __iterate (fn, reverse) {
      var this$1 = this;

      return this._map.__iterate(function (k) { return fn(k, k, this$1); }, reverse);
    };

    Set.prototype.__iterator = function __iterator (type, reverse) {
      return this._map.__iterator(type, reverse);
    };

    Set.prototype.__ensureOwner = function __ensureOwner (ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        if (this.size === 0) {
          return this.__empty();
        }
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return this.__make(newMap, ownerID);
    };

    return Set;
  }(SetCollection));

  Set.isSet = isSet;

  var SetPrototype = Set.prototype;
  SetPrototype[IS_SET_SYMBOL] = true;
  SetPrototype[DELETE] = SetPrototype.remove;
  SetPrototype.merge = SetPrototype.concat = SetPrototype.union;
  SetPrototype.withMutations = withMutations;
  SetPrototype.asImmutable = asImmutable;
  SetPrototype['@@transducer/init'] = SetPrototype.asMutable = asMutable;
  SetPrototype['@@transducer/step'] = function(result, arr) {
    return result.add(arr);
  };
  SetPrototype['@@transducer/result'] = function(obj) {
    return obj.asImmutable();
  };

  SetPrototype.__empty = emptySet;
  SetPrototype.__make = makeSet;

  function updateSet(set, newMap) {
    if (set.__ownerID) {
      set.size = newMap.size;
      set._map = newMap;
      return set;
    }
    return newMap === set._map
      ? set
      : newMap.size === 0
        ? set.__empty()
        : set.__make(newMap);
  }

  function makeSet(map, ownerID) {
    var set = Object.create(SetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
  }

  var EMPTY_SET;
  function emptySet() {
    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
  }

  /**
   * Returns a lazy seq of nums from start (inclusive) to end
   * (exclusive), by step, where start defaults to 0, step to 1, and end to
   * infinity. When start is equal to end, returns empty list.
   */
  var Range = (function (IndexedSeq$$1) {
    function Range(start, end, step) {
      if (!(this instanceof Range)) {
        return new Range(start, end, step);
      }
      invariant(step !== 0, 'Cannot step a Range by 0');
      start = start || 0;
      if (end === undefined) {
        end = Infinity;
      }
      step = step === undefined ? 1 : Math.abs(step);
      if (end < start) {
        step = -step;
      }
      this._start = start;
      this._end = end;
      this._step = step;
      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
      if (this.size === 0) {
        if (EMPTY_RANGE) {
          return EMPTY_RANGE;
        }
        EMPTY_RANGE = this;
      }
    }

    if ( IndexedSeq$$1 ) Range.__proto__ = IndexedSeq$$1;
    Range.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );
    Range.prototype.constructor = Range;

    Range.prototype.toString = function toString () {
      if (this.size === 0) {
        return 'Range []';
      }
      return (
        'Range [ ' +
        this._start +
        '...' +
        this._end +
        (this._step !== 1 ? ' by ' + this._step : '') +
        ' ]'
      );
    };

    Range.prototype.get = function get (index, notSetValue) {
      return this.has(index)
        ? this._start + wrapIndex(this, index) * this._step
        : notSetValue;
    };

    Range.prototype.includes = function includes (searchValue) {
      var possibleIndex = (searchValue - this._start) / this._step;
      return (
        possibleIndex >= 0 &&
        possibleIndex < this.size &&
        possibleIndex === Math.floor(possibleIndex)
      );
    };

    Range.prototype.slice = function slice (begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      begin = resolveBegin(begin, this.size);
      end = resolveEnd(end, this.size);
      if (end <= begin) {
        return new Range(0, 0);
      }
      return new Range(
        this.get(begin, this._end),
        this.get(end, this._end),
        this._step
      );
    };

    Range.prototype.indexOf = function indexOf (searchValue) {
      var offsetValue = searchValue - this._start;
      if (offsetValue % this._step === 0) {
        var index = offsetValue / this._step;
        if (index >= 0 && index < this.size) {
          return index;
        }
      }
      return -1;
    };

    Range.prototype.lastIndexOf = function lastIndexOf (searchValue) {
      return this.indexOf(searchValue);
    };

    Range.prototype.__iterate = function __iterate (fn, reverse) {
      var this$1 = this;

      var size = this.size;
      var step = this._step;
      var value = reverse ? this._start + (size - 1) * step : this._start;
      var i = 0;
      while (i !== size) {
        if (fn(value, reverse ? size - ++i : i++, this$1) === false) {
          break;
        }
        value += reverse ? -step : step;
      }
      return i;
    };

    Range.prototype.__iterator = function __iterator (type, reverse) {
      var size = this.size;
      var step = this._step;
      var value = reverse ? this._start + (size - 1) * step : this._start;
      var i = 0;
      return new Iterator(function () {
        if (i === size) {
          return iteratorDone();
        }
        var v = value;
        value += reverse ? -step : step;
        return iteratorValue(type, reverse ? size - ++i : i++, v);
      });
    };

    Range.prototype.equals = function equals (other) {
      return other instanceof Range
        ? this._start === other._start &&
            this._end === other._end &&
            this._step === other._step
        : deepEqual(this, other);
    };

    return Range;
  }(IndexedSeq));

  var EMPTY_RANGE;

  function getIn(collection, searchKeyPath, notSetValue) {
    var keyPath = coerceKeyPath(searchKeyPath);
    var i = 0;
    while (i !== keyPath.length) {
      collection = get(collection, keyPath[i++], NOT_SET);
      if (collection === NOT_SET) {
        return notSetValue;
      }
    }
    return collection;
  }

  function getIn$1(searchKeyPath, notSetValue) {
    return getIn(this, searchKeyPath, notSetValue);
  }

  function hasIn(collection, keyPath) {
    return getIn(collection, keyPath, NOT_SET) !== NOT_SET;
  }

  function hasIn$1(searchKeyPath) {
    return hasIn(this, searchKeyPath);
  }

  function toObject() {
    assertNotInfinite(this.size);
    var object = {};
    this.__iterate(function (v, k) {
      object[k] = v;
    });
    return object;
  }

  // Note: all of these methods are deprecated.
  Collection.isIterable = isCollection;
  Collection.isKeyed = isKeyed;
  Collection.isIndexed = isIndexed;
  Collection.isAssociative = isAssociative;
  Collection.isOrdered = isOrdered;

  Collection.Iterator = Iterator;

  mixin(Collection, {
    // ### Conversion to other types

    toArray: function toArray() {
      assertNotInfinite(this.size);
      var array = new Array(this.size || 0);
      var useTuples = isKeyed(this);
      var i = 0;
      this.__iterate(function (v, k) {
        // Keyed collections produce an array of tuples.
        array[i++] = useTuples ? [k, v] : v;
      });
      return array;
    },

    toIndexedSeq: function toIndexedSeq() {
      return new ToIndexedSequence(this);
    },

    toJS: function toJS$1() {
      return toJS(this);
    },

    toKeyedSeq: function toKeyedSeq() {
      return new ToKeyedSequence(this, true);
    },

    toMap: function toMap() {
      // Use Late Binding here to solve the circular dependency.
      return Map(this.toKeyedSeq());
    },

    toObject: toObject,

    toOrderedMap: function toOrderedMap() {
      // Use Late Binding here to solve the circular dependency.
      return OrderedMap(this.toKeyedSeq());
    },

    toOrderedSet: function toOrderedSet() {
      // Use Late Binding here to solve the circular dependency.
      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
    },

    toSet: function toSet() {
      // Use Late Binding here to solve the circular dependency.
      return Set(isKeyed(this) ? this.valueSeq() : this);
    },

    toSetSeq: function toSetSeq() {
      return new ToSetSequence(this);
    },

    toSeq: function toSeq() {
      return isIndexed(this)
        ? this.toIndexedSeq()
        : isKeyed(this)
          ? this.toKeyedSeq()
          : this.toSetSeq();
    },

    toStack: function toStack() {
      // Use Late Binding here to solve the circular dependency.
      return Stack(isKeyed(this) ? this.valueSeq() : this);
    },

    toList: function toList() {
      // Use Late Binding here to solve the circular dependency.
      return List(isKeyed(this) ? this.valueSeq() : this);
    },

    // ### Common JavaScript methods and properties

    toString: function toString() {
      return '[Collection]';
    },

    __toString: function __toString(head, tail) {
      if (this.size === 0) {
        return head + tail;
      }
      return (
        head +
        ' ' +
        this.toSeq()
          .map(this.__toStringMapper)
          .join(', ') +
        ' ' +
        tail
      );
    },

    // ### ES6 Collection methods (ES6 Array and Map)

    concat: function concat() {
      var values = [], len = arguments.length;
      while ( len-- ) values[ len ] = arguments[ len ];

      return reify(this, concatFactory(this, values));
    },

    includes: function includes(searchValue) {
      return this.some(function (value) { return is(value, searchValue); });
    },

    entries: function entries() {
      return this.__iterator(ITERATE_ENTRIES);
    },

    every: function every(predicate, context) {
      assertNotInfinite(this.size);
      var returnValue = true;
      this.__iterate(function (v, k, c) {
        if (!predicate.call(context, v, k, c)) {
          returnValue = false;
          return false;
        }
      });
      return returnValue;
    },

    filter: function filter(predicate, context) {
      return reify(this, filterFactory(this, predicate, context, true));
    },

    find: function find(predicate, context, notSetValue) {
      var entry = this.findEntry(predicate, context);
      return entry ? entry[1] : notSetValue;
    },

    forEach: function forEach(sideEffect, context) {
      assertNotInfinite(this.size);
      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
    },

    join: function join(separator) {
      assertNotInfinite(this.size);
      separator = separator !== undefined ? '' + separator : ',';
      var joined = '';
      var isFirst = true;
      this.__iterate(function (v) {
        isFirst ? (isFirst = false) : (joined += separator);
        joined += v !== null && v !== undefined ? v.toString() : '';
      });
      return joined;
    },

    keys: function keys() {
      return this.__iterator(ITERATE_KEYS);
    },

    map: function map(mapper, context) {
      return reify(this, mapFactory(this, mapper, context));
    },

    reduce: function reduce$1(reducer, initialReduction, context) {
      return reduce(
        this,
        reducer,
        initialReduction,
        context,
        arguments.length < 2,
        false
      );
    },

    reduceRight: function reduceRight(reducer, initialReduction, context) {
      return reduce(
        this,
        reducer,
        initialReduction,
        context,
        arguments.length < 2,
        true
      );
    },

    reverse: function reverse() {
      return reify(this, reverseFactory(this, true));
    },

    slice: function slice(begin, end) {
      return reify(this, sliceFactory(this, begin, end, true));
    },

    some: function some(predicate, context) {
      return !this.every(not(predicate), context);
    },

    sort: function sort(comparator) {
      return reify(this, sortFactory(this, comparator));
    },

    values: function values() {
      return this.__iterator(ITERATE_VALUES);
    },

    // ### More sequential methods

    butLast: function butLast() {
      return this.slice(0, -1);
    },

    isEmpty: function isEmpty() {
      return this.size !== undefined ? this.size === 0 : !this.some(function () { return true; });
    },

    count: function count(predicate, context) {
      return ensureSize(
        predicate ? this.toSeq().filter(predicate, context) : this
      );
    },

    countBy: function countBy(grouper, context) {
      return countByFactory(this, grouper, context);
    },

    equals: function equals(other) {
      return deepEqual(this, other);
    },

    entrySeq: function entrySeq() {
      var collection = this;
      if (collection._cache) {
        // We cache as an entries array, so we can just return the cache!
        return new ArraySeq(collection._cache);
      }
      var entriesSequence = collection
        .toSeq()
        .map(entryMapper)
        .toIndexedSeq();
      entriesSequence.fromEntrySeq = function () { return collection.toSeq(); };
      return entriesSequence;
    },

    filterNot: function filterNot(predicate, context) {
      return this.filter(not(predicate), context);
    },

    findEntry: function findEntry(predicate, context, notSetValue) {
      var found = notSetValue;
      this.__iterate(function (v, k, c) {
        if (predicate.call(context, v, k, c)) {
          found = [k, v];
          return false;
        }
      });
      return found;
    },

    findKey: function findKey(predicate, context) {
      var entry = this.findEntry(predicate, context);
      return entry && entry[0];
    },

    findLast: function findLast(predicate, context, notSetValue) {
      return this.toKeyedSeq()
        .reverse()
        .find(predicate, context, notSetValue);
    },

    findLastEntry: function findLastEntry(predicate, context, notSetValue) {
      return this.toKeyedSeq()
        .reverse()
        .findEntry(predicate, context, notSetValue);
    },

    findLastKey: function findLastKey(predicate, context) {
      return this.toKeyedSeq()
        .reverse()
        .findKey(predicate, context);
    },

    first: function first(notSetValue) {
      return this.find(returnTrue, null, notSetValue);
    },

    flatMap: function flatMap(mapper, context) {
      return reify(this, flatMapFactory(this, mapper, context));
    },

    flatten: function flatten(depth) {
      return reify(this, flattenFactory(this, depth, true));
    },

    fromEntrySeq: function fromEntrySeq() {
      return new FromEntriesSequence(this);
    },

    get: function get(searchKey, notSetValue) {
      return this.find(function (_, key) { return is(key, searchKey); }, undefined, notSetValue);
    },

    getIn: getIn$1,

    groupBy: function groupBy(grouper, context) {
      return groupByFactory(this, grouper, context);
    },

    has: function has(searchKey) {
      return this.get(searchKey, NOT_SET) !== NOT_SET;
    },

    hasIn: hasIn$1,

    isSubset: function isSubset(iter) {
      iter = typeof iter.includes === 'function' ? iter : Collection(iter);
      return this.every(function (value) { return iter.includes(value); });
    },

    isSuperset: function isSuperset(iter) {
      iter = typeof iter.isSubset === 'function' ? iter : Collection(iter);
      return iter.isSubset(this);
    },

    keyOf: function keyOf(searchValue) {
      return this.findKey(function (value) { return is(value, searchValue); });
    },

    keySeq: function keySeq() {
      return this.toSeq()
        .map(keyMapper)
        .toIndexedSeq();
    },

    last: function last(notSetValue) {
      return this.toSeq()
        .reverse()
        .first(notSetValue);
    },

    lastKeyOf: function lastKeyOf(searchValue) {
      return this.toKeyedSeq()
        .reverse()
        .keyOf(searchValue);
    },

    max: function max(comparator) {
      return maxFactory(this, comparator);
    },

    maxBy: function maxBy(mapper, comparator) {
      return maxFactory(this, comparator, mapper);
    },

    min: function min(comparator) {
      return maxFactory(
        this,
        comparator ? neg(comparator) : defaultNegComparator
      );
    },

    minBy: function minBy(mapper, comparator) {
      return maxFactory(
        this,
        comparator ? neg(comparator) : defaultNegComparator,
        mapper
      );
    },

    rest: function rest() {
      return this.slice(1);
    },

    skip: function skip(amount) {
      return amount === 0 ? this : this.slice(Math.max(0, amount));
    },

    skipLast: function skipLast(amount) {
      return amount === 0 ? this : this.slice(0, -Math.max(0, amount));
    },

    skipWhile: function skipWhile(predicate, context) {
      return reify(this, skipWhileFactory(this, predicate, context, true));
    },

    skipUntil: function skipUntil(predicate, context) {
      return this.skipWhile(not(predicate), context);
    },

    sortBy: function sortBy(mapper, comparator) {
      return reify(this, sortFactory(this, comparator, mapper));
    },

    take: function take(amount) {
      return this.slice(0, Math.max(0, amount));
    },

    takeLast: function takeLast(amount) {
      return this.slice(-Math.max(0, amount));
    },

    takeWhile: function takeWhile(predicate, context) {
      return reify(this, takeWhileFactory(this, predicate, context));
    },

    takeUntil: function takeUntil(predicate, context) {
      return this.takeWhile(not(predicate), context);
    },

    update: function update(fn) {
      return fn(this);
    },

    valueSeq: function valueSeq() {
      return this.toIndexedSeq();
    },

    // ### Hashable Object

    hashCode: function hashCode() {
      return this.__hash || (this.__hash = hashCollection(this));
    },

    // ### Internal

    // abstract __iterate(fn, reverse)

    // abstract __iterator(type, reverse)
  });

  var CollectionPrototype = Collection.prototype;
  CollectionPrototype[IS_COLLECTION_SYMBOL] = true;
  CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;
  CollectionPrototype.toJSON = CollectionPrototype.toArray;
  CollectionPrototype.__toStringMapper = quoteString;
  CollectionPrototype.inspect = CollectionPrototype.toSource = function() {
    return this.toString();
  };
  CollectionPrototype.chain = CollectionPrototype.flatMap;
  CollectionPrototype.contains = CollectionPrototype.includes;

  mixin(KeyedCollection, {
    // ### More sequential methods

    flip: function flip() {
      return reify(this, flipFactory(this));
    },

    mapEntries: function mapEntries(mapper, context) {
      var this$1 = this;

      var iterations = 0;
      return reify(
        this,
        this.toSeq()
          .map(function (v, k) { return mapper.call(context, [k, v], iterations++, this$1); })
          .fromEntrySeq()
      );
    },

    mapKeys: function mapKeys(mapper, context) {
      var this$1 = this;

      return reify(
        this,
        this.toSeq()
          .flip()
          .map(function (k, v) { return mapper.call(context, k, v, this$1); })
          .flip()
      );
    },
  });

  var KeyedCollectionPrototype = KeyedCollection.prototype;
  KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;
  KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
  KeyedCollectionPrototype.toJSON = toObject;
  KeyedCollectionPrototype.__toStringMapper = function (v, k) { return quoteString(k) + ': ' + quoteString(v); };

  mixin(IndexedCollection, {
    // ### Conversion to other types

    toKeyedSeq: function toKeyedSeq() {
      return new ToKeyedSequence(this, false);
    },

    // ### ES6 Collection methods (ES6 Array and Map)

    filter: function filter(predicate, context) {
      return reify(this, filterFactory(this, predicate, context, false));
    },

    findIndex: function findIndex(predicate, context) {
      var entry = this.findEntry(predicate, context);
      return entry ? entry[0] : -1;
    },

    indexOf: function indexOf(searchValue) {
      var key = this.keyOf(searchValue);
      return key === undefined ? -1 : key;
    },

    lastIndexOf: function lastIndexOf(searchValue) {
      var key = this.lastKeyOf(searchValue);
      return key === undefined ? -1 : key;
    },

    reverse: function reverse() {
      return reify(this, reverseFactory(this, false));
    },

    slice: function slice(begin, end) {
      return reify(this, sliceFactory(this, begin, end, false));
    },

    splice: function splice(index, removeNum /*, ...values*/) {
      var numArgs = arguments.length;
      removeNum = Math.max(removeNum || 0, 0);
      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
        return this;
      }
      // If index is negative, it should resolve relative to the size of the
      // collection. However size may be expensive to compute if not cached, so
      // only call count() if the number is in fact negative.
      index = resolveBegin(index, index < 0 ? this.count() : this.size);
      var spliced = this.slice(0, index);
      return reify(
        this,
        numArgs === 1
          ? spliced
          : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
      );
    },

    // ### More collection methods

    findLastIndex: function findLastIndex(predicate, context) {
      var entry = this.findLastEntry(predicate, context);
      return entry ? entry[0] : -1;
    },

    first: function first(notSetValue) {
      return this.get(0, notSetValue);
    },

    flatten: function flatten(depth) {
      return reify(this, flattenFactory(this, depth, false));
    },

    get: function get(index, notSetValue) {
      index = wrapIndex(this, index);
      return index < 0 ||
        (this.size === Infinity || (this.size !== undefined && index > this.size))
        ? notSetValue
        : this.find(function (_, key) { return key === index; }, undefined, notSetValue);
    },

    has: function has(index) {
      index = wrapIndex(this, index);
      return (
        index >= 0 &&
        (this.size !== undefined
          ? this.size === Infinity || index < this.size
          : this.indexOf(index) !== -1)
      );
    },

    interpose: function interpose(separator) {
      return reify(this, interposeFactory(this, separator));
    },

    interleave: function interleave(/*...collections*/) {
      var collections = [this].concat(arrCopy(arguments));
      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);
      var interleaved = zipped.flatten(true);
      if (zipped.size) {
        interleaved.size = zipped.size * collections.length;
      }
      return reify(this, interleaved);
    },

    keySeq: function keySeq() {
      return Range(0, this.size);
    },

    last: function last(notSetValue) {
      return this.get(-1, notSetValue);
    },

    skipWhile: function skipWhile(predicate, context) {
      return reify(this, skipWhileFactory(this, predicate, context, false));
    },

    zip: function zip(/*, ...collections */) {
      var collections = [this].concat(arrCopy(arguments));
      return reify(this, zipWithFactory(this, defaultZipper, collections));
    },

    zipAll: function zipAll(/*, ...collections */) {
      var collections = [this].concat(arrCopy(arguments));
      return reify(this, zipWithFactory(this, defaultZipper, collections, true));
    },

    zipWith: function zipWith(zipper /*, ...collections */) {
      var collections = arrCopy(arguments);
      collections[0] = this;
      return reify(this, zipWithFactory(this, zipper, collections));
    },
  });

  var IndexedCollectionPrototype = IndexedCollection.prototype;
  IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;
  IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;

  mixin(SetCollection, {
    // ### ES6 Collection methods (ES6 Array and Map)

    get: function get(value, notSetValue) {
      return this.has(value) ? value : notSetValue;
    },

    includes: function includes(value) {
      return this.has(value);
    },

    // ### More sequential methods

    keySeq: function keySeq() {
      return this.valueSeq();
    },
  });

  SetCollection.prototype.has = CollectionPrototype.includes;
  SetCollection.prototype.contains = SetCollection.prototype.includes;

  // Mixin subclasses

  mixin(KeyedSeq, KeyedCollection.prototype);
  mixin(IndexedSeq, IndexedCollection.prototype);
  mixin(SetSeq, SetCollection.prototype);

  // #pragma Helper functions

  function reduce(collection, reducer, reduction, context, useFirst, reverse) {
    assertNotInfinite(collection.size);
    collection.__iterate(function (v, k, c) {
      if (useFirst) {
        useFirst = false;
        reduction = v;
      } else {
        reduction = reducer.call(context, reduction, v, k, c);
      }
    }, reverse);
    return reduction;
  }

  function keyMapper(v, k) {
    return k;
  }

  function entryMapper(v, k) {
    return [k, v];
  }

  function not(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  }

  function neg(predicate) {
    return function() {
      return -predicate.apply(this, arguments);
    };
  }

  function defaultZipper() {
    return arrCopy(arguments);
  }

  function defaultNegComparator(a, b) {
    return a < b ? 1 : a > b ? -1 : 0;
  }

  function hashCollection(collection) {
    if (collection.size === Infinity) {
      return 0;
    }
    var ordered = isOrdered(collection);
    var keyed = isKeyed(collection);
    var h = ordered ? 1 : 0;
    var size = collection.__iterate(
      keyed
        ? ordered
          ? function (v, k) {
              h = (31 * h + hashMerge(hash(v), hash(k))) | 0;
            }
          : function (v, k) {
              h = (h + hashMerge(hash(v), hash(k))) | 0;
            }
        : ordered
          ? function (v) {
              h = (31 * h + hash(v)) | 0;
            }
          : function (v) {
              h = (h + hash(v)) | 0;
            }
    );
    return murmurHashOfSize(size, h);
  }

  function murmurHashOfSize(size, h) {
    h = imul(h, 0xcc9e2d51);
    h = imul((h << 15) | (h >>> -15), 0x1b873593);
    h = imul((h << 13) | (h >>> -13), 5);
    h = ((h + 0xe6546b64) | 0) ^ size;
    h = imul(h ^ (h >>> 16), 0x85ebca6b);
    h = imul(h ^ (h >>> 13), 0xc2b2ae35);
    h = smi(h ^ (h >>> 16));
    return h;
  }

  function hashMerge(a, b) {
    return (a ^ (b + 0x9e3779b9 + (a << 6) + (a >> 2))) | 0; // int
  }

  var OrderedSet = (function (Set$$1) {
    function OrderedSet(value) {
      return value === null || value === undefined
        ? emptyOrderedSet()
        : isOrderedSet(value)
          ? value
          : emptyOrderedSet().withMutations(function (set) {
              var iter = SetCollection(value);
              assertNotInfinite(iter.size);
              iter.forEach(function (v) { return set.add(v); });
            });
    }

    if ( Set$$1 ) OrderedSet.__proto__ = Set$$1;
    OrderedSet.prototype = Object.create( Set$$1 && Set$$1.prototype );
    OrderedSet.prototype.constructor = OrderedSet;

    OrderedSet.of = function of (/*...values*/) {
      return this(arguments);
    };

    OrderedSet.fromKeys = function fromKeys (value) {
      return this(KeyedCollection(value).keySeq());
    };

    OrderedSet.prototype.toString = function toString () {
      return this.__toString('OrderedSet {', '}');
    };

    return OrderedSet;
  }(Set));

  OrderedSet.isOrderedSet = isOrderedSet;

  var OrderedSetPrototype = OrderedSet.prototype;
  OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;
  OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;
  OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;

  OrderedSetPrototype.__empty = emptyOrderedSet;
  OrderedSetPrototype.__make = makeOrderedSet;

  function makeOrderedSet(map, ownerID) {
    var set = Object.create(OrderedSetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
  }

  var EMPTY_ORDERED_SET;
  function emptyOrderedSet() {
    return (
      EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()))
    );
  }

  var Record = function Record(defaultValues, name) {
    var hasInitialized;

    var RecordType = function Record(values) {
      var this$1 = this;

      if (values instanceof RecordType) {
        return values;
      }
      if (!(this instanceof RecordType)) {
        return new RecordType(values);
      }
      if (!hasInitialized) {
        hasInitialized = true;
        var keys = Object.keys(defaultValues);
        var indices = (RecordTypePrototype._indices = {});
        RecordTypePrototype._name = name;
        RecordTypePrototype._keys = keys;
        RecordTypePrototype._defaultValues = defaultValues;
        for (var i = 0; i < keys.length; i++) {
          var propName = keys[i];
          indices[propName] = i;
          if (RecordTypePrototype[propName]) {
            /* eslint-disable no-console */
            typeof console === 'object' &&
              console.warn &&
              console.warn(
                'Cannot define ' +
                  recordName(this$1) +
                  ' with property "' +
                  propName +
                  '" since that property name is part of the Record API.'
              );
            /* eslint-enable no-console */
          } else {
            setProp(RecordTypePrototype, propName);
          }
        }
      }
      this.__ownerID = undefined;
      this._values = List().withMutations(function (l) {
        l.setSize(this$1._keys.length);
        KeyedCollection(values).forEach(function (v, k) {
          l.set(this$1._indices[k], v === this$1._defaultValues[k] ? undefined : v);
        });
      });
    };

    var RecordTypePrototype = (RecordType.prototype = Object.create(
      RecordPrototype
    ));
    RecordTypePrototype.constructor = RecordType;

    return RecordType;
  };

  Record.prototype.toString = function toString () {
      var this$1 = this;

    var str = recordName(this) + ' { ';
    var keys = this._keys;
    var k;
    for (var i = 0, l = keys.length; i !== l; i++) {
      k = keys[i];
      str += (i ? ', ' : '') + k + ': ' + quoteString(this$1.get(k));
    }
    return str + ' }';
  };

  Record.prototype.equals = function equals (other) {
    return (
      this === other ||
      (other &&
        this._keys === other._keys &&
        recordSeq(this).equals(recordSeq(other)))
    );
  };

  Record.prototype.hashCode = function hashCode () {
    return recordSeq(this).hashCode();
  };

  // @pragma Access

  Record.prototype.has = function has (k) {
    return this._indices.hasOwnProperty(k);
  };

  Record.prototype.get = function get (k, notSetValue) {
    if (!this.has(k)) {
      return notSetValue;
    }
    var index = this._indices[k];
    var value = this._values.get(index);
    return value === undefined ? this._defaultValues[k] : value;
  };

  // @pragma Modification

  Record.prototype.set = function set (k, v) {
    if (this.has(k)) {
      var newValues = this._values.set(
        this._indices[k],
        v === this._defaultValues[k] ? undefined : v
      );
      if (newValues !== this._values && !this.__ownerID) {
        return makeRecord(this, newValues);
      }
    }
    return this;
  };

  Record.prototype.remove = function remove (k) {
    return this.set(k);
  };

  Record.prototype.clear = function clear () {
    var newValues = this._values.clear().setSize(this._keys.length);
    return this.__ownerID ? this : makeRecord(this, newValues);
  };

  Record.prototype.wasAltered = function wasAltered () {
    return this._values.wasAltered();
  };

  Record.prototype.toSeq = function toSeq () {
    return recordSeq(this);
  };

  Record.prototype.toJS = function toJS$1 () {
    return toJS(this);
  };

  Record.prototype.entries = function entries () {
    return this.__iterator(ITERATE_ENTRIES);
  };

  Record.prototype.__iterator = function __iterator (type, reverse) {
    return recordSeq(this).__iterator(type, reverse);
  };

  Record.prototype.__iterate = function __iterate (fn, reverse) {
    return recordSeq(this).__iterate(fn, reverse);
  };

  Record.prototype.__ensureOwner = function __ensureOwner (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newValues = this._values.__ensureOwner(ownerID);
    if (!ownerID) {
      this.__ownerID = ownerID;
      this._values = newValues;
      return this;
    }
    return makeRecord(this, newValues, ownerID);
  };

  Record.isRecord = isRecord;
  Record.getDescriptiveName = recordName;
  var RecordPrototype = Record.prototype;
  RecordPrototype[IS_RECORD_SYMBOL] = true;
  RecordPrototype[DELETE] = RecordPrototype.remove;
  RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;
  RecordPrototype.getIn = getIn$1;
  RecordPrototype.hasIn = CollectionPrototype.hasIn;
  RecordPrototype.merge = merge;
  RecordPrototype.mergeWith = mergeWith;
  RecordPrototype.mergeIn = mergeIn;
  RecordPrototype.mergeDeep = mergeDeep$1;
  RecordPrototype.mergeDeepWith = mergeDeepWith$1;
  RecordPrototype.mergeDeepIn = mergeDeepIn;
  RecordPrototype.setIn = setIn$1;
  RecordPrototype.update = update$1;
  RecordPrototype.updateIn = updateIn$1;
  RecordPrototype.withMutations = withMutations;
  RecordPrototype.asMutable = asMutable;
  RecordPrototype.asImmutable = asImmutable;
  RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;
  RecordPrototype.toJSON = RecordPrototype.toObject =
    CollectionPrototype.toObject;
  RecordPrototype.inspect = RecordPrototype.toSource = function() {
    return this.toString();
  };

  function makeRecord(likeRecord, values, ownerID) {
    var record = Object.create(Object.getPrototypeOf(likeRecord));
    record._values = values;
    record.__ownerID = ownerID;
    return record;
  }

  function recordName(record) {
    return record._name || record.constructor.name || 'Record';
  }

  function recordSeq(record) {
    return keyedSeqFromValue(record._keys.map(function (k) { return [k, record.get(k)]; }));
  }

  function setProp(prototype, name) {
    try {
      Object.defineProperty(prototype, name, {
        get: function() {
          return this.get(name);
        },
        set: function(value) {
          invariant(this.__ownerID, 'Cannot set on an immutable record.');
          this.set(name, value);
        },
      });
    } catch (error) {
      // Object.defineProperty failed. Probably IE8.
    }
  }

  /**
   * Returns a lazy Seq of `value` repeated `times` times. When `times` is
   * undefined, returns an infinite sequence of `value`.
   */
  var Repeat = (function (IndexedSeq$$1) {
    function Repeat(value, times) {
      if (!(this instanceof Repeat)) {
        return new Repeat(value, times);
      }
      this._value = value;
      this.size = times === undefined ? Infinity : Math.max(0, times);
      if (this.size === 0) {
        if (EMPTY_REPEAT) {
          return EMPTY_REPEAT;
        }
        EMPTY_REPEAT = this;
      }
    }

    if ( IndexedSeq$$1 ) Repeat.__proto__ = IndexedSeq$$1;
    Repeat.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );
    Repeat.prototype.constructor = Repeat;

    Repeat.prototype.toString = function toString () {
      if (this.size === 0) {
        return 'Repeat []';
      }
      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
    };

    Repeat.prototype.get = function get (index, notSetValue) {
      return this.has(index) ? this._value : notSetValue;
    };

    Repeat.prototype.includes = function includes (searchValue) {
      return is(this._value, searchValue);
    };

    Repeat.prototype.slice = function slice (begin, end) {
      var size = this.size;
      return wholeSlice(begin, end, size)
        ? this
        : new Repeat(
            this._value,
            resolveEnd(end, size) - resolveBegin(begin, size)
          );
    };

    Repeat.prototype.reverse = function reverse () {
      return this;
    };

    Repeat.prototype.indexOf = function indexOf (searchValue) {
      if (is(this._value, searchValue)) {
        return 0;
      }
      return -1;
    };

    Repeat.prototype.lastIndexOf = function lastIndexOf (searchValue) {
      if (is(this._value, searchValue)) {
        return this.size;
      }
      return -1;
    };

    Repeat.prototype.__iterate = function __iterate (fn, reverse) {
      var this$1 = this;

      var size = this.size;
      var i = 0;
      while (i !== size) {
        if (fn(this$1._value, reverse ? size - ++i : i++, this$1) === false) {
          break;
        }
      }
      return i;
    };

    Repeat.prototype.__iterator = function __iterator (type, reverse) {
      var this$1 = this;

      var size = this.size;
      var i = 0;
      return new Iterator(
        function () { return i === size
            ? iteratorDone()
            : iteratorValue(type, reverse ? size - ++i : i++, this$1._value); }
      );
    };

    Repeat.prototype.equals = function equals (other) {
      return other instanceof Repeat
        ? is(this._value, other._value)
        : deepEqual(other);
    };

    return Repeat;
  }(IndexedSeq));

  var EMPTY_REPEAT;

  function fromJS(value, converter) {
    return fromJSWith(
      [],
      converter || defaultConverter,
      value,
      '',
      converter && converter.length > 2 ? [] : undefined,
      { '': value }
    );
  }

  function fromJSWith(stack, converter, value, key, keyPath, parentValue) {
    var toSeq = Array.isArray(value)
      ? IndexedSeq
      : isPlainObj(value)
        ? KeyedSeq
        : null;
    if (toSeq) {
      if (~stack.indexOf(value)) {
        throw new TypeError('Cannot convert circular structure to Immutable');
      }
      stack.push(value);
      keyPath && key !== '' && keyPath.push(key);
      var converted = converter.call(
        parentValue,
        key,
        toSeq(value).map(function (v, k) { return fromJSWith(stack, converter, v, k, keyPath, value); }
        ),
        keyPath && keyPath.slice()
      );
      stack.pop();
      keyPath && keyPath.pop();
      return converted;
    }
    return value;
  }

  function defaultConverter(k, v) {
    return isKeyed(v) ? v.toMap() : v.toList();
  }

  var version = "4.0.0-rc.10";

  var Immutable = {
    version: version,

    Collection: Collection,
    // Note: Iterable is deprecated
    Iterable: Collection,

    Seq: Seq,
    Map: Map,
    OrderedMap: OrderedMap,
    List: List,
    Stack: Stack,
    Set: Set,
    OrderedSet: OrderedSet,

    Record: Record,
    Range: Range,
    Repeat: Repeat,

    is: is,
    fromJS: fromJS,
    hash: hash,

    isImmutable: isImmutable,
    isCollection: isCollection,
    isKeyed: isKeyed,
    isIndexed: isIndexed,
    isAssociative: isAssociative,
    isOrdered: isOrdered,
    isValueObject: isValueObject,
    isSeq: isSeq,
    isList: isList,
    isMap: isMap,
    isOrderedMap: isOrderedMap,
    isStack: isStack,
    isSet: isSet,
    isOrderedSet: isOrderedSet,
    isRecord: isRecord,

    get: get,
    getIn: getIn,
    has: has,
    hasIn: hasIn,
    merge: merge$1,
    mergeDeep: mergeDeep,
    mergeWith: mergeWith$1,
    mergeDeepWith: mergeDeepWith,
    remove: remove,
    removeIn: removeIn,
    set: set,
    setIn: setIn,
    update: update,
    updateIn: updateIn,
  };

  // Note: Iterable is deprecated
  var Iterable = Collection;

  exports.default = Immutable;
  exports.version = version;
  exports.Collection = Collection;
  exports.Iterable = Iterable;
  exports.Seq = Seq;
  exports.Map = Map;
  exports.OrderedMap = OrderedMap;
  exports.List = List;
  exports.Stack = Stack;
  exports.Set = Set;
  exports.OrderedSet = OrderedSet;
  exports.Record = Record;
  exports.Range = Range;
  exports.Repeat = Repeat;
  exports.is = is;
  exports.fromJS = fromJS;
  exports.hash = hash;
  exports.isImmutable = isImmutable;
  exports.isCollection = isCollection;
  exports.isKeyed = isKeyed;
  exports.isIndexed = isIndexed;
  exports.isAssociative = isAssociative;
  exports.isOrdered = isOrdered;
  exports.isValueObject = isValueObject;
  exports.get = get;
  exports.getIn = getIn;
  exports.has = has;
  exports.hasIn = hasIn;
  exports.merge = merge$1;
  exports.mergeDeep = mergeDeep;
  exports.mergeWith = mergeWith$1;
  exports.mergeDeepWith = mergeDeepWith;
  exports.remove = remove;
  exports.removeIn = removeIn;
  exports.set = set;
  exports.setIn = setIn;
  exports.update = update;
  exports.updateIn = updateIn;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],106:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

}).call(this,require('_process'))

},{"_process":128}],107:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = chain;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _ensureIterable = _interopRequireDefault(require("./internal/ensure-iterable"));

var _marked =
/*#__PURE__*/
_regenerator.default.mark(chain);

function chain() {
  var _len,
      arrayOfIter,
      _key,
      _i,
      iterable,
      _args = arguments;

  return _regenerator.default.wrap(function chain$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          for (_len = _args.length, arrayOfIter = new Array(_len), _key = 0; _key < _len; _key++) {
            arrayOfIter[_key] = _args[_key];
          }

          _i = 0;

        case 2:
          if (!(_i < arrayOfIter.length)) {
            _context.next = 8;
            break;
          }

          iterable = arrayOfIter[_i];
          return _context.delegateYield((0, _ensureIterable.default)(iterable), "t0", 5);

        case 5:
          _i++;
          _context.next = 2;
          break;

        case 8:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this);
}

module.exports = exports["default"];
},{"./internal/ensure-iterable":114,"@babel/runtime-corejs2/helpers/interopRequireDefault":9,"@babel/runtime-corejs2/regenerator":11}],108:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = compose;

function compose() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return fns.reduce(function (f, g) {
    return function () {
      return f(g.apply(void 0, arguments));
    };
  });
}

module.exports = exports["default"];
},{}],109:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _chain = _interopRequireDefault(require("./chain"));

var _default = _chain.default;
exports.default = _default;
module.exports = exports["default"];
},{"./chain":107,"@babel/runtime-corejs2/helpers/interopRequireDefault":9}],110:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = entries;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/typeof"));

var _getIterator2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/get-iterator"));

var _marked =
/*#__PURE__*/
_regenerator.default.mark(entries);

var emptyArr = [];

function entries(entriesable) {
  var key;
  return _regenerator.default.wrap(function entries$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (!(entriesable == null)) {
            _context.next = 4;
            break;
          }

          return _context.abrupt("return", (0, _getIterator2.default)(emptyArr));

        case 4:
          if (!(typeof entriesable.entries === 'function')) {
            _context.next = 8;
            break;
          }

          return _context.delegateYield(entriesable.entries(), "t0", 6);

        case 6:
          _context.next = 17;
          break;

        case 8:
          if (!((0, _typeof2.default)(entriesable) === 'object')) {
            _context.next = 17;
            break;
          }

          _context.t1 = _regenerator.default.keys(entriesable);

        case 10:
          if ((_context.t2 = _context.t1()).done) {
            _context.next = 17;
            break;
          }

          key = _context.t2.value;

          if (!entriesable.hasOwnProperty(key)) {
            _context.next = 15;
            break;
          }

          _context.next = 15;
          return [key, entriesable[key]];

        case 15:
          _context.next = 10;
          break;

        case 17:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this);
}

module.exports = exports["default"];
},{"@babel/runtime-corejs2/core-js/get-iterator":3,"@babel/runtime-corejs2/helpers/interopRequireDefault":9,"@babel/runtime-corejs2/helpers/typeof":10,"@babel/runtime-corejs2/regenerator":11}],111:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = curriedFilter;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _getIterator2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/get-iterator"));

var _ensureIterable = _interopRequireDefault(require("./internal/ensure-iterable"));

var _marked =
/*#__PURE__*/
_regenerator.default.mark(filter);

function filter(func, iterable) {
  var c, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, item;

  return _regenerator.default.wrap(function filter$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          c = 0;
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context.prev = 4;
          _iterator = (0, _getIterator2.default)((0, _ensureIterable.default)(iterable));

        case 6:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context.next = 14;
            break;
          }

          item = _step.value;

          if (!func(item, c++)) {
            _context.next = 11;
            break;
          }

          _context.next = 11;
          return item;

        case 11:
          _iteratorNormalCompletion = true;
          _context.next = 6;
          break;

        case 14:
          _context.next = 20;
          break;

        case 16:
          _context.prev = 16;
          _context.t0 = _context["catch"](4);
          _didIteratorError = true;
          _iteratorError = _context.t0;

        case 20:
          _context.prev = 20;
          _context.prev = 21;

          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }

        case 23:
          _context.prev = 23;

          if (!_didIteratorError) {
            _context.next = 26;
            break;
          }

          throw _iteratorError;

        case 26:
          return _context.finish(23);

        case 27:
          return _context.finish(20);

        case 28:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this, [[4, 16, 20, 28], [21,, 23, 27]]);
}

function curriedFilter(func, iterable) {
  if (arguments.length === 1) {
    return function (iterable) {
      return filter(func, iterable);
    };
  }

  return filter(func, iterable);
}

module.exports = exports["default"];
},{"./internal/ensure-iterable":114,"@babel/runtime-corejs2/core-js/get-iterator":3,"@babel/runtime-corejs2/helpers/interopRequireDefault":9,"@babel/runtime-corejs2/regenerator":11}],112:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = curriedFlat;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _getIterator2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/get-iterator"));

var _iterator2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/symbol/iterator"));

var _ensureIterable = _interopRequireDefault(require("./internal/ensure-iterable"));

var defaultShouldIFlat = function defaultShouldIFlat(depth) {
  if (typeof depth === 'function') {
    return depth;
  }

  if (typeof depth === 'number') {
    return function (currentDepth, iter) {
      return currentDepth <= depth && typeof iter[_iterator2.default] === 'function' && typeof iter !== 'string';
    };
  }

  throw new Error('flat: "depth" can be a function or a number');
};

function flat(shouldIFlat, iterable) {
  var _marked =
  /*#__PURE__*/
  _regenerator.default.mark(_flat);

  function _flat(currentDepth, iterable) {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, iter;

    return _regenerator.default.wrap(function _flat$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!shouldIFlat(currentDepth, iterable)) {
              _context.next = 28;
              break;
            }

            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            _context.prev = 4;
            _iterator = (0, _getIterator2.default)(iterable);

          case 6:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              _context.next = 12;
              break;
            }

            iter = _step.value;
            return _context.delegateYield(_flat(currentDepth + 1, iter), "t0", 9);

          case 9:
            _iteratorNormalCompletion = true;
            _context.next = 6;
            break;

          case 12:
            _context.next = 18;
            break;

          case 14:
            _context.prev = 14;
            _context.t1 = _context["catch"](4);
            _didIteratorError = true;
            _iteratorError = _context.t1;

          case 18:
            _context.prev = 18;
            _context.prev = 19;

            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }

          case 21:
            _context.prev = 21;

            if (!_didIteratorError) {
              _context.next = 24;
              break;
            }

            throw _iteratorError;

          case 24:
            return _context.finish(21);

          case 25:
            return _context.finish(18);

          case 26:
            _context.next = 30;
            break;

          case 28:
            _context.next = 30;
            return iterable;

          case 30:
          case "end":
            return _context.stop();
        }
      }
    }, _marked, this, [[4, 14, 18, 26], [19,, 21, 25]]);
  }

  return _flat(0, (0, _ensureIterable.default)(iterable));
}

function curriedFlat() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (args.length === 0) {
    return function (iterable) {
      return flat(defaultShouldIFlat(1), iterable);
    };
  } else if (args.length === 1) {
    if (typeof args[0][_iterator2.default] === 'function') {
      return flat(defaultShouldIFlat(1), args[0]);
    } else {
      return function (iterable) {
        return flat(defaultShouldIFlat(args[0]), iterable);
      };
    }
  } else {
    return flat(defaultShouldIFlat(args[0]), args[1]);
  }
}

module.exports = exports["default"];
},{"./internal/ensure-iterable":114,"@babel/runtime-corejs2/core-js/get-iterator":3,"@babel/runtime-corejs2/core-js/symbol/iterator":6,"@babel/runtime-corejs2/helpers/interopRequireDefault":9,"@babel/runtime-corejs2/regenerator":11}],113:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _iterator = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/symbol/iterator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var CircularBuffer =
/*#__PURE__*/
function () {
  function CircularBuffer(size) {
    (0, _classCallCheck2.default)(this, CircularBuffer);
    this.array = new Array(size);
    this._size = size;
    this.counter = 0;
  }

  (0, _createClass2.default)(CircularBuffer, [{
    key: "push",
    value: function push(newItem) {
      this.counter++;
      var index = this.counter % this._size;
      var currentItem = this.array[index];
      this.array[index] = newItem;
      return currentItem;
    }
  }, {
    key: _iterator.default,
    value:
    /*#__PURE__*/
    _regenerator.default.mark(function value() {
      var counter, i;
      return _regenerator.default.wrap(function value$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              counter = this.counter;
              i = 0;

            case 2:
              if (!(i < this._size)) {
                _context.next = 9;
                break;
              }

              counter++;
              _context.next = 6;
              return this.array[counter % this._size];

            case 6:
              i++;
              _context.next = 2;
              break;

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, value, this);
    })
  }]);
  return CircularBuffer;
}();

exports.default = CircularBuffer;
module.exports = exports["default"];
},{"@babel/runtime-corejs2/core-js/symbol/iterator":6,"@babel/runtime-corejs2/helpers/classCallCheck":7,"@babel/runtime-corejs2/helpers/createClass":8,"@babel/runtime-corejs2/helpers/interopRequireDefault":9,"@babel/runtime-corejs2/regenerator":11}],114:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ensureIterable;

var _iterator = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/symbol/iterator"));

var _getIterator2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/get-iterator"));

var emptyArr = [];

function ensureIterable(i) {
  if (i == null) {
    return (0, _getIterator2.default)(emptyArr);
  } else if (!i[_iterator.default]) {
    if (typeof i.next === 'function') {
      throw new TypeError('Iterators are not supported arguments to iter-tools. You must wrap them using the `iterable` method.');
    }

    throw new TypeError('The argument is not an iterable or null');
  }

  return i;
}

module.exports = exports["default"];
},{"@babel/runtime-corejs2/core-js/get-iterator":3,"@babel/runtime-corejs2/core-js/symbol/iterator":6,"@babel/runtime-corejs2/helpers/interopRequireDefault":9}],115:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = curriedInterpose;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _getIterator2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/get-iterator"));

var _ensureIterable = _interopRequireDefault(require("./internal/ensure-iterable"));

var _marked =
/*#__PURE__*/
_regenerator.default.mark(interpose);

function interpose(interposeItem, iterable) {
  var first, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, item;

  return _regenerator.default.wrap(function interpose$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          first = true;
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context.prev = 4;
          _iterator = (0, _getIterator2.default)((0, _ensureIterable.default)(iterable));

        case 6:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context.next = 17;
            break;
          }

          item = _step.value;

          if (first) {
            _context.next = 11;
            break;
          }

          _context.next = 11;
          return interposeItem;

        case 11:
          _context.next = 13;
          return item;

        case 13:
          first = false;

        case 14:
          _iteratorNormalCompletion = true;
          _context.next = 6;
          break;

        case 17:
          _context.next = 23;
          break;

        case 19:
          _context.prev = 19;
          _context.t0 = _context["catch"](4);
          _didIteratorError = true;
          _iteratorError = _context.t0;

        case 23:
          _context.prev = 23;
          _context.prev = 24;

          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }

        case 26:
          _context.prev = 26;

          if (!_didIteratorError) {
            _context.next = 29;
            break;
          }

          throw _iteratorError;

        case 29:
          return _context.finish(26);

        case 30:
          return _context.finish(23);

        case 31:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this, [[4, 19, 23, 31], [24,, 26, 30]]);
}

function curriedInterpose(interposeItem, iterable) {
  if (arguments.length === 1) {
    return function (iterable) {
      return interpose(interposeItem, iterable);
    };
  }

  return interpose(interposeItem, iterable);
}

module.exports = exports["default"];
},{"./internal/ensure-iterable":114,"@babel/runtime-corejs2/core-js/get-iterator":3,"@babel/runtime-corejs2/helpers/interopRequireDefault":9,"@babel/runtime-corejs2/regenerator":11}],116:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = keys;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/typeof"));

var _getIterator2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/get-iterator"));

var _marked =
/*#__PURE__*/
_regenerator.default.mark(keys);

var emptyArr = [];

function keys(keysable) {
  var key;
  return _regenerator.default.wrap(function keys$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (!(keysable == null)) {
            _context.next = 4;
            break;
          }

          return _context.abrupt("return", (0, _getIterator2.default)(emptyArr));

        case 4:
          if (!(typeof keysable.keys === 'function')) {
            _context.next = 8;
            break;
          }

          return _context.delegateYield(keysable.keys(), "t0", 6);

        case 6:
          _context.next = 17;
          break;

        case 8:
          if (!((0, _typeof2.default)(keysable) === 'object')) {
            _context.next = 17;
            break;
          }

          _context.t1 = _regenerator.default.keys(keysable);

        case 10:
          if ((_context.t2 = _context.t1()).done) {
            _context.next = 17;
            break;
          }

          key = _context.t2.value;

          if (!keysable.hasOwnProperty(key)) {
            _context.next = 15;
            break;
          }

          _context.next = 15;
          return key;

        case 15:
          _context.next = 10;
          break;

        case 17:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this);
}

module.exports = exports["default"];
},{"@babel/runtime-corejs2/core-js/get-iterator":3,"@babel/runtime-corejs2/helpers/interopRequireDefault":9,"@babel/runtime-corejs2/helpers/typeof":10,"@babel/runtime-corejs2/regenerator":11}],117:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = curriedMap;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _getIterator2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/get-iterator"));

var _ensureIterable = _interopRequireDefault(require("./internal/ensure-iterable"));

var _marked =
/*#__PURE__*/
_regenerator.default.mark(map);

function map(func, iterable) {
  var c, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, item;

  return _regenerator.default.wrap(function map$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          c = 0;
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context.prev = 4;
          _iterator = (0, _getIterator2.default)((0, _ensureIterable.default)(iterable));

        case 6:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context.next = 13;
            break;
          }

          item = _step.value;
          _context.next = 10;
          return func(item, c++);

        case 10:
          _iteratorNormalCompletion = true;
          _context.next = 6;
          break;

        case 13:
          _context.next = 19;
          break;

        case 15:
          _context.prev = 15;
          _context.t0 = _context["catch"](4);
          _didIteratorError = true;
          _iteratorError = _context.t0;

        case 19:
          _context.prev = 19;
          _context.prev = 20;

          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }

        case 22:
          _context.prev = 22;

          if (!_didIteratorError) {
            _context.next = 25;
            break;
          }

          throw _iteratorError;

        case 25:
          return _context.finish(22);

        case 26:
          return _context.finish(19);

        case 27:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this, [[4, 15, 19, 27], [20,, 22, 26]]);
}

function curriedMap(func, iterable) {
  if (arguments.length === 1) {
    return function (iterable) {
      return map(func, iterable);
    };
  }

  return map(func, iterable);
}

module.exports = exports["default"];
},{"./internal/ensure-iterable":114,"@babel/runtime-corejs2/core-js/get-iterator":3,"@babel/runtime-corejs2/helpers/interopRequireDefault":9,"@babel/runtime-corejs2/regenerator":11}],118:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = range;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/typeof"));

var _marked =
/*#__PURE__*/
_regenerator.default.mark(range);

function range(opts) {
  var start, step, end, i;
  return _regenerator.default.wrap(function range$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          opts = typeof opts === 'number' ? {
            end: opts,
            start: 0
          } : (0, _typeof2.default)(opts) === 'object' ? opts : {};
          step = typeof opts.step === 'undefined' ? 1 : opts.step;
          end = typeof opts.end === 'undefined' ? step > 0 ? Infinity : -Infinity : opts.end;
          start = opts.start ? opts.start : 0;
          i = start;

        case 5:
          if (!(step > 0 ? i < end : i > end)) {
            _context.next = 11;
            break;
          }

          _context.next = 8;
          return i;

        case 8:
          i += step;
          _context.next = 5;
          break;

        case 11:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this);
}

module.exports = exports["default"];
},{"@babel/runtime-corejs2/helpers/interopRequireDefault":9,"@babel/runtime-corejs2/helpers/typeof":10,"@babel/runtime-corejs2/regenerator":11}],119:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = curriedReduce;

var _iterator = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/symbol/iterator"));

var _getIterator2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/get-iterator"));

var _ensureIterable = _interopRequireDefault(require("./internal/ensure-iterable"));

function reduce(initial, func, iterable) {
  var c = 0;
  var acc = initial;
  var iterator = (0, _getIterator2.default)((0, _ensureIterable.default)(iterable));

  try {
    if (initial === undefined) {
      var firstResult = iterator.next();

      if (firstResult.done) {
        throw new Error('Cannot reduce: no initial value specified and iterable was empty');
      }

      acc = firstResult.value;
      c = 1;
    }

    var result;

    while (!(result = iterator.next()).done) {
      acc = func(acc, result.value, c++);
    }

    return acc;
  } finally {
    // close the iterable in case of exceptions
    if (typeof iterable.return === 'function') iterable.return();
  }
}

function curriedReduce(initial, func, iterable) {
  // is this complete? has an iterable been specified? (func can never be iterable)
  //    is there an iterable that comes after func
  //    work backwards from there
  var hasIterable = false;

  if (arguments.length === 1) {
    func = initial;
    initial = undefined;
  } else if (arguments.length === 2 && (func == null || func[_iterator.default])) {
    iterable = func;
    func = initial;
    initial = undefined;
    hasIterable = true;
  } else if (arguments.length === 3) {
    hasIterable = true;
  }

  if (!hasIterable) {
    return function (iterable) {
      return reduce(initial, func, iterable);
    };
  }

  return reduce(initial, func, iterable);
}

module.exports = exports["default"];
},{"./internal/ensure-iterable":114,"@babel/runtime-corejs2/core-js/get-iterator":3,"@babel/runtime-corejs2/core-js/symbol/iterator":6,"@babel/runtime-corejs2/helpers/interopRequireDefault":9}],120:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = repeat;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _marked =
/*#__PURE__*/
_regenerator.default.mark(repeat);

function repeat(obj) {
  var times,
      _args = arguments;
  return _regenerator.default.wrap(function repeat$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          times = _args.length > 1 && _args[1] !== undefined ? _args[1] : Infinity;

        case 1:
          if (!times--) {
            _context.next = 6;
            break;
          }

          _context.next = 4;
          return obj;

        case 4:
          _context.next = 1;
          break;

        case 6:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this);
}

module.exports = exports["default"];
},{"@babel/runtime-corejs2/helpers/interopRequireDefault":9,"@babel/runtime-corejs2/regenerator":11}],121:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = size;

var _getIterator2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/get-iterator"));

var _ensureIterable = _interopRequireDefault(require("./internal/ensure-iterable"));

function size(iterable) {
  var size = 0; // eslint-disable-next-line

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator2.default)((0, _ensureIterable.default)(iterable)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _ = _step.value;
      size++;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return size;
}

module.exports = exports["default"];
},{"./internal/ensure-iterable":114,"@babel/runtime-corejs2/core-js/get-iterator":3,"@babel/runtime-corejs2/helpers/interopRequireDefault":9}],122:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = curriedSlice;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _getIterator2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/get-iterator"));

var _circularBuffer = _interopRequireDefault(require("./internal/circular-buffer"));

var _ensureIterable = _interopRequireDefault(require("./internal/ensure-iterable"));

var _marked =
/*#__PURE__*/
_regenerator.default.mark(simpleSlice),
    _marked2 =
/*#__PURE__*/
_regenerator.default.mark(slice);

function bufferedSlice(iterable, start, end, step) {
  var bufferSize = Math.abs(start);
  var buffer = new _circularBuffer.default(bufferSize);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator2.default)(iterable), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var item = _step.value;
      buffer.push(item);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var newEnd;

  if (isFinite(end) && end > 0) {
    newEnd = end - (buffer.counter - bufferSize);
    if (newEnd < 0) return [];
  } else {
    newEnd = end;
  }

  return simpleSlice(buffer, 0, newEnd, step);
}

function simpleSlice(iterable, start, end, step) {
  var currentPos, nextValidPos, bufferSize, buffer, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, item;

  return _regenerator.default.wrap(function simpleSlice$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          currentPos = 0;
          nextValidPos = start;
          bufferSize = Math.abs(end);

          if (end < 0) {
            buffer = new _circularBuffer.default(bufferSize);
          }

          _iteratorNormalCompletion2 = true;
          _didIteratorError2 = false;
          _iteratorError2 = undefined;
          _context.prev = 7;
          _iterator2 = (0, _getIterator2.default)(iterable);

        case 9:
          if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
            _context.next = 25;
            break;
          }

          item = _step2.value;

          if (!buffer) {
            _context.next = 15;
            break;
          }

          item = buffer.push(item);

          if (!(buffer.counter <= bufferSize)) {
            _context.next = 15;
            break;
          }

          return _context.abrupt("continue", 22);

        case 15:
          if (!(currentPos >= end && end >= 0)) {
            _context.next = 17;
            break;
          }

          return _context.abrupt("break", 25);

        case 17:
          if (!(nextValidPos === currentPos)) {
            _context.next = 21;
            break;
          }

          _context.next = 20;
          return item;

        case 20:
          nextValidPos += step;

        case 21:
          currentPos++;

        case 22:
          _iteratorNormalCompletion2 = true;
          _context.next = 9;
          break;

        case 25:
          _context.next = 31;
          break;

        case 27:
          _context.prev = 27;
          _context.t0 = _context["catch"](7);
          _didIteratorError2 = true;
          _iteratorError2 = _context.t0;

        case 31:
          _context.prev = 31;
          _context.prev = 32;

          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }

        case 34:
          _context.prev = 34;

          if (!_didIteratorError2) {
            _context.next = 37;
            break;
          }

          throw _iteratorError2;

        case 37:
          return _context.finish(34);

        case 38:
          return _context.finish(31);

        case 39:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this, [[7, 27, 31, 39], [32,, 34, 38]]);
}

function slice(opts, iterable) {
  var start, step, end;
  return _regenerator.default.wrap(function slice$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          opts = typeof opts === 'number' ? {
            end: opts,
            start: 0
          } : opts;
          step = typeof opts.step === 'undefined' ? 1 : opts.step;
          end = typeof opts.end === 'undefined' ? Infinity : opts.end;
          start = opts.start ? opts.start : 0;
          iterable = (0, _ensureIterable.default)(iterable);

          if (!(step <= 0)) {
            _context2.next = 7;
            break;
          }

          throw new TypeError('Cannot slice with step <= 0');

        case 7:
          if (!(start >= 0)) {
            _context2.next = 11;
            break;
          }

          return _context2.delegateYield(simpleSlice(iterable, start, end, step), "t0", 9);

        case 9:
          _context2.next = 12;
          break;

        case 11:
          return _context2.delegateYield(bufferedSlice(iterable, start, end, step), "t1", 12);

        case 12:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2, this);
}

function curriedSlice(opts, iterable) {
  if (arguments.length === 1) {
    return function (iterable) {
      return slice(opts, iterable);
    };
  }

  return slice(opts, iterable);
}

module.exports = exports["default"];
},{"./internal/circular-buffer":113,"./internal/ensure-iterable":114,"@babel/runtime-corejs2/core-js/get-iterator":3,"@babel/runtime-corejs2/helpers/interopRequireDefault":9,"@babel/runtime-corejs2/regenerator":11}],123:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = curriedTap;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _getIterator2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/get-iterator"));

var _ensureIterable = _interopRequireDefault(require("./internal/ensure-iterable"));

var _marked =
/*#__PURE__*/
_regenerator.default.mark(tap);

function tap(func, iterable) {
  var c, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, item;

  return _regenerator.default.wrap(function tap$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          c = 0;
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context.prev = 4;
          _iterator = (0, _getIterator2.default)((0, _ensureIterable.default)(iterable));

        case 6:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context.next = 14;
            break;
          }

          item = _step.value;
          func(item, c++);
          _context.next = 11;
          return item;

        case 11:
          _iteratorNormalCompletion = true;
          _context.next = 6;
          break;

        case 14:
          _context.next = 20;
          break;

        case 16:
          _context.prev = 16;
          _context.t0 = _context["catch"](4);
          _didIteratorError = true;
          _iteratorError = _context.t0;

        case 20:
          _context.prev = 20;
          _context.prev = 21;

          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }

        case 23:
          _context.prev = 23;

          if (!_didIteratorError) {
            _context.next = 26;
            break;
          }

          throw _iteratorError;

        case 26:
          return _context.finish(23);

        case 27:
          return _context.finish(20);

        case 28:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this, [[4, 16, 20, 28], [21,, 23, 27]]);
}

function curriedTap(func, iterable) {
  if (arguments.length === 1) {
    return function (iterable) {
      return tap(func, iterable);
    };
  }

  return tap(func, iterable);
}

module.exports = exports["default"];
},{"./internal/ensure-iterable":114,"@babel/runtime-corejs2/core-js/get-iterator":3,"@babel/runtime-corejs2/helpers/interopRequireDefault":9,"@babel/runtime-corejs2/regenerator":11}],124:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _zipLongest = _interopRequireDefault(require("./zip-longest"));

var _default = _zipLongest.default;
exports.default = _default;
module.exports = exports["default"];
},{"./zip-longest":125,"@babel/runtime-corejs2/helpers/interopRequireDefault":9}],125:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = zipLongest;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _getIterator2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/get-iterator"));

var _ensureIterable = _interopRequireDefault(require("./internal/ensure-iterable"));

var _marked =
/*#__PURE__*/
_regenerator.default.mark(zipLongest);

function zipLongest() {
  var _len,
      iterables,
      _key,
      iters,
      numberOfExhausted,
      zipped,
      i,
      _iteratorNormalCompletion,
      _didIteratorError,
      _iteratorError,
      _iterator,
      _step,
      iter,
      _iter$next,
      done,
      value,
      _iteratorNormalCompletion2,
      _didIteratorError2,
      _iteratorError2,
      _iterator2,
      _step2,
      _iter,
      _args = arguments;

  return _regenerator.default.wrap(function zipLongest$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          for (_len = _args.length, iterables = new Array(_len), _key = 0; _key < _len; _key++) {
            iterables[_key] = _args[_key];
          }

          iters = iterables.map(function (i) {
            return (0, _getIterator2.default)((0, _ensureIterable.default)(i));
          });
          _context.prev = 2;

        case 3:
          if (!true) {
            _context.next = 32;
            break;
          }

          numberOfExhausted = 0;
          zipped = new Array(iterables.length);
          i = 0;
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context.prev = 10;

          for (_iterator = (0, _getIterator2.default)(iters); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            iter = _step.value;
            _iter$next = iter.next(), done = _iter$next.done, value = _iter$next.value;

            if (done) {
              numberOfExhausted++;
            }

            zipped[i++] = done ? undefined : value;
          }

          _context.next = 18;
          break;

        case 14:
          _context.prev = 14;
          _context.t0 = _context["catch"](10);
          _didIteratorError = true;
          _iteratorError = _context.t0;

        case 18:
          _context.prev = 18;
          _context.prev = 19;

          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }

        case 21:
          _context.prev = 21;

          if (!_didIteratorError) {
            _context.next = 24;
            break;
          }

          throw _iteratorError;

        case 24:
          return _context.finish(21);

        case 25:
          return _context.finish(18);

        case 26:
          if (!(iters.length === numberOfExhausted)) {
            _context.next = 28;
            break;
          }

          return _context.abrupt("return");

        case 28:
          _context.next = 30;
          return zipped;

        case 30:
          _context.next = 3;
          break;

        case 32:
          _context.prev = 32;
          _iteratorNormalCompletion2 = true;
          _didIteratorError2 = false;
          _iteratorError2 = undefined;
          _context.prev = 36;

          for (_iterator2 = (0, _getIterator2.default)(iters); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            _iter = _step2.value;
            if (typeof _iter.return === 'function') _iter.return();
          }

          _context.next = 44;
          break;

        case 40:
          _context.prev = 40;
          _context.t1 = _context["catch"](36);
          _didIteratorError2 = true;
          _iteratorError2 = _context.t1;

        case 44:
          _context.prev = 44;
          _context.prev = 45;

          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }

        case 47:
          _context.prev = 47;

          if (!_didIteratorError2) {
            _context.next = 50;
            break;
          }

          throw _iteratorError2;

        case 50:
          return _context.finish(47);

        case 51:
          return _context.finish(44);

        case 52:
          return _context.finish(32);

        case 53:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this, [[2,, 32, 53], [10, 14, 18, 26], [19,, 21, 25], [36, 40, 44, 52], [45,, 47, 51]]);
}

module.exports = exports["default"];
},{"./internal/ensure-iterable":114,"@babel/runtime-corejs2/core-js/get-iterator":3,"@babel/runtime-corejs2/helpers/interopRequireDefault":9,"@babel/runtime-corejs2/regenerator":11}],126:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = zip;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _getIterator2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/get-iterator"));

var _ensureIterable = _interopRequireDefault(require("./internal/ensure-iterable"));

var _marked =
/*#__PURE__*/
_regenerator.default.mark(zip);

function closeIterators(iters, except) {
  var c = 0;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator2.default)(iters), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var iter = _step.value;

      if (c === except) {
        c++;
        continue;
      }

      if (typeof iter.return === 'function') iter.return();
      c++;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

function zip() {
  var _len,
      iterables,
      _key,
      iters,
      zipped,
      i,
      c,
      _iteratorNormalCompletion2,
      _didIteratorError2,
      _iteratorError2,
      _iterator2,
      _step2,
      iter,
      _iter$next,
      done,
      value,
      _args = arguments;

  return _regenerator.default.wrap(function zip$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          for (_len = _args.length, iterables = new Array(_len), _key = 0; _key < _len; _key++) {
            iterables[_key] = _args[_key];
          }

          iters = iterables.map(function (i) {
            return (0, _getIterator2.default)((0, _ensureIterable.default)(i));
          });
          _context.prev = 2;

        case 3:
          if (!true) {
            _context.next = 41;
            break;
          }

          zipped = new Array(iterables.length);
          i = 0;
          c = 0;
          _iteratorNormalCompletion2 = true;
          _didIteratorError2 = false;
          _iteratorError2 = undefined;
          _context.prev = 10;
          _iterator2 = (0, _getIterator2.default)(iters);

        case 12:
          if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
            _context.next = 23;
            break;
          }

          iter = _step2.value;
          _iter$next = iter.next(), done = _iter$next.done, value = _iter$next.value;

          if (!done) {
            _context.next = 18;
            break;
          }

          closeIterators(iters, c); // clean up unfinished iterators

          return _context.abrupt("return");

        case 18:
          c++;
          zipped[i++] = value;

        case 20:
          _iteratorNormalCompletion2 = true;
          _context.next = 12;
          break;

        case 23:
          _context.next = 29;
          break;

        case 25:
          _context.prev = 25;
          _context.t0 = _context["catch"](10);
          _didIteratorError2 = true;
          _iteratorError2 = _context.t0;

        case 29:
          _context.prev = 29;
          _context.prev = 30;

          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }

        case 32:
          _context.prev = 32;

          if (!_didIteratorError2) {
            _context.next = 35;
            break;
          }

          throw _iteratorError2;

        case 35:
          return _context.finish(32);

        case 36:
          return _context.finish(29);

        case 37:
          _context.next = 39;
          return zipped;

        case 39:
          _context.next = 3;
          break;

        case 41:
          _context.prev = 41;
          closeIterators(iters);
          return _context.finish(41);

        case 44:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this, [[2,, 41, 44], [10, 25, 29, 37], [30,, 32, 36]]);
}

module.exports = exports["default"];
},{"./internal/ensure-iterable":114,"@babel/runtime-corejs2/core-js/get-iterator":3,"@babel/runtime-corejs2/helpers/interopRequireDefault":9,"@babel/runtime-corejs2/regenerator":11}],127:[function(require,module,exports){
(function (global){
/**
 * marked - a markdown parser
 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

;(function(root) {
'use strict';

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
  nptable: noop,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
  def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
  table: noop,
  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
  paragraph: /^([^\n]+(?:\n?(?!hr|heading|lheading| {0,3}>|tag)[^\n]+)+)/,
  text: /^[^\n]+/
};

block._label = /(?:\\[\[\]]|[^\[\]])+/;
block._title = /(?:"(?:\\"|[^"]|"[^"\n]*")*"|'\n?(?:[^'\n]+\n?)*'|\([^()]*\))/;
block.def = edit(block.def)
  .replace('label', block._label)
  .replace('title', block._title)
  .getRegex();

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = edit(block.item, 'gm')
  .replace(/bull/g, block.bullet)
  .getRegex();

block.list = edit(block.list)
  .replace(/bull/g, block.bullet)
  .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
  .replace('def', '\\n+(?=' + block.def.source + ')')
  .getRegex();

block._tag = '(?!(?:'
  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b';

block.html = edit(block.html)
  .replace('comment', /<!--[\s\S]*?-->/)
  .replace('closed', /<(tag)[\s\S]+?<\/\1>/)
  .replace('closing', /<tag(?:"[^"]*"|'[^']*'|\s[^'"\/>\s]*)*?\/?>/)
  .replace(/tag/g, block._tag)
  .getRegex();

block.paragraph = edit(block.paragraph)
  .replace('hr', block.hr)
  .replace('heading', block.heading)
  .replace('lheading', block.lheading)
  .replace('tag', '<' + block._tag)
  .getRegex();

block.blockquote = edit(block.blockquote)
  .replace('paragraph', block.paragraph)
  .getRegex();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\n? *\1 *(?:\n+|$)/,
  paragraph: /^/,
  heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
});

block.gfm.paragraph = edit(block.paragraph)
  .replace('(?!', '(?!'
    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
    + block.list.source.replace('\\1', '\\3') + '|')
  .getRegex();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = {};
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.gfm) {
    if (this.options.tables) {
      this.rules = block.tables;
    } else {
      this.rules = block.gfm;
    }
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top) {
  src = src.replace(/^ +$/gm, '');
  var next,
      loose,
      cap,
      bull,
      b,
      item,
      space,
      i,
      tag,
      l,
      isordered;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      this.tokens.push({
        type: 'code',
        text: !this.options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap
      });
      continue;
    }

    // fences (gfm)
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3] || ''
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (top && (cap = this.rules.nptable.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i].split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];
      isordered = bull.length > 1;

      this.tokens.push({
        type: 'list_start',
        ordered: isordered,
        start: isordered ? +bull : ''
      });

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (this.options.smartLists && i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        this.tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start'
        });

        // Recurse.
        this.token(item, false);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: !this.options.sanitizer
          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
        text: cap[0]
      });
      continue;
    }

    // def
    if (top && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
      tag = cap[1].toLowerCase();
      if (!this.tokens.links[tag]) {
        this.tokens.links[tag] = {
          href: cap[2],
          title: cap[3]
        };
      }
      continue;
    }

    // table (gfm)
    if (top && (cap = this.rules.table.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i]
          .replace(/^ *\| *| *\| *$/g, '')
          .split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noop,
  tag: /^<!--[\s\S]*?-->|^<\/?[a-zA-Z0-9\-]+(?:"[^"]*"|'[^']*'|\s[^<'">\/\s]*)*?\/?>/,
  link: /^!?\[(inside)\]\(href\)/,
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
  nolink: /^!?\[((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\]/,
  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
  em: /^_([^\s_](?:[^_]|__)+?[^\s_])_\b|^\*((?:\*\*|[^*])+?)\*(?!\*)/,
  code: /^(`+)\s*([\s\S]*?[^`]?)\s*\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  del: noop,
  text: /^[\s\S]+?(?=[\\<!\[`*]|\b_| {2,}\n|$)/
};

inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;

inline.autolink = edit(inline.autolink)
  .replace('scheme', inline._scheme)
  .replace('email', inline._email)
  .getRegex()

inline._inside = /(?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]]|\](?=[^\[]*\]))*/;
inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

inline.link = edit(inline.link)
  .replace('inside', inline._inside)
  .replace('href', inline._href)
  .getRegex();

inline.reflink = edit(inline.reflink)
  .replace('inside', inline._inside)
  .getRegex();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: edit(inline.escape).replace('])', '~|])').getRegex(),
  url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/)
    .replace('email', inline._email)
    .getRegex(),
  _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
  del: /^~~(?=\S)([\s\S]*?\S)~~/,
  text: edit(inline.text)
    .replace(']|', '~]|')
    .replace('|', '|https?://|ftp://|www\\.|[a-zA-Z0-9.!#$%&\'*+/=?^_`{\\|}~-]+@|')
    .getRegex()
});

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: edit(inline.br).replace('{2,}', '*').getRegex(),
  text: edit(inline.gfm.text).replace('{2,}', '*').getRegex()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;
  this.renderer = this.options.renderer || new Renderer();
  this.renderer.options = this.options;

  if (!this.links) {
    throw new Error('Tokens array requires a `links` property.');
  }

  if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  } else if (this.options.pedantic) {
    this.rules = inline.pedantic;
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = '',
      link,
      text,
      href,
      cap;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = escape(this.mangle(cap[1]));
        href = 'mailto:' + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // url (gfm)
    if (!this.inLink && (cap = this.rules.url.exec(src))) {
      cap[0] = this.rules._backpedal.exec(cap[0])[0];
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = escape(cap[0]);
        href = 'mailto:' + text;
      } else {
        text = escape(cap[0]);
        if (cap[1] === 'www.') {
          href = 'http://' + text;
        } else {
          href = text;
        }
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      if (!this.inLink && /^<a /i.test(cap[0])) {
        this.inLink = true;
      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
        this.inLink = false;
      }
      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? this.options.sanitizer
          ? this.options.sanitizer(cap[0])
          : escape(cap[0])
        : cap[0]
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      src = src.substring(cap[0].length);
      this.inLink = true;
      out += this.outputLink(cap, {
        href: cap[2],
        title: cap[3]
      });
      this.inLink = false;
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      this.inLink = true;
      out += this.outputLink(cap, link);
      this.inLink = false;
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.strong(this.output(cap[2] || cap[1]));
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.em(this.output(cap[2] || cap[1]));
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.codespan(escape(cap[2].trim(), true));
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.br();
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.del(this.output(cap[1]));
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.text(escape(this.smartypants(cap[0])));
      continue;
    }

    if (src) {
      throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  var href = escape(link.href),
      title = link.title ? escape(link.title) : null;

  return cap[0].charAt(0) !== '!'
    ? this.renderer.link(href, title, this.output(cap[1]))
    : this.renderer.image(href, title, escape(cap[1]));
};

/**
 * Smartypants Transformations
 */

InlineLexer.prototype.smartypants = function(text) {
  if (!this.options.smartypants) return text;
  return text
    // em-dashes
    .replace(/---/g, '\u2014')
    // en-dashes
    .replace(/--/g, '\u2013')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  if (!this.options.mangle) return text;
  var out = '',
      l = text.length,
      i = 0,
      ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Renderer
 */

function Renderer(options) {
  this.options = options || {};
}

Renderer.prototype.code = function(code, lang, escaped) {
  if (this.options.highlight) {
    var out = this.options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }

  if (!lang) {
    return '<pre><code>'
      + (escaped ? code : escape(code, true))
      + '\n</code></pre>';
  }

  return '<pre><code class="'
    + this.options.langPrefix
    + escape(lang, true)
    + '">'
    + (escaped ? code : escape(code, true))
    + '\n</code></pre>\n';
};

Renderer.prototype.blockquote = function(quote) {
  return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
  return html;
};

Renderer.prototype.heading = function(text, level, raw) {
  return '<h'
    + level
    + ' id="'
    + this.options.headerPrefix
    + raw.toLowerCase().replace(/[^\w]+/g, '-')
    + '">'
    + text
    + '</h'
    + level
    + '>\n';
};

Renderer.prototype.hr = function() {
  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
};

Renderer.prototype.list = function(body, ordered, start) {
  var type = ordered ? 'ol' : 'ul',
      startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
  return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
  return '<li>' + text + '</li>\n';
};

Renderer.prototype.paragraph = function(text) {
  return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
  return '<table>\n'
    + '<thead>\n'
    + header
    + '</thead>\n'
    + '<tbody>\n'
    + body
    + '</tbody>\n'
    + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
  return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
  var type = flags.header ? 'th' : 'td';
  var tag = flags.align
    ? '<' + type + ' style="text-align:' + flags.align + '">'
    : '<' + type + '>';
  return tag + content + '</' + type + '>\n';
};

// span level renderer
Renderer.prototype.strong = function(text) {
  return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
  return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
  return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
  return this.options.xhtml ? '<br/>' : '<br>';
};

Renderer.prototype.del = function(text) {
  return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
  if (this.options.sanitize) {
    try {
      var prot = decodeURIComponent(unescape(href))
        .replace(/[^\w:]/g, '')
        .toLowerCase();
    } catch (e) {
      return text;
    }
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
      return text;
    }
  }
  if (this.options.baseUrl && !originIndependentUrl.test(href)) {
    href = resolveUrl(this.options.baseUrl, href);
  }
  var out = '<a href="' + href + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>' + text + '</a>';
  return out;
};

Renderer.prototype.image = function(href, title, text) {
  if (this.options.baseUrl && !originIndependentUrl.test(href)) {
    href = resolveUrl(this.options.baseUrl, href);
  }
  var out = '<img src="' + href + '" alt="' + text + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += this.options.xhtml ? '/>' : '>';
  return out;
};

Renderer.prototype.text = function(text) {
  return text;
};

/**
 * TextRenderer
 * returns only the textual part of the token
 */

function TextRenderer() {}

// no need for block level renderers

TextRenderer.prototype.strong =
TextRenderer.prototype.em =
TextRenderer.prototype.codespan =
TextRenderer.prototype.del =
TextRenderer.prototype.text = function (text) {
  return text;
}

TextRenderer.prototype.link =
TextRenderer.prototype.image = function(href, title, text) {
  return '' + text;
}

TextRenderer.prototype.br = function() {
  return '';
}

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
  this.options.renderer = this.options.renderer || new Renderer();
  this.renderer = this.options.renderer;
  this.renderer.options = this.options;
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options) {
  var parser = new Parser(options);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options);
  // use an InlineLexer with a TextRenderer to extract pure text
  this.inlineText = new InlineLexer(
    src.links,
    merge({}, this.options, {renderer: new TextRenderer()})
  );
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  return this.token = this.tokens.pop();
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return this.renderer.hr();
    }
    case 'heading': {
      return this.renderer.heading(
        this.inline.output(this.token.text),
        this.token.depth,
        unescape(this.inlineText.output(this.token.text)));
    }
    case 'code': {
      return this.renderer.code(this.token.text,
        this.token.lang,
        this.token.escaped);
    }
    case 'table': {
      var header = '',
          body = '',
          i,
          row,
          cell,
          j;

      // header
      cell = '';
      for (i = 0; i < this.token.header.length; i++) {
        cell += this.renderer.tablecell(
          this.inline.output(this.token.header[i]),
          { header: true, align: this.token.align[i] }
        );
      }
      header += this.renderer.tablerow(cell);

      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];

        cell = '';
        for (j = 0; j < row.length; j++) {
          cell += this.renderer.tablecell(
            this.inline.output(row[j]),
            { header: false, align: this.token.align[j] }
          );
        }

        body += this.renderer.tablerow(cell);
      }
      return this.renderer.table(header, body);
    }
    case 'blockquote_start': {
      body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return this.renderer.blockquote(body);
    }
    case 'list_start': {
      body = '';
      var ordered = this.token.ordered,
          start = this.token.start;

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return this.renderer.list(body, ordered, start);
    }
    case 'list_item_start': {
      body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'loose_item_start': {
      body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'html': {
      var html = !this.token.pre && !this.options.pedantic
        ? this.inline.output(this.token.text)
        : this.token.text;
      return this.renderer.html(html);
    }
    case 'paragraph': {
      return this.renderer.paragraph(this.inline.output(this.token.text));
    }
    case 'text': {
      return this.renderer.paragraph(this.parseText());
    }
  }
};

/**
 * Helpers
 */

function escape(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function unescape(html) {
  // explicitly match decimal, hex, and named HTML entities
  return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, function(_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

function edit(regex, opt) {
  regex = regex.source;
  opt = opt || '';
  return {
    replace: function(name, val) {
      val = val.source || val;
      val = val.replace(/(^|[^\[])\^/g, '$1');
      regex = regex.replace(name, val);
      return this;
    },
    getRegex: function() {
      return new RegExp(regex, opt);
    }
  };
}

function resolveUrl(base, href) {
  if (!baseUrls[' ' + base]) {
    // we can ignore everything in base after the last slash of its path component,
    // but we might need to add _that_
    // https://tools.ietf.org/html/rfc3986#section-3
    if (/^[^:]+:\/*[^/]*$/.test(base)) {
      baseUrls[' ' + base] = base + '/';
    } else {
      baseUrls[' ' + base] = base.replace(/[^/]*$/, '');
    }
  }
  base = baseUrls[' ' + base];

  if (href.slice(0, 2) === '//') {
    return base.replace(/:[\s\S]*/, ':') + href;
  } else if (href.charAt(0) === '/') {
    return base.replace(/(:\/*[^/]*)[\s\S]*/, '$1') + href;
  } else {
    return base + href;
  }
}
var baseUrls = {};
var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1,
      target,
      key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}

/**
 * Marked
 */

function marked(src, opt, callback) {
  // throw error in case of non string input
  if (typeof src === 'undefined' || src === null) {
    throw new Error('marked(): input parameter is undefined or null');
  }
  if (typeof src !== 'string') {
    throw new Error('marked(): input parameter is of type '
      + Object.prototype.toString.call(src) + ', string expected');
  }

  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});

    var highlight = opt.highlight,
        tokens,
        pending,
        i = 0;

    try {
      tokens = Lexer.lex(src, opt)
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function(err) {
      if (err) {
        opt.highlight = highlight;
        return callback(err);
      }

      var out;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (err) return done(err);
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/markedjs/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occurred:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.defaults = {
  gfm: true,
  tables: true,
  breaks: false,
  pedantic: false,
  sanitize: false,
  sanitizer: null,
  mangle: true,
  smartLists: false,
  silent: false,
  highlight: null,
  langPrefix: 'lang-',
  smartypants: false,
  headerPrefix: '',
  renderer: new Renderer(),
  xhtml: false,
  baseUrl: null
};

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;

if (typeof module !== 'undefined' && typeof exports === 'object') {
  module.exports = marked;
} else if (typeof define === 'function' && define.amd) {
  define(function() { return marked; });
} else {
  root.marked = marked;
}
})(this || (typeof window !== 'undefined' ? window : global));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],128:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],129:[function(require,module,exports){
module.exports = require('./lib');

},{"./lib":130}],130:[function(require,module,exports){
// Load modules

var Stringify = require('./stringify');
var Parse = require('./parse');


// Declare internals

var internals = {};


module.exports = {
    stringify: Stringify,
    parse: Parse
};

},{"./parse":131,"./stringify":132}],131:[function(require,module,exports){
// Load modules

var Utils = require('./utils');


// Declare internals

var internals = {
    delimiter: '&',
    depth: 5,
    arrayLimit: 20,
    parameterLimit: 1000
};


internals.parseValues = function (str, options) {

    var obj = {};
    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);

    for (var i = 0, il = parts.length; i < il; ++i) {
        var part = parts[i];
        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;

        if (pos === -1) {
            obj[Utils.decode(part)] = '';
        }
        else {
            var key = Utils.decode(part.slice(0, pos));
            var val = Utils.decode(part.slice(pos + 1));

            if (!obj[key]) {
                obj[key] = val;
            }
            else {
                obj[key] = [].concat(obj[key]).concat(val);
            }
        }
    }

    return obj;
};


internals.parseObject = function (chain, val, options) {

    if (!chain.length) {
        return val;
    }

    var root = chain.shift();

    var obj = {};
    if (root === '[]') {
        obj = [];
        obj = obj.concat(internals.parseObject(chain, val, options));
    }
    else {
        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;
        var index = parseInt(cleanRoot, 10);
        if (!isNaN(index) &&
            root !== cleanRoot &&
            index <= options.arrayLimit) {

            obj = [];
            obj[index] = internals.parseObject(chain, val, options);
        }
        else {
            obj[cleanRoot] = internals.parseObject(chain, val, options);
        }
    }

    return obj;
};


internals.parseKeys = function (key, val, options) {

    if (!key) {
        return;
    }

    // The regex chunks

    var parent = /^([^\[\]]*)/;
    var child = /(\[[^\[\]]*\])/g;

    // Get the parent

    var segment = parent.exec(key);

    // Don't allow them to overwrite object prototype properties

    if (Object.prototype.hasOwnProperty(segment[1])) {
        return;
    }

    // Stash the parent if it exists

    var keys = [];
    if (segment[1]) {
        keys.push(segment[1]);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {

        ++i;
        if (!Object.prototype.hasOwnProperty(segment[1].replace(/\[|\]/g, ''))) {
            keys.push(segment[1]);
        }
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return internals.parseObject(keys, val, options);
};


module.exports = function (str, options) {

    if (str === '' ||
        str === null ||
        typeof str === 'undefined') {

        return {};
    }

    options = options || {};
    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;
    options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;
    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;
    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;

    var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;
    var obj = {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0, il = keys.length; i < il; ++i) {
        var key = keys[i];
        var newObj = internals.parseKeys(key, tempObj[key], options);
        obj = Utils.merge(obj, newObj);
    }

    return Utils.compact(obj);
};

},{"./utils":133}],132:[function(require,module,exports){
// Load modules

var Utils = require('./utils');


// Declare internals

var internals = {
    delimiter: '&'
};


internals.stringify = function (obj, prefix) {

    if (Utils.isBuffer(obj)) {
        obj = obj.toString();
    }
    else if (obj instanceof Date) {
        obj = obj.toISOString();
    }
    else if (obj === null) {
        obj = '';
    }

    if (typeof obj === 'string' ||
        typeof obj === 'number' ||
        typeof obj === 'boolean') {

        return [encodeURIComponent(prefix) + '=' + encodeURIComponent(obj)];
    }

    var values = [];

    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            values = values.concat(internals.stringify(obj[key], prefix + '[' + key + ']'));
        }
    }

    return values;
};


module.exports = function (obj, options) {

    options = options || {};
    var delimiter = typeof options.delimiter === 'undefined' ? internals.delimiter : options.delimiter;

    var keys = [];

    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            keys = keys.concat(internals.stringify(obj[key], key));
        }
    }

    return keys.join(delimiter);
};

},{"./utils":133}],133:[function(require,module,exports){
(function (Buffer){
// Load modules


// Declare internals

var internals = {};


exports.arrayToObject = function (source) {

    var obj = {};
    for (var i = 0, il = source.length; i < il; ++i) {
        if (typeof source[i] !== 'undefined') {

            obj[i] = source[i];
        }
    }

    return obj;
};


exports.merge = function (target, source) {

    if (!source) {
        return target;
    }

    if (Array.isArray(source)) {
        for (var i = 0, il = source.length; i < il; ++i) {
            if (typeof source[i] !== 'undefined') {
                if (typeof target[i] === 'object') {
                    target[i] = exports.merge(target[i], source[i]);
                }
                else {
                    target[i] = source[i];
                }
            }
        }

        return target;
    }

    if (Array.isArray(target)) {
        if (typeof source !== 'object') {
            target.push(source);
            return target;
        }
        else {
            target = exports.arrayToObject(target);
        }
    }

    var keys = Object.keys(source);
    for (var k = 0, kl = keys.length; k < kl; ++k) {
        var key = keys[k];
        var value = source[key];

        if (value &&
            typeof value === 'object') {

            if (!target[key]) {
                target[key] = value;
            }
            else {
                target[key] = exports.merge(target[key], value);
            }
        }
        else {
            target[key] = value;
        }
    }

    return target;
};


exports.decode = function (str) {

    try {
        return decodeURIComponent(str.replace(/\+/g, ' '));
    } catch (e) {
        return str;
    }
};


exports.compact = function (obj, refs) {

    if (typeof obj !== 'object' ||
        obj === null) {

        return obj;
    }

    refs = refs || [];
    var lookup = refs.indexOf(obj);
    if (lookup !== -1) {
        return refs[lookup];
    }

    refs.push(obj);

    if (Array.isArray(obj)) {
        var compacted = [];

        for (var i = 0, l = obj.length; i < l; ++i) {
            if (typeof obj[i] !== 'undefined') {
                compacted.push(obj[i]);
            }
        }

        return compacted;
    }

    var keys = Object.keys(obj);
    for (var i = 0, il = keys.length; i < il; ++i) {
        var key = keys[i];
        obj[key] = exports.compact(obj[key], refs);
    }

    return obj;
};


exports.isRegExp = function (obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};


exports.isBuffer = function (obj) {

    if (typeof Buffer !== 'undefined') {
        return Buffer.isBuffer(obj);
    }
    else {
        return false;
    }
};

}).call(this,require("buffer").Buffer)

},{"buffer":33}],134:[function(require,module,exports){
/**
 * Actions that modify the URL.
 */
var LocationActions = {

  /**
   * Indicates a new location is being pushed to the history stack.
   */
  PUSH: 'push',

  /**
   * Indicates the current location should be replaced.
   */
  REPLACE: 'replace',

  /**
   * Indicates the most recent entry should be removed from the history stack.
   */
  POP: 'pop'

};

module.exports = LocationActions;

},{}],135:[function(require,module,exports){
var LocationActions = require('../actions/LocationActions');

/**
 * A scroll behavior that attempts to imitate the default behavior
 * of modern browsers.
 */
var ImitateBrowserBehavior = {

  updateScrollPosition: function (position, actionType) {
    switch (actionType) {
      case LocationActions.PUSH:
      case LocationActions.REPLACE:
        window.scrollTo(0, 0);
        break;
      case LocationActions.POP:
        if (position) {
          window.scrollTo(position.x, position.y);
        } else {
          window.scrollTo(0, 0);
        }
        break;
    }
  }

};

module.exports = ImitateBrowserBehavior;

},{"../actions/LocationActions":134}],136:[function(require,module,exports){
/**
 * A scroll behavior that always scrolls to the top of the page
 * after a transition.
 */
var ScrollToTopBehavior = {

  updateScrollPosition: function () {
    window.scrollTo(0, 0);
  }

};

module.exports = ScrollToTopBehavior;

},{}],137:[function(require,module,exports){
var React = require('react');
var FakeNode = require('../mixins/FakeNode');
var PropTypes = require('../utils/PropTypes');

/**
 * A <DefaultRoute> component is a special kind of <Route> that
 * renders when its parent matches but none of its siblings do.
 * Only one such route may be used at any given level in the
 * route hierarchy.
 */
var DefaultRoute = React.createClass({

  displayName: 'DefaultRoute',

  mixins: [ FakeNode ],

  propTypes: {
    name: React.PropTypes.string,
    path: PropTypes.falsy,
    handler: React.PropTypes.func.isRequired
  }

});

module.exports = DefaultRoute;

},{"../mixins/FakeNode":147,"../utils/PropTypes":158,"react":"react"}],138:[function(require,module,exports){
var React = require('react');
var classSet = require('react/lib/cx');
var assign = require('react/lib/Object.assign');
var Navigation = require('../mixins/Navigation');
var State = require('../mixins/State');

function isLeftClickEvent(event) {
  return event.button === 0;
}

function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}

/**
 * <Link> components are used to create an <a> element that links to a route.
 * When that route is active, the link gets an "active" class name (or the
 * value of its `activeClassName` prop).
 *
 * For example, assuming you have the following route:
 *
 *   <Route name="showPost" path="/posts/:postID" handler={Post}/>
 *
 * You could use the following component to link to that route:
 *
 *   <Link to="showPost" params={{ postID: "123" }} />
 *
 * In addition to params, links may pass along query string parameters
 * using the `query` prop.
 *
 *   <Link to="showPost" params={{ postID: "123" }} query={{ show:true }}/>
 */
var Link = React.createClass({

  displayName: 'Link',

  mixins: [ Navigation, State ],

  propTypes: {
    activeClassName: React.PropTypes.string.isRequired,
    to: React.PropTypes.string.isRequired,
    params: React.PropTypes.object,
    query: React.PropTypes.object,
    onClick: React.PropTypes.func
  },

  getDefaultProps: function () {
    return {
      activeClassName: 'active'
    };
  },

  handleClick: function (event) {
    var allowTransition = true;
    var clickResult;

    if (this.props.onClick)
      clickResult = this.props.onClick(event);

    if (isModifiedEvent(event) || !isLeftClickEvent(event))
      return;

    if (clickResult === false || event.defaultPrevented === true)
      allowTransition = false;

    event.preventDefault();

    if (allowTransition)
      this.transitionTo(this.props.to, this.props.params, this.props.query);
  },

  /**
   * Returns the value of the "href" attribute to use on the DOM element.
   */
  getHref: function () {
    return this.makeHref(this.props.to, this.props.params, this.props.query);
  },

  /**
   * Returns the value of the "class" attribute to use on the DOM element, which contains
   * the value of the activeClassName property when this <Link> is active.
   */
  getClassName: function () {
    var classNames = {};

    if (this.props.className)
      classNames[this.props.className] = true;

    if (this.isActive(this.props.to, this.props.params, this.props.query))
      classNames[this.props.activeClassName] = true;

    return classSet(classNames);
  },

  render: function () {
    var props = assign({}, this.props, {
      href: this.getHref(),
      className: this.getClassName(),
      onClick: this.handleClick
    });

    return React.DOM.a(props, this.props.children);
  }

});

module.exports = Link;

},{"../mixins/Navigation":148,"../mixins/State":152,"react":"react","react/lib/Object.assign":169,"react/lib/cx":171}],139:[function(require,module,exports){
var React = require('react');
var FakeNode = require('../mixins/FakeNode');
var PropTypes = require('../utils/PropTypes');

/**
 * A <NotFoundRoute> is a special kind of <Route> that
 * renders when the beginning of its parent's path matches
 * but none of its siblings do, including any <DefaultRoute>.
 * Only one such route may be used at any given level in the
 * route hierarchy.
 */
var NotFoundRoute = React.createClass({

  displayName: 'NotFoundRoute',

  mixins: [ FakeNode ],

  propTypes: {
    name: React.PropTypes.string,
    path: PropTypes.falsy,
    handler: React.PropTypes.func.isRequired
  }

});

module.exports = NotFoundRoute;

},{"../mixins/FakeNode":147,"../utils/PropTypes":158,"react":"react"}],140:[function(require,module,exports){
var React = require('react');
var FakeNode = require('../mixins/FakeNode');
var PropTypes = require('../utils/PropTypes');

/**
 * A <Redirect> component is a special kind of <Route> that always
 * redirects to another route when it matches.
 */
var Redirect = React.createClass({

  displayName: 'Redirect',

  mixins: [ FakeNode ],

  propTypes: {
    path: React.PropTypes.string,
    from: React.PropTypes.string, // Alias for path.
    to: React.PropTypes.string,
    handler: PropTypes.falsy
  }

});

module.exports = Redirect;

},{"../mixins/FakeNode":147,"../utils/PropTypes":158,"react":"react"}],141:[function(require,module,exports){
var React = require('react');
var FakeNode = require('../mixins/FakeNode');

/**
 * <Route> components specify components that are rendered to the page when the
 * URL matches a given pattern.
 *
 * Routes are arranged in a nested tree structure. When a new URL is requested,
 * the tree is searched depth-first to find a route whose path matches the URL.
 * When one is found, all routes in the tree that lead to it are considered
 * "active" and their components are rendered into the DOM, nested in the same
 * order as they are in the tree.
 *
 * The preferred way to configure a router is using JSX. The XML-like syntax is
 * a great way to visualize how routes are laid out in an application.
 *
 *   var routes = [
 *     <Route handler={App}>
 *       <Route name="login" handler={Login}/>
 *       <Route name="logout" handler={Logout}/>
 *       <Route name="about" handler={About}/>
 *     </Route>
 *   ];
 *   
 *   Router.run(routes, function (Handler) {
 *     React.render(<Handler/>, document.body);
 *   });
 *
 * Handlers for Route components that contain children can render their active
 * child route using a <RouteHandler> element.
 *
 *   var App = React.createClass({
 *     render: function () {
 *       return (
 *         <div class="application">
 *           <RouteHandler/>
 *         </div>
 *       );
 *     }
 *   });
 */
var Route = React.createClass({

  displayName: 'Route',

  mixins: [ FakeNode ],

  propTypes: {
    name: React.PropTypes.string,
    path: React.PropTypes.string,
    handler: React.PropTypes.func.isRequired,
    ignoreScrollBehavior: React.PropTypes.bool
  }

});

module.exports = Route;

},{"../mixins/FakeNode":147,"react":"react"}],142:[function(require,module,exports){
var React = require('react');
var RouteHandlerMixin = require('../mixins/RouteHandler');

/**
 * A <RouteHandler> component renders the active child route handler
 * when routes are nested.
 */
var RouteHandler = React.createClass({

  displayName: 'RouteHandler',

  mixins: [RouteHandlerMixin],

  getDefaultProps: function () {
    return {
      ref: '__routeHandler__'
    };
  },

  render: function () {
    return this.getRouteHandler();
  }

});

module.exports = RouteHandler;

},{"../mixins/RouteHandler":150,"react":"react"}],143:[function(require,module,exports){
exports.DefaultRoute = require('./components/DefaultRoute');
exports.Link = require('./components/Link');
exports.NotFoundRoute = require('./components/NotFoundRoute');
exports.Redirect = require('./components/Redirect');
exports.Route = require('./components/Route');
exports.RouteHandler = require('./components/RouteHandler');

exports.HashLocation = require('./locations/HashLocation');
exports.HistoryLocation = require('./locations/HistoryLocation');
exports.RefreshLocation = require('./locations/RefreshLocation');

exports.ImitateBrowserBehavior = require('./behaviors/ImitateBrowserBehavior');
exports.ScrollToTopBehavior = require('./behaviors/ScrollToTopBehavior');

exports.Navigation = require('./mixins/Navigation');
exports.State = require('./mixins/State');

exports.create = require('./utils/createRouter');
exports.run = require('./utils/runRouter');

exports.History = require('./utils/History');

},{"./behaviors/ImitateBrowserBehavior":135,"./behaviors/ScrollToTopBehavior":136,"./components/DefaultRoute":137,"./components/Link":138,"./components/NotFoundRoute":139,"./components/Redirect":140,"./components/Route":141,"./components/RouteHandler":142,"./locations/HashLocation":144,"./locations/HistoryLocation":145,"./locations/RefreshLocation":146,"./mixins/Navigation":148,"./mixins/State":152,"./utils/History":155,"./utils/createRouter":161,"./utils/runRouter":165}],144:[function(require,module,exports){
var LocationActions = require('../actions/LocationActions');
var History = require('../utils/History');
var Path = require('../utils/Path');

/**
 * Returns the current URL path from the `hash` portion of the URL, including
 * query string.
 */
function getHashPath() {
  return Path.decode(
    // We can't use window.location.hash here because it's not
    // consistent across browsers - Firefox will pre-decode it!
    window.location.href.split('#')[1] || ''
  );
}

var _actionType;

function ensureSlash() {
  var path = getHashPath();

  if (path.charAt(0) === '/')
    return true;

  HashLocation.replace('/' + path);

  return false;
}

var _changeListeners = [];

function notifyChange(type) {
  if (type === LocationActions.PUSH)
    History.length += 1;

  var change = {
    path: getHashPath(),
    type: type
  };

  _changeListeners.forEach(function (listener) {
    listener(change);
  });
}

var _isListening = false;

function onHashChange() {
  if (ensureSlash()) {
    // If we don't have an _actionType then all we know is the hash
    // changed. It was probably caused by the user clicking the Back
    // button, but may have also been the Forward button or manual
    // manipulation. So just guess 'pop'.
    notifyChange(_actionType || LocationActions.POP);
    _actionType = null;
  }
}

/**
 * A Location that uses `window.location.hash`.
 */
var HashLocation = {

  addChangeListener: function (listener) {
    _changeListeners.push(listener);

    // Do this BEFORE listening for hashchange.
    ensureSlash();

    if (_isListening)
      return;

    if (window.addEventListener) {
      window.addEventListener('hashchange', onHashChange, false);
    } else {
      window.attachEvent('onhashchange', onHashChange);
    }

    _isListening = true;
  },

  removeChangeListener: function(listener) {
    for (var i = 0, l = _changeListeners.length; i < l; i ++) {
      if (_changeListeners[i] === listener) {
        _changeListeners.splice(i, 1);
        break;
      }
    }

    if (window.removeEventListener) {
      window.removeEventListener('hashchange', onHashChange, false);
    } else {
      window.removeEvent('onhashchange', onHashChange);
    }

    if (_changeListeners.length === 0)
      _isListening = false;
  },



  push: function (path) {
    _actionType = LocationActions.PUSH;
    window.location.hash = Path.encode(path);
  },

  replace: function (path) {
    _actionType = LocationActions.REPLACE;
    window.location.replace(window.location.pathname + '#' + Path.encode(path));
  },

  pop: function () {
    _actionType = LocationActions.POP;
    History.back();
  },

  getCurrentPath: getHashPath,

  toString: function () {
    return '<HashLocation>';
  }

};

module.exports = HashLocation;

},{"../actions/LocationActions":134,"../utils/History":155,"../utils/Path":156}],145:[function(require,module,exports){
var LocationActions = require('../actions/LocationActions');
var History = require('../utils/History');
var Path = require('../utils/Path');

/**
 * Returns the current URL path from `window.location`, including query string.
 */
function getWindowPath() {
  return Path.decode(
    window.location.pathname + window.location.search
  );
}

var _changeListeners = [];

function notifyChange(type) {
  var change = {
    path: getWindowPath(),
    type: type
  };

  _changeListeners.forEach(function (listener) {
    listener(change);
  });
}

var _isListening = false;

function onPopState() {
  notifyChange(LocationActions.POP);
}

/**
 * A Location that uses HTML5 history.
 */
var HistoryLocation = {

  addChangeListener: function (listener) {
    _changeListeners.push(listener);

    if (_isListening)
      return;

    if (window.addEventListener) {
      window.addEventListener('popstate', onPopState, false);
    } else {
      window.attachEvent('popstate', onPopState);
    }

    _isListening = true;
  },

  removeChangeListener: function(listener) {
    for (var i = 0, l = _changeListeners.length; i < l; i ++) {
      if (_changeListeners[i] === listener) {
        _changeListeners.splice(i, 1);
        break;
      }
    }

    if (window.addEventListener) {
      window.removeEventListener('popstate', onPopState);
    } else {
      window.removeEvent('popstate', onPopState);
    }

    if (_changeListeners.length === 0)
      _isListening = false;
  },



  push: function (path) {
    window.history.pushState({ path: path }, '', Path.encode(path));
    History.length += 1;
    notifyChange(LocationActions.PUSH);
  },

  replace: function (path) {
    window.history.replaceState({ path: path }, '', Path.encode(path));
    notifyChange(LocationActions.REPLACE);
  },

  pop: History.back,

  getCurrentPath: getWindowPath,

  toString: function () {
    return '<HistoryLocation>';
  }

};

module.exports = HistoryLocation;

},{"../actions/LocationActions":134,"../utils/History":155,"../utils/Path":156}],146:[function(require,module,exports){
var HistoryLocation = require('./HistoryLocation');
var History = require('../utils/History');
var Path = require('../utils/Path');

/**
 * A Location that uses full page refreshes. This is used as
 * the fallback for HistoryLocation in browsers that do not
 * support the HTML5 history API.
 */
var RefreshLocation = {

  push: function (path) {
    window.location = Path.encode(path);
  },

  replace: function (path) {
    window.location.replace(Path.encode(path));
  },

  pop: History.back,

  getCurrentPath: HistoryLocation.getCurrentPath,

  toString: function () {
    return '<RefreshLocation>';
  }

};

module.exports = RefreshLocation;

},{"../utils/History":155,"../utils/Path":156,"./HistoryLocation":145}],147:[function(require,module,exports){
var invariant = require('react/lib/invariant');

var FakeNode = {

  render: function () {
    invariant(
      false,
      '%s elements should not be rendered',
      this.constructor.displayName
    );
  }

};

module.exports = FakeNode;

},{"react/lib/invariant":173}],148:[function(require,module,exports){
var React = require('react');

/**
 * A mixin for components that modify the URL.
 *
 * Example:
 *
 *   var MyLink = React.createClass({
 *     mixins: [ Router.Navigation ],
 *     handleClick: function (event) {
 *       event.preventDefault();
 *       this.transitionTo('aRoute', { the: 'params' }, { the: 'query' });
 *     },
 *     render: function () {
 *       return (
 *         <a onClick={this.handleClick}>Click me!</a>
 *       );
 *     }
 *   });
 */
var Navigation = {

  contextTypes: {
    makePath: React.PropTypes.func.isRequired,
    makeHref: React.PropTypes.func.isRequired,
    transitionTo: React.PropTypes.func.isRequired,
    replaceWith: React.PropTypes.func.isRequired,
    goBack: React.PropTypes.func.isRequired
  },

  /**
   * Returns an absolute URL path created from the given route
   * name, URL parameters, and query values.
   */
  makePath: function (to, params, query) {
    return this.context.makePath(to, params, query);
  },

  /**
   * Returns a string that may safely be used as the href of a
   * link to the route with the given name.
   */
  makeHref: function (to, params, query) {
    return this.context.makeHref(to, params, query);
  },

  /**
   * Transitions to the URL specified in the arguments by pushing
   * a new URL onto the history stack.
   */
  transitionTo: function (to, params, query) {
    this.context.transitionTo(to, params, query);
  },

  /**
   * Transitions to the URL specified in the arguments by replacing
   * the current URL in the history stack.
   */
  replaceWith: function (to, params, query) {
    this.context.replaceWith(to, params, query);
  },

  /**
   * Transitions to the previous URL.
   */
  goBack: function () {
    this.context.goBack();
  }

};

module.exports = Navigation;

},{"react":"react"}],149:[function(require,module,exports){
var React = require('react');

/**
 * Provides the router with context for Router.Navigation.
 */
var NavigationContext = {

  childContextTypes: {
    makePath: React.PropTypes.func.isRequired,
    makeHref: React.PropTypes.func.isRequired,
    transitionTo: React.PropTypes.func.isRequired,
    replaceWith: React.PropTypes.func.isRequired,
    goBack: React.PropTypes.func.isRequired
  },

  getChildContext: function () {
    return {
      makePath: this.constructor.makePath,
      makeHref: this.constructor.makeHref,
      transitionTo: this.constructor.transitionTo,
      replaceWith: this.constructor.replaceWith,
      goBack: this.constructor.goBack
    };
  }

};

module.exports = NavigationContext;

},{"react":"react"}],150:[function(require,module,exports){
var React = require('react');

module.exports = {
  contextTypes: {
    getRouteAtDepth: React.PropTypes.func.isRequired,
    getRouteComponents: React.PropTypes.func.isRequired,
    routeHandlers: React.PropTypes.array.isRequired
  },

  childContextTypes: {
    routeHandlers: React.PropTypes.array.isRequired
  },

  getChildContext: function () {
    return {
      routeHandlers: this.context.routeHandlers.concat([ this ])
    };
  },

  getRouteDepth: function () {
    return this.context.routeHandlers.length - 1;
  },

  componentDidMount: function () {
    this._updateRouteComponent();
  },

  componentDidUpdate: function () {
    this._updateRouteComponent();
  },

  _updateRouteComponent: function () {
    var depth = this.getRouteDepth();
    var components = this.context.getRouteComponents();
    components[depth] = this.refs[this.props.ref || '__routeHandler__'];
  },

  getRouteHandler: function (props) {
    var route = this.context.getRouteAtDepth(this.getRouteDepth());
    return route ? React.createElement(route.handler, props || this.props) : null;
  }
};
},{"react":"react"}],151:[function(require,module,exports){
var invariant = require('react/lib/invariant');
var canUseDOM = require('react/lib/ExecutionEnvironment').canUseDOM;
var getWindowScrollPosition = require('../utils/getWindowScrollPosition');

function shouldUpdateScroll(state, prevState) {
  if (!prevState)
    return true;

  // Don't update scroll position when only the query has changed.
  if (state.pathname === prevState.pathname)
    return false;

  var routes = state.routes;
  var prevRoutes = prevState.routes;

  var sharedAncestorRoutes = routes.filter(function (route) {
    return prevRoutes.indexOf(route) !== -1;
  });

  return !sharedAncestorRoutes.some(function (route) {
    return route.ignoreScrollBehavior;
  });
}

/**
 * Provides the router with the ability to manage window scroll position
 * according to its scroll behavior.
 */
var Scrolling = {

  statics: {
    /**
     * Records curent scroll position as the last known position for the given URL path.
     */
    recordScrollPosition: function (path) {
      if (!this.scrollHistory)
        this.scrollHistory = {};

      this.scrollHistory[path] = getWindowScrollPosition();
    },

    /**
     * Returns the last known scroll position for the given URL path.
     */
    getScrollPosition: function (path) {
      if (!this.scrollHistory)
        this.scrollHistory = {};

      return this.scrollHistory[path] || null;
    }
  },

  componentWillMount: function () {
    invariant(
      this.getScrollBehavior() == null || canUseDOM,
      'Cannot use scroll behavior without a DOM'
    );
  },

  componentDidMount: function () {
    this._updateScroll();
  },

  componentDidUpdate: function (prevProps, prevState) {
    this._updateScroll(prevState);
  },

  _updateScroll: function (prevState) {
    if (!shouldUpdateScroll(this.state, prevState))
      return;

    var scrollBehavior = this.getScrollBehavior();

    if (scrollBehavior)
      scrollBehavior.updateScrollPosition(
        this.constructor.getScrollPosition(this.state.path),
        this.state.action
      );
  }

};

module.exports = Scrolling;

},{"../utils/getWindowScrollPosition":163,"react/lib/ExecutionEnvironment":168,"react/lib/invariant":173}],152:[function(require,module,exports){
var React = require('react');

/**
 * A mixin for components that need to know the path, routes, URL
 * params and query that are currently active.
 *
 * Example:
 *
 *   var AboutLink = React.createClass({
 *     mixins: [ Router.State ],
 *     render: function () {
 *       var className = this.props.className;
 *   
 *       if (this.isActive('about'))
 *         className += ' is-active';
 *   
 *       return React.DOM.a({ className: className }, this.props.children);
 *     }
 *   });
 */
var State = {

  contextTypes: {
    getCurrentPath: React.PropTypes.func.isRequired,
    getCurrentRoutes: React.PropTypes.func.isRequired,
    getCurrentPathname: React.PropTypes.func.isRequired,
    getCurrentParams: React.PropTypes.func.isRequired,
    getCurrentQuery: React.PropTypes.func.isRequired,
    isActive: React.PropTypes.func.isRequired
  },

  /**
   * Returns the current URL path.
   */
  getPath: function () {
    return this.context.getCurrentPath();
  },

  /**
   * Returns an array of the routes that are currently active.
   */
  getRoutes: function () {
    return this.context.getCurrentRoutes();
  },

  /**
   * Returns the current URL path without the query string.
   */
  getPathname: function () {
    return this.context.getCurrentPathname();
  },

  /**
   * Returns an object of the URL params that are currently active.
   */
  getParams: function () {
    return this.context.getCurrentParams();
  },

  /**
   * Returns an object of the query params that are currently active.
   */
  getQuery: function () {
    return this.context.getCurrentQuery();
  },

  /**
   * A helper method to determine if a given route, params, and query
   * are active.
   */
  isActive: function (to, params, query) {
    return this.context.isActive(to, params, query);
  }

};

module.exports = State;

},{"react":"react"}],153:[function(require,module,exports){
var React = require('react');
var assign = require('react/lib/Object.assign');
var Path = require('../utils/Path');

function routeIsActive(activeRoutes, routeName) {
  return activeRoutes.some(function (route) {
    return route.name === routeName;
  });
}

function paramsAreActive(activeParams, params) {
  for (var property in params)
    if (String(activeParams[property]) !== String(params[property]))
      return false;

  return true;
}

function queryIsActive(activeQuery, query) {
  for (var property in query)
    if (String(activeQuery[property]) !== String(query[property]))
      return false;

  return true;
}

/**
 * Provides the router with context for Router.State.
 */
var StateContext = {

  /**
   * Returns the current URL path + query string.
   */
  getCurrentPath: function () {
    return this.state.path;
  },

  /**
   * Returns a read-only array of the currently active routes.
   */
  getCurrentRoutes: function () {
    return this.state.routes.slice(0);
  },

  /**
   * Returns the current URL path without the query string.
   */
  getCurrentPathname: function () {
    return this.state.pathname;
  },

  /**
   * Returns a read-only object of the currently active URL parameters.
   */
  getCurrentParams: function () {
    return assign({}, this.state.params);
  },

  /**
   * Returns a read-only object of the currently active query parameters.
   */
  getCurrentQuery: function () {
    return assign({}, this.state.query);
  },

  /**
   * Returns true if the given route, params, and query are active.
   */
  isActive: function (to, params, query) {
    if (Path.isAbsolute(to))
      return to === this.state.path;

    return routeIsActive(this.state.routes, to) &&
      paramsAreActive(this.state.params, params) &&
      (query == null || queryIsActive(this.state.query, query));
  },

  childContextTypes: {
    getCurrentPath: React.PropTypes.func.isRequired,
    getCurrentRoutes: React.PropTypes.func.isRequired,
    getCurrentPathname: React.PropTypes.func.isRequired,
    getCurrentParams: React.PropTypes.func.isRequired,
    getCurrentQuery: React.PropTypes.func.isRequired,
    isActive: React.PropTypes.func.isRequired
  },

  getChildContext: function () {
    return {
      getCurrentPath: this.getCurrentPath,
      getCurrentRoutes: this.getCurrentRoutes,
      getCurrentPathname: this.getCurrentPathname,
      getCurrentParams: this.getCurrentParams,
      getCurrentQuery: this.getCurrentQuery,
      isActive: this.isActive
    };
  }

};

module.exports = StateContext;

},{"../utils/Path":156,"react":"react","react/lib/Object.assign":169}],154:[function(require,module,exports){
/**
 * Represents a cancellation caused by navigating away
 * before the previous transition has fully resolved.
 */
function Cancellation() { }

module.exports = Cancellation;

},{}],155:[function(require,module,exports){
var invariant = require('react/lib/invariant');
var canUseDOM = require('react/lib/ExecutionEnvironment').canUseDOM;

var History = {

  /**
   * Sends the browser back one entry in the history.
   */
  back: function () {
    invariant(
      canUseDOM,
      'Cannot use History.back without a DOM'
    );

    // Do this first so that History.length will
    // be accurate in location change listeners.
    History.length -= 1;

    window.history.back();
  },

  /**
   * The current number of entries in the history.
   */
  length: 1

};

module.exports = History;

},{"react/lib/ExecutionEnvironment":168,"react/lib/invariant":173}],156:[function(require,module,exports){
var invariant = require('react/lib/invariant');
var merge = require('qs/lib/utils').merge;
var qs = require('qs');

var paramCompileMatcher = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|[*.()\[\]\\+|{}^$]/g;
var paramInjectMatcher = /:([a-zA-Z_$][a-zA-Z0-9_$?]*[?]?)|[*]/g;
var paramInjectTrailingSlashMatcher = /\/\/\?|\/\?/g;
var queryMatcher = /\?(.+)/;

var _compiledPatterns = {};

function compilePattern(pattern) {
  if (!(pattern in _compiledPatterns)) {
    var paramNames = [];
    var source = pattern.replace(paramCompileMatcher, function (match, paramName) {
      if (paramName) {
        paramNames.push(paramName);
        return '([^/?#]+)';
      } else if (match === '*') {
        paramNames.push('splat');
        return '(.*?)';
      } else {
        return '\\' + match;
      }
    });

    _compiledPatterns[pattern] = {
      matcher: new RegExp('^' + source + '$', 'i'),
      paramNames: paramNames
    };
  }

  return _compiledPatterns[pattern];
}

var Path = {

  /**
   * Safely decodes special characters in the given URL path.
   */
  decode: function (path) {
    return decodeURI(path.replace(/\+/g, ' '));
  },

  /**
   * Safely encodes special characters in the given URL path.
   */
  encode: function (path) {
    return encodeURI(path).replace(/%20/g, '+');
  },

  /**
   * Returns an array of the names of all parameters in the given pattern.
   */
  extractParamNames: function (pattern) {
    return compilePattern(pattern).paramNames;
  },

  /**
   * Extracts the portions of the given URL path that match the given pattern
   * and returns an object of param name => value pairs. Returns null if the
   * pattern does not match the given path.
   */
  extractParams: function (pattern, path) {
    var object = compilePattern(pattern);
    var match = path.match(object.matcher);

    if (!match)
      return null;

    var params = {};

    object.paramNames.forEach(function (paramName, index) {
      params[paramName] = match[index + 1];
    });

    return params;
  },

  /**
   * Returns a version of the given route path with params interpolated. Throws
   * if there is a dynamic segment of the route path for which there is no param.
   */
  injectParams: function (pattern, params) {
    params = params || {};

    var splatIndex = 0;

    return pattern.replace(paramInjectMatcher, function (match, paramName) {
      paramName = paramName || 'splat';

      // If param is optional don't check for existence
      if (paramName.slice(-1) !== '?') {
        invariant(
          params[paramName] != null,
          'Missing "' + paramName + '" parameter for path "' + pattern + '"'
        );
      } else {
        paramName = paramName.slice(0, -1);

        if (params[paramName] == null)
          return '';
      }

      var segment;
      if (paramName === 'splat' && Array.isArray(params[paramName])) {
        segment = params[paramName][splatIndex++];

        invariant(
          segment != null,
          'Missing splat # ' + splatIndex + ' for path "' + pattern + '"'
        );
      } else {
        segment = params[paramName];
      }

      return segment;
    }).replace(paramInjectTrailingSlashMatcher, '/');
  },

  /**
   * Returns an object that is the result of parsing any query string contained
   * in the given path, null if the path contains no query string.
   */
  extractQuery: function (path) {
    var match = path.match(queryMatcher);
    return match && qs.parse(match[1]);
  },

  /**
   * Returns a version of the given path without the query string.
   */
  withoutQuery: function (path) {
    return path.replace(queryMatcher, '');
  },

  /**
   * Returns a version of the given path with the parameters in the given
   * query merged into the query string.
   */
  withQuery: function (path, query) {
    var existingQuery = Path.extractQuery(path);

    if (existingQuery)
      query = query ? merge(existingQuery, query) : existingQuery;

    var queryString = query && qs.stringify(query);

    if (queryString)
      return Path.withoutQuery(path) + '?' + queryString;

    return path;
  },

  /**
   * Returns true if the given path is absolute.
   */
  isAbsolute: function (path) {
    return path.charAt(0) === '/';
  },

  /**
   * Returns a normalized version of the given path.
   */
  normalize: function (path, parentRoute) {
    return path.replace(/^\/*/, '/');
  },

  /**
   * Joins two URL paths together.
   */
  join: function (a, b) {
    return a.replace(/\/*$/, '/') + b;
  }

};

module.exports = Path;

},{"qs":129,"qs/lib/utils":133,"react/lib/invariant":173}],157:[function(require,module,exports){
var Promise = require('when/lib/Promise');

// TODO: Use process.env.NODE_ENV check + envify to enable
// when's promise monitor here when in dev.

module.exports = Promise;

},{"when/lib/Promise":178}],158:[function(require,module,exports){
var PropTypes = {

  /**
   * Requires that the value of a prop be falsy.
   */
  falsy: function (props, propName, componentName) {
    if (props[propName])
      return new Error('<' + componentName + '> may not have a "' + propName + '" prop');
  }

};

module.exports = PropTypes;

},{}],159:[function(require,module,exports){
/**
 * Encapsulates a redirect to the given route.
 */
function Redirect(to, params, query) {
  this.to = to;
  this.params = params;
  this.query = query;
}

module.exports = Redirect;

},{}],160:[function(require,module,exports){
var assign = require('react/lib/Object.assign');
var reversedArray = require('./reversedArray');
var Redirect = require('./Redirect');
var Promise = require('./Promise');

/**
 * Runs all hook functions serially and calls callback(error) when finished.
 * A hook may return a promise if it needs to execute asynchronously.
 */
function runHooks(hooks, callback) {
  var promise;
  try {
    promise = hooks.reduce(function (promise, hook) {
      // The first hook to use transition.wait makes the rest
      // of the transition async from that point forward.
      return promise ? promise.then(hook) : hook();
    }, null);
  } catch (error) {
    return callback(error); // Sync error.
  }

  if (promise) {
    // Use setTimeout to break the promise chain.
    promise.then(function () {
      setTimeout(callback);
    }, function (error) {
      setTimeout(function () {
        callback(error);
      });
    });
  } else {
    callback();
  }
}

/**
 * Calls the willTransitionFrom hook of all handlers in the given matches
 * serially in reverse with the transition object and the current instance of
 * the route's handler, so that the deepest nested handlers are called first.
 * Calls callback(error) when finished.
 */
function runTransitionFromHooks(transition, routes, components, callback) {
  components = reversedArray(components);

  var hooks = reversedArray(routes).map(function (route, index) {
    return function () {
      var handler = route.handler;

      if (!transition.isAborted && handler.willTransitionFrom)
        return handler.willTransitionFrom(transition, components[index]);

      var promise = transition._promise;
      transition._promise = null;

      return promise;
    };
  });

  runHooks(hooks, callback);
}

/**
 * Calls the willTransitionTo hook of all handlers in the given matches
 * serially with the transition object and any params that apply to that
 * handler. Calls callback(error) when finished.
 */
function runTransitionToHooks(transition, routes, params, query, callback) {
  var hooks = routes.map(function (route) {
    return function () {
      var handler = route.handler;

      if (!transition.isAborted && handler.willTransitionTo)
        handler.willTransitionTo(transition, params, query);

      var promise = transition._promise;
      transition._promise = null;

      return promise;
    };
  });

  runHooks(hooks, callback);
}

/**
 * Encapsulates a transition to a given path.
 *
 * The willTransitionTo and willTransitionFrom handlers receive
 * an instance of this class as their first argument.
 */
function Transition(path, retry) {
  this.path = path;
  this.abortReason = null;
  this.isAborted = false;
  this.retry = retry.bind(this);
  this._promise = null;
}

assign(Transition.prototype, {

  abort: function (reason) {
    if (this.isAborted) {
      // First abort wins.
      return;
    }

    this.abortReason = reason;
    this.isAborted = true;
  },

  redirect: function (to, params, query) {
    this.abort(new Redirect(to, params, query));
  },

  wait: function (value) {
    this._promise = Promise.resolve(value);
  },

  from: function (routes, components, callback) {
    return runTransitionFromHooks(this, routes, components, callback);
  },

  to: function (routes, params, query, callback) {
    return runTransitionToHooks(this, routes, params, query, callback);
  }

});

module.exports = Transition;

},{"./Promise":157,"./Redirect":159,"./reversedArray":164,"react/lib/Object.assign":169}],161:[function(require,module,exports){
(function (process){
/* jshint -W058 */
var React = require('react');
var warning = require('react/lib/warning');
var invariant = require('react/lib/invariant');
var canUseDOM = require('react/lib/ExecutionEnvironment').canUseDOM;
var ImitateBrowserBehavior = require('../behaviors/ImitateBrowserBehavior');
var RouteHandler = require('../components/RouteHandler');
var LocationActions = require('../actions/LocationActions');
var HashLocation = require('../locations/HashLocation');
var HistoryLocation = require('../locations/HistoryLocation');
var RefreshLocation = require('../locations/RefreshLocation');
var NavigationContext = require('../mixins/NavigationContext');
var StateContext = require('../mixins/StateContext');
var Scrolling = require('../mixins/Scrolling');
var createRoutesFromChildren = require('./createRoutesFromChildren');
var supportsHistory = require('./supportsHistory');
var Transition = require('./Transition');
var PropTypes = require('./PropTypes');
var Redirect = require('./Redirect');
var History = require('./History');
var Cancellation = require('./Cancellation');
var Path = require('./Path');

/**
 * The default location for new routers.
 */
var DEFAULT_LOCATION = canUseDOM ? HashLocation : '/';

/**
 * The default scroll behavior for new routers.
 */
var DEFAULT_SCROLL_BEHAVIOR = canUseDOM ? ImitateBrowserBehavior : null;

/**
 * The default error handler for new routers.
 */
function defaultErrorHandler(error) {
  // Throw so we don't silently swallow async errors.
  throw error; // This error probably originated in a transition hook.
}

/**
 * The default aborted transition handler for new routers.
 */
function defaultAbortHandler(abortReason, location) {
  if (typeof location === 'string')
    throw new Error('Unhandled aborted transition! Reason: ' + abortReason);

  if (abortReason instanceof Cancellation) {
    return;
  } else if (abortReason instanceof Redirect) {
    location.replace(this.makePath(abortReason.to, abortReason.params, abortReason.query));
  } else {
    location.pop();
  }
}

function findMatch(pathname, routes, defaultRoute, notFoundRoute) {
  var match, route, params;

  for (var i = 0, len = routes.length; i < len; ++i) {
    route = routes[i];

    // Check the subtree first to find the most deeply-nested match.
    match = findMatch(pathname, route.childRoutes, route.defaultRoute, route.notFoundRoute);

    if (match != null) {
      match.routes.unshift(route);
      return match;
    }

    // No routes in the subtree matched, so check this route.
    params = Path.extractParams(route.path, pathname);

    if (params)
      return createMatch(route, params);
  }

  // No routes matched, so try the default route if there is one.
  if (defaultRoute && (params = Path.extractParams(defaultRoute.path, pathname)))
    return createMatch(defaultRoute, params);

  // Last attempt: does the "not found" route match?
  if (notFoundRoute && (params = Path.extractParams(notFoundRoute.path, pathname)))
    return createMatch(notFoundRoute, params);

  return match;
}

function createMatch(route, params) {
  return { routes: [ route ], params: params };
}

function hasProperties(object, properties) {
  for (var propertyName in properties)
    if (properties.hasOwnProperty(propertyName) && object[propertyName] !== properties[propertyName])
      return false;

  return true;
}

function hasMatch(routes, route, prevParams, nextParams, prevQuery, nextQuery) {
  return routes.some(function (r) {
    if (r !== route)
      return false;

    var paramNames = route.paramNames;
    var paramName;

    // Ensure that all params the route cares about did not change.
    for (var i = 0, len = paramNames.length; i < len; ++i) {
      paramName = paramNames[i];

      if (nextParams[paramName] !== prevParams[paramName])
        return false;
    }

    // Ensure the query hasn't changed.
    return hasProperties(prevQuery, nextQuery) && hasProperties(nextQuery, prevQuery);
  });
}

/**
 * Creates and returns a new router using the given options. A router
 * is a ReactComponent class that knows how to react to changes in the
 * URL and keep the contents of the page in sync.
 *
 * Options may be any of the following:
 *
 * - routes           (required) The route config
 * - location         The location to use. Defaults to HashLocation when
 *                    the DOM is available, "/" otherwise
 * - scrollBehavior   The scroll behavior to use. Defaults to ImitateBrowserBehavior
 *                    when the DOM is available, null otherwise
 * - onError          A function that is used to handle errors
 * - onAbort          A function that is used to handle aborted transitions
 *
 * When rendering in a server-side environment, the location should simply
 * be the URL path that was used in the request, including the query string.
 */
function createRouter(options) {
  options = options || {};

  if (typeof options === 'function') {
    options = { routes: options }; // Router.create(<Route>)
  } else if (Array.isArray(options)) {
    options = { routes: options }; // Router.create([ <Route>, <Route> ])
  }

  var routes = [];
  var namedRoutes = {};
  var components = [];
  var location = options.location || DEFAULT_LOCATION;
  var scrollBehavior = options.scrollBehavior || DEFAULT_SCROLL_BEHAVIOR;
  var onError = options.onError || defaultErrorHandler;
  var onAbort = options.onAbort || defaultAbortHandler;
  var state = {};
  var nextState = {};
  var pendingTransition = null;

  function updateState() {
    state = nextState;
    nextState = {};
  }

  if (typeof location === 'string') {
    warning(
      !canUseDOM || process.env.NODE_ENV === 'test',
      'You should not use a static location in a DOM environment because ' +
      'the router will not be kept in sync with the current URL'
    );
  } else {
    invariant(
      canUseDOM,
      'You cannot use %s without a DOM',
      location
    );
  }

  // Automatically fall back to full page refreshes in
  // browsers that don't support the HTML history API.
  if (location === HistoryLocation && !supportsHistory())
    location = RefreshLocation;

  var router = React.createClass({

    displayName: 'Router',

    mixins: [ NavigationContext, StateContext, Scrolling ],

    statics: {

      defaultRoute: null,
      notFoundRoute: null,

      /**
       * Adds routes to this router from the given children object (see ReactChildren).
       */
      addRoutes: function (children) {
        routes.push.apply(routes, createRoutesFromChildren(children, this, namedRoutes));
      },

      /**
       * Returns an absolute URL path created from the given route
       * name, URL parameters, and query.
       */
      makePath: function (to, params, query) {
        var path;
        if (Path.isAbsolute(to)) {
          path = Path.normalize(to);
        } else {
          var route = namedRoutes[to];

          invariant(
            route,
            'Unable to find <Route name="%s">',
            to
          );

          path = route.path;
        }

        return Path.withQuery(Path.injectParams(path, params), query);
      },

      /**
       * Returns a string that may safely be used as the href of a link
       * to the route with the given name, URL parameters, and query.
       */
      makeHref: function (to, params, query) {
        var path = this.makePath(to, params, query);
        return (location === HashLocation) ? '#' + path : path;
      },

      /**
       * Transitions to the URL specified in the arguments by pushing
       * a new URL onto the history stack.
       */
      transitionTo: function (to, params, query) {
        invariant(
          typeof location !== 'string',
          'You cannot use transitionTo with a static location'
        );

        var path = this.makePath(to, params, query);

        if (pendingTransition) {
          // Replace so pending location does not stay in history.
          location.replace(path);
        } else {
          location.push(path);
        }
      },

      /**
       * Transitions to the URL specified in the arguments by replacing
       * the current URL in the history stack.
       */
      replaceWith: function (to, params, query) {
        invariant(
          typeof location !== 'string',
          'You cannot use replaceWith with a static location'
        );

        location.replace(this.makePath(to, params, query));
      },

      /**
       * Transitions to the previous URL if one is available. Returns true if the
       * router was able to go back, false otherwise.
       *
       * Note: The router only tracks history entries in your application, not the
       * current browser session, so you can safely call this function without guarding
       * against sending the user back to some other site. However, when using
       * RefreshLocation (which is the fallback for HistoryLocation in browsers that
       * don't support HTML5 history) this method will *always* send the client back
       * because we cannot reliably track history length.
       */
      goBack: function () {
        invariant(
          typeof location !== 'string',
          'You cannot use goBack with a static location'
        );

        if (History.length > 1 || location === RefreshLocation) {
          location.pop();
          return true;
        }

        warning(false, 'goBack() was ignored because there is no router history');

        return false;
      },

      /**
       * Performs a match of the given pathname against this router and returns an object
       * with the { routes, params } that match. Returns null if no match can be made.
       */
      match: function (pathname) {
        return findMatch(pathname, routes, this.defaultRoute, this.notFoundRoute) || null;
      },

      /**
       * Performs a transition to the given path and calls callback(error, abortReason)
       * when the transition is finished. If both arguments are null the router's state
       * was updated. Otherwise the transition did not complete.
       *
       * In a transition, a router first determines which routes are involved by beginning
       * with the current route, up the route tree to the first parent route that is shared
       * with the destination route, and back down the tree to the destination route. The
       * willTransitionFrom hook is invoked on all route handlers we're transitioning away
       * from, in reverse nesting order. Likewise, the willTransitionTo hook is invoked on
       * all route handlers we're transitioning to.
       *
       * Both willTransitionFrom and willTransitionTo hooks may either abort or redirect the
       * transition. To resolve asynchronously, they may use transition.wait(promise). If no
       * hooks wait, the transition is fully synchronous.
       */
      dispatch: function (path, action, callback) {
        if (pendingTransition) {
          pendingTransition.abort(new Cancellation);
          pendingTransition = null;
        }

        var prevPath = state.path;
        if (prevPath === path)
          return; // Nothing to do!

        // Record the scroll position as early as possible to
        // get it before browsers try update it automatically.
        if (prevPath && action !== LocationActions.REPLACE)
          this.recordScrollPosition(prevPath);

        var pathname = Path.withoutQuery(path);
        var match = this.match(pathname);

        warning(
          match != null,
          'No route matches path "%s". Make sure you have <Route path="%s"> somewhere in your routes',
          path, path
        );

        if (match == null)
          match = {};

        var prevRoutes = state.routes || [];
        var prevParams = state.params || {};
        var prevQuery = state.query || {};

        var nextRoutes = match.routes || [];
        var nextParams = match.params || {};
        var nextQuery = Path.extractQuery(path) || {};

        var fromRoutes, toRoutes;
        if (prevRoutes.length) {
          fromRoutes = prevRoutes.filter(function (route) {
            return !hasMatch(nextRoutes, route, prevParams, nextParams, prevQuery, nextQuery);
          });

          toRoutes = nextRoutes.filter(function (route) {
            return !hasMatch(prevRoutes, route, prevParams, nextParams, prevQuery, nextQuery);
          });
        } else {
          fromRoutes = [];
          toRoutes = nextRoutes;
        }

        var transition = new Transition(path, this.replaceWith.bind(this, path));
        pendingTransition = transition;

        transition.from(fromRoutes, components, function (error) {
          if (error || transition.isAborted)
            return callback.call(router, error, transition);

          transition.to(toRoutes, nextParams, nextQuery, function (error) {
            if (error || transition.isAborted)
              return callback.call(router, error, transition);

            nextState.path = path;
            nextState.action = action;
            nextState.pathname = pathname;
            nextState.routes = nextRoutes;
            nextState.params = nextParams;
            nextState.query = nextQuery;

            callback.call(router, null, transition);
          });
        });
      },

      /**
       * Starts this router and calls callback(router, state) when the route changes.
       *
       * If the router's location is static (i.e. a URL path in a server environment)
       * the callback is called only once. Otherwise, the location should be one of the
       * Router.*Location objects (e.g. Router.HashLocation or Router.HistoryLocation).
       */
      run: function (callback) {
        var dispatchHandler = function (error, transition) {
          pendingTransition = null;

          if (error) {
            onError.call(router, error);
          } else if (transition.isAborted) {
            onAbort.call(router, transition.abortReason, location);
          } else {
            callback.call(router, router, nextState);
          }
        };

        if (typeof location === 'string') {
          router.dispatch(location, null, dispatchHandler);
        } else {
          // Listen for changes to the location.
          var changeListener = function (change) {
            router.dispatch(change.path, change.type, dispatchHandler);
          };

          if (location.addChangeListener)
            location.addChangeListener(changeListener);

          // Bootstrap using the current path.
          router.dispatch(location.getCurrentPath(), null, dispatchHandler);
        }
      },

      teardown: function() {
        location.removeChangeListener(this.changeListener);
      }

    },

    propTypes: {
      children: PropTypes.falsy
    },

    getLocation: function () {
      return location;
    },

    getScrollBehavior: function () {
      return scrollBehavior;
    },

    getRouteAtDepth: function (depth) {
      var routes = this.state.routes;
      return routes && routes[depth];
    },

    getRouteComponents: function () {
      return components;
    },

    getInitialState: function () {
      updateState();
      return state;
    },

    componentWillReceiveProps: function () {
      updateState();
      this.setState(state);
    },

    componentWillUnmount: function() {
      router.teardown();
    },

    render: function () {
      return this.getRouteAtDepth(0) ? React.createElement(RouteHandler, this.props) : null;
    },

    childContextTypes: {
      getRouteAtDepth: React.PropTypes.func.isRequired,
      getRouteComponents: React.PropTypes.func.isRequired,
      routeHandlers: React.PropTypes.array.isRequired
    },

    getChildContext: function () {
      return {
        getRouteComponents: this.getRouteComponents,
        getRouteAtDepth: this.getRouteAtDepth,
        routeHandlers: [ this ]
      };
    }

  });

  if (options.routes)
    router.addRoutes(options.routes);

  return router;
}

module.exports = createRouter;

}).call(this,require('_process'))

},{"../actions/LocationActions":134,"../behaviors/ImitateBrowserBehavior":135,"../components/RouteHandler":142,"../locations/HashLocation":144,"../locations/HistoryLocation":145,"../locations/RefreshLocation":146,"../mixins/NavigationContext":149,"../mixins/Scrolling":151,"../mixins/StateContext":153,"./Cancellation":154,"./History":155,"./Path":156,"./PropTypes":158,"./Redirect":159,"./Transition":160,"./createRoutesFromChildren":162,"./supportsHistory":166,"_process":128,"react":"react","react/lib/ExecutionEnvironment":168,"react/lib/invariant":173,"react/lib/warning":174}],162:[function(require,module,exports){
/* jshint -W084 */
var React = require('react');
var warning = require('react/lib/warning');
var invariant = require('react/lib/invariant');
var DefaultRoute = require('../components/DefaultRoute');
var NotFoundRoute = require('../components/NotFoundRoute');
var Redirect = require('../components/Redirect');
var Route = require('../components/Route');
var Path = require('./Path');

var CONFIG_ELEMENT_TYPES = [
  DefaultRoute.type,
  NotFoundRoute.type,
  Redirect.type,
  Route.type
];

function createRedirectHandler(to, _params, _query) {
  return React.createClass({
    statics: {
      willTransitionTo: function (transition, params, query) {
        transition.redirect(to, _params || params, _query || query);
      }
    },

    render: function () {
      return null;
    }
  });
}

function checkPropTypes(componentName, propTypes, props) {
  for (var propName in propTypes) {
    if (propTypes.hasOwnProperty(propName)) {
      var error = propTypes[propName](props, propName, componentName);

      if (error instanceof Error)
        warning(false, error.message);
    }
  }
}

function createRoute(element, parentRoute, namedRoutes) {
  var type = element.type;
  var props = element.props;
  var componentName = (type && type.displayName) || 'UnknownComponent';

  invariant(
    CONFIG_ELEMENT_TYPES.indexOf(type) !== -1,
    'Unrecognized route configuration element "<%s>"',
    componentName
  );

  if (type.propTypes)
    checkPropTypes(componentName, type.propTypes, props);

  var route = { name: props.name };

  if (props.ignoreScrollBehavior) {
    route.ignoreScrollBehavior = true;
  }

  if (type === Redirect.type) {
    route.handler = createRedirectHandler(props.to, props.params, props.query);
    props.path = props.path || props.from || '*';
  } else {
    route.handler = props.handler;
  }

  var parentPath = (parentRoute && parentRoute.path) || '/';

  if ((props.path || props.name) && type !== DefaultRoute.type && type !== NotFoundRoute.type) {
    var path = props.path || props.name;

    // Relative paths extend their parent.
    if (!Path.isAbsolute(path))
      path = Path.join(parentPath, path);

    route.path = Path.normalize(path);
  } else {
    route.path = parentPath;

    if (type === NotFoundRoute.type)
      route.path += '*';
  }

  route.paramNames = Path.extractParamNames(route.path);

  // Make sure the route's path has all params its parent needs.
  if (parentRoute && Array.isArray(parentRoute.paramNames)) {
    parentRoute.paramNames.forEach(function (paramName) {
      invariant(
        route.paramNames.indexOf(paramName) !== -1,
        'The nested route path "%s" is missing the "%s" parameter of its parent path "%s"',
        route.path, paramName, parentRoute.path
      );
    });
  }

  // Make sure the route can be looked up by <Link>s.
  if (props.name) {
    invariant(
      namedRoutes[props.name] == null,
      'You cannot use the name "%s" for more than one route',
      props.name
    );

    namedRoutes[props.name] = route;
  }

  // Handle <NotFoundRoute>.
  if (type === NotFoundRoute.type) {
    invariant(
      parentRoute,
      '<NotFoundRoute> must have a parent <Route>'
    );

    invariant(
      parentRoute.notFoundRoute == null,
      'You may not have more than one <NotFoundRoute> per <Route>'
    );

    parentRoute.notFoundRoute = route;

    return null;
  }

  // Handle <DefaultRoute>.
  if (type === DefaultRoute.type) {
    invariant(
      parentRoute,
      '<DefaultRoute> must have a parent <Route>'
    );

    invariant(
      parentRoute.defaultRoute == null,
      'You may not have more than one <DefaultRoute> per <Route>'
    );

    parentRoute.defaultRoute = route;

    return null;
  }

  route.childRoutes = createRoutesFromChildren(props.children, route, namedRoutes);

  return route;
}

/**
 * Creates and returns an array of route objects from the given ReactChildren.
 */
function createRoutesFromChildren(children, parentRoute, namedRoutes) {
  var routes = [];

  React.Children.forEach(children, function (child) {
    // Exclude <DefaultRoute>s and <NotFoundRoute>s.
    if (child = createRoute(child, parentRoute, namedRoutes))
      routes.push(child);
  });

  return routes;
}

module.exports = createRoutesFromChildren;

},{"../components/DefaultRoute":137,"../components/NotFoundRoute":139,"../components/Redirect":140,"../components/Route":141,"./Path":156,"react":"react","react/lib/invariant":173,"react/lib/warning":174}],163:[function(require,module,exports){
var invariant = require('react/lib/invariant');
var canUseDOM = require('react/lib/ExecutionEnvironment').canUseDOM;

/**
 * Returns the current scroll position of the window as { x, y }.
 */
function getWindowScrollPosition() {
  invariant(
    canUseDOM,
    'Cannot get current scroll position without a DOM'
  );

  return {
    x: window.pageXOffset || document.documentElement.scrollLeft,
    y: window.pageYOffset || document.documentElement.scrollTop
  };
}

module.exports = getWindowScrollPosition;

},{"react/lib/ExecutionEnvironment":168,"react/lib/invariant":173}],164:[function(require,module,exports){
function reversedArray(array) {
  return array.slice(0).reverse();
}

module.exports = reversedArray;

},{}],165:[function(require,module,exports){
var createRouter = require('./createRouter');

/**
 * A high-level convenience method that creates, configures, and
 * runs a router in one shot. The method signature is:
 *
 *   Router.run(routes[, location ], callback);
 *
 * Using `window.location.hash` to manage the URL, you could do:
 *
 *   Router.run(routes, function (Handler) {
 *     React.render(<Handler/>, document.body);
 *   });
 * 
 * Using HTML5 history and a custom "cursor" prop:
 * 
 *   Router.run(routes, Router.HistoryLocation, function (Handler) {
 *     React.render(<Handler cursor={cursor}/>, document.body);
 *   });
 *
 * Returns the newly created router.
 *
 * Note: If you need to specify further options for your router such
 * as error/abort handling or custom scroll behavior, use Router.create
 * instead.
 *
 *   var router = Router.create(options);
 *   router.run(function (Handler) {
 *     // ...
 *   });
 */
function runRouter(routes, location, callback) {
  if (typeof location === 'function') {
    callback = location;
    location = null;
  }

  var router = createRouter({
    routes: routes,
    location: location
  });

  router.run(callback);

  return router;
}

module.exports = runRouter;

},{"./createRouter":161}],166:[function(require,module,exports){
function supportsHistory() {
  /*! taken from modernizr
   * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
   * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
   * changed to avoid false negatives for Windows Phones: https://github.com/rackt/react-router/issues/586
   */
  var ua = navigator.userAgent;
  if ((ua.indexOf('Android 2.') !== -1 ||
      (ua.indexOf('Android 4.0') !== -1)) &&
      ua.indexOf('Mobile Safari') !== -1 &&
      ua.indexOf('Chrome') === -1 &&
      ua.indexOf('Windows Phone') === -1) {
    return false;
  }
  return (window.history && 'pushState' in window.history);
}

module.exports = supportsHistory;

},{}],167:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CSSCore
 * @typechecks
 */

var invariant = require("./invariant");

/**
 * The CSSCore module specifies the API (and implements most of the methods)
 * that should be used when dealing with the display of elements (via their
 * CSS classes and visibility on screen. It is an API focused on mutating the
 * display and not reading it as no logical state should be encoded in the
 * display of elements.
 */

var CSSCore = {

  /**
   * Adds the class passed in to the element if it doesn't already have it.
   *
   * @param {DOMElement} element the element to set the class on
   * @param {string} className the CSS className
   * @return {DOMElement} the element passed in
   */
  addClass: function(element, className) {
    ("production" !== process.env.NODE_ENV ? invariant(
      !/\s/.test(className),
      'CSSCore.addClass takes only a single class name. "%s" contains ' +
      'multiple classes.', className
    ) : invariant(!/\s/.test(className)));

    if (className) {
      if (element.classList) {
        element.classList.add(className);
      } else if (!CSSCore.hasClass(element, className)) {
        element.className = element.className + ' ' + className;
      }
    }
    return element;
  },

  /**
   * Removes the class passed in from the element
   *
   * @param {DOMElement} element the element to set the class on
   * @param {string} className the CSS className
   * @return {DOMElement} the element passed in
   */
  removeClass: function(element, className) {
    ("production" !== process.env.NODE_ENV ? invariant(
      !/\s/.test(className),
      'CSSCore.removeClass takes only a single class name. "%s" contains ' +
      'multiple classes.', className
    ) : invariant(!/\s/.test(className)));

    if (className) {
      if (element.classList) {
        element.classList.remove(className);
      } else if (CSSCore.hasClass(element, className)) {
        element.className = element.className
          .replace(new RegExp('(^|\\s)' + className + '(?:\\s|$)', 'g'), '$1')
          .replace(/\s+/g, ' ') // multiple spaces to one
          .replace(/^\s*|\s*$/g, ''); // trim the ends
      }
    }
    return element;
  },

  /**
   * Helper to add or remove a class from an element based on a condition.
   *
   * @param {DOMElement} element the element to set the class on
   * @param {string} className the CSS className
   * @param {*} bool condition to whether to add or remove the class
   * @return {DOMElement} the element passed in
   */
  conditionClass: function(element, className, bool) {
    return (bool ? CSSCore.addClass : CSSCore.removeClass)(element, className);
  },

  /**
   * Tests whether the element has the class specified.
   *
   * @param {DOMNode|DOMWindow} element the element to set the class on
   * @param {string} className the CSS className
   * @return {boolean} true if the element has the class, false if not
   */
  hasClass: function(element, className) {
    ("production" !== process.env.NODE_ENV ? invariant(
      !/\s/.test(className),
      'CSS.hasClass takes only a single class name.'
    ) : invariant(!/\s/.test(className)));
    if (element.classList) {
      return !!className && element.classList.contains(className);
    }
    return (' ' + element.className + ' ').indexOf(' ' + className + ' ') > -1;
  }

};

module.exports = CSSCore;

}).call(this,require('_process'))

},{"./invariant":173,"_process":128}],168:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ExecutionEnvironment
 */

/*jslint evil: true */

"use strict";

var canUseDOM = !!(
  typeof window !== 'undefined' &&
  window.document &&
  window.document.createElement
);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners:
    canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;

},{}],169:[function(require,module,exports){
/**
 * Copyright 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Object.assign
 */

// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign

function assign(target, sources) {
  if (target == null) {
    throw new TypeError('Object.assign target cannot be null or undefined');
  }

  var to = Object(target);
  var hasOwnProperty = Object.prototype.hasOwnProperty;

  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
    var nextSource = arguments[nextIndex];
    if (nextSource == null) {
      continue;
    }

    var from = Object(nextSource);

    // We don't currently support accessors nor proxies. Therefore this
    // copy cannot throw. If we ever supported this then we must handle
    // exceptions and side-effects. We don't support symbols so they won't
    // be transferred.

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
  }

  return to;
};

module.exports = assign;

},{}],170:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactTransitionEvents
 */

"use strict";

var ExecutionEnvironment = require("./ExecutionEnvironment");

/**
 * EVENT_NAME_MAP is used to determine which event fired when a
 * transition/animation ends, based on the style property used to
 * define that event.
 */
var EVENT_NAME_MAP = {
  transitionend: {
    'transition': 'transitionend',
    'WebkitTransition': 'webkitTransitionEnd',
    'MozTransition': 'mozTransitionEnd',
    'OTransition': 'oTransitionEnd',
    'msTransition': 'MSTransitionEnd'
  },

  animationend: {
    'animation': 'animationend',
    'WebkitAnimation': 'webkitAnimationEnd',
    'MozAnimation': 'mozAnimationEnd',
    'OAnimation': 'oAnimationEnd',
    'msAnimation': 'MSAnimationEnd'
  }
};

var endEvents = [];

function detectEvents() {
  var testEl = document.createElement('div');
  var style = testEl.style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are useable, and if not remove them
  // from the map
  if (!('AnimationEvent' in window)) {
    delete EVENT_NAME_MAP.animationend.animation;
  }

  if (!('TransitionEvent' in window)) {
    delete EVENT_NAME_MAP.transitionend.transition;
  }

  for (var baseEventName in EVENT_NAME_MAP) {
    var baseEvents = EVENT_NAME_MAP[baseEventName];
    for (var styleName in baseEvents) {
      if (styleName in style) {
        endEvents.push(baseEvents[styleName]);
        break;
      }
    }
  }
}

if (ExecutionEnvironment.canUseDOM) {
  detectEvents();
}

// We use the raw {add|remove}EventListener() call because EventListener
// does not know how to remove event listeners and we really should
// clean up. Also, these events are not triggered in older browsers
// so we should be A-OK here.

function addEventListener(node, eventName, eventListener) {
  node.addEventListener(eventName, eventListener, false);
}

function removeEventListener(node, eventName, eventListener) {
  node.removeEventListener(eventName, eventListener, false);
}

var ReactTransitionEvents = {
  addEndEventListener: function(node, eventListener) {
    if (endEvents.length === 0) {
      // If CSS transitions are not supported, trigger an "end animation"
      // event immediately.
      window.setTimeout(eventListener, 0);
      return;
    }
    endEvents.forEach(function(endEvent) {
      addEventListener(node, endEvent, eventListener);
    });
  },

  removeEndEventListener: function(node, eventListener) {
    if (endEvents.length === 0) {
      return;
    }
    endEvents.forEach(function(endEvent) {
      removeEventListener(node, endEvent, eventListener);
    });
  }
};

module.exports = ReactTransitionEvents;

},{"./ExecutionEnvironment":168}],171:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule cx
 */

/**
 * This function is used to mark string literals representing CSS class names
 * so that they can be transformed statically. This allows for modularization
 * and minification of CSS class names.
 *
 * In static_upstream, this function is actually implemented, but it should
 * eventually be replaced with something more descriptive, and the transform
 * that is used in the main stack should be ported for use elsewhere.
 *
 * @param string|object className to modularize, or an object of key/values.
 *                      In the object case, the values are conditions that
 *                      determine if the className keys should be included.
 * @param [string ...]  Variable list of classNames in the string case.
 * @return string       Renderable space-separated CSS className.
 */
function cx(classNames) {
  if (typeof classNames == 'object') {
    return Object.keys(classNames).filter(function(className) {
      return classNames[className];
    }).join(' ');
  } else {
    return Array.prototype.join.call(arguments, ' ');
  }
}

module.exports = cx;

},{}],172:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule emptyFunction
 */

function makeEmptyFunction(arg) {
  return function() {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
function emptyFunction() {}

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function() { return this; };
emptyFunction.thatReturnsArgument = function(arg) { return arg; };

module.exports = emptyFunction;

},{}],173:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule invariant
 */

"use strict";

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if ("production" !== process.env.NODE_ENV) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        'Invariant Violation: ' +
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

}).call(this,require('_process'))

},{"_process":128}],174:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule warning
 */

"use strict";

var emptyFunction = require("./emptyFunction");

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if ("production" !== process.env.NODE_ENV) {
  warning = function(condition, format ) {for (var args=[],$__0=2,$__1=arguments.length;$__0<$__1;$__0++) args.push(arguments[$__0]);
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (!condition) {
      var argIndex = 0;
      console.warn('Warning: ' + format.replace(/%s/g, function()  {return args[argIndex++];}));
    }
  };
}

module.exports = warning;

}).call(this,require('_process'))

},{"./emptyFunction":172,"_process":128}],175:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = require("./runtime");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}

},{"./runtime":176}],176:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);

},{}],177:[function(require,module,exports){
//! stable.js 0.1.8, https://github.com/Two-Screen/stable
//! © 2018 Angry Bytes and contributors. MIT licensed.

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.stable = factory());
}(this, (function () { 'use strict';

  // A stable array sort, because `Array#sort()` is not guaranteed stable.
  // This is an implementation of merge sort, without recursion.

  var stable = function (arr, comp) {
    return exec(arr.slice(), comp)
  };

  stable.inplace = function (arr, comp) {
    var result = exec(arr, comp);

    // This simply copies back if the result isn't in the original array,
    // which happens on an odd number of passes.
    if (result !== arr) {
      pass(result, null, arr.length, arr);
    }

    return arr
  };

  // Execute the sort using the input array and a second buffer as work space.
  // Returns one of those two, containing the final result.
  function exec(arr, comp) {
    if (typeof(comp) !== 'function') {
      comp = function (a, b) {
        return String(a).localeCompare(b)
      };
    }

    // Short-circuit when there's nothing to sort.
    var len = arr.length;
    if (len <= 1) {
      return arr
    }

    // Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.
    // Chunks are the size of the left or right hand in merge sort.
    // Stop when the left-hand covers all of the array.
    var buffer = new Array(len);
    for (var chk = 1; chk < len; chk *= 2) {
      pass(arr, comp, chk, buffer);

      var tmp = arr;
      arr = buffer;
      buffer = tmp;
    }

    return arr
  }

  // Run a single pass with the given chunk size.
  var pass = function (arr, comp, chk, result) {
    var len = arr.length;
    var i = 0;
    // Step size / double chunk size.
    var dbl = chk * 2;
    // Bounds of the left and right chunks.
    var l, r, e;
    // Iterators over the left and right chunk.
    var li, ri;

    // Iterate over pairs of chunks.
    for (l = 0; l < len; l += dbl) {
      r = l + chk;
      e = r + chk;
      if (r > len) r = len;
      if (e > len) e = len;

      // Iterate both chunks in parallel.
      li = l;
      ri = r;
      while (true) {
        // Compare the chunks.
        if (li < r && ri < e) {
          // This works for a regular `sort()` compatible comparator,
          // but also for a simple comparator like: `a > b`
          if (comp(arr[li], arr[ri]) <= 0) {
            result[i++] = arr[li++];
          }
          else {
            result[i++] = arr[ri++];
          }
        }
        // Nothing to compare, just flush what's left.
        else if (li < r) {
          result[i++] = arr[li++];
        }
        else if (ri < e) {
          result[i++] = arr[ri++];
        }
        // Both iterators are at the chunk ends.
        else {
          break
        }
      }
    }
  };

  return stable;

})));

},{}],178:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function (require) {

	var makePromise = require('./makePromise');
	var Scheduler = require('./Scheduler');
	var async = require('./async');

	return makePromise({
		scheduler: new Scheduler(async)
	});

});
})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });

},{"./Scheduler":180,"./async":181,"./makePromise":182}],179:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {
	/**
	 * Circular queue
	 * @param {number} capacityPow2 power of 2 to which this queue's capacity
	 *  will be set initially. eg when capacityPow2 == 3, queue capacity
	 *  will be 8.
	 * @constructor
	 */
	function Queue(capacityPow2) {
		this.head = this.tail = this.length = 0;
		this.buffer = new Array(1 << capacityPow2);
	}

	Queue.prototype.push = function(x) {
		if(this.length === this.buffer.length) {
			this._ensureCapacity(this.length * 2);
		}

		this.buffer[this.tail] = x;
		this.tail = (this.tail + 1) & (this.buffer.length - 1);
		++this.length;
		return this.length;
	};

	Queue.prototype.shift = function() {
		var x = this.buffer[this.head];
		this.buffer[this.head] = void 0;
		this.head = (this.head + 1) & (this.buffer.length - 1);
		--this.length;
		return x;
	};

	Queue.prototype._ensureCapacity = function(capacity) {
		var head = this.head;
		var buffer = this.buffer;
		var newBuffer = new Array(capacity);
		var i = 0;
		var len;

		if(head === 0) {
			len = this.length;
			for(; i<len; ++i) {
				newBuffer[i] = buffer[i];
			}
		} else {
			capacity = buffer.length;
			len = this.tail;
			for(; head<capacity; ++i, ++head) {
				newBuffer[i] = buffer[head];
			}

			for(head=0; head<len; ++i, ++head) {
				newBuffer[i] = buffer[head];
			}
		}

		this.buffer = newBuffer;
		this.head = 0;
		this.tail = this.length;
	};

	return Queue;

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],180:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var Queue = require('./Queue');

	// Credit to Twisol (https://github.com/Twisol) for suggesting
	// this type of extensible queue + trampoline approach for next-tick conflation.

	/**
	 * Async task scheduler
	 * @param {function} async function to schedule a single async function
	 * @constructor
	 */
	function Scheduler(async) {
		this._async = async;
		this._queue = new Queue(15);
		this._afterQueue = new Queue(5);
		this._running = false;

		var self = this;
		this.drain = function() {
			self._drain();
		};
	}

	/**
	 * Enqueue a task
	 * @param {{ run:function }} task
	 */
	Scheduler.prototype.enqueue = function(task) {
		this._add(this._queue, task);
	};

	/**
	 * Enqueue a task to run after the main task queue
	 * @param {{ run:function }} task
	 */
	Scheduler.prototype.afterQueue = function(task) {
		this._add(this._afterQueue, task);
	};

	/**
	 * Drain the handler queue entirely, and then the after queue
	 */
	Scheduler.prototype._drain = function() {
		runQueue(this._queue);
		this._running = false;
		runQueue(this._afterQueue);
	};

	/**
	 * Add a task to the q, and schedule drain if not already scheduled
	 * @param {Queue} queue
	 * @param {{run:function}} task
	 * @private
	 */
	Scheduler.prototype._add = function(queue, task) {
		queue.push(task);
		if(!this._running) {
			this._running = true;
			this._async(this.drain);
		}
	};

	/**
	 * Run all the tasks in the q
	 * @param queue
	 */
	function runQueue(queue) {
		while(queue.length > 0) {
			queue.shift().run();
		}
	}

	return Scheduler;

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"./Queue":179}],181:[function(require,module,exports){
(function (process){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	// Sniff "best" async scheduling option
	// Prefer process.nextTick or MutationObserver, then check for
	// vertx and finally fall back to setTimeout

	/*jshint maxcomplexity:6*/
	/*global process,document,setTimeout,MutationObserver,WebKitMutationObserver*/
	var nextTick, MutationObs;

	if (typeof process !== 'undefined' && process !== null &&
		typeof process.nextTick === 'function') {
		nextTick = function(f) {
			process.nextTick(f);
		};

	} else if (MutationObs =
		(typeof MutationObserver === 'function' && MutationObserver) ||
		(typeof WebKitMutationObserver === 'function' && WebKitMutationObserver)) {
		nextTick = (function (document, MutationObserver) {
			var scheduled;
			var el = document.createElement('div');
			var o = new MutationObserver(run);
			o.observe(el, { attributes: true });

			function run() {
				var f = scheduled;
				scheduled = void 0;
				f();
			}

			return function (f) {
				scheduled = f;
				el.setAttribute('class', 'x');
			};
		}(document, MutationObs));

	} else {
		nextTick = (function(cjsRequire) {
			var vertx;
			try {
				// vert.x 1.x || 2.x
				vertx = cjsRequire('vertx');
			} catch (ignore) {}

			if (vertx) {
				if (typeof vertx.runOnLoop === 'function') {
					return vertx.runOnLoop;
				}
				if (typeof vertx.runOnContext === 'function') {
					return vertx.runOnContext;
				}
			}

			// capture setTimeout to avoid being caught by fake timers
			// used in time based tests
			var capturedSetTimeout = setTimeout;
			return function (t) {
				capturedSetTimeout(t, 0);
			};
		}(require));
	}

	return nextTick;
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

}).call(this,require('_process'))

},{"_process":128}],182:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function makePromise(environment) {

		var tasks = environment.scheduler;

		var objectCreate = Object.create ||
			function(proto) {
				function Child() {}
				Child.prototype = proto;
				return new Child();
			};

		/**
		 * Create a promise whose fate is determined by resolver
		 * @constructor
		 * @returns {Promise} promise
		 * @name Promise
		 */
		function Promise(resolver, handler) {
			this._handler = resolver === Handler ? handler : init(resolver);
		}

		/**
		 * Run the supplied resolver
		 * @param resolver
		 * @returns {Pending}
		 */
		function init(resolver) {
			var handler = new Pending();

			try {
				resolver(promiseResolve, promiseReject, promiseNotify);
			} catch (e) {
				promiseReject(e);
			}

			return handler;

			/**
			 * Transition from pre-resolution state to post-resolution state, notifying
			 * all listeners of the ultimate fulfillment or rejection
			 * @param {*} x resolution value
			 */
			function promiseResolve (x) {
				handler.resolve(x);
			}
			/**
			 * Reject this promise with reason, which will be used verbatim
			 * @param {Error|*} reason rejection reason, strongly suggested
			 *   to be an Error type
			 */
			function promiseReject (reason) {
				handler.reject(reason);
			}

			/**
			 * Issue a progress event, notifying all progress listeners
			 * @param {*} x progress event payload to pass to all listeners
			 */
			function promiseNotify (x) {
				handler.notify(x);
			}
		}

		// Creation

		Promise.resolve = resolve;
		Promise.reject = reject;
		Promise.never = never;

		Promise._defer = defer;
		Promise._handler = getHandler;

		/**
		 * Returns a trusted promise. If x is already a trusted promise, it is
		 * returned, otherwise returns a new trusted Promise which follows x.
		 * @param  {*} x
		 * @return {Promise} promise
		 */
		function resolve(x) {
			return isPromise(x) ? x
				: new Promise(Handler, new Async(getHandler(x)));
		}

		/**
		 * Return a reject promise with x as its reason (x is used verbatim)
		 * @param {*} x
		 * @returns {Promise} rejected promise
		 */
		function reject(x) {
			return new Promise(Handler, new Async(new Rejected(x)));
		}

		/**
		 * Return a promise that remains pending forever
		 * @returns {Promise} forever-pending promise.
		 */
		function never() {
			return foreverPendingPromise; // Should be frozen
		}

		/**
		 * Creates an internal {promise, resolver} pair
		 * @private
		 * @returns {Promise}
		 */
		function defer() {
			return new Promise(Handler, new Pending());
		}

		// Transformation and flow control

		/**
		 * Transform this promise's fulfillment value, returning a new Promise
		 * for the transformed result.  If the promise cannot be fulfilled, onRejected
		 * is called with the reason.  onProgress *may* be called with updates toward
		 * this promise's fulfillment.
		 * @param {function=} onFulfilled fulfillment handler
		 * @param {function=} onRejected rejection handler
		 * @deprecated @param {function=} onProgress progress handler
		 * @return {Promise} new promise
		 */
		Promise.prototype.then = function(onFulfilled, onRejected) {
			var parent = this._handler;
			var state = parent.join().state();

			if ((typeof onFulfilled !== 'function' && state > 0) ||
				(typeof onRejected !== 'function' && state < 0)) {
				// Short circuit: value will not change, simply share handler
				return new this.constructor(Handler, parent);
			}

			var p = this._beget();
			var child = p._handler;

			parent.chain(child, parent.receiver, onFulfilled, onRejected,
					arguments.length > 2 ? arguments[2] : void 0);

			return p;
		};

		/**
		 * If this promise cannot be fulfilled due to an error, call onRejected to
		 * handle the error. Shortcut for .then(undefined, onRejected)
		 * @param {function?} onRejected
		 * @return {Promise}
		 */
		Promise.prototype['catch'] = function(onRejected) {
			return this.then(void 0, onRejected);
		};

		/**
		 * Creates a new, pending promise of the same type as this promise
		 * @private
		 * @returns {Promise}
		 */
		Promise.prototype._beget = function() {
			var parent = this._handler;
			var child = new Pending(parent.receiver, parent.join().context);
			return new this.constructor(Handler, child);
		};

		// Array combinators

		Promise.all = all;
		Promise.race = race;

		/**
		 * Return a promise that will fulfill when all promises in the
		 * input array have fulfilled, or will reject when one of the
		 * promises rejects.
		 * @param {array} promises array of promises
		 * @returns {Promise} promise for array of fulfillment values
		 */
		function all(promises) {
			/*jshint maxcomplexity:8*/
			var resolver = new Pending();
			var pending = promises.length >>> 0;
			var results = new Array(pending);

			var i, h, x, s;
			for (i = 0; i < promises.length; ++i) {
				x = promises[i];

				if (x === void 0 && !(i in promises)) {
					--pending;
					continue;
				}

				if (maybeThenable(x)) {
					h = getHandlerMaybeThenable(x);

					s = h.state();
					if (s === 0) {
						h.fold(settleAt, i, results, resolver);
					} else if (s > 0) {
						results[i] = h.value;
						--pending;
					} else {
						unreportRemaining(promises, i+1, h);
						resolver.become(h);
						break;
					}

				} else {
					results[i] = x;
					--pending;
				}
			}

			if(pending === 0) {
				resolver.become(new Fulfilled(results));
			}

			return new Promise(Handler, resolver);

			function settleAt(i, x, resolver) {
				/*jshint validthis:true*/
				this[i] = x;
				if(--pending === 0) {
					resolver.become(new Fulfilled(this));
				}
			}
		}

		function unreportRemaining(promises, start, rejectedHandler) {
			var i, h, x;
			for(i=start; i<promises.length; ++i) {
				x = promises[i];
				if(maybeThenable(x)) {
					h = getHandlerMaybeThenable(x);

					if(h !== rejectedHandler) {
						h.visit(h, void 0, h._unreport);
					}
				}
			}
		}

		/**
		 * Fulfill-reject competitive race. Return a promise that will settle
		 * to the same state as the earliest input promise to settle.
		 *
		 * WARNING: The ES6 Promise spec requires that race()ing an empty array
		 * must return a promise that is pending forever.  This implementation
		 * returns a singleton forever-pending promise, the same singleton that is
		 * returned by Promise.never(), thus can be checked with ===
		 *
		 * @param {array} promises array of promises to race
		 * @returns {Promise} if input is non-empty, a promise that will settle
		 * to the same outcome as the earliest input promise to settle. if empty
		 * is empty, returns a promise that will never settle.
		 */
		function race(promises) {
			// Sigh, race([]) is untestable unless we return *something*
			// that is recognizable without calling .then() on it.
			if(Object(promises) === promises && promises.length === 0) {
				return never();
			}

			var h = new Pending();
			var i, x;
			for(i=0; i<promises.length; ++i) {
				x = promises[i];
				if (x !== void 0 && i in promises) {
					getHandler(x).visit(h, h.resolve, h.reject);
				}
			}
			return new Promise(Handler, h);
		}

		// Promise internals
		// Below this, everything is @private

		/**
		 * Get an appropriate handler for x, without checking for cycles
		 * @param {*} x
		 * @returns {object} handler
		 */
		function getHandler(x) {
			if(isPromise(x)) {
				return x._handler.join();
			}
			return maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);
		}

		/**
		 * Get a handler for thenable x.
		 * NOTE: You must only call this if maybeThenable(x) == true
		 * @param {object|function|Promise} x
		 * @returns {object} handler
		 */
		function getHandlerMaybeThenable(x) {
			return isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);
		}

		/**
		 * Get a handler for potentially untrusted thenable x
		 * @param {*} x
		 * @returns {object} handler
		 */
		function getHandlerUntrusted(x) {
			try {
				var untrustedThen = x.then;
				return typeof untrustedThen === 'function'
					? new Thenable(untrustedThen, x)
					: new Fulfilled(x);
			} catch(e) {
				return new Rejected(e);
			}
		}

		/**
		 * Handler for a promise that is pending forever
		 * @constructor
		 */
		function Handler() {}

		Handler.prototype.when
			= Handler.prototype.become
			= Handler.prototype.notify
			= Handler.prototype.fail
			= Handler.prototype._unreport
			= Handler.prototype._report
			= noop;

		Handler.prototype._state = 0;

		Handler.prototype.state = function() {
			return this._state;
		};

		/**
		 * Recursively collapse handler chain to find the handler
		 * nearest to the fully resolved value.
		 * @returns {object} handler nearest the fully resolved value
		 */
		Handler.prototype.join = function() {
			var h = this;
			while(h.handler !== void 0) {
				h = h.handler;
			}
			return h;
		};

		Handler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {
			this.when({
				resolver: to,
				receiver: receiver,
				fulfilled: fulfilled,
				rejected: rejected,
				progress: progress
			});
		};

		Handler.prototype.visit = function(receiver, fulfilled, rejected, progress) {
			this.chain(failIfRejected, receiver, fulfilled, rejected, progress);
		};

		Handler.prototype.fold = function(f, z, c, to) {
			this.visit(to, function(x) {
				f.call(c, z, x, this);
			}, to.reject, to.notify);
		};

		/**
		 * Handler that invokes fail() on any handler it becomes
		 * @constructor
		 */
		function FailIfRejected() {}

		inherit(Handler, FailIfRejected);

		FailIfRejected.prototype.become = function(h) {
			h.fail();
		};

		var failIfRejected = new FailIfRejected();

		/**
		 * Handler that manages a queue of consumers waiting on a pending promise
		 * @constructor
		 */
		function Pending(receiver, inheritedContext) {
			Promise.createContext(this, inheritedContext);

			this.consumers = void 0;
			this.receiver = receiver;
			this.handler = void 0;
			this.resolved = false;
		}

		inherit(Handler, Pending);

		Pending.prototype._state = 0;

		Pending.prototype.resolve = function(x) {
			this.become(getHandler(x));
		};

		Pending.prototype.reject = function(x) {
			if(this.resolved) {
				return;
			}

			this.become(new Rejected(x));
		};

		Pending.prototype.join = function() {
			if (!this.resolved) {
				return this;
			}

			var h = this;

			while (h.handler !== void 0) {
				h = h.handler;
				if (h === this) {
					return this.handler = cycle();
				}
			}

			return h;
		};

		Pending.prototype.run = function() {
			var q = this.consumers;
			var handler = this.join();
			this.consumers = void 0;

			for (var i = 0; i < q.length; ++i) {
				handler.when(q[i]);
			}
		};

		Pending.prototype.become = function(handler) {
			if(this.resolved) {
				return;
			}

			this.resolved = true;
			this.handler = handler;
			if(this.consumers !== void 0) {
				tasks.enqueue(this);
			}

			if(this.context !== void 0) {
				handler._report(this.context);
			}
		};

		Pending.prototype.when = function(continuation) {
			if(this.resolved) {
				tasks.enqueue(new ContinuationTask(continuation, this.handler));
			} else {
				if(this.consumers === void 0) {
					this.consumers = [continuation];
				} else {
					this.consumers.push(continuation);
				}
			}
		};

		Pending.prototype.notify = function(x) {
			if(!this.resolved) {
				tasks.enqueue(new ProgressTask(x, this));
			}
		};

		Pending.prototype.fail = function(context) {
			var c = typeof context === 'undefined' ? this.context : context;
			this.resolved && this.handler.join().fail(c);
		};

		Pending.prototype._report = function(context) {
			this.resolved && this.handler.join()._report(context);
		};

		Pending.prototype._unreport = function() {
			this.resolved && this.handler.join()._unreport();
		};

		/**
		 * Wrap another handler and force it into a future stack
		 * @param {object} handler
		 * @constructor
		 */
		function Async(handler) {
			this.handler = handler;
		}

		inherit(Handler, Async);

		Async.prototype.when = function(continuation) {
			tasks.enqueue(new ContinuationTask(continuation, this));
		};

		Async.prototype._report = function(context) {
			this.join()._report(context);
		};

		Async.prototype._unreport = function() {
			this.join()._unreport();
		};

		/**
		 * Handler that wraps an untrusted thenable and assimilates it in a future stack
		 * @param {function} then
		 * @param {{then: function}} thenable
		 * @constructor
		 */
		function Thenable(then, thenable) {
			Pending.call(this);
			tasks.enqueue(new AssimilateTask(then, thenable, this));
		}

		inherit(Pending, Thenable);

		/**
		 * Handler for a fulfilled promise
		 * @param {*} x fulfillment value
		 * @constructor
		 */
		function Fulfilled(x) {
			Promise.createContext(this);
			this.value = x;
		}

		inherit(Handler, Fulfilled);

		Fulfilled.prototype._state = 1;

		Fulfilled.prototype.fold = function(f, z, c, to) {
			runContinuation3(f, z, this, c, to);
		};

		Fulfilled.prototype.when = function(cont) {
			runContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);
		};

		var errorId = 0;

		/**
		 * Handler for a rejected promise
		 * @param {*} x rejection reason
		 * @constructor
		 */
		function Rejected(x) {
			Promise.createContext(this);

			this.id = ++errorId;
			this.value = x;
			this.handled = false;
			this.reported = false;

			this._report();
		}

		inherit(Handler, Rejected);

		Rejected.prototype._state = -1;

		Rejected.prototype.fold = function(f, z, c, to) {
			to.become(this);
		};

		Rejected.prototype.when = function(cont) {
			if(typeof cont.rejected === 'function') {
				this._unreport();
			}
			runContinuation1(cont.rejected, this, cont.receiver, cont.resolver);
		};

		Rejected.prototype._report = function(context) {
			tasks.afterQueue(new ReportTask(this, context));
		};

		Rejected.prototype._unreport = function() {
			this.handled = true;
			tasks.afterQueue(new UnreportTask(this));
		};

		Rejected.prototype.fail = function(context) {
			Promise.onFatalRejection(this, context === void 0 ? this.context : context);
		};

		function ReportTask(rejection, context) {
			this.rejection = rejection;
			this.context = context;
		}

		ReportTask.prototype.run = function() {
			if(!this.rejection.handled) {
				this.rejection.reported = true;
				Promise.onPotentiallyUnhandledRejection(this.rejection, this.context);
			}
		};

		function UnreportTask(rejection) {
			this.rejection = rejection;
		}

		UnreportTask.prototype.run = function() {
			if(this.rejection.reported) {
				Promise.onPotentiallyUnhandledRejectionHandled(this.rejection);
			}
		};

		// Unhandled rejection hooks
		// By default, everything is a noop

		// TODO: Better names: "annotate"?
		Promise.createContext
			= Promise.enterContext
			= Promise.exitContext
			= Promise.onPotentiallyUnhandledRejection
			= Promise.onPotentiallyUnhandledRejectionHandled
			= Promise.onFatalRejection
			= noop;

		// Errors and singletons

		var foreverPendingHandler = new Handler();
		var foreverPendingPromise = new Promise(Handler, foreverPendingHandler);

		function cycle() {
			return new Rejected(new TypeError('Promise cycle'));
		}

		// Task runners

		/**
		 * Run a single consumer
		 * @constructor
		 */
		function ContinuationTask(continuation, handler) {
			this.continuation = continuation;
			this.handler = handler;
		}

		ContinuationTask.prototype.run = function() {
			this.handler.join().when(this.continuation);
		};

		/**
		 * Run a queue of progress handlers
		 * @constructor
		 */
		function ProgressTask(value, handler) {
			this.handler = handler;
			this.value = value;
		}

		ProgressTask.prototype.run = function() {
			var q = this.handler.consumers;
			if(q === void 0) {
				return;
			}

			for (var c, i = 0; i < q.length; ++i) {
				c = q[i];
				runNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);
			}
		};

		/**
		 * Assimilate a thenable, sending it's value to resolver
		 * @param {function} then
		 * @param {object|function} thenable
		 * @param {object} resolver
		 * @constructor
		 */
		function AssimilateTask(then, thenable, resolver) {
			this._then = then;
			this.thenable = thenable;
			this.resolver = resolver;
		}

		AssimilateTask.prototype.run = function() {
			var h = this.resolver;
			tryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);

			function _resolve(x) { h.resolve(x); }
			function _reject(x)  { h.reject(x); }
			function _notify(x)  { h.notify(x); }
		};

		function tryAssimilate(then, thenable, resolve, reject, notify) {
			try {
				then.call(thenable, resolve, reject, notify);
			} catch (e) {
				reject(e);
			}
		}

		// Other helpers

		/**
		 * @param {*} x
		 * @returns {boolean} true iff x is a trusted Promise
		 */
		function isPromise(x) {
			return x instanceof Promise;
		}

		/**
		 * Test just enough to rule out primitives, in order to take faster
		 * paths in some code
		 * @param {*} x
		 * @returns {boolean} false iff x is guaranteed *not* to be a thenable
		 */
		function maybeThenable(x) {
			return (typeof x === 'object' || typeof x === 'function') && x !== null;
		}

		function runContinuation1(f, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}

			Promise.enterContext(h);
			tryCatchReject(f, h.value, receiver, next);
			Promise.exitContext();
		}

		function runContinuation3(f, x, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}

			Promise.enterContext(h);
			tryCatchReject3(f, x, h.value, receiver, next);
			Promise.exitContext();
		}

		function runNotify(f, x, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.notify(x);
			}

			Promise.enterContext(h);
			tryCatchReturn(f, x, receiver, next);
			Promise.exitContext();
		}

		/**
		 * Return f.call(thisArg, x), or if it throws return a rejected promise for
		 * the thrown exception
		 */
		function tryCatchReject(f, x, thisArg, next) {
			try {
				next.become(getHandler(f.call(thisArg, x)));
			} catch(e) {
				next.become(new Rejected(e));
			}
		}

		/**
		 * Same as above, but includes the extra argument parameter.
		 */
		function tryCatchReject3(f, x, y, thisArg, next) {
			try {
				f.call(thisArg, x, y, next);
			} catch(e) {
				next.become(new Rejected(e));
			}
		}

		/**
		 * Return f.call(thisArg, x), or if it throws, *return* the exception
		 */
		function tryCatchReturn(f, x, thisArg, next) {
			try {
				next.notify(f.call(thisArg, x));
			} catch(e) {
				next.notify(e);
			}
		}

		function inherit(Parent, Child) {
			Child.prototype = objectCreate(Parent.prototype);
			Child.prototype.constructor = Child;
		}

		function noop() {}

		return Promise;
	};
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],183:[function(require,module,exports){
module.exports={
  "name": "sequins",
  "version": "0.9.3",
  "description": "Mutable sequences and native data structures (Map, Set, List) following the Immutable.js API",
  "author": "conrad@burningpotato.com",
  "license": "MIT",
  "files": [
    "dist/**"
  ],
  "main": "dist/_sequins.js",
  "module": "dist/sequins.mjs",
  "typings": "dist/sequins.d.ts",
  "scripts": {
    "build": "run-s build:*",
    "build:dist": "broccoli build dist --overwrite",
    "build:pages": "gulp --gulpfile ./resources/gulpfile.js default",
    "build:type-tests": "node ./resources/build-type-tests.js",
    "start:pages": "gulp --gulpfile ./resources/gulpfile.js dev",
    "format": "prettier --write \"{src,pages/src,pages/lib,resources}/**/*.js\"",
    "test": "run-p --aggregate-output test:js test:types",
    "test:__i": "run-p test:js test:types:__i",
    "test:js": "jest",
    "test:types": "run-s build:dist test:types:__i",
    "test:types:__i": "run-s build:type-tests test:types:*:__i",
    "test:types:ts": "run-s build:type-tests test:types:ts:__i",
    "test:types:ts:__i": "tsc",
    "test:no-changes": "./resources/check-changes.sh",
    "verify": "run-s format test:no-changes build test:__i"
  },
  "engines": {
    "yarn": "^1.10.1"
  },
  "devDependencies": {
    "@babel/core": "^7.2.2",
    "@babel/plugin-syntax-typescript": "^7.2.0",
    "@babel/plugin-transform-runtime": "^7.2.0",
    "@babel/preset-env": "7.2.3",
    "@babel/preset-typescript": "^7.1.0",
    "@types/jest": "^23.3.11",
    "babel-core": "^7.0.0-bridge.0",
    "babel-jest": "^23.6.0",
    "babel-plugin-minify-dead-code-elimination": "^0.5.0",
    "broccoli": "^2.0.0-beta.4",
    "broccoli-babel-transpiler": "^7.0.0",
    "broccoli-cli": "^1.0.0",
    "broccoli-merge-trees": "^3.0.1",
    "broccoli-rollup": "^2.1.1",
    "browser-sync": "2.24.4",
    "browserify": "16.2.2",
    "del": "3.0.0",
    "gulp": "3.9.1",
    "gulp-concat": "2.6.1",
    "gulp-filter": "5.1.0",
    "gulp-header": "2.0.5",
    "gulp-less": "3.5.0",
    "gulp-size": "3.0.0",
    "gulp-sourcemaps": "2.6.4",
    "gulp-uglify": "2.1.0",
    "gulp-util": "3.0.8",
    "immutable": "^4.0.0-rc.10",
    "jest": "^23.6.0",
    "marked": "0.3.19",
    "npm-run-all": "^4.1.5",
    "prettier": "^1.15.3",
    "react": "^0.12.0",
    "react-router": "^0.11.2",
    "react-tools": "0.13.3",
    "recursive-readdir": "^2.2.2",
    "rollup-plugin-babel": "^4.0.2",
    "rollup-plugin-commonjs": "^9.1.6",
    "rollup-plugin-node-resolve": "^3.3.0",
    "run-sequence": "2.2.1",
    "typescript": "3.2.2",
    "vinyl-buffer": "1.0.1",
    "vinyl-source-stream": "2.0.0"
  },
  "dependencies": {
    "@babel/runtime": "^7.0.0",
    "invariant": "^2.2.4",
    "iter-tools": "^6.1.8-next.3",
    "stable": "^0.1.8"
  },
  "resolutions": {
    "babel-core": "7.0.0-bridge.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js"
    ],
    "setupTestFrameworkScriptFile": "<rootDir>/src/__test__/helpers/framework-setup.js",
    "coveragePathIgnorePatterns": [
      "/node_modules/",
      "/__test__/"
    ]
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/conartist6/sequins.git"
  },
  "keywords": [
    "mutable",
    "immutable",
    "map",
    "set",
    "list",
    "stable",
    "sort",
    "sequence",
    "seq",
    "iter-tools",
    "es6",
    "es2015"
  ],
  "bugs": {
    "url": "https://github.com/conartist6/sequins/issues"
  },
  "homepage": "https://github.com/conartist6/sequins#readme"
}

},{}],184:[function(require,module,exports){
module.exports={"groups":[{"title":"Concrete","members":{"List":{"class":{"isClass":true,"constructor":{"signatures":[{"typeParams":["T"],"params":[{"name":"collection","type":{"k":11,"name":"Iterable","args":[{"k":10,"param":"T"}]}}],"type":{"k":11,"name":"List","args":[{"k":10,"param":"T"}]},"line":24},{"params":[{"name":"collection","type":{"k":1},"optional":true}],"type":{"k":11,"name":"List","args":[{"k":0}]},"line":25},{"typeParams":["T"],"type":{"k":11,"name":"List","args":[{"k":10,"param":"T"}]},"line":26}]},"statics":{"isList":{"doc":{"synopsis":"True if the provided value is a List","description":"<!-- runkit:activate\n  { \"preamble\": \"const { List } = require('sequins');\" }\n-->\n```js\nList.isList([]); // false\nList.isList(new List()); // true\n```","notes":[]},"signatures":[{"params":[{"name":"maybeList","type":{"k":0}}],"type":{"k":3},"line":39}]},"of":{"doc":{"synopsis":"Creates a new Sequins List containing `values`.","description":"<!-- runkit:activate\n  { \"preamble\": \"const { List } = require('sequins');\" }\n-->\n```js\nList.of(1, 2, 3, 4)\n// List [ 1, 2, 3, 4 ]\n```\n\nNote: Values are not altered or converted in any way.\n\n<!-- runkit:activate\n  { \"preamble\": \"const { List } = require('sequins');\" }\n-->\n```js\nList.of({x:1}, 2, [3], 4)\n// List [ { x: 1 }, 2, [ 3 ], 4 ]\n```","notes":[]},"signatures":[{"typeParams":["T"],"params":[{"name":"values","type":{"k":11,"name":"Array","args":[{"k":10,"param":"T"}]},"varArgs":true}],"type":{"k":11,"name":"List","args":[{"k":10,"param":"T"}]},"line":62}]}},"line":79,"doc":{"synopsis":"List is a dense `Indexed` `Collection` backed by a JavaScript array.\nList shares its peformance charactersitics with array too. `get`, `set`,\n`push`, and `pop` are all O(1) on lists. `shift` and `unshift` are O(n).","description":"Unlike a JavaScript Array, there is no distinction between an\n\"unset\" index and an index set to `undefined`. `List#forEach` visits all\nindices from 0 to size, regardless of whether they were explicitly defined.","notes":[]},"typeParams":["T"],"extends":[{"k":11,"name":"Concrete","args":[{"k":4},{"k":10,"param":"T"}]}],"implements":[{"k":11,"name":"Indexed","args":[{"k":10,"param":"T"}]}],"groups":[{"members":{"#size":{"line":83}}},{"title":"Persistent changes","members":{"#set":{"doc":{"synopsis":"Sets `index` to `value`.","description":"`index` may be a negative number, which indexes back from the end of the\nList. `v.set(-1, \"value\")` sets the last item in the List.\n\nIf `index` larger than `size`, the returned List's `size` will be large\nenough to include the `index`.\n\n<!-- runkit:activate\n     { \"preamble\": \"const { List } = require('sequins');\" }\n-->\n```js\nconst originalList = List([ 0 ]);\n// List [ 0 ]\noriginalList.set(1, 1);\n// List [ 0, 1 ]\noriginalList.set(0, 'overwritten');\n// List [ \"overwritten\" ]\noriginalList.set(2, 2);\n// List [ 0, undefined, 2 ]\n\nnew List().set(50000, 'value').size;\n// 50001\n```","notes":[]},"signatures":[{"params":[{"name":"index","type":{"k":4}},{"name":"value","type":{"k":10,"param":"T"}}],"type":{"k":11,"name":"List","args":[{"k":10,"param":"T"}]},"line":113}]},"#delete":{"doc":{"synopsis":"Removes the value at `index` from the list. Values at indices above\n`index` are shifted down by 1 to fill the position.","description":"This is synonymous with `list.splice(index, 1)`.\n\n`index` may be a negative number, which indexes back from the end of the\nList. `v.delete(-1)` deletes the last item in the List.\n\nNote: `delete` cannot be safely used in IE8\n\n<!-- runkit:activate\n     { \"preamble\": \"const { List } = require('sequins');\" }\n-->\n```js\nnew List([ 0, 1, 2, 3, 4 ]).delete(0);\n// List [ 1, 2, 3, 4 ]\n```\n","notes":[{"name":"alias","body":"remove"}]},"signatures":[{"params":[{"name":"index","type":{"k":4}}],"type":{"k":11,"name":"List","args":[{"k":10,"param":"T"}]},"line":136}]},"#insert":{"doc":{"synopsis":"Inserts `value` at `index` in the list. Values at indices above\n`index` are shifted over by 1.","description":"This is synonymous with `list.splice(index, 0, value)`.\n\n<!-- runkit:activate\n     { \"preamble\": \"const { List } = require('sequins');\" }\n-->\n```js\nnew List([ 0, 1, 2, 3, 4 ]).insert(6, 5)\n// List [ 0, 1, 2, 3, 4, 5 ]\n```","notes":[]},"signatures":[{"params":[{"name":"index","type":{"k":4}},{"name":"value","type":{"k":10,"param":"T"}}],"type":{"k":11,"name":"List","args":[{"k":10,"param":"T"}]},"line":153}]},"#clear":{"doc":{"synopsis":"Removes all values from the list.","description":"<!-- runkit:activate\n     { \"preamble\": \"const { List } = require('sequins');\" }\n-->\n```js\nnew List([ 1, 2, 3, 4 ]).clear()\n// List []\n```","notes":[]},"signatures":[{"type":{"k":11,"name":"List","args":[{"k":10,"param":"T"}]},"line":166}]},"#push":{"doc":{"synopsis":"Appends `values` to the end of the list.","description":"<!-- runkit:activate\n     { \"preamble\": \"const { List } = require('sequins');\" }\n-->\n```js\nnew List([ 1, 2, 3, 4 ]).push(5)\n// List [ 1, 2, 3, 4, 5 ]\n```","notes":[]},"signatures":[{"params":[{"name":"values","type":{"k":11,"name":"Array","args":[{"k":10,"param":"T"}]},"varArgs":true}],"type":{"k":11,"name":"List","args":[{"k":10,"param":"T"}]},"line":179}]},"#pop":{"doc":{"synopsis":"Removes the last value from the list and returns it.","description":"```js\nnew List([ 1, 2, 3, 4 ]).pop()\n// List[ 1, 2, 3 ]\n```","notes":[]},"signatures":[{"type":{"k":11,"name":"List","args":[{"k":10,"param":"T"}]},"line":189}]},"#unshift":{"doc":{"synopsis":"Inserts `values` at the beginning of the list. Note that this will\nrequire shifting every item in the list, and will take O(n) time.","description":"<!-- runkit:activate\n     { \"preamble\": \"const { List } = require('sequins');\" }\n-->\n```js\nnew List([ 2, 3, 4]).unshift(1);\n// List [ 1, 2, 3, 4 ]\n```","notes":[]},"signatures":[{"params":[{"name":"values","type":{"k":11,"name":"Array","args":[{"k":10,"param":"T"}]},"varArgs":true}],"type":{"k":11,"name":"List","args":[{"k":10,"param":"T"}]},"line":203}]},"#shift":{"doc":{"synopsis":"Removes the first value from the list and returns it. Note that\nthis will require shifting every item in the list, and will take O(n)\ntime.","description":"<!-- runkit:activate\n     { \"preamble\": \"const { List } = require('sequins');\" }\n-->\n```js\nnew List([ 0, 1, 2, 3, 4 ]).shift();\n// List [ 1, 2, 3, 4 ]\n```","notes":[]},"signatures":[{"type":{"k":11,"name":"List","args":[{"k":10,"param":"T"}]},"line":218}]},"#setSize":{"doc":{"synopsis":"Sets list's `size`. If `size` is less than the list's size, values at\nhigher indices will be excluded. If `size` is greater than the list's\nsize, newly created indicies will have undefined values.","description":"","notes":[]},"signatures":[{"params":[{"name":"size","type":{"k":4}}],"type":{"k":11,"name":"List","args":[{"k":10,"param":"T"}]},"line":225}]}}},{"title":"Sequence algorithms","members":{"#concat":{"doc":{"synopsis":"Returns a new List with other values or collections concatenated to this one.\n","description":"","notes":[{"name":"alias","body":"merge"}]},"signatures":[{"typeParams":["C"],"params":[{"name":"valuesOrCollections","type":{"k":11,"name":"Array","args":[{"k":14,"types":[{"k":11,"name":"Iterable","args":[{"k":10,"param":"C"}]},{"k":10,"param":"C"}]}]},"varArgs":true}],"type":{"k":11,"name":"List","args":[{"k":14,"types":[{"k":10,"param":"T"},{"k":10,"param":"C"}]}]},"line":234}]},"#map":{"doc":{"synopsis":"Returns a new List with values passed through a\n`mapper` function.","description":"<!-- runkit:activate\n     { \"preamble\": \"const { List } = require('sequins');\" }\n-->\n```js\nnew List([ 1, 2 ]).map(x => 10 * x)\n// List [ 10, 20 ]\n```","notes":[]},"signatures":[{"typeParams":["M"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"key","type":{"k":4}},{"name":"iter","type":{"k":12}}],"type":{"k":10,"param":"M"}}}],"type":{"k":11,"name":"List","args":[{"k":10,"param":"M"}]},"line":249}]},"#flatten":{"doc":{"synopsis":"","description":"","notes":[{"name":"see","body":"Collection.flatten"}]},"signatures":[{"params":[{"name":"depth","type":{"k":4},"optional":true}],"type":{"k":11,"name":"List","args":[{"k":0}]},"line":254},{"params":[{"name":"shallow","type":{"k":3},"optional":true}],"type":{"k":11,"name":"List","args":[{"k":0}]},"line":255}]},"#flatMap":{"doc":{"synopsis":"Flat-maps the List, returning a new List.","description":"Similar to `list.map(...).flatten(true)`.","notes":[]},"signatures":[{"typeParams":["M"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"key","type":{"k":4}},{"name":"iter","type":{"k":12}}],"type":{"k":11,"name":"Iterable","args":[{"k":10,"param":"M"}]}}}],"type":{"k":11,"name":"List","args":[{"k":10,"param":"M"}]},"line":262}]},"#filter":{"doc":{"synopsis":"Returns a new List with only the values for which the `predicate`\nfunction returns true.","description":"","notes":[]},"signatures":[{"typeParams":["F"],"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"index","type":{"k":4}},{"name":"iter","type":{"k":12}}],"type":{"k":3}}}],"type":{"k":11,"name":"List","args":[{"k":10,"param":"F"}]},"line":270},{"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"index","type":{"k":4}},{"name":"iter","type":{"k":12}}],"type":{"k":0}}}],"type":{"k":12},"line":273}]},"#zip":{"doc":{"synopsis":"Returns a List \"zipped\" with the provided collection.","description":"Like `zipWith`, but using the default `zipper`: creating an `Array`.\n\n<!-- runkit:activate\n     { \"preamble\": \"const { List } = require('sequins');\" }\n-->\n```js\nconst a = new List([ 1, 2, 3 ]);\nconst b = new List([ 4, 5, 6 ]);\nconst c = a.zip(b); // List [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]\n```","notes":[]},"signatures":[{"typeParams":["U"],"params":[{"name":"other","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"U"}]}}],"type":{"k":11,"name":"List","args":[{"k":16,"types":[{"k":10,"param":"T"},{"k":10,"param":"U"}]}]},"line":289},{"typeParams":["U","V"],"params":[{"name":"other","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"U"}]}},{"name":"other2","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"V"}]}}],"type":{"k":11,"name":"List","args":[{"k":16,"types":[{"k":10,"param":"T"},{"k":10,"param":"U"},{"k":10,"param":"V"}]}]},"line":290},{"params":[{"name":"collections","type":{"k":11,"name":"Array","args":[{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":0}]}]},"varArgs":true}],"type":{"k":11,"name":"List","args":[{"k":0}]},"line":294}]},"#zipAll":{"doc":{"synopsis":"Returns a List \"zipped\" with the provided collections.","description":"Unlike `zip`, `zipAll` continues zipping until the longest collection is\nexhausted. Missing values from shorter collections are filled with `undefined`.\n\n<!-- runkit:activate\n     { \"preamble\": \"const { List } = require('sequins');\" }\n-->\n```js\nconst a = new List([ 1, 2 ]);\nconst b = new List([ 3, 4, 5 ]);\nconst c = a.zipAll(b); // List [ [ 1, 3 ], [ 2, 4 ], [ undefined, 5 ] ]\n```\n\nNote: Since zipAll will return a collection as large as the largest\ninput, some results may contain undefined values. TypeScript cannot\naccount for these without cases (as of v2.5).","notes":[]},"signatures":[{"typeParams":["U"],"params":[{"name":"other","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"U"}]}}],"type":{"k":11,"name":"List","args":[{"k":16,"types":[{"k":10,"param":"T"},{"k":10,"param":"U"}]}]},"line":315},{"typeParams":["U","V"],"params":[{"name":"other","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"U"}]}},{"name":"other2","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"V"}]}}],"type":{"k":11,"name":"List","args":[{"k":16,"types":[{"k":10,"param":"T"},{"k":10,"param":"U"},{"k":10,"param":"V"}]}]},"line":316},{"params":[{"name":"collections","type":{"k":11,"name":"Array","args":[{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":0}]}]},"varArgs":true}],"type":{"k":11,"name":"List","args":[{"k":0}]},"line":320}]},"#zipWith":{"doc":{"synopsis":"Returns a List \"zipped\" with the provided collections by using a\ncustom `zipper` function.","description":"<!-- runkit:activate\n     { \"preamble\": \"const { List } = require('sequins');\" }\n-->\n```js\nconst a = new List([ 1, 2, 3 ]);\nconst b = new List([ 4, 5, 6 ]);\nconst c = a.zipWith((a, b) => a + b, b);\n// List [ 5, 7, 9 ]\n```","notes":[]},"signatures":[{"typeParams":["U","Z"],"params":[{"name":"zipper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"otherValue","type":{"k":10,"param":"U"}}],"type":{"k":10,"param":"Z"}}},{"name":"otherCollection","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"U"}]}}],"type":{"k":11,"name":"List","args":[{"k":10,"param":"Z"}]},"line":336},{"typeParams":["U","V","Z"],"params":[{"name":"zipper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"otherValue","type":{"k":10,"param":"U"}},{"name":"thirdValue","type":{"k":10,"param":"V"}}],"type":{"k":10,"param":"Z"}}},{"name":"otherCollection","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"U"}]}},{"name":"thirdCollection","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"V"}]}}],"type":{"k":11,"name":"List","args":[{"k":10,"param":"Z"}]},"line":340},{"typeParams":["Z"],"params":[{"name":"zipper","type":{"k":9,"params":[{"name":"any","type":{"k":11,"name":"Array","args":[{"k":0}]},"varArgs":true}],"type":{"k":10,"param":"Z"}}},{"name":"collections","type":{"k":11,"name":"Array","args":[{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":0}]}]},"varArgs":true}],"type":{"k":11,"name":"List","args":[{"k":10,"param":"Z"}]},"line":345}]}}},{"title":"Combination","members":{"#interpose":{"doc":{"synopsis":"Returns a List with `separator` between each item.","description":"<!-- runkit:activate\n     { \"preamble\": \"const { List } = require('sequins');\" }\n-->\n```js\nnew List([ 1, 2, 3 ]).interpose(null);\n// List [ 1, null, 2, null, 3]\n```","notes":[]},"signatures":[{"typeParams":["S"],"params":[{"name":"separator","type":{"k":10,"param":"S"}}],"type":{"k":11,"name":"List","args":[{"k":14,"types":[{"k":10,"param":"S"},{"k":10,"param":"T"}]}]},"line":363}]}}},{"title":"Conversions","members":{"#toJS":{"doc":{"synopsis":"Deeply converts all nested structures to Objects and Arrays.","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"Array","args":[{"k":0}]},"line":370}]},"#toJSON":{"doc":{"synopsis":"Returns an Array containing the values from the List.","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"Array","args":[{"k":10,"param":"T"}]},"line":375}]},"#toConcrete":{"signatures":[{"type":{"k":12},"line":377}]},"#toSeq":{"doc":{"synopsis":"Returns an `IndexedSequence` of the values from the List.","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"IndexedSequence","args":[{"k":10,"param":"T"}]},"line":382}]}}}]}},"Map":{"class":{"isClass":true,"constructor":{"signatures":[{"typeParams":["K","V"],"params":[{"name":"entries","type":{"k":11,"name":"Iterable","args":[{"k":16,"types":[{"k":10,"param":"K"},{"k":10,"param":"V"}]}]}}],"type":{"k":11,"name":"Map","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]},"line":396},{"typeParams":["K","V"],"params":[{"name":"collection","type":{"k":11,"name":"Collection","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]}}],"type":{"k":11,"name":"Map","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]},"line":397},{"typeParams":["V"],"params":[{"name":"obj","type":{"k":6,"members":[{"index":true,"params":[{"name":"key","type":{"k":5}}],"type":{"k":10,"param":"V"}}]}}],"type":{"k":11,"name":"Map","args":[{"k":5},{"k":10,"param":"V"}]},"line":398},{"params":[{"name":"entries","type":{"k":1},"optional":true}],"type":{"k":11,"name":"Map","args":[{"k":0},{"k":0}]},"line":399},{"typeParams":["K","V"],"type":{"k":11,"name":"Map","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]},"line":400}]},"statics":{"isMap":{"doc":{"synopsis":"True if the provided value is a Map","description":"<!-- runkit:activate\n  { \"preamble\": \"const { Map } = require('sequins');\" }\n-->\n```js\nMap.isMap({}) // false\nMap.isMap(new Map()) // true\n```","notes":[]},"signatures":[{"params":[{"name":"maybeMap","type":{"k":0}}],"type":{"k":3},"line":413}]}},"line":433,"doc":{"synopsis":"Map is a `Keyed` `Collection` of `[key, value]` tuples with\nO(1) `get` and `set`. Its API is fully compatible with that of\n[JavaScript Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map),\nbut the Sequins Map class delegates to a native Map for storage as\nopposed to extending the native Map class.","description":"Map's keys can be of any type. This allows the use of any value\n(including NaN) as a key. Strict identity is used to evaluate key\nequality. Two similar looking objects, for example, when both used as\nkeys, will store two separate values.","notes":[]},"typeParams":["K","V"],"extends":[{"k":11,"name":"Concrete","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]}],"implements":[{"k":11,"name":"Keyed","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]}],"groups":[{"members":{"#size":{"line":437}}},{"title":"Persistent changes","members":{"#set":{"doc":{"synopsis":"Sets `key` to `value`. If an equivalent the key already exists in\nthe map, it will be replaced.","description":"<!-- runkit:activate\n  { \"preamble\": \"const { Map } = require('sequins');\" }\n-->\n```js\nconst originalMap = Map()\nconst newerMap = originalMap.set('key', 'value')\nconst newestMap = newerMap.set('key', 'newer value')\n\noriginalMap\n// Map {}\nnewerMap\n// Map { \"key\": \"value\" }\nnewestMap\n// Map { \"key\": \"newer value\" }\n```","notes":[]},"signatures":[{"params":[{"name":"key","type":{"k":10,"param":"K"}},{"name":"value","type":{"k":10,"param":"V"}}],"type":{"k":12},"line":461}]},"#delete":{"doc":{"synopsis":"Removes `key` and its associated value from the map.","description":"Note: `delete` cannot be safely used in IE8, but is provided to mirror\nthe ES6 collection API.\n\n<!-- runkit:activate\n  { \"preamble\": \"const { Map } = require('sequins');\" }\n-->\n```js\nconst originalMap = Map({\n  key: 'value',\n  otherKey: 'other value'\n})\n// Map { \"key\": \"value\", \"otherKey\": \"other value\" }\noriginalMap.delete('otherKey')\n// Map { \"key\": \"value\" }\n```\n","notes":[{"name":"alias","body":"remove"}]},"signatures":[{"params":[{"name":"key","type":{"k":10,"param":"K"}}],"type":{"k":12},"line":484}]},"#clear":{"doc":{"synopsis":"Removes all keys and values from the map.","description":"<!-- runkit:activate\n  { \"preamble\": \"const { Map } = require('sequins');\" }\n-->\n```js\nnew Map({ key: 'value' }).clear()\n// Map {}\n```","notes":[]},"signatures":[{"type":{"k":12},"line":498}]},"#merge":{"doc":{"synopsis":"Returns a new Map resulting from merging the provided Collections\n(or JS objects) into this Map. In other words, this takes each entry of\neach collection and sets it on this Map.","description":"Note: Values provided to `merge` are shallowly converted before being\nmerged. No nested values are altered.\n\n<!-- runkit:activate\n  { \"preamble\": \"const { Map } = require('sequins');\" }\n-->\n```js\nconst one = new Map({ a: 10, b: 20, c: 30 })\nconst two = new Map({ b: 40, a: 50, d: 60 })\none.merge(two) // Map { \"a\": 50, \"b\": 40, \"c\": 30, \"d\": 60 }\ntwo.merge(one) // Map { \"b\": 20, \"a\": 10, \"d\": 60, \"c\": 30 }\n```\n","notes":[{"name":"alias","body":"concat"}]},"signatures":[{"typeParams":["KC","VC"],"params":[{"name":"collections","type":{"k":11,"name":"Array","args":[{"k":11,"name":"Iterable","args":[{"k":16,"types":[{"k":10,"param":"KC"},{"k":10,"param":"VC"}]}]}]},"varArgs":true}],"type":{"k":11,"name":"Map","args":[{"k":14,"types":[{"k":10,"param":"K"},{"k":10,"param":"KC"}]},{"k":14,"types":[{"k":10,"param":"V"},{"k":10,"param":"VC"}]}]},"line":520},{"typeParams":["C"],"params":[{"name":"collections","type":{"k":11,"name":"Array","args":[{"k":6,"members":[{"index":true,"params":[{"name":"key","type":{"k":5}}],"type":{"k":10,"param":"C"}}]}]},"varArgs":true}],"type":{"k":11,"name":"Map","args":[{"k":14,"types":[{"k":10,"param":"K"},{"k":5}]},{"k":14,"types":[{"k":10,"param":"V"},{"k":10,"param":"C"}]}]},"line":521}]}}},{"title":"Sequence algorithms","members":{"#map":{"doc":{"synopsis":"Returns a new Map with values passed through a\n`mapper` function.","description":"    new Map({ a: 1, b: 2 }).map(x => 10 * x)\n    // Map { a: 10, b: 20 }","notes":[]},"signatures":[{"typeParams":["M"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"iter","type":{"k":12}}],"type":{"k":10,"param":"M"}}}],"type":{"k":11,"name":"Map","args":[{"k":10,"param":"K"},{"k":10,"param":"M"}]},"line":538}]},"#mapKeys":{"doc":{"synopsis":"","description":"","notes":[{"name":"see","body":"Keyed.mapKeys"}]},"signatures":[{"typeParams":["M"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"key","type":{"k":10,"param":"K"}},{"name":"value","type":{"k":10,"param":"V"}},{"name":"iter","type":{"k":12}}],"type":{"k":10,"param":"M"}}}],"type":{"k":11,"name":"Map","args":[{"k":10,"param":"M"},{"k":10,"param":"V"}]},"line":543}]},"#mapEntries":{"doc":{"synopsis":"","description":"","notes":[{"name":"see","body":"Keyed.mapEntries"}]},"signatures":[{"typeParams":["KM","VM"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"entry","type":{"k":16,"types":[{"k":10,"param":"K"},{"k":10,"param":"V"}]}},{"name":"index","type":{"k":4}},{"name":"iter","type":{"k":12}}],"type":{"k":16,"types":[{"k":10,"param":"KM"},{"k":10,"param":"VM"}]}}}],"type":{"k":11,"name":"Map","args":[{"k":10,"param":"KM"},{"k":10,"param":"VM"}]},"line":548}]},"#flatten":{"doc":{"synopsis":"","description":"","notes":[{"name":"see","body":"Collection.flatten"}]},"signatures":[{"params":[{"name":"depth","type":{"k":4},"optional":true}],"type":{"k":11,"name":"Map","args":[{"k":0},{"k":0}]},"line":555},{"params":[{"name":"shallow","type":{"k":3},"optional":true}],"type":{"k":11,"name":"Map","args":[{"k":0},{"k":0}]},"line":556}]},"#flatMap":{"doc":{"synopsis":"Flat-maps the Map, returning a new Map.","description":"Similar to `data.map(...).flatten(true)`.","notes":[]},"signatures":[{"typeParams":["KM","VM"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"iter","type":{"k":12}}],"type":{"k":11,"name":"Iterable","args":[{"k":16,"types":[{"k":10,"param":"KM"},{"k":10,"param":"VM"}]}]}}}],"type":{"k":11,"name":"Map","args":[{"k":10,"param":"KM"},{"k":10,"param":"VM"}]},"line":563}]},"#filter":{"doc":{"synopsis":"Returns a new Map with only the entries for which the `predicate`\nfunction returns true.","description":"","notes":[]},"signatures":[{"typeParams":["F"],"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"iter","type":{"k":12}}],"type":{"k":3}}}],"type":{"k":11,"name":"Map","args":[{"k":10,"param":"K"},{"k":10,"param":"F"}]},"line":571},{"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"iter","type":{"k":12}}],"type":{"k":0}}}],"type":{"k":12},"line":574}]},"#flip":{"doc":{"synopsis":"","description":"","notes":[{"name":"see","body":"Keyed.flip"}]},"signatures":[{"type":{"k":11,"name":"Map","args":[{"k":10,"param":"V"},{"k":10,"param":"K"}]},"line":579}]}}},{"title":"Conversions","members":{"#toJS":{"doc":{"synopsis":"Deeply converts all nested structures to Objects and Arrays.","description":"","notes":[]},"signatures":[{"type":{"k":6,"members":[{"index":true,"params":[{"name":"key","type":{"k":5}}],"type":{"k":0}}]},"line":586}]},"#toJSON":{"doc":{"synopsis":"Returns an Object with the keys (stringified) and values from the Map.","description":"","notes":[]},"signatures":[{"type":{"k":6,"members":[{"index":true,"params":[{"name":"key","type":{"k":5}}],"type":{"k":10,"param":"V"}}]},"line":591}]},"#toConcrete":{"signatures":[{"type":{"k":12},"line":593}]},"#toSeq":{"doc":{"synopsis":"Returns an `KeyedSequence` of the entries from the List.","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"KeyedSequence","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]},"line":598}]}}}]}},"Set":{"class":{"isClass":true,"constructor":{"signatures":[{"typeParams":["T"],"params":[{"name":"collection","type":{"k":11,"name":"Iterable","args":[{"k":10,"param":"T"}]}}],"type":{"k":11,"name":"Set","args":[{"k":10,"param":"T"}]},"line":604},{"params":[{"name":"collection","type":{"k":1},"optional":true}],"type":{"k":11,"name":"Set","args":[{"k":0}]},"line":605},{"typeParams":["T"],"type":{"k":11,"name":"Set","args":[{"k":10,"param":"T"}]},"line":606}]},"statics":{"isSet":{"doc":{"synopsis":"True if the provided value is a Set","description":"","notes":[]},"signatures":[{"params":[{"name":"maybeSet","type":{"k":0}}],"type":{"k":3},"line":611}]},"of":{"doc":{"synopsis":"Creates a new Set containing `values`.","description":"","notes":[]},"signatures":[{"typeParams":["T"],"params":[{"name":"values","type":{"k":11,"name":"Array","args":[{"k":10,"param":"T"}]},"varArgs":true}],"type":{"k":11,"name":"Set","args":[{"k":10,"param":"T"}]},"line":616}]},"fromKeys":{"signatures":[{"typeParams":["T"],"params":[{"name":"iter","type":{"k":11,"name":"Collection","args":[{"k":10,"param":"T"},{"k":0}]}}],"type":{"k":11,"name":"Set","args":[{"k":10,"param":"T"}]},"line":622},{"params":[{"name":"obj","type":{"k":6,"members":[{"index":true,"params":[{"name":"key","type":{"k":5}}],"type":{"k":0}}]}}],"type":{"k":11,"name":"Set","args":[{"k":5}]},"line":623},{"type":{"k":11,"name":"Set","args":[{"k":0}]},"line":624}]},"union":{"doc":{"synopsis":"`Set.union()` creates a new Set that includes all members present in any\ninput Set.","description":"If an input is an associative iterable, its values are considered the Set.\n\n```js\nconst { Set } = require('immutable')\nconst unioned = Set.union([\n  Set([ 'a', 'b', 'c' ])\n  Set([ 'c', 'a', 't' ])\n])\n// Set [ \"a\", \"b\", \"c\", \"t\"\" ]\n```","notes":[]},"signatures":[{"typeParams":["T"],"params":[{"name":"sets","type":{"k":11,"name":"Array","args":[{"k":11,"name":"Iterable","args":[{"k":10,"param":"T"}]}]},"varArgs":true}],"type":{"k":11,"name":"Set","args":[{"k":10,"param":"T"}]},"line":641}]},"intersect":{"doc":{"synopsis":"`Set.intersect()` creates a new Set that includes only members that are\npresent in all input Sets.","description":"If an input is an associative iterable, its values are considered the Set.\n\n```js\nconst { Set } = require('immutable')\nconst intersected = Set.intersect([\n  Set([ 'a', 'b', 'c' ])\n  Set([ 'c', 'a', 't' ])\n])\n// Set [ \"a\", \"c\"\" ]\n```","notes":[]},"signatures":[{"typeParams":["T"],"params":[{"name":"sets","type":{"k":11,"name":"Array","args":[{"k":11,"name":"Iterable","args":[{"k":10,"param":"T"}]}]},"varArgs":true}],"type":{"k":11,"name":"Set","args":[{"k":10,"param":"T"}]},"line":658}]}},"line":678,"doc":{"synopsis":"Set is a `Duplicated` `Collection` of unique values with O(1) `add` and `has`.\nIts API is fully compatible with that of\n[JavaScript Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set),\nbut the Sequins Set class delegates to a native Set for storage as\nopposed to extending the native Set class.","description":"When iterating a Set, the entries will be [value, value] tuples.\n\nSet values, like Map keys, may be of any type including other collections\nand NaN.","notes":[]},"typeParams":["T"],"extends":[{"k":11,"name":"Concrete","args":[{"k":10,"param":"T"},{"k":10,"param":"T"}]}],"implements":[{"k":11,"name":"Duplicated","args":[{"k":10,"param":"T"}]}],"groups":[{"members":{"#size":{"line":682}}},{"title":"Persistent changes","members":{"#add":{"doc":{"synopsis":"Adds value to the set.","description":"","notes":[]},"signatures":[{"params":[{"name":"value","type":{"k":10,"param":"T"}}],"type":{"k":12},"line":689}]},"#delete":{"doc":{"synopsis":"Removes value from the set.","description":"Note: `delete` **cannot** be safely used in IE8, use `remove` if\nsupporting old browsers.\n","notes":[{"name":"alias","body":"remove"}]},"signatures":[{"params":[{"name":"value","type":{"k":10,"param":"T"}}],"type":{"k":12},"line":699}]},"#clear":{"doc":{"synopsis":"Clears all keys and values from the set","description":"","notes":[]},"signatures":[{"type":{"k":12},"line":705}]},"#union":{"doc":{"synopsis":"Returns a Set including any value from `collections` that does not already\nexist in this Set.","description":"","notes":[{"name":"alias","body":"merge"},{"name":"alias","body":"concat"}]},"signatures":[{"typeParams":["C"],"params":[{"name":"collections","type":{"k":11,"name":"Array","args":[{"k":11,"name":"Iterable","args":[{"k":10,"param":"C"}]}]},"varArgs":true}],"type":{"k":11,"name":"Set","args":[{"k":14,"types":[{"k":10,"param":"T"},{"k":10,"param":"C"}]}]},"line":713}]},"#intersect":{"doc":{"synopsis":"Returns a Set which has removed any values not also contained\nwithin `collections`.","description":"","notes":[]},"signatures":[{"params":[{"name":"collections","type":{"k":11,"name":"Array","args":[{"k":11,"name":"Iterable","args":[{"k":10,"param":"T"}]}]},"varArgs":true}],"type":{"k":12},"line":721}]},"#subtract":{"doc":{"synopsis":"Returns a Set excluding any values contained within `collections`.","description":"<!-- runkit:activate\n  { \"preamble\": \"const { Set } = require('sequins');\" }\n-->\n```js\nnew Set([ 1, 2, 3 ]).subtract([1, 3])\n// Set [2]\n```","notes":[]},"signatures":[{"params":[{"name":"collections","type":{"k":11,"name":"Array","args":[{"k":11,"name":"Iterable","args":[{"k":10,"param":"T"}]}]},"varArgs":true}],"type":{"k":12},"line":734}]}}},{"title":"Sequence algorithms","members":{"#map":{"doc":{"synopsis":"Returns a new Set with values passed through a\n`mapper` function.","description":"    new Set([1,2]).map(x => 10 * x)\n    // Set [10,20]","notes":[]},"signatures":[{"typeParams":["M"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"key","type":{"k":10,"param":"T"}},{"name":"iter","type":{"k":12}}],"type":{"k":10,"param":"M"}}}],"type":{"k":11,"name":"Set","args":[{"k":10,"param":"M"}]},"line":745}]},"#flatten":{"doc":{"synopsis":"","description":"","notes":[{"name":"see","body":"Collection.flatten"}]},"signatures":[{"params":[{"name":"depth","type":{"k":4},"optional":true}],"type":{"k":11,"name":"Set","args":[{"k":0}]},"line":750},{"params":[{"name":"shallow","type":{"k":3},"optional":true}],"type":{"k":11,"name":"Set","args":[{"k":0}]},"line":751}]},"#flatMap":{"doc":{"synopsis":"Flat-maps the Set, returning a new Set.","description":"Similar to `set.map(...).flatten(true)`.","notes":[]},"signatures":[{"typeParams":["M"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"key","type":{"k":10,"param":"T"}},{"name":"iter","type":{"k":12}}],"type":{"k":11,"name":"Iterable","args":[{"k":10,"param":"M"}]}}}],"type":{"k":11,"name":"Set","args":[{"k":10,"param":"M"}]},"line":758}]},"#filter":{"doc":{"synopsis":"Returns a new Set with only the values for which the `predicate`\nfunction returns true.","description":"","notes":[]},"signatures":[{"typeParams":["F"],"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"key","type":{"k":10,"param":"T"}},{"name":"iter","type":{"k":12}}],"type":{"k":3}}}],"type":{"k":11,"name":"Set","args":[{"k":10,"param":"F"}]},"line":764},{"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"key","type":{"k":10,"param":"T"}},{"name":"iter","type":{"k":12}}],"type":{"k":0}}}],"type":{"k":12},"line":767}]}}},{"title":"Conversions","members":{"#toJS":{"doc":{"synopsis":"Deeply converts all nested structures to Objects and Arrays.","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"Array","args":[{"k":0}]},"line":774}]},"#toJSON":{"doc":{"synopsis":"Returns an Array with the values from the Set.","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"Array","args":[{"k":10,"param":"T"}]},"line":779}]},"#toConcrete":{"signatures":[{"type":{"k":12},"line":781}]},"#toSeq":{"doc":{"synopsis":"Returns a `SetSequence` of the values from the Set.","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"SetSequence","args":[{"k":10,"param":"T"}]},"line":786}]}}}]}}}},{"title":"Sequence","members":{"IndexedSequence":{"class":{"isClass":true,"constructor":{"signatures":[{"typeParams":["T"],"params":[{"name":"collection","type":{"k":11,"name":"Iterable","args":[{"k":10,"param":"T"}]}}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":10,"param":"T"}]},"line":794},{"params":[{"name":"collection","type":{"k":1},"optional":true}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":0}]},"line":795},{"typeParams":["T"],"type":{"k":11,"name":"IndexedSequence","args":[{"k":10,"param":"T"}]},"line":796}]},"statics":{"of":{"doc":{"synopsis":"Creates a new IndexedSequence containing `values`.","description":"","notes":[]},"signatures":[{"typeParams":["T"],"params":[{"name":"values","type":{"k":11,"name":"Array","args":[{"k":10,"param":"T"}]},"varArgs":true}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":10,"param":"T"}]},"line":801}]}},"line":818,"doc":{"synopsis":"An IndexedSequence is quite simply an `Indexed` `Sequence`. It represents\nsequential transformations against Array or List-like data as a series of\nchained function calls. The chain of calls will usually be terminated with\n`toList`.","description":"When constructing an IndexedSequence from another data type, keys will be\ndiscarded.","notes":[]},"typeParams":["T"],"extends":[{"k":11,"name":"Sequence","args":[{"k":4},{"k":10,"param":"T"}]}],"implements":[{"k":11,"name":"Indexed","args":[{"k":10,"param":"T"}]}],"groups":[{"title":"Combination","members":{"#concat":{"doc":{"synopsis":"Returns a new IndexedSequence with other collections concatenated to this\none.","description":"","notes":[]},"signatures":[{"typeParams":["C"],"params":[{"name":"valuesOrCollections","type":{"k":11,"name":"Array","args":[{"k":14,"types":[{"k":11,"name":"Iterable","args":[{"k":10,"param":"C"}]},{"k":10,"param":"C"}]}]},"varArgs":true}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":14,"types":[{"k":10,"param":"T"},{"k":10,"param":"C"}]}]},"line":825}]},"#interpose":{"doc":{"synopsis":"Returns an IndexedSequence with `separator` between each item.","description":"<!-- runkit:activate\n     { \"preamble\": \"const { List } = require('sequins');\" }\n-->\n```js\nnew IndexedSequence([ 1, 2, 3 ]).interpose(null);\n// IndexedSequence [ 1, null, 2, null, 3]\n```","notes":[]},"signatures":[{"typeParams":["S"],"params":[{"name":"separator","type":{"k":10,"param":"S"}}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":14,"types":[{"k":10,"param":"S"},{"k":10,"param":"T"}]}]},"line":840}]}}},{"title":"Sequence algorithms","members":{"#map":{"doc":{"synopsis":"Returns a new IndexedSequence with values passed through a\n`mapper` function.","description":"<!-- runkit:activate\n  { \"preamble\": \"const { Seq } = require('sequins');\" }\n-->\n```js\nIndexedSequence([ 1, 2 ]).map(x => 10 * x)\n// Seq [ 10, 20 ]\n```","notes":[]},"signatures":[{"typeParams":["M"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"key","type":{"k":4}}],"type":{"k":10,"param":"M"}}}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":10,"param":"M"}]},"line":856}]},"#tap":{"doc":{"synopsis":"Does not alter the sequence, but allows you to inspect values as they are\ncomptued. Returns the sequence for chaining. Unlike `forEach`, tap does not\nevaluate the sequence.","description":"```js\nconst seq = IndexedSequence([ 1, 2 ]).tap(x => console.log(x))\nArray.from(seq); // logs 1, 2\n```","notes":[]},"signatures":[{"params":[{"name":"fn","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"key","type":{"k":4}}],"type":{"k":0}}}],"type":{"k":12},"line":868}]},"#flatten":{"doc":{"synopsis":"","description":"","notes":[{"name":"see","body":"Collection.flatten"}]},"signatures":[{"params":[{"name":"depth","type":{"k":4},"optional":true}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":0}]},"line":873},{"params":[{"name":"shallow","type":{"k":3},"optional":true}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":0}]},"line":874}]},"#flatMap":{"doc":{"synopsis":"Flat-maps the IndexedSequence, returning an IndexedSequence.","description":"Similar to `seq.map(...).flatten(true)`.","notes":[]},"signatures":[{"typeParams":["M"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"key","type":{"k":4}}],"type":{"k":11,"name":"Iterable","args":[{"k":10,"param":"M"}]}}}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":10,"param":"M"}]},"line":881}]},"#filter":{"doc":{"synopsis":"Returns a new IndexedSequence with only the values for which the\n`predicate` function returns true.","description":"","notes":[]},"signatures":[{"typeParams":["F"],"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"index","type":{"k":4}}],"type":{"k":3}}}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":10,"param":"F"}]},"line":889},{"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"index","type":{"k":4}}],"type":{"k":0}}}],"type":{"k":12},"line":892}]},"#zip":{"doc":{"synopsis":"Returns a new IndexedSequence \"zipped\" with the provided collections.","description":"Like `zipWith`, but using the default `zipper`: creating an `Array`.\n\n```js\nconst a = Seq([ 1, 2, 3 ]);\nconst b = Seq([ 4, 5, 6 ]);\nconst c = a.zip(b); // Seq [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]\n```","notes":[]},"signatures":[{"typeParams":["U"],"params":[{"name":"other","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"U"}]}}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":16,"types":[{"k":10,"param":"T"},{"k":10,"param":"U"}]}]},"line":905},{"typeParams":["U","V"],"params":[{"name":"other","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"U"}]}},{"name":"other2","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"V"}]}}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":16,"types":[{"k":10,"param":"T"},{"k":10,"param":"U"},{"k":10,"param":"V"}]}]},"line":906},{"params":[{"name":"collections","type":{"k":11,"name":"Array","args":[{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":0}]}]},"varArgs":true}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":0}]},"line":910}]},"#zipAll":{"doc":{"synopsis":"Returns a new IndexedSequence \"zipped\" with the provided collections.\nContinues until the longest collection is exhausted.","description":"Missing values from shorter collections are filled with `undefined`.\n\n```js\nconst a = Seq([ 1, 2 ]);\nconst b = Seq([ 3, 4, 5 ]);\nconst c = a.zipAll(b); // Seq [ [ 1, 3 ], [ 2, 4 ], [ undefined, 5 ] ]\n```","notes":[]},"signatures":[{"typeParams":["U"],"params":[{"name":"other","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"U"}]}}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":16,"types":[{"k":10,"param":"T"},{"k":10,"param":"U"}]}]},"line":924},{"typeParams":["U","V"],"params":[{"name":"other","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"U"}]}},{"name":"other2","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"V"}]}}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":16,"types":[{"k":10,"param":"T"},{"k":10,"param":"U"},{"k":10,"param":"V"}]}]},"line":925},{"params":[{"name":"collections","type":{"k":11,"name":"Array","args":[{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":0}]}]},"varArgs":true}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":0}]},"line":929}]},"#zipWith":{"doc":{"synopsis":"Returns a new IndexedSequence \"zipped\" with the provided collections by\nusing a custom `zipper` function.","description":"```js\nconst a = Seq([ 1, 2, 3 ]);\nconst b = Seq([ 4, 5, 6 ]);\nconst c = a.zipWith((a, b) => a + b, b);\n// Seq [ 5, 7, 9 ]\n```","notes":[]},"signatures":[{"typeParams":["U","Z"],"params":[{"name":"zipper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"otherValue","type":{"k":10,"param":"U"}}],"type":{"k":10,"param":"Z"}}},{"name":"otherCollection","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"U"}]}}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":10,"param":"Z"}]},"line":942},{"typeParams":["U","V","Z"],"params":[{"name":"zipper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"otherValue","type":{"k":10,"param":"U"}},{"name":"thirdValue","type":{"k":10,"param":"V"}}],"type":{"k":10,"param":"Z"}}},{"name":"otherCollection","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"U"}]}},{"name":"thirdCollection","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"V"}]}}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":10,"param":"Z"}]},"line":946},{"typeParams":["Z"],"params":[{"name":"zipper","type":{"k":9,"params":[{"name":"any","type":{"k":11,"name":"Array","args":[{"k":0}]},"varArgs":true}],"type":{"k":10,"param":"Z"}}},{"name":"collections","type":{"k":11,"name":"Array","args":[{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":0}]}]},"varArgs":true}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":10,"param":"Z"}]},"line":951}]}}},{"title":"Conversions","members":{"#toConcrete":{"doc":{"synopsis":"Returns a `List` of the sequence's values","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"List","args":[{"k":10,"param":"T"}]},"line":961}]},"#toSeq":{"doc":{"synopsis":"Returns itself","description":"","notes":[]},"signatures":[{"type":{"k":12},"line":966}]},"#toJS":{"doc":{"synopsis":"Deeply converts this IndexedSequence to equivalent native JavaScript\nArray.","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"Array","args":[{"k":0}]},"line":972}]},"#toJSON":{"doc":{"synopsis":"Shallowly converts this IndexedSequence to equivalent native JavaScript\nArray.","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"Array","args":[{"k":10,"param":"T"}]},"line":978}]}}}]}},"KeyedSequence":{"class":{"isClass":true,"constructor":{"signatures":[{"typeParams":["K","V"],"params":[{"name":"entries","type":{"k":11,"name":"Iterable","args":[{"k":16,"types":[{"k":10,"param":"K"},{"k":10,"param":"V"}]}]}}],"type":{"k":11,"name":"KeyedSequence","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]},"line":992},{"typeParams":["K","V"],"params":[{"name":"collection","type":{"k":11,"name":"Collection","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]}}],"type":{"k":11,"name":"KeyedSequence","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]},"line":993},{"typeParams":["V"],"params":[{"name":"obj","type":{"k":6,"members":[{"index":true,"params":[{"name":"key","type":{"k":5}}],"type":{"k":10,"param":"V"}}]}}],"type":{"k":11,"name":"KeyedSequence","args":[{"k":5},{"k":10,"param":"V"}]},"line":994},{"params":[{"name":"entries","type":{"k":1},"optional":true}],"type":{"k":11,"name":"KeyedSequence","args":[{"k":0},{"k":0}]},"line":995},{"typeParams":["K","V"],"type":{"k":11,"name":"KeyedSequence","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]},"line":996}]},"line":1014,"doc":{"synopsis":"A KeyedSequence is, as expected, a `Keyed` `Sequence`. It represents\nsequential transformations on Object or Map-like data as a series of\nchained function calls. Note that a KeyedSequence lacks the key-coalescing\nproperty of a `Map`. Duplicate keys will be eliminated when calling `as(Map)`\nwhich will usually be the last call in the chain.","description":"When constructing a KeyedSequence pass either keyed data or an iterable of\n[K, V] tuples.","notes":[]},"typeParams":["K","V"],"extends":[{"k":11,"name":"Sequence","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]}],"implements":[{"k":11,"name":"Keyed","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]}],"groups":[{"members":{"#concat":{"doc":{"synopsis":"Returns a new KeyedSequence with other collections concatenated to this one.","description":"All entries will be present in the resulting KeyedSequence, even if they\nhave the same key.","notes":[]},"signatures":[{"typeParams":["KC","VC"],"params":[{"name":"collections","type":{"k":11,"name":"Array","args":[{"k":11,"name":"Iterable","args":[{"k":16,"types":[{"k":10,"param":"KC"},{"k":10,"param":"VC"}]}]}]},"varArgs":true}],"type":{"k":11,"name":"KeyedSequence","args":[{"k":14,"types":[{"k":10,"param":"K"},{"k":10,"param":"KC"}]},{"k":14,"types":[{"k":10,"param":"V"},{"k":10,"param":"VC"}]}]},"line":1021},{"typeParams":["C"],"params":[{"name":"collections","type":{"k":11,"name":"Array","args":[{"k":6,"members":[{"index":true,"params":[{"name":"key","type":{"k":5}}],"type":{"k":10,"param":"C"}}]}]},"varArgs":true}],"type":{"k":11,"name":"KeyedSequence","args":[{"k":14,"types":[{"k":10,"param":"K"},{"k":5}]},{"k":14,"types":[{"k":10,"param":"V"},{"k":10,"param":"C"}]}]},"line":1024}]},"#map":{"doc":{"synopsis":"Returns a new KeyedSequence with values passed through a\n`mapper` function.","description":"<!-- runkit:activate\n  { \"preamble\": \"const { KeyedSequence } = require('sequins');\" }\n-->\n```js\nKeyedSequence({ a: 1, b: 2 }).map(x => 10 * x)\n// Seq { \"a\": 10, \"b\": 20 }\n```","notes":[]},"signatures":[{"typeParams":["M"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}}],"type":{"k":10,"param":"M"}}}],"type":{"k":11,"name":"KeyedSequence","args":[{"k":10,"param":"K"},{"k":10,"param":"M"}]},"line":1040}]},"#mapKeys":{"doc":{"synopsis":"","description":"","notes":[{"name":"see","body":"Keyed.mapKeys"}]},"signatures":[{"typeParams":["M"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"key","type":{"k":10,"param":"K"}},{"name":"value","type":{"k":10,"param":"V"}}],"type":{"k":10,"param":"M"}}}],"type":{"k":11,"name":"KeyedSequence","args":[{"k":10,"param":"M"},{"k":10,"param":"V"}]},"line":1045}]},"#mapEntries":{"doc":{"synopsis":"","description":"","notes":[{"name":"see","body":"Keyed.mapEntries"}]},"signatures":[{"typeParams":["KM","VM"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"entry","type":{"k":16,"types":[{"k":10,"param":"K"},{"k":10,"param":"V"}]}},{"name":"index","type":{"k":4}}],"type":{"k":16,"types":[{"k":10,"param":"KM"},{"k":10,"param":"VM"}]}}}],"type":{"k":11,"name":"KeyedSequence","args":[{"k":10,"param":"KM"},{"k":10,"param":"VM"}]},"line":1050}]},"#tap":{"doc":{"synopsis":"Does not alter the sequence, but allows you to inspect keys and values as\nthey are comptued. Returns the sequence for chaining. Unlike `forEach`, tap\ndoes not evaluate the sequence.","description":"```js\nconst seq = KeyedSequence([[1, 1], [2, 2]]).tap(x => console.log(x))\nArray.from(seq); // logs 1, 2\n```","notes":[]},"signatures":[{"params":[{"name":"fn","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}}],"type":{"k":0}}}],"type":{"k":11,"name":"KeyedSequence","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]},"line":1064}]},"#flatten":{"doc":{"synopsis":"","description":"","notes":[{"name":"see","body":"Collection.flatten"}]},"signatures":[{"params":[{"name":"depth","type":{"k":4},"optional":true}],"type":{"k":11,"name":"KeyedSequence","args":[{"k":0},{"k":0}]},"line":1069},{"params":[{"name":"shallow","type":{"k":3},"optional":true}],"type":{"k":11,"name":"KeyedSequence","args":[{"k":0},{"k":0}]},"line":1070}]},"#flatMap":{"doc":{"synopsis":"Flat-maps the KeyedSequence, returning a new KeyedSequence.","description":"Similar to `seq.map(...).flatten(true)`.","notes":[]},"signatures":[{"typeParams":["KM","VM"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}}],"type":{"k":11,"name":"Iterable","args":[{"k":16,"types":[{"k":10,"param":"KM"},{"k":10,"param":"VM"}]}]}}}],"type":{"k":11,"name":"KeyedSequence","args":[{"k":10,"param":"KM"},{"k":10,"param":"VM"}]},"line":1077}]},"#filter":{"doc":{"synopsis":"Returns a new KeyedSequence with only the entries for which the `predicate`\nfunction returns true.","description":"","notes":[]},"signatures":[{"typeParams":["F"],"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}}],"type":{"k":3}}}],"type":{"k":11,"name":"KeyedSequence","args":[{"k":10,"param":"K"},{"k":10,"param":"F"}]},"line":1085},{"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}}],"type":{"k":0}}}],"type":{"k":12},"line":1088}]},"#flip":{"doc":{"synopsis":"","description":"","notes":[{"name":"see","body":"Keyed.flip"}]},"signatures":[{"type":{"k":11,"name":"KeyedSequence","args":[{"k":10,"param":"V"},{"k":10,"param":"K"}]},"line":1093}]}}},{"title":"Conversions","members":{"#toJS":{"doc":{"synopsis":"Deeply converts this KeyedSequence to equivalent native JavaScript Object.","description":"Converts keys to Strings.","notes":[]},"signatures":[{"type":{"k":11,"name":"Object"},"line":1102}]},"#toJSON":{"doc":{"synopsis":"Shallowly converts this KeyedSequence to equivalent native JavaScript Object.","description":"Converts keys to Strings.","notes":[]},"signatures":[{"type":{"k":6,"members":[{"index":true,"params":[{"name":"key","type":{"k":5}}],"type":{"k":10,"param":"V"}}]},"line":1109}]},"#toConcrete":{"doc":{"synopsis":"Returns a `Map` of the entries from this sequence.","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"Map","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]},"line":1114}]},"#toSeq":{"doc":{"synopsis":"Returns itself","description":"","notes":[]},"signatures":[{"type":{"k":12},"line":1119}]}}}]}},"SetSequence":{"class":{"isClass":true,"constructor":{"signatures":[{"typeParams":["T"],"params":[{"name":"collection","type":{"k":11,"name":"Iterable","args":[{"k":10,"param":"T"}]}}],"type":{"k":11,"name":"SetSequence","args":[{"k":10,"param":"T"}]},"line":1125},{"params":[{"name":"collection","type":{"k":1},"optional":true}],"type":{"k":11,"name":"SetSequence","args":[{"k":0}]},"line":1126},{"typeParams":["T"],"type":{"k":11,"name":"SetSequence","args":[{"k":10,"param":"T"}]},"line":1127}]},"statics":{"of":{"doc":{"synopsis":"Creates a new SetSequence containing `values`.","description":"","notes":[]},"signatures":[{"typeParams":["T"],"params":[{"name":"values","type":{"k":11,"name":"Array","args":[{"k":10,"param":"T"}]},"varArgs":true}],"type":{"k":11,"name":"SetSequence","args":[{"k":10,"param":"T"}]},"line":1132}]}},"line":1151,"doc":{"synopsis":"A SetSequence is a `Duplicated` `Sequence`. It represents sequntial\ntransformations on Set-like data as a series of chained function calls.\nNote that a SetSequence is allowed to contain duplicate values. Such\nduplicates will be eliminated when using `as(Set)` or a similar method to\nconvert back to a concrete type after the desired transformations are\nmade.","description":"When constructing a SetSequence from another data type, any associated\nindices or keys are discareded.","notes":[]},"typeParams":["T"],"extends":[{"k":11,"name":"Sequence","args":[{"k":10,"param":"T"},{"k":10,"param":"T"}]}],"implements":[{"k":11,"name":"Duplicated","args":[{"k":10,"param":"T"}]}],"groups":[{"members":{"#concat":{"doc":{"synopsis":"Returns a new SetSequence with other collections concatenated to this one.","description":"All entries will be present in the resulting SetSequence, even if they\nare duplicates.","notes":[]},"signatures":[{"typeParams":["U"],"params":[{"name":"collections","type":{"k":11,"name":"Array","args":[{"k":11,"name":"Iterable","args":[{"k":10,"param":"U"}]}]},"varArgs":true}],"type":{"k":11,"name":"SetSequence","args":[{"k":14,"types":[{"k":10,"param":"T"},{"k":10,"param":"U"}]}]},"line":1158}]},"#map":{"doc":{"synopsis":"Returns a new SetSequence with values passed through a\n`mapper` function.","description":"```js\nSetSequence([ 1, 2 ]).map(x => 10 * x)\n// Seq { 10, 20 }\n```","notes":[]},"signatures":[{"typeParams":["M"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"key","type":{"k":10,"param":"T"}}],"type":{"k":10,"param":"M"}}}],"type":{"k":11,"name":"SetSequence","args":[{"k":10,"param":"M"}]},"line":1169}]},"#tap":{"doc":{"synopsis":"Does not alter the sequence, but allows you to inspect values as they are\ncomptued. Returns the sequence for chaining. Unlike `forEach`, tap does not\nevaluate the sequence.","description":"```js\nconst seq = SetSequence([ 1, 2 ]).tap(x => console.log(x))\nArray.from(seq); // logs 1, 2\n```","notes":[]},"signatures":[{"params":[{"name":"fn","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"key","type":{"k":10,"param":"T"}}],"type":{"k":0}}}],"type":{"k":12},"line":1181}]},"#flatten":{"doc":{"synopsis":"","description":"","notes":[{"name":"see","body":"Collection.flatten"}]},"signatures":[{"params":[{"name":"depth","type":{"k":4},"optional":true}],"type":{"k":11,"name":"SetSequence","args":[{"k":0}]},"line":1186},{"params":[{"name":"shallow","type":{"k":3},"optional":true}],"type":{"k":11,"name":"SetSequence","args":[{"k":0}]},"line":1187}]},"#flatMap":{"doc":{"synopsis":"Flat-maps the SetSequence, returning a SetSequence.","description":"Similar to `seq.map(...).flatten(true)`.","notes":[]},"signatures":[{"typeParams":["M"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"key","type":{"k":10,"param":"T"}}],"type":{"k":11,"name":"Iterable","args":[{"k":10,"param":"M"}]}}}],"type":{"k":11,"name":"SetSequence","args":[{"k":10,"param":"M"}]},"line":1194}]},"#filter":{"doc":{"synopsis":"Returns a new SetSequence with only the values for which the `predicate`\nfunction returns true.","description":"","notes":[]},"signatures":[{"typeParams":["F"],"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"key","type":{"k":10,"param":"T"}}],"type":{"k":3}}}],"type":{"k":11,"name":"SetSequence","args":[{"k":10,"param":"F"}]},"line":1200},{"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"key","type":{"k":10,"param":"T"}}],"type":{"k":0}}}],"type":{"k":12},"line":1203}]}}},{"title":"Conversion","members":{"#toJS":{"doc":{"synopsis":"Deeply converts this SetSequence to equivalent native JavaScript Array.","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"Array","args":[{"k":0}]},"line":1209}]},"#toJSON":{"doc":{"synopsis":"Shallowly converts this SetSequence to equivalent native JavaScript Array.","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"Array","args":[{"k":10,"param":"T"}]},"line":1214}]},"#toConcrete":{"doc":{"synopsis":"Returns a `Set` of the values from this sequence.","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"Set","args":[{"k":10,"param":"T"}]},"line":1219}]},"#toSeq":{"doc":{"synopsis":"Returns itself","description":"","notes":[]},"signatures":[{"type":{"k":12},"line":1224}]}}}]}},"Seq":{"call":{"signatures":[{"typeParams":["S"],"params":[{"name":"seq","type":{"k":10,"param":"S"}}],"type":{"k":10,"param":"S"},"line":1229},{"typeParams":["K","V"],"params":[{"name":"collection","type":{"k":11,"name":"Keyed","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]}}],"type":{"k":11,"name":"KeyedSequence","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]},"line":1230},{"typeParams":["T"],"params":[{"name":"collection","type":{"k":11,"name":"Indexed","args":[{"k":10,"param":"T"}]}}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":10,"param":"T"}]},"line":1231},{"typeParams":["T"],"params":[{"name":"collection","type":{"k":11,"name":"Duplicated","args":[{"k":10,"param":"T"}]}}],"type":{"k":11,"name":"SetSequence","args":[{"k":10,"param":"T"}]},"line":1232},{"typeParams":["T"],"params":[{"name":"collection","type":{"k":11,"name":"Iterable","args":[{"k":10,"param":"T"}]}}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":10,"param":"T"}]},"line":1233},{"typeParams":["V"],"params":[{"name":"obj","type":{"k":6,"members":[{"index":true,"params":[{"name":"key","type":{"k":5}}],"type":{"k":10,"param":"V"}}]}}],"type":{"k":11,"name":"KeyedSequence","args":[{"k":5},{"k":10,"param":"V"}]},"line":1234},{"params":[{"name":"collection","type":{"k":1},"optional":true}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":0}]},"line":1235}]},"doc":{"synopsis":"Seq is a helper function for creating instances of `Sequence`. Given any argument,\nSeq will make a best-effort guess as to the appropriate `Sequence` subtype, and\nwill return an instance of it. The desired Sequence type can be selected by using\none of the nested functions: `Seq.Indexed`, `Seq.Keyed`, or `Seq.Set`.","description":"Seq's best-effort selection of subtypes uses the following logic:\n\n  * If a `Collection` a `Sequence` of the same subtype as the collection\n  * If an Array-like or Iterable, an `IndexedSequence`.\n  * If an Object, a `KeyedSequence`.\n","notes":[{"name":"constructs","body":""}]},"module":{"isSeq":{"call":{"doc":{"synopsis":"True if `maybeSeq` is a Sequence, it is not backed by a concrete\nstructure such as Map, List, or Set.","description":"","notes":[]},"signatures":[{"params":[{"name":"maybeSeq","type":{"k":0}}],"type":{"k":3},"line":1256}]}},"Keyed":{"call":{"doc":{"synopsis":"Factory function for convenient construction of `KeyedSequence` instances\n","description":"","notes":[{"name":"constructs","body":""}]},"signatures":[{"typeParams":["K","V"],"params":[{"name":"collection","type":{"k":11,"name":"Iterable","args":[{"k":16,"types":[{"k":10,"param":"K"},{"k":10,"param":"V"}]}]}}],"type":{"k":11,"name":"KeyedSequence","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]},"line":1268},{"typeParams":["V"],"params":[{"name":"obj","type":{"k":6,"members":[{"index":true,"params":[{"name":"key","type":{"k":5}}],"type":{"k":10,"param":"V"}}]}}],"type":{"k":11,"name":"KeyedSequence","args":[{"k":5},{"k":10,"param":"V"}]},"line":1271},{"typeParams":["K","V"],"type":{"k":11,"name":"KeyedSequence","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]},"line":1272},{"type":{"k":11,"name":"KeyedSequence","args":[{"k":0},{"k":0}]},"line":1273}]}},"Indexed":{"module":{"of":{"call":{"doc":{"synopsis":"Provides an IndexedSequence of the values provided.","description":"","notes":[]},"signatures":[{"typeParams":["T"],"params":[{"name":"values","type":{"k":11,"name":"Array","args":[{"k":10,"param":"T"}]},"varArgs":true}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":10,"param":"T"}]},"line":1279}]}}},"call":{"doc":{"synopsis":"Factory function for convenient construction of `IndexedSequence` instances\n","description":"","notes":[{"name":"constructs","body":""}]},"signatures":[{"type":{"k":11,"name":"IndexedSequence","args":[{"k":0}]},"line":1287},{"typeParams":["T"],"type":{"k":11,"name":"IndexedSequence","args":[{"k":10,"param":"T"}]},"line":1288},{"typeParams":["T"],"params":[{"name":"collection","type":{"k":11,"name":"Iterable","args":[{"k":10,"param":"T"}]}}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":10,"param":"T"}]},"line":1289}]}},"Set":{"module":{"of":{"call":{"doc":{"synopsis":"Returns a SetSequence of the provided values","description":"","notes":[]},"signatures":[{"typeParams":["T"],"params":[{"name":"values","type":{"k":11,"name":"Array","args":[{"k":10,"param":"T"}]},"varArgs":true}],"type":{"k":11,"name":"SetSequence","args":[{"k":10,"param":"T"}]},"line":1295}]}}},"call":{"doc":{"synopsis":"Factory function for convenient construction of `SetSequence` instances\n","description":"","notes":[{"name":"constructs","body":""}]},"signatures":[{"type":{"k":11,"name":"SetSequence","args":[{"k":0}]},"line":1303},{"typeParams":["T"],"type":{"k":11,"name":"SetSequence","args":[{"k":10,"param":"T"}]},"line":1304},{"typeParams":["T"],"params":[{"name":"collection","type":{"k":11,"name":"Iterable","args":[{"k":10,"param":"T"}]}}],"type":{"k":11,"name":"SetSequence","args":[{"k":10,"param":"T"}]},"line":1305}]}}}}}},{"title":"Abstract","members":{"Concrete":{"interface":{"line":1320,"doc":{"synopsis":"Concretes are a type of `Collection` which store their own data\nand have O(1) random access. It is the base class for `List`, `Map`, and\n`Set`.","description":"","notes":[]},"typeParams":["K","V"],"extends":[{"k":11,"name":"Collection","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]}],"groups":[{"title":"Reading values","members":{"#get":{"doc":{"synopsis":"Returns the value associated with the provided key, or notSetValue if\nthe Collection does not contain this key.","description":"Note: it is possible a key may be associated with an `undefined` value,\nso if `notSetValue` is not provided and this method returns `undefined`,\nthat does not guarantee the key was not found.","notes":[]},"signatures":[{"typeParams":["NSV"],"params":[{"name":"key","type":{"k":10,"param":"K"}},{"name":"notSetValue","type":{"k":10,"param":"NSV"}}],"type":{"k":14,"types":[{"k":10,"param":"V"},{"k":10,"param":"NSV"}]},"line":1331},{"params":[{"name":"key","type":{"k":10,"param":"K"}}],"type":{"k":14,"types":[{"k":10,"param":"V"},{"k":13}]},"line":1332}]},"#has":{"doc":{"synopsis":"True if a key exists within this `Collection`.\nto determine equality","description":"","notes":[]},"signatures":[{"params":[{"name":"key","type":{"k":10,"param":"K"}}],"type":{"k":3},"line":1338}]},"#includes":{"doc":{"synopsis":"True if a value exists within this `Collection`.","description":"","notes":[{"name":"alias","body":"contains"}]},"signatures":[{"params":[{"name":"value","type":{"k":10,"param":"V"}}],"type":{"k":3},"line":1344}]},"#first":{"doc":{"synopsis":"In case the `Collection` is not empty returns the first element of the\n`Collection`.\nIn case the `Collection` is empty returns the optional default\nvalue if provided, if no default value is provided returns undefined.","description":"","notes":[]},"signatures":[{"typeParams":["NSV"],"params":[{"name":"notSetValue","type":{"k":10,"param":"NSV"},"optional":true}],"type":{"k":14,"types":[{"k":10,"param":"V"},{"k":10,"param":"NSV"}]},"line":1353}]}}},{"title":"Reducing a value","members":{"#isEmpty":{"doc":{"synopsis":"Returns true if this Collection includes no values.","description":"For some lazy `Seq`, `isEmpty` might need to iterate to determine\nemptiness. At most one iteration will occur.","notes":[]},"signatures":[{"type":{"k":3},"line":1363}]}}}]}},"Sequence":{"interface":{"line":1416,"doc":{"synopsis":"Sequence is the abstract base class for describing efficient, lazy\ntransformations. Sequences never store their own data, instead they\ndescribe how to compute values (or keys) using a series of transforms against\nsome source data. Sequences are immutable with regards to which transforms\nthey apply, but as their source data is mutable applying the sequence\ntransformations more than once may yield different results if the source data\nhas changed. Sequence subtypes are `IndexedSequence`, `KeyedSequence`,\nand `SetSequence`.","description":"Why are Sequences efficient? Both a sequence and a concrete\nstructure may be transformed through chanined operations like\n`nums.filter(x => x > 0).map(x => x + 1)`. The difference is in how they\nexecute. A concrete structure will do all the mapping (and store it) and\nthen do all the filtering on the mapped results. A sequence executes value\nby value not transform by transform. The filter function will read numbers\nuntil it finds one greater than 0 then the mapper function will\nadd one to it. Only then will a second value be read.\n\nThis method of working gives sequences their laziness, because Sequence\nvalues are consumed and operators applied to them only on demand. Values\ngenerated by a sequence are not implicitly cached or stored. This means\nthat Sequences can even have infintely many items. Take for example this way\nof expressing the concept of \"the first n natural numbers:\"\n\n<!-- runkit:activate\n  { \"preamble\": \"const { Range } = require('sequins');\" }\n-->\n```js\nfunction naturals(n) {\n  return Range(1, Infinity).slice(0, n).as(Array)\n}\nnaturals(3); // [1, 2, 3]\n```\nWe move smoothly past our inability to store a list of infinite size,\nbecause slice will only ever request three values from Range.\n\nBecause seuqences need not cache intermediate states, they shine when\nworking with multiple transforms on lists which may not be infinite but\nare simply very large. In practical terms they allow the programmer to\nreduce memory usage at the cost of CPU cycles.\n\nFinally, Sequence is often used to provide a rich collection API to JavaScript\nObject.\n\n```js\nSeq({ x: 0, y: 1, z: 2 }).map(v => v * 2).as(Object);\n// { x: 0, y: 2, z: 4 }\n```","notes":[]},"typeParams":["K","V"],"extends":[{"k":11,"name":"Collection","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]}],"groups":[{"title":"Sequence algorithms","members":{"#map":{"doc":{"synopsis":"Returns a new Sequence with values passed through a\n`mapper` function.","description":"<!-- runkit:activate\n  { \"preamble\": \"const { Seq } = require('sequins');\" }\n-->\n```js\nSeq([ 1, 2 ]).map(x => 10 * x)\n// Seq [ 10, 20 ]\n```\n\nNote: used only for sets.","notes":[]},"signatures":[{"typeParams":["M"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}}],"type":{"k":10,"param":"M"}}}],"type":{"k":11,"name":"Sequence","args":[{"k":10,"param":"K"},{"k":10,"param":"M"}]},"line":1431},{"typeParams":["M"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}}],"type":{"k":10,"param":"M"}}}],"type":{"k":11,"name":"Sequence","args":[{"k":10,"param":"M"},{"k":10,"param":"M"}]},"line":1447}]},"#flatMap":{"doc":{"synopsis":"Flat-maps the Sequence, returning a Sequence of the same type.","description":"Similar to `seq.map(...).flatten(true)`.","notes":[]},"signatures":[{"typeParams":["M"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}}],"type":{"k":11,"name":"Iterable","args":[{"k":10,"param":"M"}]}}}],"type":{"k":11,"name":"Sequence","args":[{"k":10,"param":"K"},{"k":10,"param":"M"}]},"line":1454},{"typeParams":["M"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}}],"type":{"k":11,"name":"Iterable","args":[{"k":10,"param":"M"}]}}}],"type":{"k":11,"name":"Sequence","args":[{"k":10,"param":"M"},{"k":10,"param":"M"}]},"line":1455}]},"#filter":{"doc":{"synopsis":"Returns a new Sequence with only the values for which the `predicate`\nfunction returns true.","description":"","notes":[]},"signatures":[{"typeParams":["F"],"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}}],"type":{"k":3}}}],"type":{"k":11,"name":"Sequence","args":[{"k":10,"param":"K"},{"k":10,"param":"F"}]},"line":1461},{"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}}],"type":{"k":0}}}],"type":{"k":12},"line":1464}]}}}]}},"Collection":{"interface":{"line":1477,"doc":{"synopsis":"Collection is the base type for all Sequins structures. There are two\nfundamental Collection types: Concrete and Sequence. The distinction is that\na `Concrete` stores its data, while a `Sequence` computes it.\nFurthermore, all Collections have keys and values of some kind. Values are\nsimilar everywhere, but the nature of keys is determined by the Collection's\nsubtype. Key may be explicitly declared ( `Keyed` subtype), the index of the\nitem in the collection ( `Indexed` subtype), or just the value again as a\nplaceholder ( `Duplicated` subtype).","description":"","notes":[]},"typeParams":["K","V"],"groups":[{"title":"Sequence algorithms","members":{"#map":{"doc":{"synopsis":"Returns a new Collection of the same type with values passed through a\n`mapper` function.","description":"<!-- runkit:activate\n  { \"preamble\": \"const { Collection } = require('sequins');\" }\n-->\n```js\nCollection({ a: 1, b: 2 }).map(x => 10 * x)\n// Sequence { \"a\": 10, \"b\": 20 }\n```","notes":[]},"signatures":[{"typeParams":["M"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"iter","type":{"k":12},"optional":true}],"type":{"k":10,"param":"M"}}}],"type":{"k":11,"name":"Collection","args":[{"k":10,"param":"K"},{"k":10,"param":"M"}]},"line":1492}]},"#filter":{"doc":{"synopsis":"Returns a new Collection of the same type with only the entries for which\nthe `predicate` function returns true.","description":"<!-- runkit:activate\n  { \"preamble\": \"const { Map } = require('sequins');\" }\n-->\n```js\nnew Map({ a: 1, b: 2, c: 3, d: 4}).filter(x => x % 2 === 0)\n// Map { \"b\": 2, \"d\": 4 }\n```","notes":[]},"signatures":[{"typeParams":["F"],"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"iter","type":{"k":12},"optional":true}],"type":{"k":3}}}],"type":{"k":11,"name":"Collection","args":[{"k":10,"param":"K"},{"k":10,"param":"F"}]},"line":1514},{"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"iter","type":{"k":12},"optional":true}],"type":{"k":0}}}],"type":{"k":12},"line":1517}]},"#filterNot":{"doc":{"synopsis":"Returns a new Collection of the same type with only the entries for which\nthe `predicate` function returns false.","description":"<!-- runkit:activate\n  { \"preamble\": \"const { Map } = require('sequins');\" }\n-->\n```js\nnew Map({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)\n// Map { \"a\": 1, \"c\": 3 }\n```","notes":[]},"signatures":[{"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"iter","type":{"k":12},"optional":true}],"type":{"k":3}}}],"type":{"k":12},"line":1531}]},"#reverse":{"doc":{"synopsis":"Reverses the order of elements in the collection.","description":"","notes":[]},"signatures":[{"type":{"k":12},"line":1536}]},"#sort":{"doc":{"synopsis":"Stably sorts the elements of the collection by using a `comparator`.","description":"If a `comparator` is not provided, a default comparator uses `<` and `>`.\n\n`comparator(valueA, valueB)`:\n\n  * Returns `0` if the elements should not be swapped.\n  * Returns `-1` (or any negative number) if `valueA` comes before `valueB`\n  * Returns `1` (or any positive number) if `valueA` comes after `valueB`\n  * Is pure, i.e. it must always return the same value for the same pair\n    of values.\n\nWhen sorting collections which have no defined order, their ordered\nequivalents will be returned. e.g. `map.sort()` returns OrderedMap.\n\n<!-- runkit:activate\n  { \"preamble\": \"const { Map } = require('sequins');\" }\n-->\n```js\nnew Map({ \"c\": 3, \"a\": 1, \"b\": 2 }).sort((a, b) => {\n  if (a < b) { return -1; }\n  if (a > b) { return 1; }\n  if (a === b) { return 0; }\n});\n// Map { \"a\": 1, \"b\": 2, \"c\": 3 }\n```","notes":[]},"signatures":[{"params":[{"name":"comparator","type":{"k":9,"params":[{"name":"valueA","type":{"k":10,"param":"V"}},{"name":"valueB","type":{"k":10,"param":"V"}}],"type":{"k":4}},"optional":true}],"type":{"k":12},"line":1566}]},"#sortBy":{"doc":{"synopsis":"Like `sort`, but also accepts a `comparatorValueMapper` which allows for\nsorting by more sophisticated means:","description":"    hitters.sortBy(hitter => hitter.avgHits)","notes":[]},"signatures":[{"typeParams":["C"],"params":[{"name":"comparatorValueMapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"iter","type":{"k":12},"optional":true}],"type":{"k":10,"param":"C"}}},{"name":"comparator","type":{"k":9,"params":[{"name":"valueA","type":{"k":10,"param":"C"}},{"name":"valueB","type":{"k":10,"param":"C"}}],"type":{"k":4}},"optional":true}],"type":{"k":12},"line":1574}]},"#groupBy":{"doc":{"synopsis":"Returns a `Keyed` of `Keyeds`, grouped by the return\nvalue of the `grouper` function.","description":"<!-- runkit:activate\n  { \"preamble\": \"const { List, Map } = require('sequins');\" }\n-->\n```js\nconst listOfMaps = new List([\n  new Map({ v: 0 }),\n  new Map({ v: 1 }),\n  new Map({ v: 1 }),\n  new Map({ v: 0 }),\n  new Map({ v: 2 })\n])\nconst groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))\n// Map {\n//   0: List [ new Map{ \"v\": 0 }, new Map { \"v\": 0 } ],\n//   1: List [ new Map{ \"v\": 1 }, new Map { \"v\": 1 } ],\n//   2: List [ new Map{ \"v\": 2 } ],\n// }\n```","notes":[]},"signatures":[{"typeParams":["G"],"params":[{"name":"grouper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"iter","type":{"k":12},"optional":true}],"type":{"k":10,"param":"G"}}}],"type":{"k":11,"name":"KeyedSequence","args":[{"k":10,"param":"G"},{"k":11,"name":"Collection","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]}]},"line":1602}]}}},{"title":"Side effects","members":{"#forEach":{"doc":{"synopsis":"The `sideEffect` is executed for every entry in the Collection.\n`forEach` has no return value!","description":"","notes":[]},"signatures":[{"params":[{"name":"sideEffect","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"iter","type":{"k":12},"optional":true}],"type":{"k":0}}}],"type":{"k":2},"line":1612}]},"#forSome":{"doc":{"synopsis":"The `sideEffect` is executed for entries in the Collection.","description":"If any call of `sideEffect` returns\n`false`, the iteration will stop. Returns the number of entries iterated\n(including the last iteration which returned false).","notes":[]},"signatures":[{"params":[{"name":"sideEffect","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"iter","type":{"k":12},"optional":true}],"type":{"k":0}}}],"type":{"k":4},"line":1621}]}}},{"title":"Creating subsets","members":{"#slice":{"doc":{"synopsis":"Returns a new Collection of the same type representing a portion of this\nCollection from start up to but not including end.","description":"If begin is negative, it is offset from the end of the Collection. e.g.\n`slice(-2)` returns a Collection of the last two entries. If it is not\nprovided the new Collection will begin at the beginning of this Collection.\n\nIf end is negative, it is offset from the end of the Collection. e.g.\n`slice(0, -1)` returns a Collection of everything but the last entry. If\nit is not provided, the new Collection will continue through the end of\nthis Collection.\n\nIf the requested slice is equivalent to the current Collection, then it\nwill return itself.","notes":[]},"signatures":[{"params":[{"name":"begin","type":{"k":4},"optional":true},{"name":"end","type":{"k":4},"optional":true}],"type":{"k":12},"line":1641}]}}},{"title":"Combination","members":{"#concat":{"doc":{"synopsis":"Returns a new Collection of the same type with other values and\ncollection-like concatenated to this one.","description":"For Seqs, all entries will be present in the resulting Sequence, even if they\nhave the same key.","notes":[]},"signatures":[{"params":[{"name":"valuesOrCollections","type":{"k":11,"name":"Array","args":[{"k":0}]},"varArgs":true}],"type":{"k":11,"name":"Collection","args":[{"k":0},{"k":0}]},"line":1652}]},"#flatten":{"doc":{"synopsis":"Flattens nested Collections.","description":"Will deeply flatten the Collection by default, returning a Collection of the\nsame type, but a `depth` can be provided in the form of a number or\nboolean (where true means to shallowly flatten one level). A depth of 0\n(or shallow: false) will deeply flatten.\n\nFlattens only others Collection, not Arrays or Objects.\n\nNote: `flatten(true)` operates on Collection<any, Collection<K, V>> and\nreturns Collection<K, V>","notes":[]},"signatures":[{"params":[{"name":"depth","type":{"k":4},"optional":true}],"type":{"k":11,"name":"Collection","args":[{"k":0},{"k":0}]},"line":1667},{"params":[{"name":"shallow","type":{"k":3},"optional":true}],"type":{"k":11,"name":"Collection","args":[{"k":0},{"k":0}]},"line":1668}]},"#flatMap":{"doc":{"synopsis":"Flat-maps the Collection, returning a Collection of the same type.","description":"Similar to `collection.map(...).flatten(true)`.\nUsed for Dictionaries only.","notes":[]},"signatures":[{"typeParams":["M"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"iter","type":{"k":12},"optional":true}],"type":{"k":11,"name":"Iterable","args":[{"k":10,"param":"M"}]}}}],"type":{"k":11,"name":"Collection","args":[{"k":10,"param":"K"},{"k":10,"param":"M"}]},"line":1675},{"typeParams":["KM","VM"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"iter","type":{"k":12},"optional":true}],"type":{"k":11,"name":"Iterable","args":[{"k":16,"types":[{"k":10,"param":"KM"},{"k":10,"param":"VM"}]}]}}}],"type":{"k":11,"name":"Collection","args":[{"k":10,"param":"KM"},{"k":10,"param":"VM"}]},"line":1685}]}}},{"title":"Reducing a value","members":{"#reduce":{"doc":{"synopsis":"Reduces the Collection to a value by calling the `reducer` for every entry\nin the Collection and passing along the reduced value.","description":"If `initialReduction` is not provided, the first item in the\nCollection will be used.\n","notes":[{"name":"see","body":"`Array#reduce`."}]},"signatures":[{"typeParams":["R"],"params":[{"name":"reducer","type":{"k":9,"params":[{"name":"reduction","type":{"k":10,"param":"R"}},{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"iter","type":{"k":12},"optional":true}],"type":{"k":10,"param":"R"}}},{"name":"initialReduction","type":{"k":10,"param":"R"}}],"type":{"k":10,"param":"R"},"line":1700},{"typeParams":["R"],"params":[{"name":"reducer","type":{"k":9,"params":[{"name":"reduction","type":{"k":14,"types":[{"k":10,"param":"V"},{"k":10,"param":"R"}]}},{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"iter","type":{"k":12},"optional":true}],"type":{"k":10,"param":"R"}}}],"type":{"k":10,"param":"R"},"line":1704}]},"#every":{"doc":{"synopsis":"True if `predicate` returns true for all entries in the Collection.","description":"","notes":[]},"signatures":[{"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"iter","type":{"k":12},"optional":true}],"type":{"k":3}}}],"type":{"k":3},"line":1709}]},"#some":{"doc":{"synopsis":"True if `predicate` returns true for any entry in the Collection.","description":"","notes":[]},"signatures":[{"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"iter","type":{"k":12},"optional":true}],"type":{"k":3}}}],"type":{"k":3},"line":1714}]},"#count":{"doc":{"synopsis":"Returns the size of this Collection by iterating through it.","description":"If a `predicate` is provided, returns the count of entries in the\nSequence for which the `predicate` returns true.\n\nNOTE: For concrete collections, this returns size when no args\nare passed. For sequences it must always iterate over the whole\ncollection.","notes":[]},"signatures":[{"type":{"k":4},"line":1726},{"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"iter","type":{"k":12},"optional":true}],"type":{"k":3}}}],"type":{"k":4},"line":1727}]}}},{"title":"Search for value","members":{"#find":{"doc":{"synopsis":"Returns the first value for which the `predicate` returns true.","description":"","notes":[]},"signatures":[{"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"iter","type":{"k":12},"optional":true}],"type":{"k":3}}},{"name":"notSetValue","type":{"k":10,"param":"V"},"optional":true}],"type":{"k":14,"types":[{"k":10,"param":"V"},{"k":13}]},"line":1734}]}}},{"title":"Conversions","members":{"#to":{"doc":{"synopsis":"Converts this collection into the type of collection specified as the\n`CollectionConstructor` parameter. If no conversion is neccessary, returns\n the original instance. The easiest way to describe the function is to show\nsome example usages:","description":"```js\nimport {List, Map, Set, IndexedSequence, KeyedSequence, SetSequence, NativeMap, NativeSet} from 'sequins';\nconst list = new List([1, 2, 3]);\nlist.to(Map) // Map{0 => 1, 1 => 2, 2 => 3}\nlist.to(Set) // Set{1, 2, 3}\nlist.to(List) // list\nlist.to(IndexedSequence) // new IndexedSequence(list)\nlist.to(KeyedSequence) // new KeyedSequence(list)\nlist.to(SetSequence) // new SetSequence(list)\nlist.to(NativeMap) // NativeMap{0 => 1, 1 => 2, 2 => 3}\nlist.to(NativeMap) instanceof global.Map // true\nlist.to(NativeSet) // NativeSet{1, 2, 3}\nlist.to(NativeSet) instanceof global.Set // true\nlist.to(Array) // [1, 2, 3]\nlist.to(Object) // {'0': 1, '1': 2, '2': 3}\n```\n\n\nWhile you can find definitive information in the constructor references,\nthe basics are that keys will be discarded when converting from a `Keyed`\nto anything other than a `Keyed`. When converting an `Indexed` to a\n`Keyed`, the indexes will become the keys. When converting a `Duplicated`\nto a keyed, the keys will be the same as the values.\n","notes":[{"name":"pragma","body":"showExampleAboveType"}]},"signatures":[{"params":[{"name":"Type","type":{"k":6,"members":[{"construct":true,"name":"new","type":{"k":11,"name":"IndexedSequence","args":[{"k":0}]}}]}}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":10,"param":"V"}]},"line":1774},{"params":[{"name":"Type","type":{"k":6,"members":[{"construct":true,"name":"new","type":{"k":11,"name":"KeyedSequence","args":[{"k":0},{"k":0}]}}]}}],"type":{"k":11,"name":"KeyedSequence","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]},"line":1775},{"params":[{"name":"Type","type":{"k":6,"members":[{"construct":true,"name":"new","type":{"k":11,"name":"SetSequence","args":[{"k":0}]}}]}}],"type":{"k":11,"name":"SetSequence","args":[{"k":10,"param":"V"}]},"line":1776},{"params":[{"name":"Type","type":{"k":6,"members":[{"construct":true,"name":"new","type":{"k":11,"name":"List","args":[{"k":0}]}}]}}],"type":{"k":11,"name":"List","args":[{"k":10,"param":"V"}]},"line":1777},{"params":[{"name":"Type","type":{"k":6,"members":[{"construct":true,"name":"new","type":{"k":11,"name":"Map","args":[{"k":0},{"k":0}]}}]}}],"type":{"k":11,"name":"Map","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]},"line":1778},{"params":[{"name":"Type","type":{"k":6,"members":[{"construct":true,"name":"new","type":{"k":11,"name":"Set","args":[{"k":0}]}}]}}],"type":{"k":11,"name":"Set","args":[{"k":10,"param":"V"}]},"line":1779},{"params":[{"name":"Type","type":{"k":6,"members":[{"construct":true,"name":"new","type":{"k":11,"name":"NativeMap","args":[{"k":0},{"k":0}]}}]}}],"type":{"k":11,"name":"NativeMap","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]},"line":1780},{"params":[{"name":"Type","type":{"k":6,"members":[{"construct":true,"name":"new","type":{"k":11,"name":"NativeSet","args":[{"k":0}]}}]}}],"type":{"k":11,"name":"NativeSet","args":[{"k":10,"param":"V"}]},"line":1781},{"params":[{"name":"Type","type":{"k":6,"members":[{"construct":true,"name":"new","type":{"k":11,"name":"Array","args":[{"k":0}]}}]}}],"type":{"k":11,"name":"Array","args":[{"k":10,"param":"V"}]},"line":1782},{"params":[{"name":"Type","type":{"k":6,"members":[{"name":"prototype","type":{"k":11,"name":"Object"}}]}}],"type":{"k":6,"members":[{"index":true,"params":[{"name":"key","type":{"k":5}}],"type":{"k":10,"param":"V"}}]},"line":1783}]},"#toConcrete":{"doc":{"synopsis":"Converts this collection to `Map` if it is `Keyed`, `List` if it is\n`Indexed`, or `Set` if it is `Duplicated`.\nor","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"Concrete","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]},"line":1790}]},"#toSeq":{"doc":{"synopsis":"Converts this Collection to a Sequence of the same kind (`Indexed`,\n`Keyed`, or `Duplicated`).","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"Sequence","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]},"line":1796}]},"#toJS":{"doc":{"synopsis":"Deeply converts this Collection to equivalent native JavaScript Array or Object.","description":"`Indexed`, and `Duplicated` become `Array`, while\n`Keyed` becomes `Object`, converting keys to Strings.","notes":[]},"signatures":[{"type":{"k":14,"types":[{"k":11,"name":"Array","args":[{"k":0}]},{"k":6,"members":[{"index":true,"params":[{"name":"key","type":{"k":5}}],"type":{"k":0}}]}]},"line":1804}]},"#toJSON":{"doc":{"synopsis":"Shallowly converts this Collection to equivalent native JavaScript Array or Object.","description":"`Indexed`, and `Duplicated` become `Array`, while\n`Keyed` becomes `Object`, converting keys to Strings.","notes":[]},"signatures":[{"type":{"k":14,"types":[{"k":11,"name":"Array","args":[{"k":10,"param":"V"}]},{"k":6,"members":[{"index":true,"params":[{"name":"key","type":{"k":5}}],"type":{"k":10,"param":"V"}}]}]},"line":1812}]}}},{"title":"Iterables","members":{"#keys":{"doc":{"synopsis":"Returns a `SetSequence` of the collection's keys, which is also suitable for\nuse as an es6 iterable over the collection's keys.","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"SetSequence","args":[{"k":10,"param":"K"}]},"line":1820}]},"#values":{"doc":{"synopsis":"Returns a `SetSequence` of the collection's values, which is also suitable\nfor use as an es6 iterable over the collection's values.","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"SetSequence","args":[{"k":10,"param":"V"}]},"line":1826}]},"#entries":{"doc":{"synopsis":"Returns a `KeyedSequence` of the collection's entries, which is also suitable\nfor use as an es6 iterable over the collection's `[key, value]` entry tuples.","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"KeyedSequence","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]},"line":1832}]}}}],"constructor":{"signatures":[{"type":{"k":11,"name":"IndexedSequence","args":[{"k":0}]},"line":1774},{"type":{"k":11,"name":"KeyedSequence","args":[{"k":0},{"k":0}]},"line":1775},{"type":{"k":11,"name":"SetSequence","args":[{"k":0}]},"line":1776},{"type":{"k":11,"name":"List","args":[{"k":0}]},"line":1777},{"type":{"k":11,"name":"Map","args":[{"k":0},{"k":0}]},"line":1778},{"type":{"k":11,"name":"Set","args":[{"k":0}]},"line":1779},{"type":{"k":11,"name":"NativeMap","args":[{"k":0},{"k":0}]},"line":1780},{"type":{"k":11,"name":"NativeSet","args":[{"k":0}]},"line":1781},{"type":{"k":11,"name":"Array","args":[{"k":0}]},"line":1782}]}}}}},{"title":"Subtypes","members":{"Keyed":{"interface":{"line":1844,"doc":{"synopsis":"Keyed is used to describe Collections which have explicit keys and values.\nCallbacks for methods in classes implementing Keyed will receive\n`(value, key)` as thier first two arguments.","description":"Iterating over a `Keyed`, yields `[K, V]` tuples.","notes":[]},"typeParams":["K","V"],"extends":[{"k":11,"name":"Collection","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]}],"groups":[{"members":{"#toJS":{"doc":{"synopsis":"Deeply converts this Keyed collection to equivalent native JavaScript Object.","description":"Converts keys to Strings.","notes":[]},"signatures":[{"type":{"k":11,"name":"Object"},"line":1850}]},"#toJSON":{"doc":{"synopsis":"Shallowly converts this Keyed collection to equivalent native JavaScript Object.","description":"Converts keys to Strings.","notes":[]},"signatures":[{"type":{"k":6,"members":[{"index":true,"params":[{"name":"key","type":{"k":5}}],"type":{"k":10,"param":"V"}}]},"line":1857}]},"#toConcrete":{"doc":{"synopsis":"Converts this collection to a `Map`","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"Map","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]},"line":1862}]},"#toSeq":{"doc":{"synopsis":"Returns KeyedSequence.","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"KeyedSequence","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]},"line":1868}]}}},{"title":"Sequence functions","members":{"#flip":{"doc":{"synopsis":"Returns a new Keyed of the same type where the keys and values\nhave been flipped.","description":"<!-- runkit:activate\n  { \"preamble\": \"const { KeyedSequence } = require('sequins');\" }\n-->\n```js\nnew KeyedSequence({ a: 'z', b: 'y' }).flip()\n// KeyedSequence { \"z\": \"a\", \"y\": \"b\" }\n```","notes":[]},"signatures":[{"type":{"k":11,"name":"Keyed","args":[{"k":10,"param":"V"},{"k":10,"param":"K"}]},"line":1884}]},"#concat":{"doc":{"synopsis":"Returns a new Collection with other collections concatenated to this one.","description":"","notes":[]},"signatures":[{"typeParams":["KC","VC"],"params":[{"name":"collections","type":{"k":11,"name":"Array","args":[{"k":11,"name":"Iterable","args":[{"k":16,"types":[{"k":10,"param":"KC"},{"k":10,"param":"VC"}]}]}]},"varArgs":true}],"type":{"k":11,"name":"Keyed","args":[{"k":14,"types":[{"k":10,"param":"K"},{"k":10,"param":"KC"}]},{"k":14,"types":[{"k":10,"param":"V"},{"k":10,"param":"VC"}]}]},"line":1889},{"typeParams":["C"],"params":[{"name":"collections","type":{"k":11,"name":"Array","args":[{"k":6,"members":[{"index":true,"params":[{"name":"key","type":{"k":5}}],"type":{"k":10,"param":"C"}}]}]},"varArgs":true}],"type":{"k":11,"name":"Keyed","args":[{"k":14,"types":[{"k":10,"param":"K"},{"k":5}]},{"k":14,"types":[{"k":10,"param":"V"},{"k":10,"param":"C"}]}]},"line":1892}]},"#map":{"doc":{"synopsis":"Returns a new Keyed with values passed through a\n`mapper` function.","description":"<!-- runkit:activate\n  { \"preamble\": \"const { KeyedSequence } = require('sequins');\" }\n-->\n```js\nnew KeyedSequence({ a: 1, b: 2 }).map(x => 10 * x)\n// KeyedSequence { \"a\": 10, \"b\": 20 }\n```","notes":[]},"signatures":[{"typeParams":["M"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"iter","type":{"k":12},"optional":true}],"type":{"k":10,"param":"M"}}}],"type":{"k":11,"name":"Keyed","args":[{"k":10,"param":"K"},{"k":10,"param":"M"}]},"line":1908}]},"#mapKeys":{"doc":{"synopsis":"Returns a new Keyed of the same type with keys passed through\na `mapper` function.","description":"<!-- runkit:activate\n  { \"preamble\": \"const { KeyedSequence } = require('sequins');\" }\n-->\n<!-- runkit:activate -->\n```js\nnew KeyedSequence({ a: 1, b: 2 }).mapKeys(x => x.toUpperCase())\n// KeyedSequence { \"A\": 1, \"B\": 2 }\n```","notes":[]},"signatures":[{"typeParams":["M"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"key","type":{"k":10,"param":"K"}},{"name":"value","type":{"k":10,"param":"V"}},{"name":"iter","type":{"k":12},"optional":true}],"type":{"k":10,"param":"M"}}}],"type":{"k":11,"name":"Keyed","args":[{"k":10,"param":"M"},{"k":10,"param":"V"}]},"line":1923}]},"#mapEntries":{"doc":{"synopsis":"Returns a new Keyed of the same type with entries\n([key, value] tuples) passed through a `mapper` function.","description":"<!-- runkit:activate\n  { \"preamble\": \"const { KeyedSequence } = require('sequins');\" }\n-->\n```js\nnew KeyedSequence({ a: 1, b: 2 })\n  .mapEntries(([ k, v ]) => [ k.toUpperCase(), v * 2 ])\n// KeyedSequence { \"A\": 2, \"B\": 4 }\n```","notes":[]},"signatures":[{"typeParams":["KM","VM"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"entry","type":{"k":16,"types":[{"k":10,"param":"K"},{"k":10,"param":"V"}]}},{"name":"index","type":{"k":4}},{"name":"iter","type":{"k":12},"optional":true}],"type":{"k":16,"types":[{"k":10,"param":"KM"},{"k":10,"param":"VM"}]}}}],"type":{"k":11,"name":"Keyed","args":[{"k":10,"param":"KM"},{"k":10,"param":"VM"}]},"line":1938}]},"#flatMap":{"doc":{"synopsis":"Flat-maps the Collection, returning a Collection of the same type.","description":"Similar to `collection.map(...).flatten(true)`.","notes":[]},"signatures":[{"typeParams":["KM","VM"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"iter","type":{"k":12},"optional":true}],"type":{"k":11,"name":"Iterable","args":[{"k":16,"types":[{"k":10,"param":"KM"},{"k":10,"param":"VM"}]}]}}}],"type":{"k":11,"name":"Keyed","args":[{"k":10,"param":"KM"},{"k":10,"param":"VM"}]},"line":1947}]},"#filter":{"doc":{"synopsis":"Returns a new Collection with only the values for which the `predicate`\nfunction returns true.","description":"","notes":[]},"signatures":[{"typeParams":["F"],"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"iter","type":{"k":12},"optional":true}],"type":{"k":3}}}],"type":{"k":11,"name":"Keyed","args":[{"k":10,"param":"K"},{"k":10,"param":"F"}]},"line":1955},{"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"V"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"iter","type":{"k":12},"optional":true}],"type":{"k":0}}}],"type":{"k":12},"line":1958}]},"#[Symbol.iterator]":{"signatures":[{"type":{"k":11,"name":"IterableIterator","args":[{"k":16,"types":[{"k":10,"param":"K"},{"k":10,"param":"V"}]}]},"line":1960}]}}}]}},"Indexed":{"interface":{"line":1975,"doc":{"synopsis":"Indexed is used to describe Collections of values where the collections\nalso track the indexes of those values. Callbacks for methods in classes\nimplementing Indexed will receive `(value, index)` as their first two\narguments.","description":"Iterating over an `Indexed` yields only values, no indexes.\n\nUnlike JavaScript arrays, `Indexed` collections are always dense. \"Unset\"\nindices and `undefined` indices are indistinguishable, and all indices from\n0 to `size` are visited when iterated.","notes":[]},"typeParams":["T"],"extends":[{"k":11,"name":"Collection","args":[{"k":4},{"k":10,"param":"T"}]}],"groups":[{"members":{"#toJS":{"doc":{"synopsis":"Deeply converts this Indexed collection to equivalent native JavaScript Array.","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"Array","args":[{"k":0}]},"line":1979}]},"#toJSON":{"doc":{"synopsis":"Shallowly converts this Indexed collection to equivalent native JavaScript Array.","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"Array","args":[{"k":10,"param":"T"}]},"line":1984}]},"#toConcrete":{"doc":{"synopsis":"Converts this collection to a `List`","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"List","args":[{"k":10,"param":"T"}]},"line":1989}]}}},{"title":"Reading values","members":{"#get":{"doc":{"synopsis":"Returns the value associated with the provided index, or notSetValue if\nthe index is beyond the bounds of the Collection.","description":"`index` may be a negative number, which indexes back from the end of the\nCollection. `s.get(-1)` gets the last item in the Collection.","notes":[]},"signatures":[{"typeParams":["NSV"],"params":[{"name":"index","type":{"k":4}},{"name":"notSetValue","type":{"k":10,"param":"NSV"}}],"type":{"k":14,"types":[{"k":10,"param":"T"},{"k":10,"param":"NSV"}]},"line":2000},{"params":[{"name":"index","type":{"k":4}}],"type":{"k":14,"types":[{"k":10,"param":"T"},{"k":13}]},"line":2001}]}}},{"title":"Conversions","members":{"#toSeq":{"doc":{"synopsis":"Returns IndexedSequence.","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"IndexedSequence","args":[{"k":10,"param":"T"}]},"line":2009}]}}},{"title":"Combination","members":{"#zip":{"doc":{"synopsis":"Returns a Collection of the same type \"zipped\" with the provided\ncollections.","description":"Like `zipWith`, but using the default `zipper`: creating an `Array`.\n\n\n<!-- runkit:activate\n  { \"preamble\": \"const { IndexedSequence } = require('sequins');\" }\n-->\n```js\nconst a = new IndexedSequence([ 1, 2, 3 ]);\nconst b = new IndexedSequence([ 4, 5, 6 ]);\nconst c = a.zip(b); // IndexedSequence [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]\n```","notes":[]},"signatures":[{"typeParams":["U"],"params":[{"name":"other","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"U"}]}}],"type":{"k":11,"name":"Indexed","args":[{"k":16,"types":[{"k":10,"param":"T"},{"k":10,"param":"U"}]}]},"line":2029},{"typeParams":["U","V"],"params":[{"name":"other","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"U"}]}},{"name":"other2","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"V"}]}}],"type":{"k":11,"name":"Indexed","args":[{"k":16,"types":[{"k":10,"param":"T"},{"k":10,"param":"U"},{"k":10,"param":"V"}]}]},"line":2030},{"params":[{"name":"collections","type":{"k":11,"name":"Array","args":[{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":0}]}]},"varArgs":true}],"type":{"k":11,"name":"Indexed","args":[{"k":0}]},"line":2034}]},"#zipAll":{"doc":{"synopsis":"Returns a Collection \"zipped\" with the provided collections.","description":"Unlike `zip`, `zipAll` continues zipping until the longest collection is\nexhausted. Missing values from shorter collections are filled with `undefined`.\n\n<!-- runkit:activate\n  { \"preamble\": \"const { IndexedSequence } = require('sequins');\" }\n-->\n```js\nconst a = new IndexedSequence([ 1, 2 ]);\nconst b = new IndexedSequence([ 3, 4, 5 ]);\nconst c = a.zipAll(b);\n// IndexedSequence [ [ 1, 3 ], [ 2, 4 ], [ undefined, 5 ] ]\n```","notes":[]},"signatures":[{"typeParams":["U"],"params":[{"name":"other","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"U"}]}}],"type":{"k":11,"name":"Indexed","args":[{"k":16,"types":[{"k":10,"param":"T"},{"k":10,"param":"U"}]}]},"line":2052},{"typeParams":["U","V"],"params":[{"name":"other","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"U"}]}},{"name":"other2","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"V"}]}}],"type":{"k":11,"name":"Indexed","args":[{"k":16,"types":[{"k":10,"param":"T"},{"k":10,"param":"U"},{"k":10,"param":"V"}]}]},"line":2053},{"params":[{"name":"collections","type":{"k":11,"name":"Array","args":[{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":0}]}]},"varArgs":true}],"type":{"k":11,"name":"Indexed","args":[{"k":0}]},"line":2057}]},"#zipWith":{"doc":{"synopsis":"Returns a Collection of the same type \"zipped\" with the provided\ncollections by using a custom `zipper` function.","description":"<!-- runkit:activate\n     { \"preamble\": \"const { IndexedSequence } = require('sequins')\" }\n-->\n```js\nconst a = new IndexedSequence([ 1, 2, 3 ]);\nconst b = new IndexedSequence([ 4, 5, 6 ]);\nconst c = a.zipWith((a, b) => a + b, b);\n// IndexedSequence [ 5, 7, 9 ]\n```","notes":[]},"signatures":[{"typeParams":["U","Z"],"params":[{"name":"zipper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"otherValue","type":{"k":10,"param":"U"}}],"type":{"k":10,"param":"Z"}}},{"name":"otherCollection","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"U"}]}}],"type":{"k":11,"name":"Indexed","args":[{"k":10,"param":"Z"}]},"line":2073},{"typeParams":["U","V","Z"],"params":[{"name":"zipper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"otherValue","type":{"k":10,"param":"U"}},{"name":"thirdValue","type":{"k":10,"param":"V"}}],"type":{"k":10,"param":"Z"}}},{"name":"otherCollection","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"U"}]}},{"name":"thirdCollection","type":{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":10,"param":"V"}]}}],"type":{"k":11,"name":"Indexed","args":[{"k":10,"param":"Z"}]},"line":2077},{"typeParams":["Z"],"params":[{"name":"zipper","type":{"k":9,"params":[{"name":"any","type":{"k":11,"name":"Array","args":[{"k":0}]},"varArgs":true}],"type":{"k":10,"param":"Z"}}},{"name":"collections","type":{"k":11,"name":"Array","args":[{"k":11,"name":"CollectionLike","args":[{"k":0},{"k":0}]}]},"varArgs":true}],"type":{"k":11,"name":"Indexed","args":[{"k":10,"param":"Z"}]},"line":2082}]}}},{"title":"Sequence algorithms","members":{"#concat":{"doc":{"synopsis":"Returns a new Collection with other collections concatenated to this one.","description":"","notes":[]},"signatures":[{"typeParams":["C"],"params":[{"name":"valuesOrCollections","type":{"k":11,"name":"Array","args":[{"k":14,"types":[{"k":11,"name":"Iterable","args":[{"k":10,"param":"C"}]},{"k":10,"param":"C"}]}]},"varArgs":true}],"type":{"k":11,"name":"Indexed","args":[{"k":14,"types":[{"k":10,"param":"T"},{"k":10,"param":"C"}]}]},"line":2092}]},"#map":{"doc":{"synopsis":"Returns a new Indexed with values passed through a\n`mapper` function.","description":"<!-- runkit:activate\n     { \"preamble\": \"const { IndexedSequence } = require('sequins')\" }\n-->\n```js\nnew IndexedSequence([1,2]).map(x => 10 * x)\n// IndexedSequence [ 1, 2 ]\n```","notes":[]},"signatures":[{"typeParams":["M"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"key","type":{"k":4}}],"type":{"k":10,"param":"M"}}}],"type":{"k":11,"name":"Indexed","args":[{"k":10,"param":"M"}]},"line":2106}]},"#flatMap":{"doc":{"synopsis":"Flat-maps the Collection, returning a Collection of the same type.","description":"Similar to `collection.map(...).flatten(true)`.","notes":[]},"signatures":[{"typeParams":["M"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"key","type":{"k":4}}],"type":{"k":11,"name":"Iterable","args":[{"k":10,"param":"M"}]}}}],"type":{"k":11,"name":"Indexed","args":[{"k":10,"param":"M"}]},"line":2113}]},"#filter":{"doc":{"synopsis":"Returns a new Collection with only the values for which the `predicate`\nfunction returns true.","description":"","notes":[]},"signatures":[{"typeParams":["F"],"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"index","type":{"k":4}}],"type":{"k":3}}}],"type":{"k":11,"name":"Indexed","args":[{"k":10,"param":"F"}]},"line":2119},{"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"index","type":{"k":4}}],"type":{"k":0}}}],"type":{"k":12},"line":2122}]},"#[Symbol.iterator]":{"signatures":[{"type":{"k":11,"name":"IterableIterator","args":[{"k":10,"param":"T"}]},"line":2124}]}}}]}},"Duplicated":{"interface":{"line":2135,"doc":{"synopsis":"Duplicated describes collections of values where no index is desired.\nInstead, callbacks for methods in classes implementing Duplicated will\nreceive `(value, value)` as their first two arguments, which is the source\nof the name.","description":"Iterating over a Duplicated yields only values.","notes":[]},"typeParams":["T"],"extends":[{"k":11,"name":"Collection","args":[{"k":10,"param":"T"},{"k":10,"param":"T"}]}],"groups":[{"members":{"#toJS":{"doc":{"synopsis":"Deeply converts this Set collection to equivalent native JavaScript Array.","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"Array","args":[{"k":0}]},"line":2139}]},"#toJSON":{"doc":{"synopsis":"Shallowly converts this Set collection to equivalent native JavaScript Array.","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"Array","args":[{"k":10,"param":"T"}]},"line":2144}]},"#toConcrete":{"doc":{"synopsis":"Converts this collection to a `Set`","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"Set","args":[{"k":10,"param":"T"}]},"line":2149}]},"#toSeq":{"doc":{"synopsis":"Returns SetSequence.","description":"","notes":[]},"signatures":[{"type":{"k":11,"name":"SetSequence","args":[{"k":10,"param":"T"}]},"line":2155}]}}},{"title":"Sequence algorithms","members":{"#concat":{"doc":{"synopsis":"Returns a new Collection with other collections concatenated to this one.","description":"","notes":[]},"signatures":[{"typeParams":["U"],"params":[{"name":"collections","type":{"k":11,"name":"Array","args":[{"k":11,"name":"Iterable","args":[{"k":10,"param":"U"}]}]},"varArgs":true}],"type":{"k":11,"name":"Duplicated","args":[{"k":14,"types":[{"k":10,"param":"T"},{"k":10,"param":"U"}]}]},"line":2162}]},"#map":{"doc":{"synopsis":"Returns a new Duplicated with values passed through a\n`mapper` function.","description":"```\nDuplicated([ 1, 2 ]).map(x => 10 * x)\n// Sequence { 1, 2 }\n```","notes":[]},"signatures":[{"typeParams":["M"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"key","type":{"k":10,"param":"T"}}],"type":{"k":10,"param":"M"}}}],"type":{"k":11,"name":"Duplicated","args":[{"k":10,"param":"M"}]},"line":2173}]},"#flatMap":{"doc":{"synopsis":"Flat-maps the Collection, returning a Collection of the same type.","description":"Similar to `collection.map(...).flatten(true)`.","notes":[]},"signatures":[{"typeParams":["M"],"params":[{"name":"mapper","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"key","type":{"k":10,"param":"T"}}],"type":{"k":11,"name":"Iterable","args":[{"k":10,"param":"M"}]}}}],"type":{"k":11,"name":"Duplicated","args":[{"k":10,"param":"M"}]},"line":2180}]},"#filter":{"doc":{"synopsis":"Returns a new Collection with only the values for which the `predicate`\nfunction returns true.","description":"","notes":[]},"signatures":[{"typeParams":["F"],"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"key","type":{"k":10,"param":"T"}}],"type":{"k":3}}}],"type":{"k":11,"name":"Duplicated","args":[{"k":10,"param":"F"}]},"line":2186},{"params":[{"name":"predicate","type":{"k":9,"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"key","type":{"k":10,"param":"T"}}],"type":{"k":0}}}],"type":{"k":12},"line":2189}]},"#[Symbol.iterator]":{"signatures":[{"type":{"k":11,"name":"IterableIterator","args":[{"k":10,"param":"T"}]},"line":2191}]}}}]}}}},{"title":"Construction","members":{"Range":{"call":{"doc":{"synopsis":"Returns a IndexedSequence of numbers from `start` (inclusive) to `end`\n(exclusive), by `step`, where `start` defaults to 0, `step` to 1, and `end` to\ninfinity. When `start` is equal to `end`, returns empty range.","description":"```js\nRange() // [ 0, 1, 2, 3, ... ]\nRange(10) // [ 10, 11, 12, 13, ... ]\nRange(10, 15) // [ 10, 11, 12, 13, 14 ]\nRange(10, 30, 5) // [ 10, 15, 20, 25 ]\nRange(30, 10, 5) // [ 30, 25, 20, 15 ]\nRange(30, 30, 5) // []\n```","notes":[]},"signatures":[{"params":[{"name":"start","type":{"k":4},"optional":true},{"name":"end","type":{"k":4},"optional":true},{"name":"step","type":{"k":4},"optional":true}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":4}]},"line":2210}]}},"Repeat":{"call":{"doc":{"synopsis":"Returns a IndexedSequence of `value` repeated `times` times. When `times` is\nnot defined, returns an infinite `Sequence` of `value`.","description":"```js\nRepeat('foo') // [ 'foo', 'foo', 'foo', ... ]\nRepeat('bar', 4) // [ 'bar', 'bar', 'bar', 'bar' ]\n```","notes":[]},"signatures":[{"typeParams":["T"],"params":[{"name":"value","type":{"k":10,"param":"T"}},{"name":"times","type":{"k":4},"optional":true}],"type":{"k":11,"name":"IndexedSequence","args":[{"k":10,"param":"T"}]},"line":2225}]}}}},{"title":"Utility","members":{"isCollection":{"call":{"doc":{"synopsis":"True if `maybeCollection` is a Collection, or any of its subclasses.","description":"<!-- runkit:activate\n     { \"preamble\": \"const { isCollection, Map, List } = require('sequins')\" }\n-->\n```js\nisCollection([]); // false\nisCollection({}); // false\nisCollection(new Map()); // true\nisCollection(new List()); // true\n```","notes":[]},"signatures":[{"params":[{"name":"maybeCollection","type":{"k":0}}],"type":{"k":3},"line":2242}]}},"isKeyed":{"call":{"doc":{"synopsis":"True if `maybeKeyed` is a Keyed, or any of its subclasses.","description":"<!-- runkit:activate\n     { \"preamble\": \"const { isKeyed, Map, List } = require('sequins')\" }\n-->\n```js\nisKeyed([]); // false\nisKeyed({}); // false\nisKeyed(new Map()); // true\nisKeyed(new List()); // false\n```","notes":[]},"signatures":[{"params":[{"name":"maybeKeyed","type":{"k":0}}],"type":{"k":3},"line":2259}]}},"isIndexed":{"call":{"doc":{"synopsis":"True if `maybeIndexed` is an Indexed, or any of its subclasses.","description":"<!-- runkit:activate\n     { \"preamble\": \"const { isIndexed, Map, List } = require('sequins')\" }\n-->\n```js\nisIndexed([]); // false\nisIndexed({}); // false\nisIndexed(new Map()); // false\nisIndexed(new List()); // true\nisIndexed(new Set()); // false\n```","notes":[]},"signatures":[{"params":[{"name":"maybeIndexed","type":{"k":0}}],"type":{"k":3},"line":2275}]}},"isAssociative":{"call":{"doc":{"synopsis":"True if `maybeAssociative` is either a Keyed or Indexed Collection.","description":"<!-- runkit:activate\n     { \"preamble\": \"const { isAssociative, Map, List } = require('sequins')\" }\n-->\n```js\nisAssociative([]); // false\nisAssociative({}); // false\nisAssociative(new Map()); // true\nisAssociative(new List()); // true\nisAssociative(new Set()); // false\n```","notes":[]},"signatures":[{"params":[{"name":"maybeAssociative","type":{"k":0}}],"type":{"k":3},"line":2291}]}},"isSeq":{"call":{"doc":{"synopsis":"True if `maybeSeq` is a Sequence.","description":"","notes":[]},"signatures":[{"params":[{"name":"maybeSeq","type":{"k":0}}],"type":{"k":3},"line":2298}]}},"isList":{"call":{"doc":{"synopsis":"True if `maybeList` is a List.","description":"","notes":[]},"signatures":[{"params":[{"name":"maybeList","type":{"k":0}}],"type":{"k":3},"line":2308}]}},"isMap":{"call":{"doc":{"synopsis":"True if `maybeMap` is a Map.","description":"Also true for OrderedMaps.","notes":[]},"signatures":[{"params":[{"name":"maybeMap","type":{"k":0}}],"type":{"k":3},"line":2315}]}},"isSet":{"call":{"doc":{"synopsis":"True if `maybeSet` is a Set.","description":"Also true for OrderedSets.","notes":[]},"signatures":[{"params":[{"name":"maybeSet","type":{"k":0}}],"type":{"k":3},"line":2322}]}},"get":{"call":{"doc":{"synopsis":"Returns the value within the provided collection associated with the\nprovided key, or notSetValue if the key is not defined in the collection.","description":"A functional alternative to `collection.get(key)` which will also work on\nplain Objects and Arrays as an alternative for `collection[key]`.\n\n<!-- runkit:activate\n     { \"preamble\": \"const { get } = require('sequins')\" }\n-->\n```js\nget([ 'dog', 'frog', 'cat' ], 2) // 'frog'\nget({ x: 123, y: 456 }, 'x') // 123\nget({ x: 123, y: 456 }, 'z', 'ifNotSet') // 'ifNotSet'\n```","notes":[]},"signatures":[{"typeParams":["K","V"],"params":[{"name":"collection","type":{"k":11,"name":"Collection","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]}},{"name":"key","type":{"k":10,"param":"K"}}],"type":{"k":14,"types":[{"k":10,"param":"V"},{"k":13}]},"line":2340},{"typeParams":["K","V","NSV"],"params":[{"name":"collection","type":{"k":11,"name":"Collection","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"notSetValue","type":{"k":10,"param":"NSV"}}],"type":{"k":14,"types":[{"k":10,"param":"V"},{"k":10,"param":"NSV"}]},"line":2341},{"typeParams":["V"],"params":[{"name":"collection","type":{"k":11,"name":"Array","args":[{"k":10,"param":"V"}]}},{"name":"key","type":{"k":4}}],"type":{"k":14,"types":[{"k":10,"param":"V"},{"k":13}]},"line":2346},{"typeParams":["V","NSV"],"params":[{"name":"collection","type":{"k":11,"name":"Array","args":[{"k":10,"param":"V"}]}},{"name":"key","type":{"k":4}},{"name":"notSetValue","type":{"k":10,"param":"NSV"}}],"type":{"k":14,"types":[{"k":10,"param":"V"},{"k":10,"param":"NSV"}]},"line":2347},{"typeParams":["C","K"],"params":[{"name":"object","type":{"k":10,"param":"C"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"notSetValue","type":{"k":0}}],"type":{"k":17,"type":{"k":10,"param":"C"},"index":{"k":10,"param":"K"}},"line":2352},{"typeParams":["V"],"params":[{"name":"collection","type":{"k":6,"members":[{"index":true,"params":[{"name":"key","type":{"k":5}}],"type":{"k":10,"param":"V"}}]}},{"name":"key","type":{"k":5}}],"type":{"k":14,"types":[{"k":10,"param":"V"},{"k":13}]},"line":2357},{"typeParams":["V","NSV"],"params":[{"name":"collection","type":{"k":6,"members":[{"index":true,"params":[{"name":"key","type":{"k":5}}],"type":{"k":10,"param":"V"}}]}},{"name":"key","type":{"k":5}},{"name":"notSetValue","type":{"k":10,"param":"NSV"}}],"type":{"k":14,"types":[{"k":10,"param":"V"},{"k":10,"param":"NSV"}]},"line":2361}]}},"has":{"call":{"doc":{"synopsis":"Returns true if the key is defined in the provided collection.","description":"A functional alternative to `collection.has(key)` which will also work with\nplain Objects and Arrays as an alternative for\n`collection.hasOwnProperty(key)`.\n\n<!-- runkit:activate\n     { \"preamble\": \"const { has } = require('sequins')\" }\n-->\n```js\nhas([ 'dog', 'frog', 'cat' ], 2) // true\nhas([ 'dog', 'frog', 'cat' ], 5) // false\nhas({ x: 123, y: 456 }, 'x') // true\nhas({ x: 123, y: 456 }, 'z') // false\n```","notes":[]},"signatures":[{"params":[{"name":"collection","type":{"k":11,"name":"Object"}},{"name":"key","type":{"k":0}}],"type":{"k":3},"line":2384}]}},"remove":{"call":{"doc":{"synopsis":"Removes the key at value","description":"A functional alternative to `collection.remove(key)` which will also work\nwith plain Objects and Arrays as an alternative for\n`delete collectionCopy[key]`.\n\n<!-- runkit:activate\n     { \"preamble\": \"const { remove } = require('sequins')\" }\n-->\n```js\nconst array = [ 'dog', 'frog', 'cat' ]\nremove(array, 1)\nconsole.log(array) // [ 'dog', 'cat' ]\n\nconst object = { x: 123, y: 456 }\nremove(object, 'x')\nconsole.log(object) // { y: 456 }\n```","notes":[]},"signatures":[{"typeParams":["K","C"],"params":[{"name":"collection","type":{"k":10,"param":"C"}},{"name":"key","type":{"k":10,"param":"K"}}],"type":{"k":10,"param":"C"},"line":2406},{"typeParams":["C"],"params":[{"name":"collection","type":{"k":10,"param":"C"}},{"name":"key","type":{"k":4}}],"type":{"k":10,"param":"C"},"line":2410},{"typeParams":["C","K"],"params":[{"name":"collection","type":{"k":10,"param":"C"}},{"name":"key","type":{"k":10,"param":"K"}}],"type":{"k":10,"param":"C"},"line":2411},{"typeParams":["C","K"],"params":[{"name":"collection","type":{"k":10,"param":"C"}},{"name":"key","type":{"k":10,"param":"K"}}],"type":{"k":10,"param":"C"},"line":2412}]}},"set":{"call":{"doc":{"synopsis":"Sets key to value","description":"A functional alternative to `collection.set(key, value)` which will also\nwork with plain Objects and Arrays as an alternative for\n`collectionCopy[key] = value`.\n\n<!-- runkit:activate\n     { \"preamble\": \"const { set } = require('sequins')\" }\n-->\n```js\nconst array = [ 'dog', 'frog', 'cat' ]\nset(array, 1, 'cow')\nconsole.log(array) // [ 'dog', 'cow', 'cat' ]\n\nconst object = { x: 123, y: 456 }\nset(object, 'x', 789)\nconsole.log(object) // { x: 123, y: 456 }\n```","notes":[]},"signatures":[{"typeParams":["K","V","C"],"params":[{"name":"collection","type":{"k":10,"param":"C"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"value","type":{"k":10,"param":"V"}}],"type":{"k":10,"param":"C"},"line":2437},{"typeParams":["V","C"],"params":[{"name":"collection","type":{"k":10,"param":"C"}},{"name":"key","type":{"k":4}},{"name":"value","type":{"k":10,"param":"V"}}],"type":{"k":10,"param":"C"},"line":2442},{"typeParams":["C","K"],"params":[{"name":"object","type":{"k":10,"param":"C"}},{"name":"key","type":{"k":10,"param":"K"}},{"name":"value","type":{"k":17,"type":{"k":10,"param":"C"},"index":{"k":10,"param":"K"}}}],"type":{"k":10,"param":"C"},"line":2447},{"typeParams":["V","C"],"params":[{"name":"collection","type":{"k":10,"param":"C"}},{"name":"key","type":{"k":5}},{"name":"value","type":{"k":10,"param":"V"}}],"type":{"k":10,"param":"C"},"line":2448}]}},"keys":{"call":{"doc":{"synopsis":"Gets the keys of a Collection, Object, or Array.","description":"","notes":[]},"signatures":[{"params":[{"name":"shape","type":{"k":6,"members":[{"index":true,"params":[{"name":"key","type":{"k":5}}],"type":{"k":0}}]}}],"type":{"k":11,"name":"SetSequence","args":[{"k":5}]},"line":2457},{"params":[{"name":"shape","type":{"k":11,"name":"Array","args":[{"k":0}]}}],"type":{"k":11,"name":"SetSequence","args":[{"k":4}]},"line":2458},{"typeParams":["K"],"params":[{"name":"shape","type":{"k":11,"name":"NativeMap","args":[{"k":10,"param":"K"},{"k":0}]}}],"type":{"k":11,"name":"SetSequence","args":[{"k":10,"param":"K"}]},"line":2459},{"typeParams":["V"],"params":[{"name":"shape","type":{"k":11,"name":"NativeSet","args":[{"k":10,"param":"V"}]}}],"type":{"k":11,"name":"SetSequence","args":[{"k":10,"param":"V"}]},"line":2460},{"typeParams":["K"],"params":[{"name":"shape","type":{"k":11,"name":"Collection","args":[{"k":10,"param":"K"},{"k":0}]}}],"type":{"k":11,"name":"SetSequence","args":[{"k":10,"param":"K"}]},"line":2461}]}},"values":{"call":{"doc":{"synopsis":"Gets the value of a Collection, Object, or Array.","description":"","notes":[]},"signatures":[{"typeParams":["V"],"params":[{"name":"shape","type":{"k":6,"members":[{"index":true,"params":[{"name":"key","type":{"k":5}}],"type":{"k":10,"param":"V"}}]}}],"type":{"k":11,"name":"SetSequence","args":[{"k":10,"param":"V"}]},"line":2466},{"typeParams":["V"],"params":[{"name":"shape","type":{"k":11,"name":"Array","args":[{"k":10,"param":"V"}]}}],"type":{"k":11,"name":"SetSequence","args":[{"k":10,"param":"V"}]},"line":2467},{"typeParams":["V"],"params":[{"name":"shape","type":{"k":11,"name":"NativeMap","args":[{"k":0},{"k":10,"param":"V"}]}}],"type":{"k":11,"name":"SetSequence","args":[{"k":10,"param":"V"}]},"line":2468},{"typeParams":["V"],"params":[{"name":"shape","type":{"k":11,"name":"NativeSet","args":[{"k":10,"param":"V"}]}}],"type":{"k":11,"name":"SetSequence","args":[{"k":10,"param":"V"}]},"line":2469},{"typeParams":["V"],"params":[{"name":"shape","type":{"k":11,"name":"Collection","args":[{"k":0},{"k":10,"param":"V"}]}}],"type":{"k":11,"name":"SetSequence","args":[{"k":10,"param":"V"}]},"line":2470}]}},"entries":{"call":{"doc":{"synopsis":"Gets the entries of a Collection, Object, or Array.","description":"","notes":[]},"signatures":[{"typeParams":["V"],"params":[{"name":"shape","type":{"k":6,"members":[{"index":true,"params":[{"name":"key","type":{"k":5}}],"type":{"k":10,"param":"V"}}]}}],"type":{"k":11,"name":"SetSequence","args":[{"k":16,"types":[{"k":5},{"k":10,"param":"V"}]}]},"line":2475},{"typeParams":["V"],"params":[{"name":"shape","type":{"k":11,"name":"Array","args":[{"k":10,"param":"V"}]}}],"type":{"k":11,"name":"SetSequence","args":[{"k":16,"types":[{"k":4},{"k":10,"param":"V"}]}]},"line":2476},{"typeParams":["K","V"],"params":[{"name":"shape","type":{"k":11,"name":"NativeMap","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]}}],"type":{"k":11,"name":"SetSequence","args":[{"k":16,"types":[{"k":10,"param":"K"},{"k":10,"param":"V"}]}]},"line":2477},{"typeParams":["V"],"params":[{"name":"shape","type":{"k":11,"name":"NativeSet","args":[{"k":10,"param":"V"}]}}],"type":{"k":11,"name":"SetSequence","args":[{"k":16,"types":[{"k":10,"param":"V"},{"k":10,"param":"V"}]}]},"line":2478},{"typeParams":["K","V"],"params":[{"name":"shape","type":{"k":11,"name":"Collection","args":[{"k":10,"param":"K"},{"k":10,"param":"V"}]}}],"type":{"k":11,"name":"SetSequence","args":[{"k":16,"types":[{"k":10,"param":"K"},{"k":10,"param":"V"}]}]},"line":2479}]}}}}]}
},{}],185:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var TypeKind = {
  Any: 0,

  Null: 1,
  Void: 2,
  Boolean: 3,
  Number: 4,
  String: 5,
  Object: 6,
  Array: 7,
  Never: 8,
  Function: 9,

  Param: 10,
  Type: 11,

  This: 12,
  Undefined: 13,
  Union: 14,
  Intersection: 15,
  Tuple: 16,
  Indexed: 17,
  Operator: 18
};

module.exports = TypeKind;

},{}],186:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var $__0=    require("../.."),Seq=$__0.Seq;
var getDefByPath = require("./getDefByPath");

function collectMemberGroups(interfaceDef, options = {}) {
  var members = {};

  if (interfaceDef) {
    collectFromDef(interfaceDef);
  }

  var groups = { "": [] };

  if (options.showInGroups) {
    Seq(members).forEach(function(member)  {
      (groups[member.group] || (groups[member.group] = [])).push(member);
    });
  } else {
    groups[""] = Seq(members)
      .sortBy(function(member)  {return member.memberName;})
      .to(Array);
  }

  return groups;

  function collectFromDef(def, name) {
    def.extends &&
      def.extends.forEach(function(e)  {
        var superModule = getDefByPath(e.name);
        var superInterface = superModule && superModule.interface;
        if (superInterface) {
          collectFromDef(superInterface, e.name);
        }
      });

    def.groups &&
      def.groups.forEach(function(g)  {
        Seq(g.members).forEach(function(memberDef, memberName)  {
          collectMember(g.title || "", memberName, memberDef);
        });
      });

    function collectMember(group, memberName, memberDef) {
      var member = members[memberName];
      if (member) {
        if (!member.inherited) {
          member.overrides = { name:name, def:def, memberDef:memberDef };
        }
        if (!member.group && group) {
          member.group = group;
        }
      } else {
        member = {
          group:group,
          memberName: memberName.substr(1),
          memberDef:memberDef
        };
        if (def !== interfaceDef) {
          member.inherited = { name:name, def:def };
        }
        members[memberName] = member;
      }
    }
  }
}

module.exports = collectMemberGroups;

},{"../..":1,"./getDefByPath":187}],187:[function(require,module,exports){
// Note: intentionally using raw defs, not getTypeDefs to avoid circular ref.
var defs = require("../generated/sequins.d.json");

module.exports = function getByPath(path) {
  if (!path) {
    return defs;
  }

  var pathSegments;
  if (typeof path === "string") {
    pathSegments = path.split(".");
  } else {
    pathSegments = path;
  }

  var def = defs.groups.find(function(group)  {return group.members[pathSegments[0]];}).members[
    pathSegments[0]
  ];

  pathSegments.slice(1).forEach(function(part)  {
    def =
      def &&
      def.module &&
      def.module.groups.find(function(group)  {return group.members[part];}).members[part];
  });

  return def;
};

},{"../generated/sequins.d.json":184}],188:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var markdownDocs = require("./markdownDocs");
var defs = require("../generated/sequins.d.json");

markdownDocs(defs);

module.exports = defs;

},{"../generated/sequins.d.json":184,"./markdownDocs":190}],189:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var $__0=    require("../.."),Seq=$__0.Seq;
var marked = require("marked");
var prism = require("./prism");
var collectMemberGroups = require("./collectMemberGroups");
// Note: intentionally using raw defs, not getTypeDefs to avoid circular ref.
var defs = require("../generated/sequins.d.json");

function collectAllMembersForAllTypes(defs) {
  var allMembers = new WeakMap();
  _collectAllMembersForAllTypes(defs);
  return allMembers;
  function _collectAllMembersForAllTypes(defs) {
    Seq(defs).forEach(function(def)  {
      if (def.interface) {
        var groups = collectMemberGroups(def.interface);
        allMembers.set(
          def.interface,
          Seq.Keyed(
            groups[""].map(function(member)  {return [member.memberName, member.memberDef];})
          ).to(Object)
        );
      }
      if (def.module) {
        _collectAllMembersForAllTypes(def.module);
      }
    });
    return allMembers;
  }
}

var allMembers = collectAllMembersForAllTypes(defs);

// functions come before keywords
prism.languages.insertBefore("javascript", "keyword", {
  var: /\b(this)\b/g,
  "block-keyword": /\b(if|else|while|for|function)\b/g,
  primitive: /\b(true|false|null|undefined)\b/g,
  function: prism.languages.function
});

marked.setOptions({
  xhtml: true,
  highlight: function(code)  {return prism.highlight(code, prism.languages.javascript);}
});

var renderer = new marked.Renderer();

const runkitRegExp = /^<!--\s*runkit:activate((.|\n)*)-->(.|\n)*$/;
const runkitContext = { options: "{}", activated: false };

renderer.html = function(text) {
  const result = runkitRegExp.exec(text);

  if (!result) return text;

  runkitContext.activated = true;
  try {
    runkitContext.options = result[1] ? JSON.parse(result[1]) : {};
  } catch (e) {
    runkitContext.options = {};
  }
  return text;
};

renderer.code = function(code, lang, escaped) {
  if (this.options.highlight) {
    var out = this.options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }

  const runItButton = runkitContext.activated
    ? '<a class="try-it" data-options="' +
      escape(JSON.stringify(runkitContext.options)) +
      '" onClick="runIt(this)">run it</a>'
    : "";

  runkitContext.activated = false;
  runkitContext.options = "{}";

  return (
    '<code class="codeBlock">' +
    (escaped ? code : escapeCode(code, true)) +
    runItButton +
    "</code>"
  );
};

var METHOD_RX = /^(\w+)(?:[#.](\w+))?(?:\(\))?$/;
var PARAM_RX = /^\w+$/;
var MDN_TYPES = {
  Array: true,
  Object: true,
  JSON: true
};
var MDN_BASE_URL =
  "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/";

renderer.codespan = function(text) {
  return "<code>" + decorateCodeSpan(text, this.options) + "</code>";
};

function decorateCodeSpan(text, options) {
  var context = options.context;

  if (
    context.signatures &&
    PARAM_RX.test(text) &&
    context.signatures.some(
      function(sig)  {return sig.params && sig.params.some(function(param)  {return param.name === text;});}
    )
  ) {
    return '<span class="t param">' + text + "</span>";
  }

  var method = METHOD_RX.exec(text);
  if (method) {
    method = method.slice(1).filter(Boolean);
    if (MDN_TYPES[method[0]]) {
      return (
        '<a href="' + MDN_BASE_URL + method.join("/") + '">' + text + "</a>"
      );
    }
    if (
      context.typePath &&
      !arrEndsWith(context.typePath, method) &&
      !arrEndsWith(context.typePath.slice(0, -1), method)
    ) {
      var path = findPath(context, method);
      if (path) {
        var relPath = context.relPath || "";
        return (
          '<a target="_self" href="' +
          relPath +
          "#/" +
          path.slice(1).join("/") +
          '">' +
          text +
          "</a>"
        );
      }
    }
  }

  if (options.highlight) {
    return options.highlight(unescapeCode(text), prism.languages.javascript);
  }

  return text;
}

function arrEndsWith(arr1, arr2) {
  for (var ii = 1; ii <= arr2.length; ii++) {
    if (arr2[arr2.length - ii] !== arr1[arr1.length - ii]) {
      return false;
    }
  }
  return true;
}

function findPath(context, search) {
  var relative = context.typePath;

  for (var ii = 0; ii <= relative.length; ii++) {
    var path = relative.slice(0, relative.length - ii).concat(search);
    if (
      path.reduce(
        function(def, name) 
          {return def &&
          ((def.module && def.module[name]) ||
            (def.interface &&
              allMembers &&
              allMembers.get(def.interface)[name]) ||
            undefined);},
        { module: defs }
      )
    ) {
      return path;
    }
  }
}

function escapeCode(code) {
  return code
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

function unescapeCode(code) {
  return code
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&amp;/g, "&");
}

function markdown(content, context) {
  context || (context = {});
  return content ? marked(content, { renderer:renderer, context:context }) : content;
}

module.exports = markdown;

},{"../..":1,"../generated/sequins.d.json":184,"./collectMemberGroups":186,"./prism":191,"marked":127}],190:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var $__0=    require("../.."),Seq=$__0.Seq;
var markdown = require("./markdown");

var noteTypesToPreserve = ["alias", "memberof", "pragma"];

function markdownDocs(defs) {
  markdownTypes(defs, []);

  function markdownType(typeDef, typeName, typePath) {
    markdownDoc(typeDef.doc, { typePath:typePath });
    typeDef.call &&
      markdownDoc(typeDef.call.doc, {
        typePath:typePath,
        signatures: typeDef.call.signatures
      });
    var classLikeDoc = typeDef.class || typeDef.interface;
    if (classLikeDoc) {
      markdownDoc(classLikeDoc.doc, { defs:defs, typePath:typePath });
      Seq(classLikeDoc.groups).forEach(function(group) 
        {return Seq(group.members).forEach(function(member, memberName) 
          {return markdownDoc(member.doc, {
            typePath: typePath.concat(memberName.slice(1)),
            signatures: member.signatures
          });}
        );}
      );
    }
    typeDef.module && markdownTypes(typeDef.module, typePath);
    typeDef.class &&
      typeDef.class.statics &&
      markdownTypes(typeDef.class.statics, typePath);
  }

  function markdownTypes(typeDefs, path) {
    if (typeDefs.groups) {
      for (const group of typeDefs.groups) {
        Seq(group.members).forEach(function(memberDef, memberName)  {
          markdownType(memberDef, memberName, path.concat(memberName));
        });
      }
    } else {
      Seq(typeDefs).forEach(function(typeDef, typeName)  {
        markdownType(typeDef, typeName, path.concat(typeName));
      });
    }
  }
}

function markdownDoc(doc, context) {
  if (!doc) {
    return;
  }
  doc.synopsis && (doc.synopsis = markdown(doc.synopsis, context));
  doc.description && (doc.description = markdown(doc.description, context));
  doc.notes &&
    doc.notes.forEach(function(note)  {
      if (!noteTypesToPreserve.includes(note.name)) {
        note.body = markdown(note.body, context);
      }
    });
}

module.exports = markdownDocs;

},{"../..":1,"./markdown":189}],191:[function(require,module,exports){
/* eslint-disable */

/* **********************************************
     Begin prism-core.js
********************************************** */

self =
  typeof window !== "undefined"
    ? window // if in browser
    : typeof WorkerGlobalScope !== "undefined" &&
      self instanceof WorkerGlobalScope
    ? self // if in worker
    : {}; // if in node js

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 * MIT license http://www.opensource.org/licenses/mit-license.php/
 * @author Lea Verou http://lea.verou.me
 */

var Prism = (function() {
  // Private helper vars
  var lang = /\blang(?:uage)?-(?!\*)(\w+)\b/i;

  var _ = (self.Prism = {
    util: {
      encode: function(tokens) {
        if (tokens instanceof Token) {
          return new Token(
            tokens.type,
            _.util.encode(tokens.content),
            tokens.alias
          );
        } else if (_.util.type(tokens) === "Array") {
          return tokens.map(_.util.encode);
        } else {
          return tokens
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/\u00a0/g, " ");
        }
      },

      type: function(o) {
        return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
      },

      // Deep clone a language definition (e.g. to extend it)
      clone: function(o) {
        var type = _.util.type(o);

        switch (type) {
          case "Object":
            var clone = {};

            for (var key in o) {
              if (o.hasOwnProperty(key)) {
                clone[key] = _.util.clone(o[key]);
              }
            }

            return clone;

          case "Array":
            return o.slice();
        }

        return o;
      }
    },

    languages: {
      extend: function(id, redef) {
        var lang = _.util.clone(_.languages[id]);

        for (var key in redef) {
          lang[key] = redef[key];
        }

        return lang;
      },

      /**
       * Insert a token before another token in a language literal
       * As this needs to recreate the object (we cannot actually insert before keys in object literals),
       * we cannot just provide an object, we need anobject and a key.
       * @param inside The key (or language id) of the parent
       * @param before The key to insert before. If not provided, the function appends instead.
       * @param insert Object with the key/value pairs to insert
       * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
       */
      insertBefore: function(inside, before, insert, root) {
        root = root || _.languages;
        var grammar = root[inside];

        if (arguments.length == 2) {
          insert = arguments[1];

          for (var newToken in insert) {
            if (insert.hasOwnProperty(newToken)) {
              grammar[newToken] = insert[newToken];
            }
          }

          return grammar;
        }

        var ret = {};

        for (var token in grammar) {
          if (grammar.hasOwnProperty(token)) {
            if (token == before) {
              for (var newToken in insert) {
                if (insert.hasOwnProperty(newToken)) {
                  ret[newToken] = insert[newToken];
                }
              }
            }

            ret[token] = grammar[token];
          }
        }

        // Update references in other language definitions
        _.languages.DFS(_.languages, function(key, value) {
          if (value === root[inside] && key != inside) {
            this[key] = ret;
          }
        });

        return (root[inside] = ret);
      },

      // Traverse a language definition with Depth First Search
      DFS: function(o, callback, type) {
        for (var i in o) {
          if (o.hasOwnProperty(i)) {
            callback.call(o, i, o[i], type || i);

            if (_.util.type(o[i]) === "Object") {
              _.languages.DFS(o[i], callback);
            } else if (_.util.type(o[i]) === "Array") {
              _.languages.DFS(o[i], callback, i);
            }
          }
        }
      }
    },

    highlightAll: function(async, callback) {
      var elements = document.querySelectorAll(
        'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
      );

      for (var i = 0, element; (element = elements[i++]); ) {
        _.highlightElement(element, async === true, callback);
      }
    },

    highlightElement: function(element, async, callback) {
      // Find language
      var language,
        grammar,
        parent = element;

      while (parent && !lang.test(parent.className)) {
        parent = parent.parentNode;
      }

      if (parent) {
        language = (parent.className.match(lang) || [, ""])[1];
        grammar = _.languages[language];
      }

      if (!grammar) {
        return;
      }

      // Set language on the element, if not present
      element.className =
        element.className.replace(lang, "").replace(/\s+/g, " ") +
        " language-" +
        language;

      // Set language on the parent, for styling
      parent = element.parentNode;

      if (/pre/i.test(parent.nodeName)) {
        parent.className =
          parent.className.replace(lang, "").replace(/\s+/g, " ") +
          " language-" +
          language;
      }

      var code = element.textContent;

      if (!code) {
        return;
      }

      var env = {
        element: element,
        language: language,
        grammar: grammar,
        code: code
      };

      _.hooks.run("before-highlight", env);

      if (async && self.Worker) {
        var worker = new Worker(_.filename);

        worker.onmessage = function(evt) {
          env.highlightedCode = Token.stringify(JSON.parse(evt.data), language);

          _.hooks.run("before-insert", env);

          env.element.innerHTML = env.highlightedCode;

          callback && callback.call(env.element);
          _.hooks.run("after-highlight", env);
        };

        worker.postMessage(
          JSON.stringify({
            language: env.language,
            code: env.code
          })
        );
      } else {
        env.highlightedCode = _.highlight(env.code, env.grammar, env.language);

        _.hooks.run("before-insert", env);

        env.element.innerHTML = env.highlightedCode;

        callback && callback.call(element);

        _.hooks.run("after-highlight", env);
      }
    },

    highlight: function(text, grammar, language) {
      var tokens = _.tokenize(text, grammar);
      return Token.stringify(_.util.encode(tokens), language);
    },

    tokenize: function(text, grammar, language) {
      var Token = _.Token;

      var strarr = [text];

      var rest = grammar.rest;

      if (rest) {
        for (var token in rest) {
          grammar[token] = rest[token];
        }

        delete grammar.rest;
      }

      tokenloop: for (var token in grammar) {
        if (!grammar.hasOwnProperty(token) || !grammar[token]) {
          continue;
        }

        var patterns = grammar[token];
        patterns = _.util.type(patterns) === "Array" ? patterns : [patterns];

        for (var j = 0; j < patterns.length; ++j) {
          var pattern = patterns[j],
            inside = pattern.inside,
            lookbehind = !!pattern.lookbehind,
            lookbehindLength = 0,
            alias = pattern.alias;

          pattern = pattern.pattern || pattern;

          for (var i = 0; i < strarr.length; i++) {
            // Don’t cache length as it changes during the loop

            var str = strarr[i];

            if (strarr.length > text.length) {
              // Something went terribly wrong, ABORT, ABORT!
              break tokenloop;
            }

            if (str instanceof Token) {
              continue;
            }

            pattern.lastIndex = 0;

            var match = pattern.exec(str);

            if (match) {
              if (lookbehind) {
                lookbehindLength = match[1].length;
              }

              var from = match.index - 1 + lookbehindLength,
                match = match[0].slice(lookbehindLength),
                len = match.length,
                to = from + len,
                before = str.slice(0, from + 1),
                after = str.slice(to + 1);

              var args = [i, 1];

              if (before) {
                args.push(before);
              }

              var wrapped = new Token(
                token,
                inside ? _.tokenize(match, inside) : match,
                alias
              );

              args.push(wrapped);

              if (after) {
                args.push(after);
              }

              Array.prototype.splice.apply(strarr, args);
            }
          }
        }
      }

      return strarr;
    },

    hooks: {
      all: {},

      add: function(name, callback) {
        var hooks = _.hooks.all;

        hooks[name] = hooks[name] || [];

        hooks[name].push(callback);
      },

      run: function(name, env) {
        var callbacks = _.hooks.all[name];

        if (!callbacks || !callbacks.length) {
          return;
        }

        for (var i = 0, callback; (callback = callbacks[i++]); ) {
          callback(env);
        }
      }
    }
  });

  var Token = (_.Token = function(type, content, alias) {
    this.type = type;
    this.content = content;
    this.alias = alias;
  });

  Token.stringify = function(o, language, parent) {
    if (typeof o == "string") {
      return o;
    }

    if (Object.prototype.toString.call(o) == "[object Array]") {
      return o
        .map(function(element) {
          return Token.stringify(element, language, o);
        })
        .join("");
    }

    var env = {
      type: o.type,
      content: Token.stringify(o.content, language, parent),
      tag: "span",
      classes: ["token", o.type],
      attributes: {},
      language: language,
      parent: parent
    };

    if (env.type == "comment") {
      env.attributes["spellcheck"] = "true";
    }

    if (o.alias) {
      var aliases = _.util.type(o.alias) === "Array" ? o.alias : [o.alias];
      Array.prototype.push.apply(env.classes, aliases);
    }

    _.hooks.run("wrap", env);

    var attributes = "";

    for (var name in env.attributes) {
      attributes += name + '="' + (env.attributes[name] || "") + '"';
    }

    return (
      "<" +
      env.tag +
      ' class="' +
      env.classes.join(" ") +
      '" ' +
      attributes +
      ">" +
      env.content +
      "</" +
      env.tag +
      ">"
    );
  };

  if (!self.document) {
    if (!self.addEventListener) {
      // in Node.js
      return self.Prism;
    }
    // In worker
    self.addEventListener(
      "message",
      function(evt) {
        var message = JSON.parse(evt.data),
          lang = message.language,
          code = message.code;

        self.postMessage(
          JSON.stringify(_.util.encode(_.tokenize(code, _.languages[lang])))
        );
        self.close();
      },
      false
    );

    return self.Prism;
  }

  // Get current script and highlight
  var script = document.getElementsByTagName("script");

  script = script[script.length - 1];

  if (script) {
    _.filename = script.src;

    if (document.addEventListener && !script.hasAttribute("data-manual")) {
      document.addEventListener("DOMContentLoaded", _.highlightAll);
    }
  }

  return self.Prism;
})();

if (typeof module !== "undefined" && module.exports) {
  module.exports = Prism;
}

/* **********************************************
     Begin prism-markup.js
********************************************** */

Prism.languages.markup = {
  comment: /<!--[\w\W]*?-->/g,
  prolog: /<\?.+?\?>/,
  doctype: /<!DOCTYPE.+?>/,
  cdata: /<!\[CDATA\[[\w\W]*?]]>/i,
  tag: {
    pattern: /<\/?[\w:-]+\s*(?:\s+[\w:-]+(?:=(?:("|')(\\?[\w\W])*?\1|[^\s'">=]+))?\s*)*\/?>/gi,
    inside: {
      tag: {
        pattern: /^<\/?[\w:-]+/i,
        inside: {
          punctuation: /^<\/?/,
          namespace: /^[\w-]+?:/
        }
      },
      "attr-value": {
        pattern: /=(?:('|")[\w\W]*?(\1)|[^\s>]+)/gi,
        inside: {
          punctuation: /=|>|"/g
        }
      },
      punctuation: /\/?>/g,
      "attr-name": {
        pattern: /[\w:-]+/g,
        inside: {
          namespace: /^[\w-]+?:/
        }
      }
    }
  },
  entity: /\&#?[\da-z]{1,8};/gi
};

// Plugin to make entity title show the real entity, idea by Roman Komarov
Prism.hooks.add("wrap", function(env) {
  if (env.type === "entity") {
    env.attributes["title"] = env.content.replace(/&amp;/, "&");
  }
});

/* **********************************************
     Begin prism-css.js
********************************************** */

Prism.languages.css = {
  comment: /\/\*[\w\W]*?\*\//g,
  atrule: {
    pattern: /@[\w-]+?.*?(;|(?=\s*{))/gi,
    inside: {
      punctuation: /[;:]/g
    }
  },
  url: /url\((["']?).*?\1\)/gi,
  selector: /[^\{\}\s][^\{\};]*(?=\s*\{)/g,
  property: /(\b|\B)[\w-]+(?=\s*:)/gi,
  string: /("|')(\\?.)*?\1/g,
  important: /\B!important\b/gi,
  punctuation: /[\{\};:]/g,
  function: /[-a-z0-9]+(?=\()/gi
};

if (Prism.languages.markup) {
  Prism.languages.insertBefore("markup", "tag", {
    style: {
      pattern: /<style[\w\W]*?>[\w\W]*?<\/style>/gi,
      inside: {
        tag: {
          pattern: /<style[\w\W]*?>|<\/style>/gi,
          inside: Prism.languages.markup.tag.inside
        },
        rest: Prism.languages.css
      },
      alias: "language-css"
    }
  });

  Prism.languages.insertBefore(
    "inside",
    "attr-value",
    {
      "style-attr": {
        pattern: /\s*style=("|').+?\1/gi,
        inside: {
          "attr-name": {
            pattern: /^\s*style/gi,
            inside: Prism.languages.markup.tag.inside
          },
          punctuation: /^\s*=\s*['"]|['"]\s*$/,
          "attr-value": {
            pattern: /.+/gi,
            inside: Prism.languages.css
          }
        },
        alias: "language-css"
      }
    },
    Prism.languages.markup.tag
  );
}

/* **********************************************
     Begin prism-clike.js
********************************************** */

Prism.languages.clike = {
  comment: [
    {
      pattern: /(^|[^\\])\/\*[\w\W]*?\*\//g,
      lookbehind: true
    },
    {
      pattern: /(^|[^\\:])\/\/.*?(\r?\n|$)/g,
      lookbehind: true
    }
  ],
  string: /("|')(\\?.)*?\1/g,
  "class-name": {
    pattern: /((?:(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/gi,
    lookbehind: true,
    inside: {
      punctuation: /(\.|\\)/
    }
  },
  keyword: /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/g,
  boolean: /\b(true|false)\b/g,
  function: {
    pattern: /[a-z0-9_]+\(/gi,
    inside: {
      punctuation: /\(/
    }
  },
  number: /\b-?(0x[\dA-Fa-f]+|\d*\.?\d+([Ee]-?\d+)?)\b/g,
  operator: /[-+]{1,2}|!|<=?|>=?|={1,3}|&{1,2}|\|?\||\?|\*|\/|\~|\^|\%/g,
  ignore: /&(lt|gt|amp);/gi,
  punctuation: /[{}[\];(),.:]/g
};

/* **********************************************
     Begin prism-javascript.js
********************************************** */

Prism.languages.javascript = Prism.languages.extend("clike", {
  keyword: /\b(break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|get|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|set|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/g,
  number: /\b-?(0x[\dA-Fa-f]+|\d*\.?\d+([Ee]-?\d+)?|NaN|-?Infinity)\b/g
});

Prism.languages.insertBefore("javascript", "keyword", {
  regex: {
    pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\r\n])+\/[gim]{0,3}(?=\s*($|[\r\n,.;})]))/g,
    lookbehind: true
  }
});

if (Prism.languages.markup) {
  Prism.languages.insertBefore("markup", "tag", {
    script: {
      pattern: /<script[\w\W]*?>[\w\W]*?<\/script>/gi,
      inside: {
        tag: {
          pattern: /<script[\w\W]*?>|<\/script>/gi,
          inside: Prism.languages.markup.tag.inside
        },
        rest: Prism.languages.javascript
      },
      alias: "language-javascript"
    }
  });
}

/* **********************************************
     Begin prism-file-highlight.js
********************************************** */

(function() {
  if (!self.Prism || !self.document || !document.querySelector) {
    return;
  }

  var Extensions = {
    js: "javascript",
    html: "markup",
    svg: "markup",
    xml: "markup",
    py: "python",
    rb: "ruby"
  };

  Array.prototype.slice
    .call(document.querySelectorAll("pre[data-src]"))
    .forEach(function(pre) {
      var src = pre.getAttribute("data-src");
      var extension = (src.match(/\.(\w+)$/) || [, ""])[1];
      var language = Extensions[extension] || extension;

      var code = document.createElement("code");
      code.className = "language-" + language;

      pre.textContent = "";

      code.textContent = "Loading…";

      pre.appendChild(code);

      var xhr = new XMLHttpRequest();

      xhr.open("GET", src, true);

      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          if (xhr.status < 400 && xhr.responseText) {
            code.textContent = xhr.responseText;

            Prism.highlightElement(code);
          } else if (xhr.status >= 400) {
            code.textContent =
              "✖ Error " +
              xhr.status +
              " while fetching file: " +
              xhr.statusText;
          } else {
            code.textContent = "✖ Error: File does not exist or is empty";
          }
        }
      };

      xhr.send(null);
    });
})();

},{}],192:[function(require,module,exports){
(function (global){
global.runIt = function runIt(button) {
  if (!global.RunKit) return;

  var container = document.createElement("div");
  var codeElement = button.parentNode;
  var parent = codeElement.parentNode;

  parent.insertBefore(container, codeElement);
  parent.removeChild(codeElement);
  codeElement.removeChild(button);

  const options = JSON.parse(unescape(button.dataset.options));

  function withCorrectVersion(code) {
    return code;
    // return code.replace(
    //   /require\('sequins'\)/g,
    //   "require('sequins@VERSION')"
    // );
  }

  global.RunKit.createNotebook({
    element: container,
    nodeVersion: options.nodeVersion || "*",
    preamble: withCorrectVersion(
      "const assert = (" +
        makeAssert +
        ")(require('sequins'));" +
        (options.preamble || "")
    ),
    source: withCorrectVersion(
      codeElement.textContent.replace(/\n(>[^\n]*\n?)+$/g, "")
    ),
    minHeight: "52px",
    onLoad: function(notebook) {
      notebook.evaluate();
    }
  });
};

function makeAssert(Sequins) {
  var isCollection = Sequins.isCollection;
  var html = ("\n    <style>\n      * {\n        font-size: 14px;\n        font-family: monospace;\n      }\n\n      code {\n        font-family: monospace;\n        color: #4183C4;\n        text-decoration: none;\n        text-decoration: none;\n        background: rgba(65, 131, 196, 0.1);\n        border-radius: 2px;\n        padding: 2px;\n    }\n\n      .success {\n        color: rgba(84,184,54,1.0);\n      }\n\n      .success:before {\n        content: \"✅\";\n      }\n\n      .failure {\n        color: rgba(220,47,33,1.0);\n      }\n\n      .failure i {\n        color: rgba(210,44,31,1.0);\n      }\n\n      .failure:before {\n        content: \"❌\";\n      }\n    </style>"



































);

  function compare(lhs, rhs, same, identical) {
    var both = !identical && isCollection(lhs) && isCollection(rhs);

    if (both) return lhs.equals(rhs);

    return lhs === rhs;
  }

  function message(lhs, rhs, same, identical) {
    var result = compare(lhs, rhs, same, identical);
    var comparison = result
      ? identical
        ? "strict equal to"
        : "does equal"
      : identical
      ? "not strict equal to"
      : "does not equal";
    var className = result === same ? "success" : "failure";
    var lhsString = isCollection(lhs) ? lhs + "" : JSON.stringify(lhs);
    var rhsString = isCollection(rhs) ? rhs + "" : JSON.stringify(rhs);

    return (html += ("\n      <span class=\"" + 
className + "\">\n        <code>" + 
lhsString + "</code>\n        " + 
comparison + "\n        <code>" + 
rhsString + "</code>\n      </span><br/>"
));
  }

  function equal(lhs, rhs) {
    return message(lhs, rhs, true);
  }

  function notEqual(lhs, rhs) {
    return message(lhs, rhs, false);
  }

  function strictEqual(lhs, rhs) {
    return message(lhs, rhs, true, true);
  }

  function notStrictEqual(lhs, rhs) {
    return message(lhs, rhs, false, true);
  }

  return { equal:equal, notEqual:notEqual, strictEqual:strictEqual, notStrictEqual:notStrictEqual };
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],193:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var React = require("react");
var CSSCore = require("react/lib/CSSCore");
var Router = require("react-router");
var $__0=    require("../../../.."),Seq=$__0.Seq;
var TypeKind = require("../../../lib/TypeKind");
var defs = require("../../../lib/getTypeDefs");

var InterfaceDef = React.createClass({displayName: "InterfaceDef",
  render:function() {
    const $__0=     this.props,name=$__0.name,def=$__0.def;

    return (
      React.createElement("span", {className: "t interfaceDef"}, 
        React.createElement("span", {className: "t keyword"}, def.isClass ? "class" : "type", " "), 
        React.createElement("span", {className: "t typeName"}, name), 
        def.typeParams && [
          "<",
          Seq(def.typeParams)
            .map(function(t, k)  
              {return React.createElement("span", {className: "t typeParam", key: k}, 
                t
              );}
            )
            .interpose(", ")
            .to(Array),
          ">"
        ], 
        def.extends && def.extends.length
          ? [
              React.createElement("span", {className: "t keyword"}, " extends "),
              Seq(def.extends)
                .map(function(e, i)  {return React.createElement(TypeDef, {key: i, type: e});})
                .interpose(", ")
                .to(Array)
            ]
          : null, 
        def.implements && def.implements.length
          ? [
              React.createElement("span", {className: "t keyword"}, " implements "),
              Seq(def.implements)
                .map(function(e, i)  {return React.createElement(TypeDef, {key: i, type: e});})
                .interpose(", ")
                .to(Array)
            ]
          : null, 
        def.isClass && (
          React.createElement("span", null, 
            " {", " ", React.createElement("br", null), 
            Seq(def.constructor.signatures)
              .map(function(constructSig, i)  
                {return React.createElement(CallSigDef, {name: "constructor", callSig: constructSig, key: i});}
              )
              .concat([null])
              .interpose(React.createElement("br", null))
              .to(Array), 
            "}"
          )
        )
      )
    );
  }
});

exports.InterfaceDef = InterfaceDef;

var CallSigDef = React.createClass({displayName: "CallSigDef",
  render:function() {
    var info = this.props.info;
    var module = this.props.module;
    var name = this.props.name;
    var callSig = this.props.callSig || {};

    var shouldWrap = callSigLength(info, module, name, callSig) > 80;

    return (
      React.createElement("span", {className: "t callSig"}, 
        module && [React.createElement("span", {className: "t fnQualifier"}, module), "."], 
        React.createElement("span", {className: "t fnName"}, name), 
        callSig.typeParams && [
          "<",
          Seq(callSig.typeParams)
            .map(function(t)  {return React.createElement("span", {className: "t typeParam"}, t);})
            .interpose(", ")
            .to(Array),
          ">"
        ], 
        "(", 
        callSig && functionParams(info, callSig.params, shouldWrap), 
        ")", 
        callSig.type && [": ", React.createElement(TypeDef, {info: info, type: callSig.type})]
      )
    );
  }
});

exports.CallSigDef = CallSigDef;

var TypeDef = React.createClass({displayName: "TypeDef",
  render:function() {
    var info = this.props.info;
    var type = this.props.type;
    var prefix = this.props.prefix;
    switch (type.k) {
      case TypeKind.Never:
        return this.wrap("primitive", "never");
      case TypeKind.Null:
        return this.wrap("primitive", "null");
      case TypeKind.Void:
        return this.wrap("primitive", "void");
      case TypeKind.Any:
        return this.wrap("primitive", "any");
      case TypeKind.This:
        return this.wrap("primitive", "this");
      case TypeKind.Undefined:
        return this.wrap("primitive", "undefined");
      case TypeKind.Boolean:
        return this.wrap("primitive", "boolean");
      case TypeKind.Number:
        return this.wrap("primitive", "number");
      case TypeKind.String:
        return this.wrap("primitive", "string");
      case TypeKind.Union:
        return this.wrap("union", [
          Seq(type.types)
            .map(function(t)  {return React.createElement(TypeDef, {info: info, type: t});})
            .interpose(" | ")
            .to(Array)
        ]);
      case TypeKind.Intersection:
        return this.wrap("intersection", [
          Seq(type.types)
            .map(function(t)  {return React.createElement(TypeDef, {info: info, type: t});})
            .interpose(" & ")
            .to(Array)
        ]);
      case TypeKind.Tuple:
        return this.wrap("tuple", [
          "[",
          Seq(type.types)
            .map(function(t)  {return React.createElement(TypeDef, {info: info, type: t});})
            .interpose(", ")
            .to(Array),
          "]"
        ]);
      case TypeKind.Object:
        return this.wrap("object", [
          "{",
          Seq(type.members)
            .map(function(t)  {return React.createElement(MemberDef, {member: t});})
            .interpose(", ")
            .to(Array),
          "}"
        ]);
      case TypeKind.Indexed:
        return this.wrap("indexed", [
          React.createElement(TypeDef, {info: info, type: type.type}),
          "[",
          React.createElement(TypeDef, {info: info, type: type.index}),
          "]"
        ]);
      case TypeKind.Operator:
        return this.wrap("operator", [
          this.wrap("primitive", type.operator),
          " ",
          React.createElement(TypeDef, {info: info, type: type.type})
        ]);
      case TypeKind.Array:
        return this.wrap("array", [
          React.createElement(TypeDef, {info: info, type: type.type}),
          "[]"
        ]);
      case TypeKind.Function:
        var shouldWrap = (prefix || 0) + funcLength(info, type) > 78;
        return this.wrap("function", [
          type.typeParams && [
            "<",
            Seq(type.typeParams)
              .map(function(t, k)  
                {return React.createElement("span", {className: "t typeParam", key: k}, 
                  t
                );}
              )
              .interpose(", ")
              .to(Array),
            ">"
          ],
          "(",
          functionParams(info, type.params, shouldWrap),
          ") => ",
          React.createElement(TypeDef, {info: info, type: type.type})
        ]);
      case TypeKind.Param:
        return info && info.propMap[info.defining + "<" + type.param] ? (
          React.createElement(TypeDef, {type: info.propMap[info.defining + "<" + type.param]})
        ) : (
          this.wrap("typeParam", type.param)
        );
      case TypeKind.Type:
        var def = defs[type.name];

        var typeNameElement = React.createElement("span", {className: "t typeName"}, type.name);
        if (def) {
          typeNameElement = (
            React.createElement(Router.Link, {to: "/" + type.name}, typeNameElement)
          );
        }
        return this.wrap("type", [
          typeNameElement,
          type.args && [
            "<",
            Seq(type.args)
              .map(function(a)  {return React.createElement(TypeDef, {info: info, type: a});})
              .interpose(", ")
              .to(Array),
            ">"
          ]
        ]);
    }
    throw new Error("Unknown kind " + type.k);
  },

  mouseOver:function(event) {
    CSSCore.addClass(this.getDOMNode(), "over");
    event.stopPropagation();
  },

  mouseOut:function() {
    CSSCore.removeClass(this.getDOMNode(), "over");
  },

  wrap:function(className, child) {
    return (
      React.createElement("span", {
        className: "t " + className, 
        onMouseOver: this.mouseOver, 
        onFocus: this.mouseOver, 
        onMouseOut: this.mouseOut, 
        onBlur: this.mouseOut
      }, 
        child
      )
    );
  }
});

exports.TypeDef = TypeDef;

var MemberDef = React.createClass({displayName: "MemberDef",
  render:function() {
    var module = this.props.module;
    var member = this.props.member;
    return (
      React.createElement("span", {className: "t member"}, 
        module && [React.createElement("span", {className: "t fnQualifier"}, module), "."], 
        member.index ? (
          ["[", functionParams(null, member.params), "]"]
        ) : (
          React.createElement("span", {className: "t memberName"}, member.name)
        ), 
        member.construct ? "()" : "", 
        member.type && [": ", React.createElement(TypeDef, {type: member.type})]
      )
    );
  }
});

exports.MemberDef = MemberDef;

function functionParams(info, params, shouldWrap) {
  var elements = Seq(params)
    .map(function(t)  {return [
      t.varArgs ? "..." : null,
      React.createElement("span", {className: "t param"}, t.name),
      t.optional ? "?: " : ": ",
      React.createElement(TypeDef, {
        prefix: t.name.length + (t.varArgs ? 3 : 0) + (t.optional ? 3 : 2), 
        info: info, 
        type: t.type}
      )
    ];})
    .interpose(shouldWrap ? [",", React.createElement("br", null)] : ", ")
    .to(Array);
  return shouldWrap ? (
    React.createElement("div", {className: "t blockParams"}, elements)
  ) : (
    elements
  );
}

function callSigLength(info, module, name, sig) {
  return (module ? module.length + 1 : 0) + name.length + funcLength(info, sig);
}

function funcLength(info, sig) {
  return (
    (sig.typeParams ? 2 + sig.typeParams.join(", ").length : 0) +
    2 +
    (sig.params ? paramLength(info, sig.params) : 0) +
    (sig.type ? 2 + typeLength(info, sig.type) : 0)
  );
}

function paramLength(info, params) {
  return params.reduce(
    function(s, p) 
      {return s +
      (p.varArgs ? 3 : 0) +
      p.name.length +
      (p.optional ? 3 : 2) +
      typeLength(info, p.type);},
    (params.length - 1) * 2
  );
}

function memberLength(info, members) {
  return members.reduce(
    function(s, m) 
      {return s +
      (m.index ? paramLength(info, m.params) + 4 : m.name + 2) +
      typeLength(info, m.type);},
    (members.length - 1) * 2
  );
}

function typeLength(info, type) {
  if (!type) {
    throw new Error("Expected type");
  }
  switch (type.k) {
    case TypeKind.Never:
      return 5;
    case TypeKind.Null:
      return 4;
    case TypeKind.Void:
      return 4;
    case TypeKind.Any:
      return 3;
    case TypeKind.This:
      return 4;
    case TypeKind.Undefined:
      return 9;
    case TypeKind.Boolean:
      return 7;
    case TypeKind.Number:
      return 6;
    case TypeKind.String:
      return 6;
    case TypeKind.Union:
    case TypeKind.Intersection:
      return (
        type.types.reduce(function(s, t)  {return s + typeLength(info, t);}, 0) +
        (type.types.length - 1) * 3
      );
    case TypeKind.Tuple:
      return (
        2 +
        type.types.reduce(function(s, t)  {return s + typeLength(info, t);}, 0) +
        (type.types.length - 1) * 2
      );
    case TypeKind.Object:
      return 2 + memberLength(info, type.members);
    case TypeKind.Indexed:
      return 2 + typeLength(info, type.type) + typeLength(info, type.index);
    case TypeKind.Operator:
      return 1 + type.operator.length + typeLength(info, type.type);
    case TypeKind.Array:
      return typeLength(info, type.type) + 2;
    case TypeKind.Function:
      return 2 + funcLength(info, type);
    case TypeKind.Param:
      return info && info.propMap[info.defining + "<" + type.param]
        ? typeLength(null, info.propMap[info.defining + "<" + type.param])
        : type.param.length;
    case TypeKind.Type:
      return (
        type.name.length +
        (!type.args
          ? 0
          : type.args.reduce(
              function(s, a)  {return s + typeLength(info, a);},
              type.args.length * 2
            ))
      );
  }
  throw new Error("Type with unknown kind " + JSON.stringify(type));
}

},{"../../../..":1,"../../../lib/TypeKind":185,"../../../lib/getTypeDefs":188,"react":"react","react-router":143,"react/lib/CSSCore":167}],194:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var React = require("react");
var packageJson = require("../../../../package.json");

var DocHeader = React.createClass({displayName: "DocHeader",
  render:function() {
    return (
      React.createElement("div", {className: "header"}, 
        React.createElement("div", {className: "miniHeader"}, 
          React.createElement("div", {className: "miniHeaderMask"}, 
            React.createElement("div", {className: "miniHeaderBody"}, 
              React.createElement("div", {className: "miniHeaderContents"}, 
                React.createElement("a", {href: "./", target: "_self", className: "miniLogo"}, 
                  "sequins"
                ), 
                React.createElement("a", {href: "./", target: "_self"}, 
                  "Docs (v", 
                  packageJson.version, ")"
                ), 
                React.createElement("a", {href: "https://stackoverflow.com/questions/tagged/sequins?sort=votes"}, 
                  "Questions"
                ), 
                React.createElement("a", {href: "https://github.com/conartist6/sequins/"}, "Github")
              )
            )
          ), 
          React.createElement("div", {className: "miniHeaderBody"}, 
            React.createElement("div", {className: "miniHeaderContents"}, 
              React.createElement("div", {className: "miniLogo inverted"}, 
                React.createElement("span", {className: "hidden"}, "se"), "q", 
                React.createElement("span", {className: "hidden"}, "uins")
              )
            )
          )
        )
      )
    );
  }
});

module.exports = DocHeader;

},{"../../../../package.json":183,"react":"react"}],195:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var React = require("react");
var Router = require("react-router");
var $__0=    require("../../../.."),Seq=$__0.Seq;
var Markdown = require("./MarkDown");

var DocOverview = React.createClass({displayName: "DocOverview",
  render:function() {
    var def = this.props.def;
    var doc = def.doc;

    return (
      React.createElement("div", null, 
        doc && (
          React.createElement("section", null, 
            React.createElement(Markdown, {contents: doc.synopsis}), 
            doc.description && React.createElement(Markdown, {contents: doc.description})
          )
        ), 
        Seq(def.groups)
          .map(function(group)  {
            return (
              React.createElement("section", null, 
                React.createElement("h4", {className: "groupTitle"}, group.title), 
                Seq(group.members)
                  .map(function(t, name)  {
                    let isFunction = false;
                    if (t.class) {
                      t = t.class;
                    } else if (t.interface) {
                      t = t.interface;
                    } else if (!t.module) {
                      isFunction = true;
                      t = t.call;
                    }

                    return (
                      React.createElement("section", {key: name, className: "interfaceMember"}, 
                        React.createElement("h3", {className: "memberLabel"}, 
                          React.createElement(Router.Link, {to: "/" + name}, 
                            name + (isFunction ? "()" : "")
                          )
                        ), 
                        t.doc && (
                          React.createElement(Markdown, {
                            className: "detail", 
                            contents: t.doc.synopsis}
                          )
                        )
                      )
                    );
                  })
                  .values()
                  .to(Array)
              )
            );
          })
          .to(Array)
      )
    );
  }
});

module.exports = DocOverview;

},{"../../../..":1,"./MarkDown":196,"react":"react","react-router":143}],196:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var React = require("react");

var MarkDown = React.createClass({displayName: "MarkDown",
  shouldComponentUpdate:function() {
    return false;
  },

  render:function() {
    var html = this.props.contents;
    return (
      React.createElement("div", {
        className: this.props.className, 
        dangerouslySetInnerHTML: { __html: html}}
      )
    );
  }
});

module.exports = MarkDown;

},{"react":"react"}],197:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var React = require("react");
var ReactTransitionEvents = require("react/lib/ReactTransitionEvents");
var Router = require("react-router");
var $__0=     require("./Defs"),CallSigDef=$__0.CallSigDef,MemberDef=$__0.MemberDef;
var PageDataMixin = require("./PageDataMixin");
var isMobile = require("./isMobile");
var MarkDown = require("./MarkDown");
var $__1=    require("./utils"),getDisplayTypeName=$__1.getDisplayTypeName;

var $__2=    React.addons,TransitionGroup=$__2.TransitionGroup;

var ignoredNotes = ["constructs", "pragma"];

var MemberDoc = React.createClass({displayName: "MemberDoc",
  mixins: [PageDataMixin, Router.Navigation],

  getInitialState:function() {
    var showDetail = this.props.showDetail;
    return { detail: showDetail };
  },

  componentDidMount:function() {
    if (this.props.showDetail) {
      var node = this.getDOMNode();
      var navType = this.getPageData().type;
      if (navType === "init" || navType === "push") {
        window.scrollTo(window.scrollX, offsetTop(node) - FIXED_HEADER_HEIGHT);
      }
    }
  },

  componentWillReceiveProps:function(nextProps) {
    if (nextProps.showDetail && !this.props.showDetail) {
      this.scrollTo = true;
      this.setState({ detail: true });
    }
  },

  componentDidUpdate:function() {
    if (this.scrollTo) {
      this.scrollTo = false;
      var node = this.getDOMNode();
      var navType = this.getPageData().type;
      if (navType === "init" || navType === "push") {
        window.scrollTo(window.scrollX, offsetTop(node) - FIXED_HEADER_HEIGHT);
      }
    }
  },

  toggleDetail:function() {
    // Note: removed this because it drops the URL bar on mobile, and that's
    // the only place it's currently being used.
    // var member = this.props.member;
    // var name = member.memberName;
    // var typeName = this.props.parentName;
    // var showDetail = this.props.showDetail;
    // if (!this.state.detail) {
    //   this.replaceWith('/' + (typeName ? typeName + '/' : '') + name );
    // } else if (this.state.detail && showDetail) {
    //   this.replaceWith('/' + (typeName || '') );
    // }
    this.setState({ detail: !this.state.detail });
  },

  render:function() {
    var typePropMap = this.props.typePropMap;
    var member = this.props.member;
    var module = member.isStatic ? this.props.parentName : null;
    var name = member.memberName;
    var def = member.memberDef;
    var doc = def.doc || {};
    var isProp = !def.signatures;

    var typeInfo = member.inherited && {
      propMap: typePropMap,
      defining: member.inherited.name
    };

    var showDetail = isMobile ? this.state.detail : true;

    var memberAnchorLink = this.props.parentName + "/" + name;

    var typeDef = isProp ? (
      React.createElement("code", {key: "typeDef", className: "codeBlock memberSignature"}, 
        React.createElement(MemberDef, {module: module, member: { name:name, type: def.type}})
      )
    ) : (
      React.createElement("code", {key: "typeDef", className: "codeBlock memberSignature"}, 
        def.signatures.map(function(callSig, i)  {return [
          React.createElement(CallSigDef, {
            key: i, 
            info: typeInfo, 
            module: module, 
            name: name, 
            callSig: callSig}
          ),
          "\n"
        ];})
      )
    );

    var metadata = [
      member.inherited && (
        React.createElement("section", {key: "inherited"}, 
          React.createElement("h4", {className: "infoHeader"}, "Inherited from"), 
          React.createElement("code", null, 
            React.createElement(Router.Link, {to: "/" + member.inherited.name + "/" + name}, 
              member.inherited.name + "#" + name
            )
          )
        )
      ),
      member.overrides && (
        React.createElement("section", {key: "overrides"}, 
          React.createElement("h4", {className: "infoHeader"}, "Overrides"), 
          React.createElement("code", null, 
            React.createElement(Router.Link, {to: "/" + member.overrides.name + "/" + name}, 
              member.overrides.name + "#" + name
            )
          )
        )
      ),
      ...(doc.notes
        ? doc.notes
            .filter(function(note)  {return !ignoredNotes.includes(note.name);})
            .map(function(note, i)  
              {return React.createElement("section", {key: ("note_" + i)}, 
                React.createElement("h4", {className: "infoHeader"}, note.name), 
                note.name === "alias" ? (
                  React.createElement("code", null, 
                    React.createElement(CallSigDef, {name: note.body})
                  )
                ) : (
                  React.createElement(MarkDown, {className: "discussion", contents: note.body})
                )
              );}
            )
        : [])
    ].filter(Boolean);

    var description = doc.description && (
      React.createElement("section", {key: "description"}, 
        React.createElement("h4", {className: "infoHeader"}, 
          doc.description.substr(0, 5) === "<code" ? "Example" : "Discussion"
        ), 
        React.createElement(MarkDown, {className: "discussion", contents: doc.description})
      )
    );

    var detail =
      doc.notes &&
      doc.notes.find(
        function(note) 
          {return note.name === "pragma" && note.body.trim() === "showExampleAboveType";}
      )
        ? [description, typeDef, metadata]
        : [typeDef, metadata, description];

    return (
      React.createElement("div", {className: "interfaceMember"}, 
        React.createElement("h3", {className: "memberLabel"}, 
          React.createElement(Router.Link, {
            to: "/" + memberAnchorLink, 
            onClick: isMobile ? this.toggleDetail : null
          }, 
            (module ? module + "." : "") + name + (isProp ? "" : "()")
          )
        ), 
        React.createElement(TransitionGroup, {childFactory: makeSlideDown}, 
          showDetail && (
            React.createElement("div", {key: "detail", className: "detail"}, 
              doc.synopsis && (
                React.createElement(MarkDown, {className: "synopsis", contents: doc.synopsis})
              ), 
              detail
            )
          )
        )
      )
    );
  }
});

function makeSlideDown(child) {
  return React.createElement(SlideDown, null, child);
}

var SlideDown = React.createClass({displayName: "SlideDown",
  componentWillEnter:function(done) {
    this.slide(false, done);
  },

  componentWillLeave:function(done) {
    this.slide(true, done);
  },

  slide:function(slidingUp, done) {
    var node = this.getDOMNode();
    node.style.height = "auto";
    var height = getComputedStyle(node).height;
    var start = slidingUp ? height : 0;
    var end = slidingUp ? 0 : height;
    node.style.transition = "";
    node.style.height = start;
    node.style.transition = "height 0.35s ease-in-out";
    var endListener = function()  {
      ReactTransitionEvents.removeEndEventListener(node, endListener);
      done();
    };
    ReactTransitionEvents.addEndEventListener(node, endListener);
    this.timeout = setTimeout(function()  {
      node.style.height = end;
    }, 17);
  },

  render:function() {
    return this.props.children;
  }
});

var FIXED_HEADER_HEIGHT = 75;

function offsetTop(node) {
  var top = 0;
  do {
    top += node.offsetTop;
  } while ((node = node.offsetParent));
  return top;
}

module.exports = MemberDoc;

},{"./Defs":193,"./MarkDown":196,"./PageDataMixin":198,"./isMobile":201,"./utils":202,"react":"react","react-router":143,"react/lib/ReactTransitionEvents":170}],198:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var React = require("react");

module.exports = {
  contextTypes: {
    getPageData: React.PropTypes.func.isRequired
  },

  /**
   * Returns the most recent change event.
   */
  getPageData:function() {
    return this.context.getPageData();
  }
};

},{"react":"react"}],199:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var React = require("react");
var Router = require("react-router");
var $__0=    require("../../../.."),Seq=$__0.Seq;
var defs = require("../../../lib/getTypeDefs");
var $__1=     require("./utils"),flattenDef=$__1.flattenDef,getDisplayTypeName=$__1.getDisplayTypeName;

var SideBar = React.createClass({displayName: "SideBar",
  render:function() {
    var type = defs;

    return (
      React.createElement("div", {className: "sideBar"}, 
        React.createElement("div", {className: "toolBar"}, 
          React.createElement("div", {
            onClick: this.props.toggleShowInGroups, 
            onKeyPress: this.props.toggleShowInGroups
          }, 
            React.createElement("span", {className: this.props.showInGroups && "selected"}, 
              "Grouped"
            ), 
            " • ", 
            React.createElement("span", {className: this.props.showInGroups || "selected"}, 
              "Alphabetized"
            )
          )
        ), 
        React.createElement("div", {className: "scrollContent"}, 
          Seq(type.groups)
            .map(function(group)  {
              return (
                React.createElement("section", null, 
                  React.createElement("h4", {className: "groupTitle"}, group.title), 
                  Seq(group.members)
                    .map(function(t, name)  {return this.renderSideBarType(name, t);}.bind(this))
                    .values()
                    .to(Array)
                )
              );
            }.bind(this))
            .to(Array)
        )
      )
    );
  },

  renderSideBarType:function(typeName, def) {
    var isFocus = this.props.focus === typeName;
    var isFunction = !def.interface && !def.class && !def.module;
    def = flattenDef(def, typeName);
    var calls = Seq(def.constructors);
    var functions = Seq((def.class && def.class.statics) || def.functions);

    var label = typeName + (isFunction ? "()" : "");

    if (!isFocus) {
      label = React.createElement(Router.Link, {to: "/" + typeName}, label);
    }

    var memberGroups = this.props.memberGroups;

    const flat = Seq(memberGroups)
      .map(function(members, title) 
        {return members.length === 0
          ? null
          : Seq([
              React.createElement("h4", {key: title || "Members", className: "groupTitle"}, 
                title || "Members"
              ),
              Seq(members).map(function(member)  
                {return React.createElement("div", {key: member.memberName}, 
                  React.createElement(Router.Link, {to: "/" + typeName + "/" + member.memberName}, 
                    member.memberName +
                      (member.memberDef.signatures ? "()" : "")
                  )
                );}
              )
            ]);}
      )
      .flatten()
      .values()
      .to(Array);

    var members =
      !isFocus || isFunction ? null : (
        React.createElement("div", {className: "members"}, 
          calls.count() > 0 && (
            React.createElement("section", null, 
              calls
                .map(function(call, name)  
                  {return React.createElement("div", {key: name}, 
                    React.createElement(Router.Link, {to: "/" + typeName + "/" + name}, 
                      getDisplayTypeName(name, typeName)
                    )
                  );}
                )
                .values()
                .to(Array)
            )
          ), 

          functions.count() > 0 && (
            React.createElement("section", null, 
              React.createElement("h4", {className: "groupTitle"}, "Static Methods"), 
              functions
                .map(function(t, name)  
                  {return React.createElement("div", {key: name}, 
                    React.createElement(Router.Link, {to: "/" + typeName + "/" + name}, 
                      getDisplayTypeName(name, typeName)
                    )
                  );}
                )
                .values()
                .to(Array)
            )
          ), 

          React.createElement("section", null, 
            Seq(memberGroups)
              .map(function(members, title) 
                {return members.length === 0
                  ? null
                  : Seq([
                      React.createElement("h4", {key: title || "Members", className: "groupTitle"}, 
                        title || "Members"
                      ),
                      Seq(members).map(function(member)  
                        {return React.createElement("div", {key: member.memberName}, 
                          React.createElement(Router.Link, {
                            to: "/" + typeName + "/" + member.memberName
                          }, 
                            member.memberName +
                              (member.memberDef.signatures ? "()" : "")
                          )
                        );}
                      )
                    ]);}
              )
              .flatten()
              .values()
              .to(Array)
          )
        )
      );

    return (
      React.createElement("div", {key: typeName}, 
        React.createElement("h2", null, label), 
        members
      )
    );
  }
});

module.exports = SideBar;

},{"../../../..":1,"../../../lib/getTypeDefs":188,"./utils":202,"react":"react","react-router":143}],200:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var React = require("react");
var Router = require("react-router");
var $__0=     require("../../../.."),Seq=$__0.Seq,KeyedSequence=$__0.KeyedSequence;
var $__1=     require("./Defs"),InterfaceDef=$__1.InterfaceDef,CallSigDef=$__1.CallSigDef;
var MemberDoc = require("./MemberDoc");
var isMobile = require("./isMobile");
var SideBar = require("./SideBar");
var MarkDown = require("./MarkDown");
var DocOverview = require("./DocOverview");
var collectMemberGroups = require("../../../lib/collectMemberGroups");
var TypeKind = require("../../../lib/TypeKind");
var getDefByPath = require("../../../lib/getDefByPath");
var $__2=    require("./utils"),flattenDef=$__2.flattenDef;

var typeDefURL =
  "https://github.com/conartist6/sequins/blob/master/type-definitions/sequins.d.ts";
var issuesURL = "https://github.com/conartist6/sequins/issues";

var Disclaimer = function() {
  return (
    React.createElement("section", {className: "disclaimer"}, 
      "This documentation is generated from ", React.createElement("a", {href: typeDefURL}, "sequins.d.ts"), 
      ". Pull requests and ", React.createElement("a", {href: issuesURL}, "Issues"), " welcome."
    )
  );
};

var TypeDocumentation = React.createClass({displayName: "TypeDocumentation",
  getInitialState:function() {
    return {
      showInGroups: true
    };
  },

  toggleShowInGroups:function() {
    this.setState({ showInGroups: !this.state.showInGroups });
  },

  render:function() {
    var name = this.props.name;
    var memberName = this.props.memberName;
    var def = this.props.def;

    var memberGroups = collectMemberGroups(
      def && (def.class || def.interface),
      {
        showInGroups: this.state.showInGroups
      }
    );

    return (
      React.createElement("div", null, 
        isMobile || (
          React.createElement(SideBar, {
            focus: name, 
            memberGroups: memberGroups, 
            toggleShowInherited: this.toggleShowInherited, 
            toggleShowInGroups: this.toggleShowInGroups, 
            showInGroups: this.state.showInGroups}
          )
        ), 
        React.createElement("div", {key: name, className: "docContents"}, 
          !def ? (
            React.createElement(NotFound, null)
          ) : !name ? (
            React.createElement(DocOverview, {def: def})
          ) : !def.interface && !def.class && !def.module ? (
            React.createElement(FunctionDoc, {name: name, def: def.call})
          ) : (
            React.createElement(TypeDoc, {
              name: name, 
              def: def, 
              memberName: memberName, 
              memberGroups: memberGroups}
            )
          )
        )
      )
    );
  }
});

function NotFound() {
  return React.createElement("div", null, "Not found");
}

var FunctionDoc = React.createClass({displayName: "FunctionDoc",
  render:function() {
    var name = this.props.name;
    var def = this.props.def;
    var doc = def.doc || {};

    return (
      React.createElement("div", null, 
        React.createElement("h1", {className: "typeHeader"}, name + "()"), 
        doc.synopsis && (
          React.createElement(MarkDown, {className: "synopsis", contents: doc.synopsis})
        ), 
        React.createElement("code", {className: "codeBlock memberSignature"}, 
          def.signatures.map(function(callSig, i)  {return [
            React.createElement(CallSigDef, {key: i, name: name, callSig: callSig}),
            "\n"
          ];})
        ), 
        doc.notes &&
          doc.notes.map(function(note, i)  
            {return React.createElement("section", {key: i}, 
              React.createElement("h4", {className: "infoHeader"}, note.name), 
              note.name === "alias" ? (
                React.createElement(CallSigDef, {name: note.body})
              ) : (
                note.body
              )
            );}
          ), 
        doc.description && (
          React.createElement("section", null, 
            React.createElement("h4", {className: "infoHeader"}, 
              doc.description.substr(0, 5) === "<code"
                ? "Example"
                : "Discussion"
            ), 
            React.createElement(MarkDown, {className: "discussion", contents: doc.description})
          )
        ), 
        React.createElement(Disclaimer, null)
      )
    );
  }
});

var TypeDoc = React.createClass({displayName: "TypeDoc",
  render:function() {
    var name = this.props.name;
    var def = this.props.def;
    var memberName = this.props.memberName;
    var memberGroups = this.props.memberGroups;

    var flatDef = flattenDef(def, name);

    var calls = Seq(flatDef.constructors);

    var interfaceDef = def.class || def.interface;
    var functions = Seq((def.class && def.class.statics) || flatDef.functions);
    var types = Seq(def.module).filter(function(t)  {return t.interface || t.class || t.module;});

    var typePropMap = getTypePropMap(interfaceDef);

    var doc = (interfaceDef ? interfaceDef.doc : def.doc) || {};

    return (
      React.createElement("div", null, 
        React.createElement("h1", {className: "typeHeader"}, name), 
        doc.synopsis && (
          React.createElement(MarkDown, {className: "synopsis", contents: doc.synopsis})
        ), 
        interfaceDef && (
          React.createElement("code", {className: "codeBlock memberSignature"}, 
            React.createElement(InterfaceDef, {name: name, def: interfaceDef})
          )
        ), 

        doc.notes &&
          doc.notes.map(function(note, i)  
            {return React.createElement("section", {key: i}, 
              React.createElement("h4", {className: "infoHeader"}, note.name), 
              note.name === "alias" ? (
                React.createElement(CallSigDef, {name: note.body})
              ) : (
                note.body
              )
            );}
          ), 

        doc.description && (
          React.createElement("section", null, 
            React.createElement("h4", {className: "infoHeader"}, 
              doc.description.substr(0, 5) === "<code"
                ? "Example"
                : "Discussion"
            ), 
            React.createElement(MarkDown, {className: "discussion", contents: doc.description})
          )
        ), 

        types.size > 0 && (
          React.createElement("section", null, 
            React.createElement("h4", {className: "groupTitle"}, "Sub-types"), 
            types
              .map(function(t, typeName)  
                {return React.createElement("div", {key: typeName}, 
                  React.createElement(Router.Link, {
                    to: "/" + (name ? name + "." + typeName : typeName)
                  }, 
                    name ? name + "." + typeName : typeName
                  )
                );}
              )
              .values()
              .to(Array)
          )
        ), 

        calls.count() > 0 && (
          React.createElement("section", null, 
            calls
              .map(function(call, callName)  
                {return React.createElement(MemberDoc, {
                  key: callName, 
                  showDetail: callName === memberName, 
                  parentName: name, 
                  member: {
                    memberName: callName,
                    memberDef: call,
                    isStatic: callName !== name
                  }}
                );}
              )
              .values()
              .to(Array)
          )
        ), 

        functions.count() > 0 && (
          React.createElement("section", null, 
            React.createElement("h4", {className: "groupTitle"}, "Static methods"), 
            functions
              .map(function(def, fnName)  
                {return React.createElement(MemberDoc, {
                  key: fnName, 
                  showDetail: fnName === memberName, 
                  parentName: name, 
                  member: {
                    memberName: fnName,
                    memberDef: def,
                    isStatic: true
                  }}
                );}
              )
              .values()
              .to(Array)
          )
        ), 

        React.createElement("section", null, 
          Seq(memberGroups)
            .map(function(members, title) 
              {return members.length === 0
                ? null
                : Seq([
                    React.createElement("h4", {key: title || "Members", className: "groupTitle"}, 
                      title || "Members"
                    ),
                    Seq(members).map(function(member)  
                      {return React.createElement(MemberDoc, {
                        typePropMap: typePropMap, 
                        key: member.memberName, 
                        showDetail: member.memberName === memberName, 
                        parentName: name, 
                        member: member}
                      );}
                    )
                  ]);}
            )
            .flatten()
            .values()
            .to(Array)
        ), 

        React.createElement(Disclaimer, null)
      )
    );
  }
});

/**
 * Get a map from super type parameter to concrete type definition. This is
 * used when rendering inherited type definitions to ensure contextually
 * relevant information.
 *
 * Example:
 *
 *   type A<T> implements B<number, T>
 *   type B<K, V> implements C<K, V, V>
 *   type C<X, Y, Z>
 *
 * parse C:
 *   {}
 *
 * parse B:
 *   { C<X: K
 *     C<Y: V
 *     C<Z: V }
 *
 * parse A:
 *   { B<K: number
 *     B<V: T
 *     C<X: number
 *     C<Y: T
 *     C<Z: T }
 */
function getTypePropMap(def) {
  var map = {};
  def &&
    def.extends &&
    def.extends.forEach(function(e)  {
      var superModule = getDefByPath(e.name);
      var superInterface =
        (superModule && superModule.class) || superModule.interface;
      if (superInterface) {
        var interfaceMap = Seq(superInterface.typeParams)
          .to(KeyedSequence)
          .flip()
          .map(function(i)  {return e.args[i];})
          .to(Object);
        Seq(interfaceMap).forEach(function(v, k)  {
          map[e.name + "<" + k] = v;
        });
        var superMap = getTypePropMap(superInterface);
        Seq(superMap).forEach(function(v, k)  {
          map[k] = v.k === TypeKind.Param ? interfaceMap[v.param] : v;
        });
      }
    });
  return map;
}

module.exports = TypeDocumentation;

},{"../../../..":1,"../../../lib/TypeKind":185,"../../../lib/collectMemberGroups":186,"../../../lib/getDefByPath":187,"./Defs":193,"./DocOverview":195,"./MarkDown":196,"./MemberDoc":197,"./SideBar":199,"./isMobile":201,"./utils":202,"react":"react","react-router":143}],"/home/travis/build/conartist6/sequins/pages/src/docs/src/index.js":[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var React = require("react");
var assign = require("react/lib/Object.assign");
var Router = require("react-router");
var DocHeader = require("./DocHeader");
var TypeDocumentation = require("./TypeDocumentation");
var getDefByPath = require("../../../lib/getDefByPath");
var Sequins = require("../../../..");

window.Sequins = Sequins;
console.log("Feel free to try Sequins!");
console.log(Sequins);

var $__0=      Router,Route=$__0.Route,DefaultRoute=$__0.DefaultRoute,RouteHandler=$__0.RouteHandler;

require("../../../lib/runkit-embed");

var Documentation = React.createClass({displayName: "Documentation",
  render:function() {
    return (
      React.createElement("div", null, 
        React.createElement(DocHeader, null), 
        React.createElement("div", {className: "pageBody", id: "body"}, 
          React.createElement("div", {className: "contents"}, 
            React.createElement(RouteHandler, null)
          )
        )
      )
    );
  }
});

var DocDeterminer = React.createClass({displayName: "DocDeterminer",
  mixins: [Router.State],

  render:function() {
    var $__0=      determineDoc(this.getPath()),def=$__0.def,name=$__0.name,memberName=$__0.memberName;
    return React.createElement(TypeDocumentation, {def: def, name: name, memberName: memberName});
  }
});

function determineDoc(path) {
  var $__0=    path.split("/"),name=$__0[1],memberName=$__0[2];

  var def = getDefByPath(name);

  return { def:def, name:name, memberName:memberName };
}

module.exports = React.createClass({displayName: "exports",
  childContextTypes: {
    getPageData: React.PropTypes.func.isRequired
  },

  getChildContext:function() {
    return {
      getPageData: this.getPageData
    };
  },

  getPageData:function() {
    return this.pageData;
  },

  componentWillMount:function() {
    var location;
    var scrollBehavior;

    if (window.document) {
      location = Router.HashLocation;
      location.addChangeListener(function(change)  {
        this.pageData = assign({}, change, determineDoc(change.path));
      }.bind(this));

      this.pageData = !window.document
        ? {}
        : assign(
            {
              path: location.getCurrentPath(),
              type: "init"
            },
            determineDoc(location.getCurrentPath())
          );

      scrollBehavior = {
        updateScrollPosition: function(position, actionType)  {
          switch (actionType) {
            case "push":
              return this.getPageData().memberName
                ? null
                : window.scrollTo(0, 0);
            case "pop":
              return window.scrollTo(
                position ? position.x : 0,
                position ? position.y : 0
              );
          }
        }.bind(this)
      };
    }

    Router.create({
      routes: (
        React.createElement(Route, {handler: Documentation, path: "/"}, 
          React.createElement(DefaultRoute, {handler: DocDeterminer}), 
          React.createElement(Route, {name: "type", path: "/:name", handler: DocDeterminer}), 
          React.createElement(Route, {
            name: "method", 
            path: "/:name/:memberName", 
            handler: DocDeterminer}
          )
        )
      ),
      location: location,
      scrollBehavior: scrollBehavior
    }).run(function(Handler)  {
      this.setState({ handler: Handler });
      if (window.document) {
        window.document.title = this.pageData.name
          ? (this.pageData.name + " — Sequins")
          : "Sequins — API";
      }
    }.bind(this));
  },

  // TODO: replace this. this is hacky and probably wrong

  componentDidMount:function() {
    setTimeout(function()  {
      this.pageData.type = "";
    }.bind(this), 0);
  },

  componentDidUpdate:function() {
    setTimeout(function()  {
      this.pageData.type = "";
    }.bind(this), 0);
  },

  render:function() {
    var Handler = this.state.handler;
    return React.createElement(Handler, null);
  }
});

},{"../../../..":1,"../../../lib/getDefByPath":187,"../../../lib/runkit-embed":192,"./DocHeader":194,"./TypeDocumentation":200,"react":"react","react-router":143,"react/lib/Object.assign":169}],201:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var isMobile =
  window.matchMedia && window.matchMedia("(max-device-width: 680px)");
module.exports = false && !!(isMobile && isMobile.matches);

},{}],202:[function(require,module,exports){
var $__0=      require("immutable"),Seq=$__0.Seq,merge=$__0.merge,mergeWith=$__0.mergeWith;

function makeKey(rootName, name, key) {
  return name === rootName ? key : (name + "." + key);
}

function flattenDef(def, name, rootName = name) {
  var flatDef = Object.assign({}, def);
  if (flatDef.call) {
    flatDef.constructors = { [name]: flatDef.call };
    delete flatDef.call;
  }

  delete flatDef.module;

  return mergeWith.apply(null, [function(a, b)  {return merge(a, b);},
    flatDef].concat(Seq(def.module)
      .map(function(def, key)  {
        const flatDef = {};
        if (def.call) {
          if (def.call.doc.notes.find(function(note)  {return note.name === "constructs";})) {
            flatDef.constructors = { [makeKey(rootName, name, key)]: def.call };
          } else {
            flatDef.functions = { [makeKey(rootName, name, key)]: def.call };
          }
        }
        return flatDef;
      })
      .concat(
        Seq(def.module)
          .filter(function(def)  {return def.module;})
          .map(function(def, key) 
            {return flattenDef(def, makeKey(rootName, name, key), rootName);}
          )
      )
      .valueSeq()
      .toArray()));
}

function getDisplayTypeName(name, typeName) {
  return (name === typeName ? name : (typeName + "." + name)) + "()";
}

module.exports = {
  flattenDef:flattenDef,
  getDisplayTypeName:getDisplayTypeName
};

},{"immutable":105}],"react":[function(require,module,exports){
(function (global){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

module.exports = global.React;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"sequins":[function(require,module,exports){
(function (global){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

module.exports = global.Sequins;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},["/home/travis/build/conartist6/sequins/pages/src/docs/src/index.js"])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi8uLi8uLi9kaXN0L19zZXF1aW5zLmpzIiwiLi4vLi4vLi4vZGlzdC9zZXF1aW5zLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczIvY29yZS1qcy9nZXQtaXRlcmF0b3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9jb3JlLWpzL3N5bWJvbC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMyL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczIvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMyL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMyL2hlbHBlcnMvdHlwZW9mLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczIvcmVnZW5lcmF0b3IvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aG91dEhvbGVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5TGltaXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVJlc3QuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVNwcmVhZC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zdXBlclByb3BCYXNlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0ta2V5cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2h0bWwuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19tZXRhLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZXh0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ltbXV0YWJsZS9kaXN0L2ltbXV0YWJsZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9pbnZhcmlhbnQvYnJvd3Nlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9pdGVyLXRvb2xzL2VzNS9jaGFpbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9pdGVyLXRvb2xzL2VzNS9jb21wb3NlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2l0ZXItdG9vbHMvZXM1L2NvbmNhdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9pdGVyLXRvb2xzL2VzNS9lbnRyaWVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2l0ZXItdG9vbHMvZXM1L2ZpbHRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9pdGVyLXRvb2xzL2VzNS9mbGF0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2l0ZXItdG9vbHMvZXM1L2ludGVybmFsL2NpcmN1bGFyLWJ1ZmZlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9pdGVyLXRvb2xzL2VzNS9pbnRlcm5hbC9lbnN1cmUtaXRlcmFibGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvaXRlci10b29scy9lczUvaW50ZXJwb3NlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2l0ZXItdG9vbHMvZXM1L2tleXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvaXRlci10b29scy9lczUvbWFwLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2l0ZXItdG9vbHMvZXM1L3JhbmdlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2l0ZXItdG9vbHMvZXM1L3JlZHVjZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9pdGVyLXRvb2xzL2VzNS9yZXBlYXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvaXRlci10b29scy9lczUvc2l6ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9pdGVyLXRvb2xzL2VzNS9zbGljZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9pdGVyLXRvb2xzL2VzNS90YXAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvaXRlci10b29scy9lczUvemlwLWFsbC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9pdGVyLXRvb2xzL2VzNS96aXAtbG9uZ2VzdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9pdGVyLXRvb2xzL2VzNS96aXAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3FzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3FzL2xpYi9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9xcy9saWIvcGFyc2UuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcXMvbGliL3N0cmluZ2lmeS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9xcy9saWIvdXRpbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvYWN0aW9ucy9Mb2NhdGlvbkFjdGlvbnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvYmVoYXZpb3JzL0ltaXRhdGVCcm93c2VyQmVoYXZpb3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvYmVoYXZpb3JzL1Njcm9sbFRvVG9wQmVoYXZpb3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvY29tcG9uZW50cy9EZWZhdWx0Um91dGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvY29tcG9uZW50cy9MaW5rLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2NvbXBvbmVudHMvTm90Rm91bmRSb3V0ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy9jb21wb25lbnRzL1JlZGlyZWN0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2NvbXBvbmVudHMvUm91dGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvY29tcG9uZW50cy9Sb3V0ZUhhbmRsZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvbG9jYXRpb25zL0hhc2hMb2NhdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy9sb2NhdGlvbnMvSGlzdG9yeUxvY2F0aW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2xvY2F0aW9ucy9SZWZyZXNoTG9jYXRpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvbWl4aW5zL0Zha2VOb2RlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL21peGlucy9OYXZpZ2F0aW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL21peGlucy9OYXZpZ2F0aW9uQ29udGV4dC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy9taXhpbnMvUm91dGVIYW5kbGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL21peGlucy9TY3JvbGxpbmcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvbWl4aW5zL1N0YXRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL21peGlucy9TdGF0ZUNvbnRleHQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvdXRpbHMvQ2FuY2VsbGF0aW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL3V0aWxzL0hpc3RvcnkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvdXRpbHMvUGF0aC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy91dGlscy9Qcm9taXNlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL3V0aWxzL1Byb3BUeXBlcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy91dGlscy9SZWRpcmVjdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy91dGlscy9UcmFuc2l0aW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL3V0aWxzL2NyZWF0ZVJvdXRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy91dGlscy9jcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvdXRpbHMvZ2V0V2luZG93U2Nyb2xsUG9zaXRpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvdXRpbHMvcmV2ZXJzZWRBcnJheS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy91dGlscy9ydW5Sb3V0ZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvdXRpbHMvc3VwcG9ydHNIaXN0b3J5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9DU1NDb3JlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvT2JqZWN0LmFzc2lnbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RUcmFuc2l0aW9uRXZlbnRzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jeC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvaW52YXJpYW50LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi93YXJuaW5nLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0YWJsZS9zdGFibGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvd2hlbi9saWIvUHJvbWlzZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy93aGVuL2xpYi9RdWV1ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy93aGVuL2xpYi9TY2hlZHVsZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvd2hlbi9saWIvYXN5bmMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvd2hlbi9saWIvbWFrZVByb21pc2UuanMiLCIuLi8uLi8uLi9wYWNrYWdlLmpzb24iLCIuLi8uLi9nZW5lcmF0ZWQvc2VxdWlucy5kLmpzb24iLCIuLi8uLi9saWIvVHlwZUtpbmQuanMiLCIuLi8uLi9saWIvY29sbGVjdE1lbWJlckdyb3Vwcy5qcyIsIi4uLy4uL2xpYi9nZXREZWZCeVBhdGguanMiLCIuLi8uLi9saWIvZ2V0VHlwZURlZnMuanMiLCIuLi8uLi9saWIvbWFya2Rvd24uanMiLCIuLi8uLi9saWIvbWFya2Rvd25Eb2NzLmpzIiwiLi4vLi4vbGliL3ByaXNtLmpzIiwiLi4vLi4vbGliL3J1bmtpdC1lbWJlZC5qcyIsInNyYy9EZWZzLmpzIiwic3JjL0RvY0hlYWRlci5qcyIsInNyYy9Eb2NPdmVydmlldy5qcyIsInNyYy9NYXJrRG93bi5qcyIsInNyYy9NZW1iZXJEb2MuanMiLCJzcmMvUGFnZURhdGFNaXhpbi5qcyIsInNyYy9TaWRlQmFyLmpzIiwic3JjL1R5cGVEb2N1bWVudGF0aW9uLmpzIiwic3JjL2luZGV4LmpzIiwic3JjL2lzTW9iaWxlLmpzIiwic3JjL3V0aWxzLmpzIiwiLi4vLi4vLi4vcmVzb3VyY2VzL3JlYWN0LWdsb2JhbC5qcyIsIi4uLy4uLy4uL3Jlc291cmNlcy9zZXF1aW5zLWdsb2JhbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeDVFQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2p2REE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFPQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2p1TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzUyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL3NCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1eEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDellBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIvLyBUT0RPIHJlbW92ZSBtZSB3aGVuIGJhYmVsLXBsdWdpbi1hZGQtbW9kdWxlLWV4cG9ydHMgd29ya3MgcmlnaHRcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zZXF1aW5zJykuZGVmYXVsdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuU2VxID0gU2VxO1xuZXhwb3J0cy5pc0NvbGxlY3Rpb24gPSBpc011dGFibGVDb2xsZWN0aW9uO1xuZXhwb3J0cy5pc0tleWVkID0gaXNNdXRhYmxlS2V5ZWQ7XG5leHBvcnRzLmlzSW5kZXhlZCA9IGlzTXV0YWJsZUluZGV4ZWQ7XG5leHBvcnRzLmlzQXNzb2NpYXRpdmUgPSBpc011dGFibGVBc3NvY2lhdGl2ZTtcbmV4cG9ydHMuaXNTZXEgPSBpc011dGFibGVTZXE7XG5leHBvcnRzLmlzTGlzdCA9IGlzTXV0YWJsZUxpc3Q7XG5leHBvcnRzLmlzTWFwID0gaXNNdXRhYmxlTWFwO1xuZXhwb3J0cy5pc1NldCA9IGlzTXV0YWJsZVNldDtcbmV4cG9ydHMuUmFuZ2UgPSBSYW5nZTtcbmV4cG9ydHMuUmVwZWF0ID0gUmVwZWF0O1xuZXhwb3J0cy5nZXQgPSBnZXQ7XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMuaGFzID0gaGFzO1xuZXhwb3J0cy5rZXlzID0ga2V5cyQxO1xuZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5leHBvcnRzLmVudHJpZXMgPSBlbnRyaWVzJDE7XG5leHBvcnRzLk5hdGl2ZVNldCA9IGV4cG9ydHMuTmF0aXZlTWFwID0gZXhwb3J0cy5TZXQgPSBleHBvcnRzLk1hcCA9IGV4cG9ydHMuTGlzdCA9IGV4cG9ydHMuU2V0U2VxdWVuY2UgPSBleHBvcnRzLktleWVkU2VxdWVuY2UgPSBleHBvcnRzLkluZGV4ZWRTZXF1ZW5jZSA9IGV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfaW52YXJpYW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiaW52YXJpYW50XCIpKTtcblxudmFyIF90b0NvbnN1bWFibGVBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5XCIpKTtcblxudmFyIF9jb25jYXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiaXRlci10b29scy9lczUvY29uY2F0XCIpKTtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9zbGljZWRUb0FycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheVwiKSk7XG5cbnZhciBfcmVkdWNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiaXRlci10b29scy9lczUvcmVkdWNlXCIpKTtcblxudmFyIF9zdGFibGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJzdGFibGVcIikpO1xuXG52YXIgX3ppcEFsbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIml0ZXItdG9vbHMvZXM1L3ppcC1hbGxcIikpO1xuXG52YXIgX3ppcCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIml0ZXItdG9vbHMvZXM1L3ppcFwiKSk7XG5cbnZhciBfc2l6ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIml0ZXItdG9vbHMvZXM1L3NpemVcIikpO1xuXG52YXIgX2ZpbHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJpdGVyLXRvb2xzL2VzNS9maWx0ZXJcIikpO1xuXG52YXIgX2tleXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJpdGVyLXRvb2xzL2VzNS9rZXlzXCIpKTtcblxudmFyIF9zbGljZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJpdGVyLXRvb2xzL2VzNS9zbGljZVwiKSk7XG5cbnJlcXVpcmUoXCJpdGVyLXRvb2xzL2VzNS9jb21wb3NlXCIpO1xuXG52YXIgX2dldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFwiKSk7XG5cbnZhciBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkXCIpKTtcblxudmFyIF9tYXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiaXRlci10b29scy9lczUvbWFwXCIpKTtcblxudmFyIF90YXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiaXRlci10b29scy9lczUvdGFwXCIpKTtcblxudmFyIF9pbnRlcnBvc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiaXRlci10b29scy9lczUvaW50ZXJwb3NlXCIpKTtcblxudmFyIF9yYW5nZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIml0ZXItdG9vbHMvZXM1L3JhbmdlXCIpKTtcblxudmFyIF9lbnRyaWVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiaXRlci10b29scy9lczUvZW50cmllc1wiKSk7XG5cbnZhciBfZmxhdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIml0ZXItdG9vbHMvZXM1L2ZsYXRcIikpO1xuXG52YXIgX3JlcGVhdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIml0ZXItdG9vbHMvZXM1L3JlcGVhdFwiKSk7XG5cbmZ1bmN0aW9uIGlzSW1tdXRhYmxlQ29sbGVjdGlvbihzaGFwZSkge1xuICByZXR1cm4gISFzaGFwZVsnQEBfX0lNTVVUQUJMRV9JVEVSQUJMRV9fQEAnXTtcbn1cblxuZnVuY3Rpb24gaXNJbW11dGFibGVSZWNvcmQoc2hhcGUpIHtcbiAgcmV0dXJuICEhc2hhcGVbJ0BAX19JTU1VVEFCTEVfUkVDT1JEX19AQCddO1xufVxuXG5mdW5jdGlvbiBpc0ltbXV0YWJsZShzaGFwZSkge1xuICByZXR1cm4gaXNJbW11dGFibGVDb2xsZWN0aW9uKHNoYXBlKSB8fCBpc0ltbXV0YWJsZVJlY29yZChzaGFwZSk7XG59XG5cbmZ1bmN0aW9uIGlzTXV0YWJsZUNvbGxlY3Rpb24oc2hhcGUpIHtcbiAgcmV0dXJuICEhc2hhcGVbJ0BAX19NVVRBQkxFX0NPTExFQ1RJT05fX0BAJ107XG59XG5cbmZ1bmN0aW9uIGlzTXV0YWJsZVNlcShzaGFwZSkge1xuICByZXR1cm4gISFzaGFwZVsnQEBfX01VVEFCTEVfU0VRVUVOQ0VfX0BAJ107XG59XG5cbmZ1bmN0aW9uIGlzQ29sbGVjdGlvbihzaGFwZSkge1xuICByZXR1cm4gaXNJbW11dGFibGVDb2xsZWN0aW9uKHNoYXBlKSB8fCBpc011dGFibGVDb2xsZWN0aW9uKHNoYXBlKTtcbn1cblxuZnVuY3Rpb24gaXNOYXRpdmUoc2hhcGUpIHtcbiAgcmV0dXJuIGlzTmF0aXZlS2V5ZWQoc2hhcGUpIHx8IGlzTmF0aXZlU2V0KHNoYXBlKTtcbn0gLy8gSW1wbC4gYm9ycm93ZWQgZnJvbSBpbW11dGFibGUsIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuXG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmooc2hhcGUpIHtcbiAgcmV0dXJuICFzaGFwZVtTeW1ib2wuaXRlcmF0b3JdICYmIHNoYXBlLmNvbnN0cnVjdG9yID09PSBPYmplY3QgfHwgc2hhcGUuY29uc3RydWN0b3IgPT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNEYXRhU3RydWN0dXJlKHNoYXBlKSB7XG4gIHJldHVybiBpc0ZhbmN5RGF0YVN0cnVjdHVyZShzaGFwZSkgfHwgaXNOYXRpdmUoc2hhcGUpIHx8IEFycmF5LmlzQXJyYXkoc2hhcGUpIHx8IGlzUGxhaW5PYmooc2hhcGUpO1xufVxuXG5mdW5jdGlvbiBpc0ZhbmN5RGF0YVN0cnVjdHVyZShzaGFwZSkge1xuICByZXR1cm4gaXNNdXRhYmxlQ29sbGVjdGlvbihzaGFwZSkgfHwgaXNJbW11dGFibGUoc2hhcGUpO1xufVxuXG5mdW5jdGlvbiBpc01vZGVybkRhdGFTdHJ1Y3R1cmUoc2hhcGUpIHtcbiAgcmV0dXJuIGlzRmFuY3lEYXRhU3RydWN0dXJlKHNoYXBlKSB8fCBpc05hdGl2ZShzaGFwZSk7XG59XG5cbmZ1bmN0aW9uIGlzTXV0YWJsZUNvbmNyZXRlaXNoKHNoYXBlKSB7XG4gIHJldHVybiAhIXNoYXBlWydAQF9fTVVUQUJMRV9DT0xMRUNUSU9OX19AQCddICYmICFzaGFwZVsnQEBfX01VVEFCTEVfU0VRVUVOQ0VfX0BAJ107XG59XG5cbmZ1bmN0aW9uIGlzTXV0YWJsZUxpc3Qoc2hhcGUpIHtcbiAgcmV0dXJuIGlzTXV0YWJsZUNvbmNyZXRlaXNoKHNoYXBlKSAmJiBpc011dGFibGVJbmRleGVkKHNoYXBlKTtcbn1cblxuZnVuY3Rpb24gaXNNdXRhYmxlTWFwKHNoYXBlKSB7XG4gIHJldHVybiBpc011dGFibGVDb25jcmV0ZWlzaChzaGFwZSkgJiYgaXNNdXRhYmxlS2V5ZWQoc2hhcGUpO1xufVxuXG5mdW5jdGlvbiBpc011dGFibGVTZXQoc2hhcGUpIHtcbiAgcmV0dXJuIGlzTXV0YWJsZUNvbmNyZXRlaXNoKHNoYXBlKSAmJiAhaXNNdXRhYmxlQXNzb2NpYXRpdmUoc2hhcGUpO1xufVxuXG5mdW5jdGlvbiBpc0ltbXV0YWJsZUluZGV4ZWQoc2hhcGUpIHtcbiAgcmV0dXJuICEhc2hhcGVbJ0BAX19JTU1VVEFCTEVfSU5ERVhFRF9fQEAnXTtcbn1cblxuZnVuY3Rpb24gaXNJbW11dGFibGVLZXllZChzaGFwZSkge1xuICByZXR1cm4gISFzaGFwZVsnQEBfX0lNTVVUQUJMRV9LRVlFRF9fQEAnXTtcbn1cblxuZnVuY3Rpb24gaXNOYXRpdmVTZXQoc2hhcGUpIHtcbiAgcmV0dXJuIHNoYXBlIGluc3RhbmNlb2YgU2V0O1xufVxuXG5mdW5jdGlvbiBpc05hdGl2ZUtleWVkKHNoYXBlKSB7XG4gIHJldHVybiBzaGFwZSBpbnN0YW5jZW9mIE1hcDtcbn1cblxuZnVuY3Rpb24gaXNNdXRhYmxlSW5kZXhlZChzaGFwZSkge1xuICByZXR1cm4gISFzaGFwZVsnQEBfX01VVEFCTEVfSU5ERVhFRF9fQEAnXTtcbn1cblxuZnVuY3Rpb24gaXNNdXRhYmxlS2V5ZWQoc2hhcGUpIHtcbiAgcmV0dXJuICEhc2hhcGVbJ0BAX19NVVRBQkxFX0tFWUVEX19AQCddO1xufVxuXG5mdW5jdGlvbiBpc011dGFibGVBc3NvY2lhdGl2ZShzaGFwZSkge1xuICByZXR1cm4gaXNNdXRhYmxlSW5kZXhlZChzaGFwZSkgfHwgaXNNdXRhYmxlS2V5ZWQoc2hhcGUpO1xufVxuXG5mdW5jdGlvbiBpc0luZGV4ZWQoc2hhcGUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc2hhcGUpIHx8IGlzTXV0YWJsZUluZGV4ZWQoc2hhcGUpIHx8IGlzSW1tdXRhYmxlSW5kZXhlZChzaGFwZSk7XG59XG5cbmZ1bmN0aW9uIGlzS2V5ZWQoc2hhcGUpIHtcbiAgcmV0dXJuIGlzTmF0aXZlS2V5ZWQoc2hhcGUpIHx8IGlzTXV0YWJsZUtleWVkKHNoYXBlKSB8fCBpc0ltbXV0YWJsZUtleWVkKHNoYXBlKTtcbn1cblxudmFyIE5hbWVzcGFjZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE5hbWVzcGFjZSgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBOYW1lc3BhY2UpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoTmFtZXNwYWNlLCBbe1xuICAgIGtleTogXCJfX2dldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfX2dldChrZXkpIHtcbiAgICAgIHZhciBfa2V5ID0gXCJfXCIuY29uY2F0KGtleSk7XG5cbiAgICAgICgwLCBfaW52YXJpYW50LmRlZmF1bHQpKHRoaXMuaGFzT3duUHJvcGVydHkoX2tleSksICdUcmllZCB0byBhY2Nlc3MgbWVtYmVyICVzIG9mICVzLCBidXQgbm8gc3VjaCBtZW1iZXIgd2FzIHJlZ2lzdGVyZWQgeWV0LiBUaGUgbW9kdWxlIGluY2x1ZGUgb3JkZXIgd2FzIGxpa2VseSB3cm9uZy4nLCBrZXksIHRoaXMuX19kZXNjcmlwdGlvbik7XG4gICAgICByZXR1cm4gdGhpc1tfa2V5XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX19kZXNjcmlwdGlvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICduYW1lc3BhY2UnO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTmFtZXNwYWNlO1xufSgpO1xuXG52YXIgUm9vdE5hbWVzcGFjZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX05hbWVzcGFjZSkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShSb290TmFtZXNwYWNlLCBfTmFtZXNwYWNlKTtcblxuICBmdW5jdGlvbiBSb290TmFtZXNwYWNlKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFJvb3ROYW1lc3BhY2UpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKFJvb3ROYW1lc3BhY2UpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoUm9vdE5hbWVzcGFjZSwgW3tcbiAgICBrZXk6IFwiX19yZWdpc3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfX3JlZ2lzdGVyKGNvbGxlY3Rpb25UeXBlLCBOZXN0ZWROYW1lc3BhY2UpIHtcbiAgICAgIHJldHVybiB0aGlzW1wiX1wiLmNvbmNhdChjb2xsZWN0aW9uVHlwZSldID0gTmVzdGVkTmFtZXNwYWNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfX2Rlc2NyaXB0aW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ3RoZSByb290IG5hbWVzcGFjZSc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIkNvbmNyZXRlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2dldCgnQ29uY3JldGUnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiU2VxdWVuY2VcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZ2V0KCdTZXF1ZW5jZScpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUm9vdE5hbWVzcGFjZTtcbn0oTmFtZXNwYWNlKTtcblxudmFyIFN1YnR5cGVOYW1lc3BhY2UgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9OYW1lc3BhY2UyKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKFN1YnR5cGVOYW1lc3BhY2UsIF9OYW1lc3BhY2UyKTtcblxuICBmdW5jdGlvbiBTdWJ0eXBlTmFtZXNwYWNlKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFN1YnR5cGVOYW1lc3BhY2UpO1xuICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKFN1YnR5cGVOYW1lc3BhY2UpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoU3VidHlwZU5hbWVzcGFjZSwgW3tcbiAgICBrZXk6IFwiX19yZWdpc3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfX3JlZ2lzdGVyKGNvbGxlY3Rpb25TdWJ0eXBlLCBDb2xsZWN0aW9uQ29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzW1wiX1wiLmNvbmNhdChjb2xsZWN0aW9uU3VidHlwZSldID0gQ29sbGVjdGlvbkNvbnN0cnVjdG9yO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJEdXBsaWNhdGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2dldCgnRHVwbGljYXRlZCcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJJbmRleGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2dldCgnSW5kZXhlZCcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJLZXllZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19nZXQoJ0tleWVkJyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTdWJ0eXBlTmFtZXNwYWNlO1xufShOYW1lc3BhY2UpO1xuXG5mdW5jdGlvbiBtYWtlS2V5KGNvbGxlY3Rpb25TdWJ0eXBlLCBjb2xsZWN0aW9uVHlwZSkge1xuICByZXR1cm4gXCJcIi5jb25jYXQoY29sbGVjdGlvblN1YnR5cGUsIFwiX19cIikuY29uY2F0KGNvbGxlY3Rpb25UeXBlKTtcbn1cblxuZnVuY3Rpb24gbWVtb2l6ZUZhY3RvcnkoZmFjdG9yeSkge1xuICB2YXIgcmVzdWx0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vaXplZEZhY3RvcnkoQ29sbGVjdGlvbikge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBkeW5hbWljQXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBkeW5hbWljQXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGtleSA9IG1ha2VLZXkuYXBwbHkodm9pZCAwLCBkeW5hbWljQXJncyk7XG5cbiAgICBpZiAoIXJlc3VsdHNba2V5XSkge1xuICAgICAgcmVzdWx0c1trZXldID0gZmFjdG9yeS5hcHBseSh2b2lkIDAsIFtDb2xsZWN0aW9uXS5jb25jYXQoZHluYW1pY0FyZ3MpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0c1trZXldO1xuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlQ29uY2F0KENvbGxlY3Rpb24sIGNvbGxlY3Rpb25UeXBlLCBjb2xsZWN0aW9uU3VidHlwZSkge1xuICB2YXIgU2VxdWVuY2VDb25zdHJ1Y3RvciA9IENvbGxlY3Rpb24uU2VxdWVuY2VbY29sbGVjdGlvblN1YnR5cGVdO1xuICByZXR1cm4gZnVuY3Rpb24gY29uY2F0KGl0ZXJhYmxlKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZXJhYmxlcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBpdGVyYWJsZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfY29uY2F0Mi5kZWZhdWx0LmFwcGx5KHZvaWQgMCwgW2l0ZXJhYmxlXS5jb25jYXQoKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkoaXRlcmFibGVzLm1hcChmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgIHJldHVybiBuZXcgU2VxdWVuY2VDb25zdHJ1Y3RvcihpdGVyYWJsZSk7XG4gICAgfSkpKSk7XG4gIH07XG59XG5cbnZhciBjb25jYXQkMSA9IG1lbW9pemVGYWN0b3J5KG1ha2VDb25jYXQpO1xudmFyIHJlZmxlY3QgPSBPYmplY3QuZnJlZXplKHtcbiAgRHVwbGljYXRlZDoge1xuICAgIE5hdGl2ZUNvbnN0cnVjdG9yOiBTZXQsXG4gICAgaXRlbVZhbHVlOiBmdW5jdGlvbiBpdGVtVmFsdWUoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSxcbiAgICBwcmltaXRpdmVJdGVyYXRvcjogZnVuY3Rpb24gcHJpbWl0aXZlSXRlcmF0b3IoY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24udmFsdWVzKCk7XG4gICAgfVxuICB9LFxuICBJbmRleGVkOiB7XG4gICAgTmF0aXZlQ29uc3RydWN0b3I6IEFycmF5LFxuICAgIGl0ZW1WYWx1ZTogZnVuY3Rpb24gaXRlbVZhbHVlKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH0sXG4gICAgcHJpbWl0aXZlSXRlcmF0b3I6IGZ1bmN0aW9uIHByaW1pdGl2ZUl0ZXJhdG9yKGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLnZhbHVlcygpO1xuICAgIH1cbiAgfSxcbiAgS2V5ZWQ6IHtcbiAgICBOYXRpdmVDb25zdHJ1Y3RvcjogTWFwLFxuICAgIGl0ZW1WYWx1ZTogZnVuY3Rpb24gaXRlbVZhbHVlKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtWzFdO1xuICAgIH0sXG4gICAgcHJpbWl0aXZlSXRlcmF0b3I6IGZ1bmN0aW9uIHByaW1pdGl2ZUl0ZXJhdG9yKGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmVudHJpZXMoKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBtYWtlRmxhdHRlbihDb2xsZWN0aW9uLCBjb2xsZWN0aW9uVHlwZSQkMSwgY29sbGVjdGlvblN1YnR5cGUpIHtcbiAgdmFyIF9yZWZsZWN0JGNvbGxlY3Rpb25TdSA9IHJlZmxlY3RbY29sbGVjdGlvblN1YnR5cGVdLFxuICAgICAgaXRlbVZhbHVlID0gX3JlZmxlY3QkY29sbGVjdGlvblN1Lml0ZW1WYWx1ZSxcbiAgICAgIHByaW1pdGl2ZUl0ZXJhdG9yID0gX3JlZmxlY3QkY29sbGVjdGlvblN1LnByaW1pdGl2ZUl0ZXJhdG9yO1xuICByZXR1cm4gKFxuICAgIC8qI19fUFVSRV9fKi9cbiAgICBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIGZsYXR0ZW4oaXRlcmFibGUpIHtcbiAgICAgIHZhciBzaGFsbG93T3JEZXB0aCxcbiAgICAgICAgICBkZXB0aCxcbiAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uLFxuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yLFxuICAgICAgICAgIF9pdGVyYXRvckVycm9yLFxuICAgICAgICAgIF9pdGVyYXRvcixcbiAgICAgICAgICBfc3RlcCxcbiAgICAgICAgICBpdGVtLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuXG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBmbGF0dGVuJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgc2hhbGxvd09yRGVwdGggPSBfYXJncy5sZW5ndGggPiAxICYmIF9hcmdzWzFdICE9PSB1bmRlZmluZWQgPyBfYXJnc1sxXSA6IGZhbHNlO1xuICAgICAgICAgICAgICBkZXB0aCA9IE51bWJlcihzaGFsbG93T3JEZXB0aCk7XG4gICAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDU7XG4gICAgICAgICAgICAgIF9pdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0oKTtcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBpZiAoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpdGVtID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIHZhbHVlID0gaXRlbVZhbHVlKGl0ZW0pO1xuXG4gICAgICAgICAgICAgIGlmICghKCF2YWx1ZSB8fCAhaXNNdXRhYmxlQ29sbGVjdGlvbih2YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEzO1xuICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcblxuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIwO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgaWYgKCEoZGVwdGggIT09IDEpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmRlbGVnYXRlWWllbGQoZmxhdHRlbihwcmltaXRpdmVJdGVyYXRvcih2YWx1ZSksIGRlcHRoID09PSAwID8gMCA6IGRlcHRoIC0gMSksIFwidDBcIiwgMTcpO1xuXG4gICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZGVsZWdhdGVZaWVsZChwcmltaXRpdmVJdGVyYXRvcih2YWx1ZSksIFwidDFcIiwgMjApO1xuXG4gICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjU7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQyID0gX2NvbnRleHRbXCJjYXRjaFwiXSg1KTtcbiAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IF9jb250ZXh0LnQyO1xuXG4gICAgICAgICAgICBjYXNlIDI5OlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjk7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAzMDtcblxuICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAzMjtcblxuICAgICAgICAgICAgICBpZiAoIV9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG5cbiAgICAgICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goMzIpO1xuXG4gICAgICAgICAgICBjYXNlIDM2OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDI5KTtcblxuICAgICAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIGZsYXR0ZW4sIHRoaXMsIFtbNSwgMjUsIDI5LCAzN10sIFszMCwsIDMyLCAzNl1dKTtcbiAgICB9KVxuICApO1xufVxuXG52YXIgZmxhdHRlbiA9IG1lbW9pemVGYWN0b3J5KG1ha2VGbGF0dGVuKTtcblxuZnVuY3Rpb24gbWFrZVB1c2goQ29sbGVjdGlvbiwgY29sbGVjdGlvblR5cGUsIGNvbGxlY3Rpb25TdWJ0eXBlKSB7XG4gIGlmIChjb2xsZWN0aW9uU3VidHlwZSA9PT0gJ0luZGV4ZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBfLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24ucHVzaCh2YWx1ZSk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChjb2xsZWN0aW9uU3VidHlwZSA9PT0gJ0tleWVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY29sbGVjdGlvbiwga2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uc2V0KGtleSwgdmFsdWUpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBfLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uYWRkKHZhbHVlKTtcbiAgICB9O1xuICB9XG59XG5cbnZhciBtYWtlUHVzaCQxID0gbWVtb2l6ZUZhY3RvcnkobWFrZVB1c2gpO1xudmFyIHJlZHVjZUJ5VHlwZSA9IHtcbiAgRHVwbGljYXRlZDogZnVuY3Rpb24gcmVkdWNlKGl0ZXJhYmxlLCByZWR1Y2VyLCBpbml0aWFsKSB7XG4gICAgdmFyIHNldFJlZHVjZXIgPSBmdW5jdGlvbiBzZXRSZWR1Y2VyKGFjYywgaXRlbSkge1xuICAgICAgcmV0dXJuIHJlZHVjZXIoYWNjLCBpdGVtLCBpdGVtKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlZHVjZWQ7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIHJlZHVjZWQgPSAoMCwgX3JlZHVjZS5kZWZhdWx0KShpbml0aWFsLCBzZXRSZWR1Y2VyLCBpdGVyYWJsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZHVjZWQgPSAoMCwgX3JlZHVjZS5kZWZhdWx0KShzZXRSZWR1Y2VyLCBpdGVyYWJsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZHVjZWQ7XG4gIH0sXG4gIEluZGV4ZWQ6IGZ1bmN0aW9uIHJlZHVjZShpdGVyYWJsZSwgcmVkdWNlciwgaW5pdGlhbCkge1xuICAgIHZhciByZWR1Y2VkO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICByZWR1Y2VkID0gKDAsIF9yZWR1Y2UuZGVmYXVsdCkoaW5pdGlhbCwgcmVkdWNlciwgaXRlcmFibGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWR1Y2VkID0gKDAsIF9yZWR1Y2UuZGVmYXVsdCkocmVkdWNlciwgaXRlcmFibGUpO1xuICAgIH1cblxuICAgIHJldHVybiByZWR1Y2VkO1xuICB9LFxuICBLZXllZDogZnVuY3Rpb24gcmVkdWNlKGl0ZXJhYmxlLCByZWR1Y2VyLCBpbml0aWFsKSB7XG4gICAgdmFyIGludm9jYXRpb25zID0gMDtcbiAgICB2YXIgaGFzSW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIHZhciByZWR1Y2VkO1xuXG4gICAgdmFyIGtleWVkUmVkdWNlciA9IGZ1bmN0aW9uIGtleWVkUmVkdWNlcihhY2MsIF9yZWYpIHtcbiAgICAgIHZhciBfcmVmMiA9ICgwLCBfc2xpY2VkVG9BcnJheTIuZGVmYXVsdCkoX3JlZiwgMiksXG4gICAgICAgICAga2V5ID0gX3JlZjJbMF0sXG4gICAgICAgICAgdmFsdWUgPSBfcmVmMlsxXTtcblxuICAgICAgaWYgKGludm9jYXRpb25zKysgPT09IDAgJiYgIWhhc0luaXRpYWwpIHtcbiAgICAgICAgYWNjID0gYWNjWzFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVkdWNlcihhY2MsIHZhbHVlLCBrZXkpO1xuICAgIH07XG5cbiAgICBpZiAoaGFzSW5pdGlhbCkge1xuICAgICAgcmVkdWNlZCA9ICgwLCBfcmVkdWNlLmRlZmF1bHQpKGluaXRpYWwsIGtleWVkUmVkdWNlciwgaXRlcmFibGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWR1Y2VkID0gKDAsIF9yZWR1Y2UuZGVmYXVsdCkoa2V5ZWRSZWR1Y2VyLCBpdGVyYWJsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZHVjZWQ7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG1ha2VSZWR1Y2UoQ29sbGVjdGlvbiwgY29sbGVjdGlvblR5cGUsIGNvbGxlY3Rpb25TdWJ0eXBlKSB7XG4gIHJldHVybiByZWR1Y2VCeVR5cGVbY29sbGVjdGlvblN1YnR5cGVdO1xufVxuXG5mdW5jdGlvbiBtYWtlR3JvdXBCeShDb2xsZWN0aW9uLCBjb2xsZWN0aW9uVHlwZSwgY29sbGVjdGlvblN1YnR5cGUpIHtcbiAgdmFyIGNvbmNyZXRlVHlwZSA9IGNvbGxlY3Rpb25UeXBlID09PSAnU2VxdWVuY2UnID8gJ0NvbmNyZXRlJyA6IGNvbGxlY3Rpb25UeXBlO1xuICB2YXIgQ29sbGVjdGlvbkNvbnN0cnVjdG9yID0gQ29sbGVjdGlvbltjb2xsZWN0aW9uVHlwZV1bY29sbGVjdGlvblN1YnR5cGVdO1xuICB2YXIgQ29uY3JldGVDb2xsZWN0aW9uQ29uc3RydWN0b3IgPSBDb2xsZWN0aW9uW2NvbmNyZXRlVHlwZV1bY29sbGVjdGlvblN1YnR5cGVdO1xuICB2YXIgTWFwID0gQ29sbGVjdGlvbi5Db25jcmV0ZS5LZXllZDtcbiAgdmFyIHB1c2ggPSBtYWtlUHVzaCQxLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgdmFyIHJlZHVjZSA9IG1ha2VSZWR1Y2UuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICByZXR1cm4gZnVuY3Rpb24gZ3JvdXBCeShjb2xsZWN0aW9uLCBncm91cGVyKSB7XG4gICAgdmFyIG1hcCA9IHJlZHVjZShjb2xsZWN0aW9uLCBmdW5jdGlvbiAocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICB2YXIgZ3JvdXBLZXkgPSBncm91cGVyKHZhbHVlLCBrZXkpO1xuXG4gICAgICBpZiAoIXJlc3VsdC5nZXQoZ3JvdXBLZXkpKSB7XG4gICAgICAgIHZhciBjb25jcmV0ZSA9IG5ldyBDb25jcmV0ZUNvbGxlY3Rpb25Db25zdHJ1Y3RvcigpO1xuICAgICAgICByZXN1bHQuc2V0KGdyb3VwS2V5LCBjb25jcmV0ZSk7XG4gICAgICB9XG5cbiAgICAgIHB1c2gocmVzdWx0LmdldChncm91cEtleSksIGtleSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBuZXcgTWFwKCkpO1xuICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gbWFwLmtleXMoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgdmFyIGtleSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICBtYXAuc2V0KGtleSwgbmV3IENvbGxlY3Rpb25Db25zdHJ1Y3RvcihtYXAuZ2V0KGtleSkpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG4gIH07XG59XG5cbnZhciBncm91cEJ5ID0gbWVtb2l6ZUZhY3RvcnkobWFrZUdyb3VwQnkpO1xuXG5mdW5jdGlvbiBlbnN1cmVBcnJheShpdGVyYWJsZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShpdGVyYWJsZSkgPyBpdGVyYWJsZSA6IEFycmF5LmZyb20oaXRlcmFibGUpO1xufVxuXG52YXIgZGVmYXVsdENvbXBhcmF0b3IgPSBmdW5jdGlvbiBkZWZhdWx0Q29tcGFyYXRvcihhLCBiKSB7XG4gIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbn07XG5cbmZ1bmN0aW9uIG1ha2VTb3J0KENvbGxlY3Rpb24sIGNvbGxlY3Rpb25UeXBlLCBjb2xsZWN0aW9uU3VidHlwZSkge1xuICB2YXIgX3JlZmxlY3QkY29sbGVjdGlvblN1ID0gcmVmbGVjdFtjb2xsZWN0aW9uU3VidHlwZV0sXG4gICAgICBpdGVtVmFsdWUgPSBfcmVmbGVjdCRjb2xsZWN0aW9uU3UuaXRlbVZhbHVlLFxuICAgICAgTmF0aXZlQ29uc3RydWN0b3IgPSBfcmVmbGVjdCRjb2xsZWN0aW9uU3UuTmF0aXZlQ29uc3RydWN0b3I7XG4gIHJldHVybiBmdW5jdGlvbiBzb3J0KGluUGxhY2UsIGl0ZXJhYmxlLCBzZWxlY3Rvcikge1xuICAgIHZhciBjb21wYXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBkZWZhdWx0Q29tcGFyYXRvcjtcbiAgICB2YXIgYXJyYXkgPSBlbnN1cmVBcnJheShpdGVyYWJsZSk7XG4gICAgdmFyIHdyYXBwZWRDb21wYXJhdG9yID0gc2VsZWN0b3IgPyBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGNvbXBhcmF0b3Ioc2VsZWN0b3IoaXRlbVZhbHVlKGEpKSwgc2VsZWN0b3IoaXRlbVZhbHVlKGIpKSk7XG4gICAgfSA6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gY29tcGFyYXRvcihpdGVtVmFsdWUoYSksIGl0ZW1WYWx1ZShiKSk7XG4gICAgfTtcblxuICAgIGlmIChpblBsYWNlKSB7XG4gICAgICBfc3RhYmxlLmRlZmF1bHQuaW5wbGFjZShhcnJheSwgd3JhcHBlZENvbXBhcmF0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcnJheSA9ICgwLCBfc3RhYmxlLmRlZmF1bHQpKGFycmF5LCB3cmFwcGVkQ29tcGFyYXRvcik7XG4gICAgfVxuXG4gICAgaWYgKGNvbGxlY3Rpb25UeXBlID09PSAnU2VxdWVuY2UnIHx8IGNvbGxlY3Rpb25TdWJ0eXBlID09PSAnSW5kZXhlZCcpIHtcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKGFycmF5KTtcbiAgfTtcbn1cblxudmFyIHNvcnQgPSBtZW1vaXplRmFjdG9yeShtYWtlU29ydCk7XG5cbmZ1bmN0aW9uIG1ha2VUb0NvbmNyZXRlKENvbGxlY3Rpb24sIGNvbGxlY3Rpb25UeXBlLCBjb2xsZWN0aW9uU3VidHlwZSkge1xuICB2YXIgQ29uY3JldGVDb25zdHJ1Y3RvciA9IENvbGxlY3Rpb24uQ29uY3JldGVbY29sbGVjdGlvblN1YnR5cGVdO1xuICByZXR1cm4gZnVuY3Rpb24gdG9OYXRpdmUodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IENvbmNyZXRlQ29uc3RydWN0b3IodmFsdWUpO1xuICB9O1xufVxuXG52YXIgdG9Db25jcmV0ZSA9IG1lbW9pemVGYWN0b3J5KG1ha2VUb0NvbmNyZXRlKTtcblxuZnVuY3Rpb24gbWFrZVRvSlMoQ29sbGVjdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gdG9KUyh2YWx1ZSkge1xuICAgIHJldHVybiBpc0RhdGFTdHJ1Y3R1cmUodmFsdWUpID8gQ29sbGVjdGlvbi5TZXF1ZW5jZS5mcm9tKHZhbHVlKS5tYXAodG9KUykudG9KU09OKCkgOiB2YWx1ZTtcbiAgfTtcbn1cblxudmFyIHRvSnMgPSBtZW1vaXplRmFjdG9yeShtYWtlVG9KUyk7XG5cbmZ1bmN0aW9uIG1ha2VaaXBBbGwoQ29sbGVjdGlvbiwgY29sbGVjdGlvblR5cGUsIGNvbGxlY3Rpb25TdWJ0eXBlKSB7XG4gIHZhciBTZXF1ZW5jZUNvbnN0cnVjdG9yID0gQ29sbGVjdGlvbi5TZXF1ZW5jZVtjb2xsZWN0aW9uU3VidHlwZV07XG4gIHJldHVybiBmdW5jdGlvbiB6aXBBbGwoaXRlcmFibGUpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlcmFibGVzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGl0ZXJhYmxlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF96aXBBbGwuZGVmYXVsdC5hcHBseSh2b2lkIDAsIFtpdGVyYWJsZV0uY29uY2F0KCgwLCBfdG9Db25zdW1hYmxlQXJyYXkyLmRlZmF1bHQpKGl0ZXJhYmxlcy5tYXAoZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICByZXR1cm4gbmV3IFNlcXVlbmNlQ29uc3RydWN0b3IoaXRlcmFibGUpO1xuICAgIH0pKSkpO1xuICB9O1xufVxuXG52YXIgemlwQWxsID0gbWVtb2l6ZUZhY3RvcnkobWFrZVppcEFsbCk7XG5cbmZ1bmN0aW9uIG1ha2VaaXAoQ29sbGVjdGlvbiwgY29sbGVjdGlvblR5cGUsIGNvbGxlY3Rpb25TdWJ0eXBlKSB7XG4gIHZhciBTZXF1ZW5jZUNvbnN0cnVjdG9yID0gQ29sbGVjdGlvbi5TZXF1ZW5jZVtjb2xsZWN0aW9uU3VidHlwZV07XG4gIHJldHVybiBmdW5jdGlvbiB6aXAoaXRlcmFibGUpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlcmFibGVzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGl0ZXJhYmxlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF96aXAuZGVmYXVsdC5hcHBseSh2b2lkIDAsIFtpdGVyYWJsZV0uY29uY2F0KCgwLCBfdG9Db25zdW1hYmxlQXJyYXkyLmRlZmF1bHQpKGl0ZXJhYmxlcy5tYXAoZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICByZXR1cm4gbmV3IFNlcXVlbmNlQ29uc3RydWN0b3IoaXRlcmFibGUpO1xuICAgIH0pKSkpO1xuICB9O1xufVxuXG52YXIgemlwID0gbWVtb2l6ZUZhY3RvcnkobWFrZVppcCk7XG52YXIgZmFjdG9yaWVzID1cbi8qI19fUFVSRV9fKi9cbk9iamVjdC5mcmVlemUoe1xuICBjb25jYXQ6IGNvbmNhdCQxLFxuICBmbGF0dGVuOiBmbGF0dGVuLFxuICBncm91cEJ5OiBncm91cEJ5LFxuICByZWR1Y2U6IG1ha2VSZWR1Y2UsXG4gIHNvcnQ6IHNvcnQsXG4gIHRvQ29uY3JldGU6IHRvQ29uY3JldGUsXG4gIHRvSlM6IHRvSnMsXG4gIHppcEFsbDogemlwQWxsLFxuICB6aXA6IHppcFxufSk7XG52YXIgTmFtZXNwYWNlJDEgPSBuZXcgUm9vdE5hbWVzcGFjZSgpO1xudmFyIENvbGxlY3Rpb24gPSBOYW1lc3BhY2UkMTtcbnZhciBlbXB0eUFycmF5ID0gW107XG5cbnZhciBNZXRob2RGYWN0b3J5ID0gZnVuY3Rpb24gTWV0aG9kRmFjdG9yeShjb2xsZWN0aW9uVHlwZSwgY29sbGVjdGlvblN1YnR5cGUpIHtcbiAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgTWV0aG9kRmFjdG9yeSk7XG4gIHRoaXMuX2NvbGxlY3Rpb25UeXBlID0gY29sbGVjdGlvblR5cGU7XG4gIHRoaXMuX2NvbGxlY3Rpb25TdWJ0eXBlID0gY29sbGVjdGlvblN1YnR5cGU7XG59O1xuXG52YXIgbmF0aXZlRmFjdG9yaWVzID0gbmV3IE1hcChbW01hcCwgZnVuY3Rpb24gKGNvbGwpIHtcbiAgcmV0dXJuIG5ldyBNYXAobmV3IENvbGxlY3Rpb24uU2VxdWVuY2UuS2V5ZWQoY29sbCkpO1xufV0sIFtTZXQsIGZ1bmN0aW9uIChjb2xsKSB7XG4gIHJldHVybiBuZXcgU2V0KG5ldyBDb2xsZWN0aW9uLlNlcXVlbmNlLkR1cGxpY2F0ZWQoY29sbCkpO1xufV0sIFtBcnJheSwgZnVuY3Rpb24gKGNvbGwpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IENvbGxlY3Rpb24uU2VxdWVuY2UuSW5kZXhlZChjb2xsKSk7XG59XSwgW09iamVjdCwgLy8gVE9ETyB1c2UgT2JqZWN0LmZyb21FbnRyaWVzIGhlcmUgd2hlbiBpdCBpcyByZWFkeS5cbmZ1bmN0aW9uIChjb2xsKSB7XG4gIHJldHVybiBuZXcgQ29sbGVjdGlvbi5TZXF1ZW5jZS5LZXllZChjb2xsKS5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgdmFsdWUsIGtleSkge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xufV1dKTtcbnZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbnZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xudmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG50cnkge1xuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICB2YXIgbmFtZSA9IF9zdGVwLnZhbHVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXRob2RGYWN0b3J5LnByb3RvdHlwZSwgbmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBmYWN0b3JpZXNbbmFtZV0oQ29sbGVjdGlvbiwgdGhpcy5fY29sbGVjdGlvblR5cGUsIHRoaXMuX2NvbGxlY3Rpb25TdWJ0eXBlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBfaXRlcmF0b3IgPSAoMCwgX2tleXMuZGVmYXVsdCkoZmFjdG9yaWVzKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICBfbG9vcCgpO1xuICB9XG59IGNhdGNoIChlcnIpIHtcbiAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbn0gZmluYWxseSB7XG4gIHRyeSB7XG4gICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgIH1cbiAgfVxufVxuXG52YXIgQ29sbGVjdGlvbk1peGluID0gZnVuY3Rpb24gQ29sbGVjdGlvbk1peGluKEJhc2UpIHtcbiAgdmFyIENvbGxlY3Rpb25NaXhpbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9CYXNlKSB7XG4gICAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoQ29sbGVjdGlvbk1peGluLCBfQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBDb2xsZWN0aW9uTWl4aW4oaXRlcmFibGUsIGNvbGxlY3Rpb25UeXBlLCBjb2xsZWN0aW9uU3VidHlwZSkge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBDb2xsZWN0aW9uTWl4aW4pO1xuICAgICAgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKENvbGxlY3Rpb25NaXhpbikuY2FsbCh0aGlzLCBpdGVyYWJsZSwgY29sbGVjdGlvblN1YnR5cGUpKTtcbiAgICAgIF90aGlzLl9fc2VsZlBhcmFtID0gZW1wdHlBcnJheTtcbiAgICAgIF90aGlzLl9fZHluYW1pY01ldGhvZHMgPSBuZXcgTWV0aG9kRmFjdG9yeShjb2xsZWN0aW9uVHlwZSwgY29sbGVjdGlvblN1YnR5cGUpO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKENvbGxlY3Rpb25NaXhpbiwgW3tcbiAgICAgIGtleTogXCJzbGljZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNsaWNlKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IEluZmluaXR5O1xuICAgICAgICByZXR1cm4gdGhpcy5fX2RvQ29sbGVjdGlvblRyYW5zZm9ybSgoMCwgX3NsaWNlMi5kZWZhdWx0KSh7XG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgIGVuZDogZW5kXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY29uY2F0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29uY2F0KCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX19kb0NvbGxlY3Rpb25UcmFuc2Zvcm0oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgICAgdmFyIF90aGlzMiRfX2R5bmFtaWNNZXRobztcblxuICAgICAgICAgIHJldHVybiAoX3RoaXMyJF9fZHluYW1pY01ldGhvID0gX3RoaXMyLl9fZHluYW1pY01ldGhvZHMpLmNvbmNhdC5hcHBseShfdGhpczIkX19keW5hbWljTWV0aG8sIFtpdGVyYWJsZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZsYXR0ZW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmbGF0dGVuJCQxKCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fX2RvQ29sbGVjdGlvblRyYW5zZm9ybShmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMzJF9fZHluYW1pY01ldGhvO1xuXG4gICAgICAgICAgcmV0dXJuIChfdGhpczMkX19keW5hbWljTWV0aG8gPSBfdGhpczMuX19keW5hbWljTWV0aG9kcykuZmxhdHRlbi5hcHBseShfdGhpczMkX19keW5hbWljTWV0aG8sIFtpdGVyYWJsZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdyb3VwQnlcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBncm91cEJ5JCQxKGdyb3VwZXIpIHtcbiAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX19kb0NvbGxlY3Rpb25UcmFuc2Zvcm0oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNC5fX2R5bmFtaWNNZXRob2RzLmdyb3VwQnkoaXRlcmFibGUsIGdyb3VwZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZmxhdE1hcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZsYXRNYXAobWFwRm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKG1hcEZuKS5mbGF0dGVuKHRydWUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzb3J0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc29ydCQkMSgpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc29ydEJ5LmFwcGx5KHRoaXMsIFtudWxsXS5jb25jYXQoYXJncykpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjb3VudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvdW50KHByZWRpY2F0ZSkge1xuICAgICAgICByZXR1cm4gKDAsIF9zaXplLmRlZmF1bHQpKHByZWRpY2F0ZSA/IHRoaXMuZmlsdGVyKHByZWRpY2F0ZSkgOiB0aGlzKTtcbiAgICAgIH0gLy8gUmVkdWN0aXZlIGZ1bmN0aW9uc1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInJlZHVjZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlZHVjZShyZWR1Y2VyKSB7XG4gICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCA+IDEgPyBfbGVuNCAtIDEgOiAwKSwgX2tleTQgPSAxOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5NCAtIDFdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9fZG9SZWR1Y3RpdmVUcmFuc2Zvcm0oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgICAgdmFyIF90aGlzNSRfX2R5bmFtaWNNZXRobztcblxuICAgICAgICAgIHJldHVybiAoX3RoaXM1JF9fZHluYW1pY01ldGhvID0gX3RoaXM1Ll9fZHluYW1pY01ldGhvZHMpLnJlZHVjZS5hcHBseShfdGhpczUkX19keW5hbWljTWV0aG8sIFtpdGVyYWJsZSwgZnVuY3Rpb24gKGFjYywgdmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVkdWNlci5hcHBseSh2b2lkIDAsIFthY2MsIHZhbHVlLCBpbmRleF0uY29uY2F0KCgwLCBfdG9Db25zdW1hYmxlQXJyYXkyLmRlZmF1bHQpKF90aGlzNS5fX3NlbGZQYXJhbSkpKTtcbiAgICAgICAgICB9XS5jb25jYXQoYXJncykpO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gRGVlcCBjb252ZXJzaW9uc1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInRvSlNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2R5bmFtaWNNZXRob2RzLnRvSlModGhpcyk7XG4gICAgICB9IC8vIFNoYWxsb3cgY29udmVyc2lvbnNcblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0b1NlcVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU2VxKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb24uU2VxdWVuY2UuZnJvbSh0aGlzKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidG9Db25jcmV0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvQ29uY3JldGUkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZHluYW1pY01ldGhvZHMudG9Db25jcmV0ZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidG9cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0byhDb2xsZWN0aW9uQ29uc3RydWN0b3IpIHtcbiAgICAgICAgaWYgKG5hdGl2ZUZhY3Rvcmllcy5oYXMoQ29sbGVjdGlvbkNvbnN0cnVjdG9yKSkge1xuICAgICAgICAgIHJldHVybiBuYXRpdmVGYWN0b3JpZXMuZ2V0KENvbGxlY3Rpb25Db25zdHJ1Y3RvcikodGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBDb2xsZWN0aW9uQ29uc3RydWN0b3IgPyB0aGlzIDogbmV3IENvbGxlY3Rpb25Db25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gQ29sbGVjdGlvbk1peGluO1xuICB9KEJhc2UpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xsZWN0aW9uTWl4aW4ucHJvdG90eXBlLCAnQEBfX01VVEFCTEVfQ09MTEVDVElPTl9fQEAnLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBDb2xsZWN0aW9uTWl4aW47XG59O1xuXG52YXIgQ29sbGVjdGlvbiQxID0gQ29sbGVjdGlvbk1peGluKGZ1bmN0aW9uIFNlcXVpbnNCYXNlKCkge1xuICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBTZXF1aW5zQmFzZSk7XG59KTtcbnZhciBlbXB0eUFycmF5JDEgPSBbXTtcblxuZnVuY3Rpb24gbWFrZUZyb20oQ29sbGVjdGlvbiwgY29sbGVjdGlvblR5cGUkJDEpIHtcbiAgdmFyIFR5cGVkQ29sbGVjdGlvbiA9IENvbGxlY3Rpb25bY29sbGVjdGlvblR5cGUkJDFdO1xuICByZXR1cm4gZnVuY3Rpb24gZnJvbShpbml0aWFsKSB7XG4gICAgaWYgKGluaXRpYWwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBUeXBlZENvbGxlY3Rpb24uSW5kZXhlZChlbXB0eUFycmF5JDEpO1xuICAgIH0gZWxzZSBpZiAoaXNDb2xsZWN0aW9uKGluaXRpYWwpIHx8IGlzTmF0aXZlKGluaXRpYWwpKSB7XG4gICAgICBpZiAoaXNJbmRleGVkKGluaXRpYWwpKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWRDb2xsZWN0aW9uLkluZGV4ZWQoaW5pdGlhbCk7XG4gICAgICB9IGVsc2UgaWYgKGlzS2V5ZWQoaW5pdGlhbCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZENvbGxlY3Rpb24uS2V5ZWQoaW5pdGlhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkQ29sbGVjdGlvbi5EdXBsaWNhdGVkKGluaXRpYWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGluaXRpYWxbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG5ldyBUeXBlZENvbGxlY3Rpb24uSW5kZXhlZChpbml0aWFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmooaW5pdGlhbCkpIHtcbiAgICAgIHJldHVybiBuZXcgVHlwZWRDb2xsZWN0aW9uLktleWVkKGluaXRpYWwpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xufVxuXG52YXIgbWFrZUZyb20kMSA9IG1lbW9pemVGYWN0b3J5KG1ha2VGcm9tKTtcblxudmFyIFNlcXVlbmNlTmFtZXNwYWNlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfU3VidHlwZU5hbWVzcGFjZSkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShTZXF1ZW5jZU5hbWVzcGFjZSwgX1N1YnR5cGVOYW1lc3BhY2UpO1xuXG4gIGZ1bmN0aW9uIFNlcXVlbmNlTmFtZXNwYWNlKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFNlcXVlbmNlTmFtZXNwYWNlKTtcbiAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShTZXF1ZW5jZU5hbWVzcGFjZSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShTZXF1ZW5jZU5hbWVzcGFjZSwgW3tcbiAgICBrZXk6IFwiZnJvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tKGluaXRpYWwpIHtcbiAgICAgIHJldHVybiBzZXF1ZW5jZUZyb20oaW5pdGlhbCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTZXF1ZW5jZU5hbWVzcGFjZTtcbn0oU3VidHlwZU5hbWVzcGFjZSk7XG5cbnZhciBOYW1lc3BhY2UkMiA9IE5hbWVzcGFjZSQxLl9fcmVnaXN0ZXIoJ1NlcXVlbmNlJywgbmV3IFNlcXVlbmNlTmFtZXNwYWNlKCkpO1xuXG52YXIgc2VxdWVuY2VGcm9tID0gbWFrZUZyb20kMShOYW1lc3BhY2UkMSwgJ1NlcXVlbmNlJyk7XG5cbnZhciBpZGVudGl0eUZuID0gZnVuY3Rpb24gaWRlbnRpdHlGbihfKSB7XG4gIHJldHVybiBfO1xufTtcblxudmFyIFNlcXVlbmNlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQ29sbGVjdGlvbikge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShTZXF1ZW5jZSwgX0NvbGxlY3Rpb24pO1xuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShTZXF1ZW5jZSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZnJvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tKGluaXRpYWwpIHtcbiAgICAgIHJldHVybiBzZXF1ZW5jZUZyb20oaW5pdGlhbCk7XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gU2VxdWVuY2UoaXRlcmFibGUsIGNvbGxlY3Rpb25TdWJ0eXBlKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgU2VxdWVuY2UpO1xuICAgIGl0ZXJhYmxlID0gaXRlcmFibGUgfHwgW107XG4gICAgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKFNlcXVlbmNlKS5jYWxsKHRoaXMsIGl0ZXJhYmxlLCAnU2VxdWVuY2UnLCBjb2xsZWN0aW9uU3VidHlwZSkpO1xuICAgIF90aGlzLl9faXRlcmFibGUgPSBpdGVyYWJsZTtcbiAgICBfdGhpcy5fX3RyYW5zZm9ybSA9IG51bGw7XG4gICAgX3RoaXMuX19jb25zdHJ1Y3RvclRyYW5zZm9ybSA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoU2VxdWVuY2UsIFt7XG4gICAga2V5OiBcIl9fZG9Db2xsZWN0aW9uVHJhbnNmb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9fZG9Db2xsZWN0aW9uVHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICAgICAgdmFyIFNlcXVlbmNlID0gdGhpc1tTeW1ib2wuc3BlY2llc10oKTtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgU2VxdWVuY2UodGhpcyk7XG4gICAgICByZXN1bHQuX190cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfX2RvUmVkdWN0aXZlVHJhbnNmb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9fZG9SZWR1Y3RpdmVUcmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtKHRoaXMuX3RyYW5zZm9ybSgpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3RyYW5zZm9ybVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdHJhbnNmb3JtKCkge1xuICAgICAgdmFyIGNvbnN0cnVjdG9yVHJhbnNmb3JtID0gdGhpcy5fX2NvbnN0cnVjdG9yVHJhbnNmb3JtIHx8IGlkZW50aXR5Rm47XG4gICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5fX3RyYW5zZm9ybSB8fCBpZGVudGl0eUZuO1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybShjb25zdHJ1Y3RvclRyYW5zZm9ybSh0aGlzLl9faXRlcmFibGUpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFN5bWJvbC5pdGVyYXRvcixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtKClbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGtleSwgbmV3VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID09PSBrZXkgPyBuZXdWYWx1ZSA6IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInB1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaChrZXksIG5ld1ZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25jYXQoW25ld1ZhbHVlXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uIChfLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSAhPT0ga2V5O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdyb3VwQnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ3JvdXBCeShncm91cGVyKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGNvbmNyZXRlID0gdGhpcy50b0NvbmNyZXRlKCk7XG4gICAgICB2YXIga2V5ZWQgPSBuZXcgTmFtZXNwYWNlJDIuS2V5ZWQoY29uY3JldGUpO1xuXG4gICAgICBrZXllZC5fX3RyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5fX2R5bmFtaWNNZXRob2RzLmdyb3VwQnkoY29uY3JldGUsIGdyb3VwZXIpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGtleWVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXZlcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RvQ29sbGVjdGlvblRyYW5zZm9ybShmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oaXRlcmFibGUpLnJldmVyc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzb3J0QnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29ydEJ5KCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX2RvQ29sbGVjdGlvblRyYW5zZm9ybShmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgdmFyIF90aGlzMyRfX2R5bmFtaWNNZXRobztcblxuICAgICAgICByZXR1cm4gKF90aGlzMyRfX2R5bmFtaWNNZXRobyA9IF90aGlzMy5fX2R5bmFtaWNNZXRob2RzKS5zb3J0LmFwcGx5KF90aGlzMyRfX2R5bmFtaWNNZXRobywgW2ZhbHNlLCBpdGVyYWJsZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU2VxdWVuY2U7XG59KENvbGxlY3Rpb24kMSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXF1ZW5jZS5wcm90b3R5cGUsICdAQF9fTVVUQUJMRV9TRVFVRU5DRV9fQEAnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIE5hbWVzcGFjZSQzID0gTmFtZXNwYWNlJDEuX19yZWdpc3RlcignQ29uY3JldGUnLCBuZXcgU3VidHlwZU5hbWVzcGFjZSgpKTtcblxudmFyIGNvbmNyZXRlRnJvbSA9IG1ha2VGcm9tJDEoQ29sbGVjdGlvbiQxLCAnQ29uY3JldGUnKTtcblxudmFyIENvbmNyZXRlQ29sbGVjdGlvbiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0NvbGxlY3Rpb24pIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoQ29uY3JldGVDb2xsZWN0aW9uLCBfQ29sbGVjdGlvbik7XG5cbiAgZnVuY3Rpb24gQ29uY3JldGVDb2xsZWN0aW9uKGl0ZXJhYmxlLCBjb2xsZWN0aW9uU3VidHlwZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIENvbmNyZXRlQ29sbGVjdGlvbik7XG4gICAgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKENvbmNyZXRlQ29sbGVjdGlvbikuY2FsbCh0aGlzLCBpdGVyYWJsZSwgJ0NvbmNyZXRlJywgY29sbGVjdGlvblN1YnR5cGUpKTtcbiAgICBfdGhpcy5fX3NlbGZQYXJhbSA9IFsoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzKSldO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKENvbmNyZXRlQ29sbGVjdGlvbiwgW3tcbiAgICBrZXk6IFwiX19kb0NvbGxlY3Rpb25UcmFuc2Zvcm1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX19kb0NvbGxlY3Rpb25UcmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgICB2YXIgQ29sbGVjdGlvbkNvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgIHZhciB0cmFuc2Zvcm1lZCA9IHRyYW5zZm9ybSh0aGlzLl9fbmF0aXZlKTtcblxuICAgICAgaWYgKHRyYW5zZm9ybWVkIGluc3RhbmNlb2YgQ29uY3JldGVDb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb2xsID0gbmV3IENvbGxlY3Rpb25Db25zdHJ1Y3RvcigpO1xuICAgICAgICBjb2xsLl9fbmF0aXZlID0gdGhpcy5fX2NvbnN0cnVjdE5hdGl2ZSh0cmFuc2Zvcm1lZCk7XG4gICAgICAgIHJldHVybiBjb2xsO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfX2NvbnN0cnVjdE5hdGl2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfX2NvbnN0cnVjdE5hdGl2ZShpdGVyYWJsZSkge1xuICAgICAgdmFyIE5hdGl2ZUNvbnN0cnVjdG9yID0gdGhpcy5fX25hdGl2ZS5jb25zdHJ1Y3RvcjtcbiAgICAgIHJldHVybiBuZXcgTmF0aXZlQ29uc3RydWN0b3IoaXRlcmFibGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfX2RvUmVkdWN0aXZlVHJhbnNmb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9fZG9SZWR1Y3RpdmVUcmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtKHRoaXMuX19uYXRpdmUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3VudChwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBwcmVkaWNhdGUgPyAoMCwgX2dldDIuZGVmYXVsdCkoKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoQ29uY3JldGVDb2xsZWN0aW9uLnByb3RvdHlwZSksIFwiY291bnRcIiwgdGhpcykuY2FsbCh0aGlzLCBwcmVkaWNhdGUpIDogdGhpcy5zaXplO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXMoa2V5KSA/IHRoaXMuX19uYXRpdmUuZ2V0KGtleSkgOiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX25hdGl2ZS5oYXMoa2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX25hdGl2ZS5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB2YXIgTmF0aXZlQ29uc3RydWN0b3IgPSB0aGlzLl9fbmF0aXZlLmNvbnN0cnVjdG9yO1xuICAgICAgdGhpcy5fX25hdGl2ZSA9IG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzRW1wdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNpemUgPT09IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbmNhdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoX2NvbmNhdCkge1xuICAgICAgZnVuY3Rpb24gY29uY2F0KCkge1xuICAgICAgICByZXR1cm4gX2NvbmNhdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICBjb25jYXQudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfY29uY2F0LnRvU3RyaW5nKCk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gY29uY2F0O1xuICAgIH0oZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9fZG9Db2xsZWN0aW9uVHJhbnNmb3JtKGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gY29uY2F0LmFwcGx5KHZvaWQgMCwgW2l0ZXJhYmxlXS5jb25jYXQoYXJncykpO1xuICAgICAgfSk7XG4gICAgfSlcbiAgfSwge1xuICAgIGtleTogXCJfX3JldmVyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX19yZXZlcnNlKCkge1xuICAgICAgdmFyIHJldmVyc2VkU2VxID0gTmFtZXNwYWNlJDEuU2VxdWVuY2UuZnJvbSh0aGlzKS5yZXZlcnNlKCkudG9Db25jcmV0ZSgpO1xuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgcmV0dXJuIHJldmVyc2VkU2VxO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0NvbmNyZXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvQ29uY3JldGUoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IC8vIEl0ZXJhdG9yc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwia2V5c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBrZXlzJCQxKCkge1xuICAgICAgcmV0dXJuIG5ldyBOYW1lc3BhY2UkMS5TZXF1ZW5jZS5EdXBsaWNhdGVkKHRoaXMuX19uYXRpdmUua2V5cygpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgIHJldHVybiBuZXcgTmFtZXNwYWNlJDEuU2VxdWVuY2UuRHVwbGljYXRlZCh0aGlzLl9fbmF0aXZlLnZhbHVlcygpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW50cmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbnRyaWVzJCQxKCkge1xuICAgICAgcmV0dXJuIG5ldyBOYW1lc3BhY2UkMS5TZXF1ZW5jZS5EdXBsaWNhdGVkKHRoaXMuX19uYXRpdmUuZW50cmllcygpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFN5bWJvbC5pdGVyYXRvcixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX25hdGl2ZVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fbmF0aXZlLnNpemU7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tKGluaXRpYWwpIHtcbiAgICAgIHJldHVybiBjb25jcmV0ZUZyb20oaW5pdGlhbCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb25jcmV0ZUNvbGxlY3Rpb247XG59KENvbGxlY3Rpb24kMSk7XG5cbmZ1bmN0aW9uIGZvckVhY2goZnVuYywgaXRlcmFibGUpIHtcbiAgdmFyIGMgPSAwO1xuICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgIHZhciBpdGVtID0gX3N0ZXAudmFsdWU7XG4gICAgICBmdW5jKGl0ZW0sIGMrKyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGl0ZXJhYmxlO1xufVxuXG5mdW5jdGlvbiBmb3JTb21lKGZ1bmMsIGl0ZXJhYmxlKSB7XG4gIHZhciBjID0gMDtcbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICB2YXIgaXRlbSA9IF9zdGVwLnZhbHVlO1xuICAgICAgdmFyIHJldCA9IGZ1bmMoaXRlbSwgYysrKTtcblxuICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGM7XG59XG5cbnZhciBEdXBsaWNhdGVkTWl4aW4gPSBmdW5jdGlvbiBEdXBsaWNhdGVkTWl4aW4oQmFzZSkge1xuICByZXR1cm4gKFxuICAgIC8qI19fUFVSRV9fKi9cbiAgICBmdW5jdGlvbiAoX0Jhc2UpIHtcbiAgICAgICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKFNldENvbGxlY3Rpb24sIF9CYXNlKTtcblxuICAgICAgZnVuY3Rpb24gU2V0Q29sbGVjdGlvbihpdGVyYWJsZSkge1xuICAgICAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBTZXRDb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoU2V0Q29sbGVjdGlvbikuY2FsbCh0aGlzLCBpdGVyYWJsZSwgJ0R1cGxpY2F0ZWQnKSk7XG4gICAgICB9IC8vIENvbGxlY3Rpb24gZnVuY3Rpb25zXG5cblxuICAgICAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoU2V0Q29sbGVjdGlvbiwgW3tcbiAgICAgICAga2V5OiBcIm1hcFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKG1hcEZuKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgIHJldHVybiB0aGlzLl9fZG9Db2xsZWN0aW9uVHJhbnNmb3JtKCgwLCBfbWFwMi5kZWZhdWx0KShmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcEZuLmFwcGx5KHZvaWQgMCwgW2l0ZW0sIGl0ZW1dLmNvbmNhdCgoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KShfdGhpcy5fX3NlbGZQYXJhbSkpKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcInRhcFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdGFwKHRhcEZuKSB7XG4gICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5fX2RvQ29sbGVjdGlvblRyYW5zZm9ybSgoMCwgX3RhcDIuZGVmYXVsdCkoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiB0YXBGbi5hcHBseSh2b2lkIDAsIFtpdGVtLCBpdGVtXS5jb25jYXQoKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkoX3RoaXMyLl9fc2VsZlBhcmFtKSkpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiZmlsdGVyXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaWx0ZXIoZmlsdGVyRm4pIHtcbiAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgIHJldHVybiB0aGlzLl9fZG9Db2xsZWN0aW9uVHJhbnNmb3JtKCgwLCBfZmlsdGVyMi5kZWZhdWx0KShmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlckZuLmFwcGx5KHZvaWQgMCwgW2l0ZW0sIGl0ZW1dLmNvbmNhdCgoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KShfdGhpczMuX19zZWxmUGFyYW0pKSk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJmaWx0ZXJOb3RcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbHRlck5vdChmaWx0ZXJGbikge1xuICAgICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX19kb0NvbGxlY3Rpb25UcmFuc2Zvcm0oKDAsIF9maWx0ZXIyLmRlZmF1bHQpKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gIWZpbHRlckZuLmFwcGx5KHZvaWQgMCwgW2l0ZW0sIGl0ZW1dLmNvbmNhdCgoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KShfdGhpczQuX19zZWxmUGFyYW0pKSk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9IC8vIFJlZHVjdGl2ZSBmdW5jdGlvbnNcblxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiZm9yRWFjaFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaCQkMShlYWNoRm4pIHtcbiAgICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgICAgIGZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBlYWNoRm4uYXBwbHkodm9pZCAwLCBbaXRlbSwgaXRlbV0uY29uY2F0KCgwLCBfdG9Db25zdW1hYmxlQXJyYXkyLmRlZmF1bHQpKF90aGlzNS5fX3NlbGZQYXJhbSkpKTtcbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiZm9yU29tZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZm9yU29tZSQkMShlYWNoRm4pIHtcbiAgICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgICAgIHJldHVybiBmb3JTb21lKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gZWFjaEZuLmFwcGx5KHZvaWQgMCwgW2l0ZW0sIGl0ZW1dLmNvbmNhdCgoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KShfdGhpczYuX19zZWxmUGFyYW0pKSk7XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gLy8gQ29udmVyc2lvbnNcblxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG8oQXJyYXkpO1xuICAgICAgICB9XG4gICAgICB9XSk7XG4gICAgICByZXR1cm4gU2V0Q29sbGVjdGlvbjtcbiAgICB9KEJhc2UpXG4gICk7XG59O1xuXG52YXIgSW5kZXhlZE1peGluID0gZnVuY3Rpb24gSW5kZXhlZE1peGluKEJhc2UpIHtcbiAgdmFyIEluZGV4ZWRDb2xsZWN0aW9uID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0Jhc2UpIHtcbiAgICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShJbmRleGVkQ29sbGVjdGlvbiwgX0Jhc2UpO1xuXG4gICAgZnVuY3Rpb24gSW5kZXhlZENvbGxlY3Rpb24oaXRlcmFibGUpIHtcbiAgICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEluZGV4ZWRDb2xsZWN0aW9uKTtcbiAgICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKEluZGV4ZWRDb2xsZWN0aW9uKS5jYWxsKHRoaXMsIGl0ZXJhYmxlLCAnSW5kZXhlZCcpKTtcbiAgICB9IC8vIHByZXR0aWVyLWlnbm9yZVxuXG5cbiAgICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShJbmRleGVkQ29sbGVjdGlvbiwgW3tcbiAgICAgIGtleTogXCJ6aXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB6aXAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9fZG9Db2xsZWN0aW9uVHJhbnNmb3JtKGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICAgIHZhciBfdGhpcyRfX2R5bmFtaWNNZXRob2Q7XG5cbiAgICAgICAgICByZXR1cm4gKF90aGlzJF9fZHluYW1pY01ldGhvZCA9IF90aGlzLl9fZHluYW1pY01ldGhvZHMpLnppcC5hcHBseShfdGhpcyRfX2R5bmFtaWNNZXRob2QsIFtpdGVyYWJsZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInppcEFsbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHppcEFsbCgpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX19kb0NvbGxlY3Rpb25UcmFuc2Zvcm0oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgICAgdmFyIF90aGlzMiRfX2R5bmFtaWNNZXRobztcblxuICAgICAgICAgIHJldHVybiAoX3RoaXMyJF9fZHluYW1pY01ldGhvID0gX3RoaXMyLl9fZHluYW1pY01ldGhvZHMpLnppcEFsbC5hcHBseShfdGhpczIkX19keW5hbWljTWV0aG8sIFtpdGVyYWJsZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInppcFdpdGhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB6aXBXaXRoKHppcHBlcikge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICAgIGFyZ3NbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fX2RvQ29sbGVjdGlvblRyYW5zZm9ybShmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMzJF9fZHluYW1pY01ldGhvO1xuXG4gICAgICAgICAgcmV0dXJuICgwLCBfbWFwMi5kZWZhdWx0KShmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgICAgICAgIHJldHVybiB6aXBwZXIuYXBwbHkodm9pZCAwLCAoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KShpdGVtcykpO1xuICAgICAgICAgIH0sIChfdGhpczMkX19keW5hbWljTWV0aG8gPSBfdGhpczMuX19keW5hbWljTWV0aG9kcykuemlwLmFwcGx5KF90aGlzMyRfX2R5bmFtaWNNZXRobywgW2l0ZXJhYmxlXS5jb25jYXQoYXJncykpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImludGVycG9zZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGludGVycG9zZShzZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19kb0NvbGxlY3Rpb25UcmFuc2Zvcm0oKDAsIF9pbnRlcnBvc2UyLmRlZmF1bHQpKHNlcGFyYXRvcikpO1xuICAgICAgfSAvLyBDb2xsZWN0aW9uIGZ1bmN0aW9uc1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIm1hcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChtYXBGbikge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICByZXR1cm4gdGhpcy5fX2RvQ29sbGVjdGlvblRyYW5zZm9ybSgoMCwgX21hcDIuZGVmYXVsdCkoZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIG1hcEZuLmFwcGx5KHZvaWQgMCwgW3ZhbHVlLCBpXS5jb25jYXQoKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkoX3RoaXM0Ll9fc2VsZlBhcmFtKSkpO1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInRhcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRhcCh0YXBGbikge1xuICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgICByZXR1cm4gdGhpcy5fX2RvQ29sbGVjdGlvblRyYW5zZm9ybSgoMCwgX3RhcDIuZGVmYXVsdCkoZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIHRhcEZuLmFwcGx5KHZvaWQgMCwgW3ZhbHVlLCBpXS5jb25jYXQoKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkoX3RoaXM1Ll9fc2VsZlBhcmFtKSkpO1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZpbHRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbHRlcihmaWx0ZXJGbikge1xuICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgICByZXR1cm4gdGhpcy5fX2RvQ29sbGVjdGlvblRyYW5zZm9ybSgoMCwgX2ZpbHRlcjIuZGVmYXVsdCkoZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbHRlckZuLmFwcGx5KHZvaWQgMCwgW3ZhbHVlLCBpXS5jb25jYXQoKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkoX3RoaXM2Ll9fc2VsZlBhcmFtKSkpO1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZpbHRlck5vdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbHRlck5vdChmaWx0ZXJGbikge1xuICAgICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgICByZXR1cm4gdGhpcy5fX2RvQ29sbGVjdGlvblRyYW5zZm9ybSgoMCwgX2ZpbHRlcjIuZGVmYXVsdCkoZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuICFmaWx0ZXJGbi5hcHBseSh2b2lkIDAsIFt2YWx1ZSwgaV0uY29uY2F0KCgwLCBfdG9Db25zdW1hYmxlQXJyYXkyLmRlZmF1bHQpKF90aGlzNy5fX3NlbGZQYXJhbSkpKTtcbiAgICAgICAgfSkpO1xuICAgICAgfSAvLyBSZWR1Y3RpdmUgZnVuY3Rpb25zXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZm9yRWFjaFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvckVhY2gkJDEoZWFjaEZuKSB7XG4gICAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICAgIGZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGVhY2hGbi5hcHBseSh2b2lkIDAsIFt2YWx1ZSwgaV0uY29uY2F0KCgwLCBfdG9Db25zdW1hYmxlQXJyYXkyLmRlZmF1bHQpKF90aGlzOC5fX3NlbGZQYXJhbSkpKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZvclNvbWVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JTb21lJCQxKGVhY2hGbikge1xuICAgICAgICB2YXIgX3RoaXM5ID0gdGhpcztcblxuICAgICAgICByZXR1cm4gZm9yU29tZShmdW5jdGlvbiAodmFsdWUsIGkpIHtcbiAgICAgICAgICByZXR1cm4gZWFjaEZuLmFwcGx5KHZvaWQgMCwgW3ZhbHVlLCBpXS5jb25jYXQoKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkoX3RoaXM5Ll9fc2VsZlBhcmFtKSkpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0gLy8gQ29udmVyc2lvbnNcblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0b0pTT05cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvKEFycmF5KTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIEluZGV4ZWRDb2xsZWN0aW9uO1xuICB9KEJhc2UpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbmRleGVkQ29sbGVjdGlvbi5wcm90b3R5cGUsICdAQF9fTVVUQUJMRV9JTkRFWEVEX19AQCcsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIEluZGV4ZWRDb2xsZWN0aW9uO1xufTtcblxudmFyIEtleWVkTWl4aW4gPSBmdW5jdGlvbiBLZXllZE1peGluKEJhc2UpIHtcbiAgdmFyIEtleWVkQ29sbGVjdGlvbiA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9CYXNlKSB7XG4gICAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoS2V5ZWRDb2xsZWN0aW9uLCBfQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBLZXllZENvbGxlY3Rpb24oaXRlcmFibGUpIHtcbiAgICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEtleWVkQ29sbGVjdGlvbik7XG4gICAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLZXllZENvbGxlY3Rpb24pLmNhbGwodGhpcywgaXRlcmFibGUsICdLZXllZCcpKTtcbiAgICB9XG5cbiAgICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShLZXllZENvbGxlY3Rpb24sIFt7XG4gICAgICBrZXk6IFwiZmxpcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZsaXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZG9Db2xsZWN0aW9uVHJhbnNmb3JtKCgwLCBfbWFwMi5kZWZhdWx0KShmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIHZhciBfcmVmMiA9ICgwLCBfc2xpY2VkVG9BcnJheTIuZGVmYXVsdCkoX3JlZiwgMiksXG4gICAgICAgICAgICAgIGtleSA9IF9yZWYyWzBdLFxuICAgICAgICAgICAgICB2YWx1ZSA9IF9yZWYyWzFdO1xuXG4gICAgICAgICAgcmV0dXJuIFt2YWx1ZSwga2V5XTtcbiAgICAgICAgfSkpO1xuICAgICAgfSAvLyBDb2xsZWN0aW9uIGZ1bmN0aW9uc1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIm1hcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChtYXBGbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9fZG9Db2xsZWN0aW9uVHJhbnNmb3JtKCgwLCBfbWFwMi5kZWZhdWx0KShmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgICB2YXIgX3JlZjQgPSAoMCwgX3NsaWNlZFRvQXJyYXkyLmRlZmF1bHQpKF9yZWYzLCAyKSxcbiAgICAgICAgICAgICAga2V5ID0gX3JlZjRbMF0sXG4gICAgICAgICAgICAgIHZhbHVlID0gX3JlZjRbMV07XG5cbiAgICAgICAgICByZXR1cm4gW2tleSwgbWFwRm4uYXBwbHkodm9pZCAwLCBbdmFsdWUsIGtleV0uY29uY2F0KCgwLCBfdG9Db25zdW1hYmxlQXJyYXkyLmRlZmF1bHQpKF90aGlzLl9fc2VsZlBhcmFtKSkpXTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtYXBLZXlzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbWFwS2V5cyhtYXBGbikge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICByZXR1cm4gdGhpcy5fX2RvQ29sbGVjdGlvblRyYW5zZm9ybSgoMCwgX21hcDIuZGVmYXVsdCkoZnVuY3Rpb24gKF9yZWY1KSB7XG4gICAgICAgICAgdmFyIF9yZWY2ID0gKDAsIF9zbGljZWRUb0FycmF5Mi5kZWZhdWx0KShfcmVmNSwgMiksXG4gICAgICAgICAgICAgIGtleSA9IF9yZWY2WzBdLFxuICAgICAgICAgICAgICB2YWx1ZSA9IF9yZWY2WzFdO1xuXG4gICAgICAgICAgcmV0dXJuIFttYXBGbi5hcHBseSh2b2lkIDAsIFtrZXksIHZhbHVlXS5jb25jYXQoKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkoX3RoaXMyLl9fc2VsZlBhcmFtKSkpLCB2YWx1ZV07XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibWFwRW50cmllc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hcEVudHJpZXMobWFwRm4pIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX19kb0NvbGxlY3Rpb25UcmFuc2Zvcm0oKDAsIF9tYXAyLmRlZmF1bHQpKGZ1bmN0aW9uIChlbnRyeSwgaSkge1xuICAgICAgICAgIHJldHVybiBtYXBGbi5hcHBseSh2b2lkIDAsIFtlbnRyeSwgaV0uY29uY2F0KCgwLCBfdG9Db25zdW1hYmxlQXJyYXkyLmRlZmF1bHQpKF90aGlzMy5fX3NlbGZQYXJhbSkpKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0YXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0YXAodGFwRm4pIHtcbiAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX19kb0NvbGxlY3Rpb25UcmFuc2Zvcm0oKDAsIF90YXAyLmRlZmF1bHQpKGZ1bmN0aW9uIChfcmVmNykge1xuICAgICAgICAgIHZhciBfcmVmOCA9ICgwLCBfc2xpY2VkVG9BcnJheTIuZGVmYXVsdCkoX3JlZjcsIDIpLFxuICAgICAgICAgICAgICBrZXkgPSBfcmVmOFswXSxcbiAgICAgICAgICAgICAgdmFsdWUgPSBfcmVmOFsxXTtcblxuICAgICAgICAgIHJldHVybiB0YXBGbi5hcHBseSh2b2lkIDAsIFt2YWx1ZSwga2V5XS5jb25jYXQoKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkoX3RoaXM0Ll9fc2VsZlBhcmFtKSkpO1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZpbHRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbHRlcihmaWx0ZXJGbikge1xuICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgICByZXR1cm4gdGhpcy5fX2RvQ29sbGVjdGlvblRyYW5zZm9ybSgoMCwgX2ZpbHRlcjIuZGVmYXVsdCkoZnVuY3Rpb24gKF9yZWY5KSB7XG4gICAgICAgICAgdmFyIF9yZWYxMCA9ICgwLCBfc2xpY2VkVG9BcnJheTIuZGVmYXVsdCkoX3JlZjksIDIpLFxuICAgICAgICAgICAgICBrZXkgPSBfcmVmMTBbMF0sXG4gICAgICAgICAgICAgIHZhbHVlID0gX3JlZjEwWzFdO1xuXG4gICAgICAgICAgcmV0dXJuIGZpbHRlckZuLmFwcGx5KHZvaWQgMCwgW3ZhbHVlLCBrZXldLmNvbmNhdCgoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KShfdGhpczUuX19zZWxmUGFyYW0pKSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZmlsdGVyTm90XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmlsdGVyTm90KGZpbHRlckZuKSB7XG4gICAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9fZG9Db2xsZWN0aW9uVHJhbnNmb3JtKCgwLCBfZmlsdGVyMi5kZWZhdWx0KShmdW5jdGlvbiAoX3JlZjExKSB7XG4gICAgICAgICAgdmFyIF9yZWYxMiA9ICgwLCBfc2xpY2VkVG9BcnJheTIuZGVmYXVsdCkoX3JlZjExLCAyKSxcbiAgICAgICAgICAgICAga2V5ID0gX3JlZjEyWzBdLFxuICAgICAgICAgICAgICB2YWx1ZSA9IF9yZWYxMlsxXTtcblxuICAgICAgICAgIHJldHVybiAhZmlsdGVyRm4uYXBwbHkodm9pZCAwLCBbdmFsdWUsIGtleV0uY29uY2F0KCgwLCBfdG9Db25zdW1hYmxlQXJyYXkyLmRlZmF1bHQpKF90aGlzNi5fX3NlbGZQYXJhbSkpKTtcbiAgICAgICAgfSkpO1xuICAgICAgfSAvLyBSZWR1Y3RpdmUgZnVuY3Rpb25zXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZm9yRWFjaFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvckVhY2gkJDEoZWFjaEZuKSB7XG4gICAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICAgIGZvckVhY2goZnVuY3Rpb24gKF9yZWYxMykge1xuICAgICAgICAgIHZhciBfcmVmMTQgPSAoMCwgX3NsaWNlZFRvQXJyYXkyLmRlZmF1bHQpKF9yZWYxMywgMiksXG4gICAgICAgICAgICAgIGtleSA9IF9yZWYxNFswXSxcbiAgICAgICAgICAgICAgdmFsdWUgPSBfcmVmMTRbMV07XG5cbiAgICAgICAgICByZXR1cm4gZWFjaEZuLmFwcGx5KHZvaWQgMCwgW3ZhbHVlLCBrZXldLmNvbmNhdCgoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KShfdGhpczcuX19zZWxmUGFyYW0pKSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmb3JTb21lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZm9yU29tZSQkMShlYWNoRm4pIHtcbiAgICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIGZvclNvbWUoZnVuY3Rpb24gKF9yZWYxNSkge1xuICAgICAgICAgIHZhciBfcmVmMTYgPSAoMCwgX3NsaWNlZFRvQXJyYXkyLmRlZmF1bHQpKF9yZWYxNSwgMiksXG4gICAgICAgICAgICAgIGtleSA9IF9yZWYxNlswXSxcbiAgICAgICAgICAgICAgdmFsdWUgPSBfcmVmMTZbMV07XG5cbiAgICAgICAgICByZXR1cm4gZWFjaEZuLmFwcGx5KHZvaWQgMCwgW3ZhbHVlLCBrZXldLmNvbmNhdCgoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KShfdGhpczguX19zZWxmUGFyYW0pKSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfSAvLyBDb252ZXJzaW9uc1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcInRvSlNPTlwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8oT2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIEtleWVkQ29sbGVjdGlvbjtcbiAgfShCYXNlKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoS2V5ZWRDb2xsZWN0aW9uLnByb3RvdHlwZSwgJ0BAX19NVVRBQkxFX0tFWUVEX19AQCcsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIEtleWVkQ29sbGVjdGlvbjtcbn07XG5cbnZhciBfbWFya2VkID1cbi8qI19fUFVSRV9fKi9cbl9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoYXJyYXlFbnRyaWVzKTtcblxuZnVuY3Rpb24gYXJyYXlFbnRyaWVzKGFycmF5KSB7XG4gIHZhciBpO1xuICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBhcnJheUVudHJpZXMkKF9jb250ZXh0KSB7XG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoIShpIDwgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICByZXR1cm4gW2ksIGFycmF5W2ldXTtcblxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBfbWFya2VkLCB0aGlzKTtcbn1cblxudmFyIExpc3QgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9JbmRleGVkTWl4aW4pIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoTGlzdCwgX0luZGV4ZWRNaXhpbik7XG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKExpc3QsIG51bGwsIFt7XG4gICAga2V5OiBcImlzTGlzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0xpc3Qoc2hhcGUpIHtcbiAgICAgIHJldHVybiBpc011dGFibGVMaXN0KHNoYXBlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib2ZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2YoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICB2YWx1ZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgTGlzdCh2YWx1ZXMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIExpc3QoaXRlcmFibGUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBMaXN0KTtcbiAgICBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoTGlzdCkuY2FsbCh0aGlzLCBpdGVyYWJsZSkpO1xuICAgIF90aGlzLl9fbmF0aXZlID0gaXRlcmFibGUgPT0gbnVsbCA/IFtdIDogQXJyYXkuZnJvbShpc0tleWVkKGl0ZXJhYmxlKSA/IGl0ZXJhYmxlLnZhbHVlcygpIDogaXRlcmFibGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKExpc3QsIFt7XG4gICAga2V5OiBcIl9fY29uc3RydWN0TmF0aXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9fY29uc3RydWN0TmF0aXZlKGl0ZXJhYmxlKSB7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShpdGVyYWJsZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoaWR4KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX25hdGl2ZVtpZHhdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGlkeCwgdmFsdWUpIHtcbiAgICAgIHRoaXMuX19uYXRpdmVbaWR4XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMoaWR4KSB7XG4gICAgICByZXR1cm4gaWR4IDwgdGhpcy5fX25hdGl2ZS5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInB1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaCgpIHtcbiAgICAgIHZhciBfdGhpcyRfX25hdGl2ZTtcblxuICAgICAgKF90aGlzJF9fbmF0aXZlID0gdGhpcy5fX25hdGl2ZSkucHVzaC5hcHBseShfdGhpcyRfX25hdGl2ZSwgYXJndW1lbnRzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3AoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX25hdGl2ZS5wb3AoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX25hdGl2ZS5zaGlmdCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2hpZnQodmFsdWUpIHtcbiAgICAgIHRoaXMuX19uYXRpdmUudW5zaGlmdCh2YWx1ZSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaXJzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXJzdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fbmF0aXZlWzBdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsYXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxhc3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX25hdGl2ZVt0aGlzLl9fbmF0aXZlLmxlbmd0aF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNvcnRCeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb3J0QnkoKSB7XG4gICAgICB2YXIgX3RoaXMkX19keW5hbWljTWV0aG9kO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICAoX3RoaXMkX19keW5hbWljTWV0aG9kID0gdGhpcy5fX2R5bmFtaWNNZXRob2RzKS5zb3J0LmFwcGx5KF90aGlzJF9fZHluYW1pY01ldGhvZCwgW3RydWUsIHRoaXMuX19uYXRpdmVdLmNvbmNhdChhcmdzKSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbGwoKSB7XG4gICAgICB2YXIgX3RoaXMkX19uYXRpdmUyO1xuXG4gICAgICAoX3RoaXMkX19uYXRpdmUyID0gdGhpcy5fX25hdGl2ZSkuZmlsbC5hcHBseShfdGhpcyRfX25hdGl2ZTIsIGFyZ3VtZW50cyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbmNsdWRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmNsdWRlcyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19uYXRpdmUuaW5jbHVkZXModmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKG1hcEZuKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMuX19kb0NvbGxlY3Rpb25UcmFuc2Zvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLl9fbmF0aXZlLm1hcChmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIG1hcEZuKHZhbHVlLCBpbmRleCwgX3RoaXMyKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlsdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbHRlcihmaWx0ZXJGbikge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLl9fZG9Db2xsZWN0aW9uVHJhbnNmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5fX25hdGl2ZS5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBmaWx0ZXJGbih2YWx1ZSwgaW5kZXgsIF90aGlzMyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbHRlck5vdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWx0ZXJOb3QoZmlsdGVyRm4pIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5fX2RvQ29sbGVjdGlvblRyYW5zZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczQuX19uYXRpdmUuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gIWZpbHRlckZuKHZhbHVlLCBpbmRleCwgX3RoaXM0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2xpY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2xpY2UoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX19kb0NvbGxlY3Rpb25UcmFuc2Zvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXM1JF9fbmF0aXZlO1xuXG4gICAgICAgIHJldHVybiAoX3RoaXM1JF9fbmF0aXZlID0gX3RoaXM1Ll9fbmF0aXZlKS5zbGljZS5hcHBseShfdGhpczUkX19uYXRpdmUsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbmNhdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25jYXQoKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX19kb0NvbGxlY3Rpb25UcmFuc2Zvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXM2JF9fbmF0aXZlO1xuXG4gICAgICAgIHJldHVybiAoX3RoaXM2JF9fbmF0aXZlID0gX3RoaXM2Ll9fbmF0aXZlKS5jb25jYXQuYXBwbHkoX3RoaXM2JF9fbmF0aXZlLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXZlcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgICB0aGlzLl9fbmF0aXZlLnJldmVyc2UoKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlZHVjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWR1Y2UocmVkdWNlcikge1xuICAgICAgdmFyIF90aGlzJF9fbmF0aXZlMyxcbiAgICAgICAgICBfdGhpczcgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUgPiAxID8gX2xlbjUgLSAxIDogMCksIF9rZXk1ID0gMTsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgICAgICBhcmdzW19rZXk1IC0gMV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKF90aGlzJF9fbmF0aXZlMyA9IHRoaXMuX19uYXRpdmUpLnJlZHVjZS5hcHBseShfdGhpcyRfX25hdGl2ZTMsIFtmdW5jdGlvbiAoYWNjLCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHJlZHVjZXIoYWNjLCB2YWx1ZSwgaW5kZXgsIF90aGlzNyk7XG4gICAgICB9XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJqb2luXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX25hdGl2ZS5qb2luKHNlcGFyYXRvcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMoaWR4KSB7XG4gICAgICByZXR1cm4gaWR4IDwgdGhpcy5zaXplKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKGlkeCkge1xuICAgICAgdmFyIGhhc0lkeCA9IHRoaXMuaGFzKGlkeCk7XG5cbiAgICAgIGlmIChoYXNJZHgpIHtcbiAgICAgICAgdGhpcy5fX25hdGl2ZVtpZHhdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzSWR4O1xuICAgIH0gLy8gSXRlcmF0b3JzXG5cbiAgfSwge1xuICAgIGtleTogXCJrZXlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtleXMkJDEoKSB7XG4gICAgICByZXR1cm4gbmV3IE5hbWVzcGFjZSQxLlNlcXVlbmNlLkR1cGxpY2F0ZWQoKDAsIF9yYW5nZS5kZWZhdWx0KSh0aGlzLl9fbmF0aXZlLmxlbmd0aCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgcmV0dXJuIG5ldyBOYW1lc3BhY2UkMS5TZXF1ZW5jZS5EdXBsaWNhdGVkKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbnRyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVudHJpZXMkJDEoKSB7XG4gICAgICByZXR1cm4gbmV3IE5hbWVzcGFjZSQxLlNlcXVlbmNlLkR1cGxpY2F0ZWQoYXJyYXlFbnRyaWVzKHRoaXMuX19uYXRpdmUpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFN5bWJvbC5zcGVjaWVzLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiBMaXN0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX25hdGl2ZS5sZW5ndGg7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBMaXN0O1xufShJbmRleGVkTWl4aW4oQ29uY3JldGVDb2xsZWN0aW9uKSk7XG5cbnZhciBMaXN0JDEgPSBOYW1lc3BhY2UkMy5fX3JlZ2lzdGVyKCdJbmRleGVkJywgTGlzdCk7XG5cbmV4cG9ydHMuTGlzdCA9IExpc3QkMTtcblxudmFyIFNlcXVpbnNNYXAgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9LZXllZE1peGluKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKFNlcXVpbnNNYXAsIF9LZXllZE1peGluKTtcbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoU2VxdWluc01hcCwgbnVsbCwgW3tcbiAgICBrZXk6IFwiaXNNYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNNYXAoc2hhcGUpIHtcbiAgICAgIHJldHVybiBpc011dGFibGVNYXAoc2hhcGUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIFNlcXVpbnNNYXAoaXRlcmFibGUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBTZXF1aW5zTWFwKTtcbiAgICBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoU2VxdWluc01hcCkuY2FsbCh0aGlzLCBpdGVyYWJsZSkpOyAvLyBwcmV0dGllci1pZ25vcmVcblxuICAgIF90aGlzLl9fbmF0aXZlID0gbmV3IE1hcChpdGVyYWJsZSA9PSBudWxsID8gW10gOiBpc0NvbGxlY3Rpb24oaXRlcmFibGUpIHx8IGlzTmF0aXZlKGl0ZXJhYmxlKSA/IGl0ZXJhYmxlLmVudHJpZXMoKSA6IGlzUGxhaW5PYmooaXRlcmFibGUpID8gKDAsIF9lbnRyaWVzLmRlZmF1bHQpKGl0ZXJhYmxlKSA6IGl0ZXJhYmxlKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShTZXF1aW5zTWFwLCBbe1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuX19uYXRpdmUuc2V0KGtleSwgdmFsdWUpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic29ydEJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvcnRCeSgpIHtcbiAgICAgIHZhciBfdGhpcyRfX2R5bmFtaWNNZXRob2Q7XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9fbmF0aXZlID0gbmV3IE1hcCgoX3RoaXMkX19keW5hbWljTWV0aG9kID0gdGhpcy5fX2R5bmFtaWNNZXRob2RzKS5zb3J0LmFwcGx5KF90aGlzJF9fZHluYW1pY01ldGhvZCwgW3RydWUsIEFycmF5LmZyb20odGhpcy5fX25hdGl2ZSldLmNvbmNhdChhcmdzKSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJldmVyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICAgIHZhciByZXZlcnNlZFNlcSA9IHRoaXMuX19yZXZlcnNlKCk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSByZXZlcnNlZFNlcVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSAoMCwgX3NsaWNlZFRvQXJyYXkyLmRlZmF1bHQpKF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAga2V5ID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgICAgICAgIHZhbHVlID0gX3N0ZXAkdmFsdWVbMV07XG5cbiAgICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSAvLyBDb252ZXJzaW9uc1xuXG4gIH0sIHtcbiAgICBrZXk6IFN5bWJvbC5zcGVjaWVzLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiBTZXF1aW5zTWFwO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU2VxdWluc01hcDtcbn0oS2V5ZWRNaXhpbihDb25jcmV0ZUNvbGxlY3Rpb24pKTtcblxudmFyIE1hcCQxID0gTmFtZXNwYWNlJDMuX19yZWdpc3RlcignS2V5ZWQnLCBTZXF1aW5zTWFwKTtcblxuZXhwb3J0cy5NYXAgPSBNYXAkMTtcblxudmFyIFNlcXVpbnNTZXQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9EdXBsaWNhdGVkTWl4aW4pIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoU2VxdWluc1NldCwgX0R1cGxpY2F0ZWRNaXhpbik7XG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFNlcXVpbnNTZXQsIG51bGwsIFt7XG4gICAga2V5OiBcImlzU2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzU2V0KHNoYXBlKSB7XG4gICAgICByZXR1cm4gaXNNdXRhYmxlU2V0KHNoYXBlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib2ZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2YoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICB2YWx1ZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgU2VxdWluc1NldCh2YWx1ZXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcm9tS2V5c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tS2V5cyhzaGFwZSkge1xuICAgICAgcmV0dXJuIG1ha2VGcm9tJDEoTmFtZXNwYWNlJDEsICdTZXF1ZW5jZScpKHNoYXBlKS5rZXlzKCkudG8oU2VxdWluc1NldCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuaW9uKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBpdGVyYWJsZXMgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgaXRlcmFibGVzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgU2VxdWluc1NldCgoMCwgX2ZsYXQuZGVmYXVsdCkoMSwgKDAsIF9tYXAyLmRlZmF1bHQpKGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gbmV3IE5hbWVzcGFjZSQxLlNlcXVlbmNlLkR1cGxpY2F0ZWQoaXRlcmFibGUpO1xuICAgICAgfSwgaXRlcmFibGVzKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnRlcnNlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJzZWN0KCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBpdGVyYWJsZXMgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgaXRlcmFibGVzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICB9XG5cbiAgICAgIHZhciBjb3VudE1hcCA9IG5ldyBOYW1lc3BhY2UkMy5LZXllZCgpO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgaXRlcmFibGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgaXRlcmFibGUgPSBpdGVyYWJsZXNbX2ldO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBuZXcgTmFtZXNwYWNlJDEuU2VxdWVuY2UuRHVwbGljYXRlZChpdGVyYWJsZSlbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIGNvdW50TWFwLnNldCh2YWx1ZSwgKGNvdW50TWFwLmdldCh2YWx1ZSkgfHwgMCkgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBOYW1lc3BhY2UkMS5TZXF1ZW5jZS5LZXllZChjb3VudE1hcCkuZmlsdGVyKGZ1bmN0aW9uIChjb3VudCkge1xuICAgICAgICByZXR1cm4gY291bnQgPT09IGl0ZXJhYmxlcy5sZW5ndGg7XG4gICAgICB9KS5rZXlzKCkudG8oU2VxdWluc1NldCk7XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gU2VxdWluc1NldChpdGVyYWJsZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFNlcXVpbnNTZXQpO1xuICAgIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShTZXF1aW5zU2V0KS5jYWxsKHRoaXMsIGl0ZXJhYmxlKSk7XG4gICAgX3RoaXMuX19uYXRpdmUgPSBuZXcgU2V0KGl0ZXJhYmxlID09IG51bGwgPyBbXSA6IGlzS2V5ZWQoaXRlcmFibGUpID8gaXRlcmFibGUudmFsdWVzKCkgOiBpdGVyYWJsZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoU2VxdWluc1NldCwgW3tcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLl9fbmF0aXZlLmFkZChrZXksIHZhbHVlKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNvcnRCeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb3J0QnkoKSB7XG4gICAgICB2YXIgX3RoaXMkX19keW5hbWljTWV0aG9kO1xuXG4gICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9fbmF0aXZlID0gbmV3IFNldCgoX3RoaXMkX19keW5hbWljTWV0aG9kID0gdGhpcy5fX2R5bmFtaWNNZXRob2RzKS5zb3J0LmFwcGx5KF90aGlzJF9fZHluYW1pY01ldGhvZCwgW3RydWUsIEFycmF5LmZyb20odGhpcy5fX25hdGl2ZSldLmNvbmNhdChhcmdzKSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJldmVyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICAgIHZhciByZXZlcnNlZFNlcSA9IHRoaXMuX19yZXZlcnNlKCk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gcmV2ZXJzZWRTZXFbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgdGhpcy5hZGQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuaW9uKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBpdGVyYWJsZXMgPSBuZXcgQXJyYXkoX2xlbjUpLCBfa2V5NSA9IDA7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICAgICAgaXRlcmFibGVzW19rZXk1XSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBTZXF1aW5zU2V0LnVuaW9uLmFwcGx5KFNlcXVpbnNTZXQsIFt0aGlzXS5jb25jYXQoaXRlcmFibGVzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludGVyc2VjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnNlY3QoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZXJhYmxlcyA9IG5ldyBBcnJheShfbGVuNiksIF9rZXk2ID0gMDsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgICAgICBpdGVyYWJsZXNbX2tleTZdID0gYXJndW1lbnRzW19rZXk2XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFNlcXVpbnNTZXQuaW50ZXJzZWN0LmFwcGx5KFNlcXVpbnNTZXQsIFt0aGlzXS5jb25jYXQoaXRlcmFibGVzKSk7XG4gICAgfSAvLyBDb252ZXJzaW9uc1xuXG4gIH0sIHtcbiAgICBrZXk6IFN5bWJvbC5zcGVjaWVzLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiBTZXF1aW5zU2V0O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU2VxdWluc1NldDtcbn0oRHVwbGljYXRlZE1peGluKENvbmNyZXRlQ29sbGVjdGlvbikpO1xuXG52YXIgU2V0JDEgPSBOYW1lc3BhY2UkMy5fX3JlZ2lzdGVyKCdEdXBsaWNhdGVkJywgU2VxdWluc1NldCk7XG5cbmV4cG9ydHMuU2V0ID0gU2V0JDE7XG5cbnZhciBJbmRleGVkU2VxdWVuY2UgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9JbmRleGVkTWl4aW4pIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoSW5kZXhlZFNlcXVlbmNlLCBfSW5kZXhlZE1peGluKTtcbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoSW5kZXhlZFNlcXVlbmNlLCBudWxsLCBbe1xuICAgIGtleTogXCJvZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvZigpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIHZhbHVlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBJbmRleGVkU2VxdWVuY2UodmFsdWVzKTtcbiAgICB9XG4gIH1dKTtcblxuICBmdW5jdGlvbiBJbmRleGVkU2VxdWVuY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBJbmRleGVkU2VxdWVuY2UpO1xuICAgIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShJbmRleGVkU2VxdWVuY2UpLmNhbGwodGhpcywgaXRlcmFibGUpKTtcblxuICAgIGlmIChpc0tleWVkKF90aGlzLl9faXRlcmFibGUpKSB7XG4gICAgICBfdGhpcy5fX2NvbnN0cnVjdG9yVHJhbnNmb3JtID0gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZS52YWx1ZXMoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9IC8vIEl0ZXJhdG9yc1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoSW5kZXhlZFNlcXVlbmNlLCBbe1xuICAgIGtleTogXCJrZXlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtleXMkJDEoKSB7XG4gICAgICByZXR1cm4gbmV3IE5hbWVzcGFjZSQyLkR1cGxpY2F0ZWQoKDAsIF9tYXAyLmRlZmF1bHQpKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfSwgdGhpcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgcmV0dXJuIG5ldyBOYW1lc3BhY2UkMi5EdXBsaWNhdGVkKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbnRyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVudHJpZXMkJDEoKSB7XG4gICAgICByZXR1cm4gbmV3IE5hbWVzcGFjZSQyLkR1cGxpY2F0ZWQoKDAsIF9tYXAyLmRlZmF1bHQpKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgICByZXR1cm4gW2ksIHZhbHVlXTtcbiAgICAgIH0sIHRoaXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFN5bWJvbC5zcGVjaWVzLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiBJbmRleGVkU2VxdWVuY2U7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBJbmRleGVkU2VxdWVuY2U7XG59KEluZGV4ZWRNaXhpbihTZXF1ZW5jZSkpO1xuXG5leHBvcnRzLkluZGV4ZWRTZXF1ZW5jZSA9IEluZGV4ZWRTZXF1ZW5jZTtcblxuTmFtZXNwYWNlJDIuX19yZWdpc3RlcignSW5kZXhlZCcsIEluZGV4ZWRTZXF1ZW5jZSk7XG5cbnZhciBLZXllZFNlcXVlbmNlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfS2V5ZWRNaXhpbikge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShLZXllZFNlcXVlbmNlLCBfS2V5ZWRNaXhpbik7XG5cbiAgZnVuY3Rpb24gS2V5ZWRTZXF1ZW5jZShpdGVyYWJsZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEtleWVkU2VxdWVuY2UpO1xuICAgIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShLZXllZFNlcXVlbmNlKS5jYWxsKHRoaXMsIGl0ZXJhYmxlKSk7XG5cbiAgICBpZiAoaXNNdXRhYmxlQ29sbGVjdGlvbihfdGhpcy5fX2l0ZXJhYmxlKSAmJiAhaXNLZXllZChfdGhpcy5fX2l0ZXJhYmxlKSkge1xuICAgICAgX3RoaXMuX19jb25zdHJ1Y3RvclRyYW5zZm9ybSA9IGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gaXRlcmFibGUuZW50cmllcygpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmooX3RoaXMuX19pdGVyYWJsZSkpIHtcbiAgICAgIF90aGlzLl9fY29uc3RydWN0b3JUcmFuc2Zvcm0gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiAoMCwgX2VudHJpZXMuZGVmYXVsdCkob2JqKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9IC8vIEl0ZXJhdG9yc1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoS2V5ZWRTZXF1ZW5jZSwgW3tcbiAgICBrZXk6IFwia2V5c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBrZXlzJCQxKCkge1xuICAgICAgcmV0dXJuIG5ldyBOYW1lc3BhY2UkMi5EdXBsaWNhdGVkKCgwLCBfbWFwMi5kZWZhdWx0KShmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgX3JlZjIgPSAoMCwgX3NsaWNlZFRvQXJyYXkyLmRlZmF1bHQpKF9yZWYsIDIpLFxuICAgICAgICAgICAga2V5ID0gX3JlZjJbMF0sXG4gICAgICAgICAgICBfID0gX3JlZjJbMV07XG5cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgIH0sIHRoaXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgIHJldHVybiBuZXcgTmFtZXNwYWNlJDIuRHVwbGljYXRlZCgoMCwgX21hcDIuZGVmYXVsdCkoZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgIHZhciBfcmVmNCA9ICgwLCBfc2xpY2VkVG9BcnJheTIuZGVmYXVsdCkoX3JlZjMsIDIpLFxuICAgICAgICAgICAgXyA9IF9yZWY0WzBdLFxuICAgICAgICAgICAgdmFsdWUgPSBfcmVmNFsxXTtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9LCB0aGlzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVudHJpZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW50cmllcyQkMSgpIHtcbiAgICAgIHJldHVybiBuZXcgTmFtZXNwYWNlJDIuRHVwbGljYXRlZCgoMCwgX21hcDIuZGVmYXVsdCkoZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIF87XG4gICAgICB9LCB0aGlzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBTeW1ib2wuc3BlY2llcyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gS2V5ZWRTZXF1ZW5jZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEtleWVkU2VxdWVuY2U7XG59KEtleWVkTWl4aW4oU2VxdWVuY2UpKTtcblxuZXhwb3J0cy5LZXllZFNlcXVlbmNlID0gS2V5ZWRTZXF1ZW5jZTtcblxuTmFtZXNwYWNlJDIuX19yZWdpc3RlcignS2V5ZWQnLCBLZXllZFNlcXVlbmNlKTtcblxudmFyIFNldFNlcXVlbmNlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRHVwbGljYXRlZE1peGluKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKFNldFNlcXVlbmNlLCBfRHVwbGljYXRlZE1peGluKTtcbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoU2V0U2VxdWVuY2UsIG51bGwsIFt7XG4gICAga2V5OiBcIm9mXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9mKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbHVlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgdmFsdWVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFNldFNlcXVlbmNlKHZhbHVlcyk7XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gU2V0U2VxdWVuY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBTZXRTZXF1ZW5jZSk7XG4gICAgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKFNldFNlcXVlbmNlKS5jYWxsKHRoaXMsIGl0ZXJhYmxlKSk7XG5cbiAgICBpZiAoaXNLZXllZChfdGhpcy5fX2l0ZXJhYmxlKSkge1xuICAgICAgX3RoaXMuX19jb25zdHJ1Y3RvclRyYW5zZm9ybSA9IGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gaXRlcmFibGUudmFsdWVzKCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfSAvLyBJdGVyYXRvcnNcblxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFNldFNlcXVlbmNlLCBbe1xuICAgIGtleTogXCJrZXlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtleXMkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbnRyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVudHJpZXMkJDEoKSB7XG4gICAgICByZXR1cm4gbmV3IE5hbWVzcGFjZSQyLkR1cGxpY2F0ZWQoKDAsIF9tYXAyLmRlZmF1bHQpKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gW3ZhbHVlLCB2YWx1ZV07XG4gICAgICB9LCB0aGlzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBTeW1ib2wuc3BlY2llcyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gU2V0U2VxdWVuY2U7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTZXRTZXF1ZW5jZTtcbn0oRHVwbGljYXRlZE1peGluKFNlcXVlbmNlKSk7XG5cbmV4cG9ydHMuU2V0U2VxdWVuY2UgPSBTZXRTZXF1ZW5jZTtcblxuTmFtZXNwYWNlJDIuX19yZWdpc3RlcignRHVwbGljYXRlZCcsIFNldFNlcXVlbmNlKTtcblxudmFyIF9nbG9iYWwgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbDtcblxudmFyIE1hcCQyID0gX2dsb2JhbC5NYXA7XG5leHBvcnRzLk5hdGl2ZU1hcCA9IE1hcCQyO1xudmFyIFNldCQyID0gX2dsb2JhbC5TZXQ7XG5leHBvcnRzLk5hdGl2ZVNldCA9IFNldCQyO1xuXG5mdW5jdGlvbiBoYXMoc2hhcGUsIGtleSkge1xuICBpZiAoc2hhcGUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc01vZGVybkRhdGFTdHJ1Y3R1cmUoc2hhcGUpKSB7XG4gICAgcmV0dXJuIHNoYXBlLmhhcyhrZXkpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2hhcGUpKSB7XG4gICAgcmV0dXJuIGtleSA8IHNoYXBlLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2hhcGUsIGtleSk7XG59XG5cbmZ1bmN0aW9uIGdldChzaGFwZSwga2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHNoYXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNNb2Rlcm5EYXRhU3RydWN0dXJlKHNoYXBlKSkge1xuICAgIHJldHVybiBzaGFwZS5nZXQoa2V5LCBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuICFoYXMoc2hhcGUsIGtleSkgPyBkZWZhdWx0VmFsdWUgOiBzaGFwZVtrZXldO1xufVxuXG5mdW5jdGlvbiBzZXQoc2hhcGUsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGlzTXV0YWJsZUNvbGxlY3Rpb24oc2hhcGUpIHx8IGlzTmF0aXZlS2V5ZWQobWFwKSkge1xuICAgIHJldHVybiBzaGFwZS5zZXQoa2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNJbW11dGFibGUoc2hhcGUpKSB7XG4gICAgLy8gUmVhc29uaW5nOiBJbW11dGFibGUncyBzZXQgZG9lcyBub3QgaGF2ZSB0aGUgc2FtZSBjb250cmFjdCBhcyB0aGlzIGZ1bmN0aW9uOlxuICAgIC8vIGl0IHJlcXVpcmVzIHlvdSB0byB1c2UgdGhlIHJldHVybmVkIHJlZmVyZW5jZS5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTZXF1aW5zLnNldCBjYW5ub3Qgc2V0IG9uIEltbXV0YWJsZSBkYXRhIHN0cnVjdHVyZXMuJyk7XG4gIH0gZWxzZSBpZiAoaXNOYXRpdmVTZXQoc2hhcGUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2V0cyBkbyBub3Qgc3VwcG9ydCB0aGUgc2V0IG1ldGhvZC4nKTtcbiAgfVxuXG4gIHNoYXBlW2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIHNoYXBlO1xufVxuXG5mdW5jdGlvbiBrZXlzJDEoc2hhcGUpIHtcbiAgcmV0dXJuIG1ha2VGcm9tJDEoTmFtZXNwYWNlJDEsICdTZXF1ZW5jZScpKHNoYXBlKS5rZXlzKCk7XG59XG5cbmZ1bmN0aW9uIHZhbHVlcyhzaGFwZSkge1xuICByZXR1cm4gbWFrZUZyb20kMShOYW1lc3BhY2UkMSwgJ1NlcXVlbmNlJykoc2hhcGUpLnZhbHVlcygpO1xufVxuXG5mdW5jdGlvbiBlbnRyaWVzJDEoc2hhcGUpIHtcbiAgcmV0dXJuIG1ha2VGcm9tJDEoTmFtZXNwYWNlJDEsICdTZXF1ZW5jZScpKHNoYXBlKS5lbnRyaWVzKCk7XG59XG5cbmZ1bmN0aW9uIFJhbmdlKCkge1xuICB2YXIgc3RhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IEluZmluaXR5O1xuICB2YXIgc3RlcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgcmV0dXJuIG5ldyBJbmRleGVkU2VxdWVuY2UoKDAsIF9yYW5nZS5kZWZhdWx0KSh7XG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIHN0ZXA6IHN0ZXAsXG4gICAgZW5kOiBlbmRcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBSZXBlYXQodmFsdWUpIHtcbiAgdmFyIHRpbWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBJbmZpbml0eTtcbiAgcmV0dXJuIG5ldyBJbmRleGVkU2VxdWVuY2UoKDAsIF9yZXBlYXQuZGVmYXVsdCkodmFsdWUsIHRpbWVzKSk7XG59XG5cbmZ1bmN0aW9uIFNlcShpbml0aWFsKSB7XG4gIHZhciBzZXEgPSBTZXF1ZW5jZS5mcm9tKGluaXRpYWwpO1xuXG4gIGlmICghc2VxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGNyZWF0ZSBhIHNlcXVlbmNlIG91dCBvZiBcIi5jb25jYXQoaW5pdGlhbCwgXCIuXCIpKTtcbiAgfVxuXG4gIHJldHVybiBzZXE7XG59XG5cbmZ1bmN0aW9uIEluZGV4ZWRTZXF1ZW5jZUZhY3RvcnkoaXRlcmFibGUpIHtcbiAgcmV0dXJuIG5ldyBJbmRleGVkU2VxdWVuY2UoaXRlcmFibGUpO1xufVxuXG5PYmplY3QuYXNzaWduKEluZGV4ZWRTZXF1ZW5jZUZhY3RvcnksIEluZGV4ZWRTZXF1ZW5jZSk7XG5cbmZ1bmN0aW9uIEtleWVkU2VxdWVuY2VGYWN0b3J5KGl0ZXJhYmxlKSB7XG4gIHJldHVybiBuZXcgS2V5ZWRTZXF1ZW5jZShpdGVyYWJsZSk7XG59XG5cbk9iamVjdC5hc3NpZ24oS2V5ZWRTZXF1ZW5jZUZhY3RvcnksIEtleWVkU2VxdWVuY2UpO1xuXG5mdW5jdGlvbiBTZXRTZXF1ZW5jZUZhY3RvcnkoaXRlcmFibGUpIHtcbiAgcmV0dXJuIG5ldyBTZXRTZXF1ZW5jZShpdGVyYWJsZSk7XG59XG5cbk9iamVjdC5hc3NpZ24oU2V0U2VxdWVuY2VGYWN0b3J5LCBTZXRTZXF1ZW5jZSk7XG5TZXEuSW5kZXhlZCA9IEluZGV4ZWRTZXF1ZW5jZUZhY3Rvcnk7XG5TZXEuS2V5ZWQgPSBLZXllZFNlcXVlbmNlRmFjdG9yeTtcblNlcS5TZXQgPSBTZXRTZXF1ZW5jZUZhY3Rvcnk7XG52YXIgaW5kZXggPSB7XG4gIFNlcTogU2VxLFxuICBJbmRleGVkU2VxdWVuY2U6IEluZGV4ZWRTZXF1ZW5jZSxcbiAgS2V5ZWRTZXF1ZW5jZTogS2V5ZWRTZXF1ZW5jZSxcbiAgU2V0U2VxdWVuY2U6IFNldFNlcXVlbmNlLFxuICBMaXN0OiBMaXN0JDEsXG4gIE1hcDogTWFwJDEsXG4gIFNldDogU2V0JDEsXG4gIE5hdGl2ZU1hcDogTWFwJDIsXG4gIE5hdGl2ZVNldDogU2V0JDIsXG4gIGlzQ29sbGVjdGlvbjogaXNNdXRhYmxlQ29sbGVjdGlvbixcbiAgaXNLZXllZDogaXNNdXRhYmxlS2V5ZWQsXG4gIGlzSW5kZXhlZDogaXNNdXRhYmxlSW5kZXhlZCxcbiAgaXNBc3NvY2lhdGl2ZTogaXNNdXRhYmxlQXNzb2NpYXRpdmUsXG4gIGlzU2VxOiBpc011dGFibGVTZXEsXG4gIGlzTGlzdDogaXNNdXRhYmxlTGlzdCxcbiAgaXNNYXA6IGlzTXV0YWJsZU1hcCxcbiAgaXNTZXQ6IGlzTXV0YWJsZVNldCxcbiAgUmFuZ2U6IFJhbmdlLFxuICBSZXBlYXQ6IFJlcGVhdCxcbiAgZ2V0OiBnZXQsXG4gIHNldDogc2V0LFxuICBoYXM6IGhhcyxcbiAga2V5czoga2V5cyQxLFxuICB2YWx1ZXM6IHZhbHVlcyxcbiAgZW50cmllczogZW50cmllcyQxXG59O1xudmFyIF9kZWZhdWx0ID0gaW5kZXg7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2xcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvclwiKTsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjazsiLCJ2YXIgX09iamVjdCRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuXG4gICAgX09iamVjdCRkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7IiwiZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBkZWZhdWx0OiBvYmpcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0OyIsInZhciBfU3ltYm9sJGl0ZXJhdG9yID0gcmVxdWlyZShcIi4uL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yXCIpO1xuXG52YXIgX1N5bWJvbCA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbFwiKTtcblxuZnVuY3Rpb24gX3R5cGVvZjIob2JqKSB7IGlmICh0eXBlb2YgX1N5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBfU3ltYm9sJGl0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YyID0gZnVuY3Rpb24gX3R5cGVvZjIob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mMiA9IGZ1bmN0aW9uIF90eXBlb2YyKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBfU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfU3ltYm9sICYmIG9iaiAhPT0gX1N5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZjIob2JqKTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBpZiAodHlwZW9mIF9TeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mMihfU3ltYm9sJGl0ZXJhdG9yKSA9PT0gXCJzeW1ib2xcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gX3R5cGVvZjIob2JqKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBfU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfU3ltYm9sICYmIG9iaiAhPT0gX1N5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogX3R5cGVvZjIob2JqKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG4iLCJmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aEhvbGVzOyIsImZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnIyW2ldID0gYXJyW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBhcnIyO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aG91dEhvbGVzOyIsImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZDsiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NyZWF0ZUNsYXNzOyIsInZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL2dldFByb3RvdHlwZU9mXCIpO1xuXG52YXIgc3VwZXJQcm9wQmFzZSA9IHJlcXVpcmUoXCIuL3N1cGVyUHJvcEJhc2VcIik7XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBzdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0OyIsImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZjsiLCJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZlwiKTtcblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbmhlcml0czsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5OyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdDsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVSZXN0OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVNwcmVhZDsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIGFzc2VydFRoaXNJbml0aWFsaXplZCA9IHJlcXVpcmUoXCIuL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiKTtcblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjsiLCJmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZjsiLCJ2YXIgYXJyYXlXaXRoSG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5TGltaXRcIik7XG5cbnZhciBub25JdGVyYWJsZVJlc3QgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVJlc3RcIik7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zbGljZWRUb0FycmF5OyIsInZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL2dldFByb3RvdHlwZU9mXCIpO1xuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3N1cGVyUHJvcEJhc2U7IiwidmFyIGFycmF5V2l0aG91dEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRob3V0SG9sZXNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlU3ByZWFkXCIpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3RvQ29uc3VtYWJsZUFycmF5OyIsImZ1bmN0aW9uIF90eXBlb2YyKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZjIgPSBmdW5jdGlvbiBfdHlwZW9mMihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YyID0gZnVuY3Rpb24gX3R5cGVvZjIob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mMihvYmopOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgX3R5cGVvZjIoU3ltYm9sLml0ZXJhdG9yKSA9PT0gXCJzeW1ib2xcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gX3R5cGVvZjIob2JqKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogX3R5cGVvZjIob2JqKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mOyIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0geyBfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICE9IG51bGwgJiZcbiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3InKTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYykge1xuICByZXR1cm4gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbn07XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLlN5bWJvbDtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX3drcy1leHQnKS5mKCdpdGVyYXRvcicpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykge1xuICAgICAgaWYgKE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcbiIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcbiIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjYuMCcgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuIiwiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcmVzdWx0ID0gZ2V0S2V5cyhpdCk7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICBpZiAoZ2V0U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdCk7XG4gICAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChzeW1ib2xzLmxlbmd0aCA+IGkpIGlmIChpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciBJU19XUkFQID0gdHlwZSAmICRleHBvcnQuVztcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGtleSwgb3duLCBvdXQ7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG93biAmJiBoYXMoZXhwb3J0cywga2V5KSkgY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbiAoQykge1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEMpIHtcbiAgICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDKCk7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmIChJU19QUk9UTykge1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmICh0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKSBoaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcbiIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgdHlwZW9mIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge307XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHRydWU7XG4iLCJ2YXIgTUVUQSA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBzZXREZXNjID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBpZCA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIHNldERlc2MoaXQsIE1FVEEsIHsgdmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6IE1FVEEsXG4gIE5FRUQ6IGZhbHNlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrOiBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG4iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG4iLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uIChpdCkge1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcbiIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbiIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgdGFnLCBzdGF0KSB7XG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWcgfSk7XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246IGNvcmUudmVyc2lvbixcbiAgbW9kZTogcmVxdWlyZSgnLi9fbGlicmFyeScpID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTggRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG59KTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBwb3MpIHtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgICB2YXIgaSA9IHRvSW50ZWdlcihwb3MpO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gbCkgcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcbiIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG4iLCJ2YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYgKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpIGRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHsgdmFsdWU6IHdrc0V4dC5mKG5hbWUpIH0pO1xufTtcbiIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXQgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGl0ZXJGbiA9IGdldChpdCk7XG4gIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICByZXR1cm4gYW5PYmplY3QoaXRlckZuLmNhbGwoaXQpKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0JywgeyBkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZiB9KTtcbiIsIiIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBpbmRleCA9IHRoaXMuX2k7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IE8ubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7IHZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2UgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIE1FVEEgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZO1xudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciB3a3NEZWZpbmUgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJyk7XG52YXIgZW51bUtleXMgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBfY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGdPUE5FeHQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKTtcbnZhciAkR09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUEQgPSAkR09QRC5mO1xudmFyIGRQID0gJERQLmY7XG52YXIgZ09QTiA9IGdPUE5FeHQuZjtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkSlNPTiA9IGdsb2JhbC5KU09OO1xudmFyIF9zdHJpbmdpZnkgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7XG52YXIgVE9fUFJJTUlUSVZFID0gd2tzKCd0b1ByaW1pdGl2ZScpO1xudmFyIGlzRW51bSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT1BTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciBVU0VfTkFUSVZFID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKGl0LCBrZXksIEQpIHtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmIChwcm90b0Rlc2MpIGRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYgKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pIGRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZykge1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkge1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvKSAkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUQuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXMoaXQsIEhJRERFTikpIGRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSBpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHsgZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCkge1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGwgPiBpKSAkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKSB7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICBpdCA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZiAoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSBELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHZhciBuYW1lcyA9IGdPUE4odG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICB2YXIgSVNfT1AgPSBpdCA9PT0gT2JqZWN0UHJvdG87XG4gIHZhciBuYW1lcyA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSkgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8pICRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyAmJiBzZXR0ZXIpIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldCB9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZiAoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSkge1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgU3ltYm9sOiAkU3ltYm9sIH0pO1xuXG5mb3IgKHZhciBlczZTeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGogPSAwOyBlczZTeW1ib2xzLmxlbmd0aCA+IGo7KXdrcyhlczZTeW1ib2xzW2orK10pO1xuXG5mb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHdrc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICAgIGZvciAodmFyIGtleSBpbiBTeW1ib2xSZWdpc3RyeSkgaWYgKFN5bWJvbFJlZ2lzdHJ5W2tleV0gPT09IHN5bSkgcmV0dXJuIGtleTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHsgYTogUyB9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHtcbiAgICB2YXIgYXJncyA9IFtpdF07XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICAkcmVwbGFjZXIgPSByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYgKCFpc09iamVjdChyZXBsYWNlcikgJiYgaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpIHJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIGlmICghaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgJHJlcGxhY2VyID09ICdmdW5jdGlvbicpIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IHJlcXVpcmUoJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcbiIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpO1xuIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdvYnNlcnZhYmxlJyk7XG4iLCJyZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG52YXIgRE9NSXRlcmFibGVzID0gKCdDU1NSdWxlTGlzdCxDU1NTdHlsZURlY2xhcmF0aW9uLENTU1ZhbHVlTGlzdCxDbGllbnRSZWN0TGlzdCxET01SZWN0TGlzdCxET01TdHJpbmdMaXN0LCcgK1xuICAnRE9NVG9rZW5MaXN0LERhdGFUcmFuc2Zlckl0ZW1MaXN0LEZpbGVMaXN0LEhUTUxBbGxDb2xsZWN0aW9uLEhUTUxDb2xsZWN0aW9uLEhUTUxGb3JtRWxlbWVudCxIVE1MU2VsZWN0RWxlbWVudCwnICtcbiAgJ01lZGlhTGlzdCxNaW1lVHlwZUFycmF5LE5hbWVkTm9kZU1hcCxOb2RlTGlzdCxQYWludFJlcXVlc3RMaXN0LFBsdWdpbixQbHVnaW5BcnJheSxTVkdMZW5ndGhMaXN0LFNWR051bWJlckxpc3QsJyArXG4gICdTVkdQYXRoU2VnTGlzdCxTVkdQb2ludExpc3QsU1ZHU3RyaW5nTGlzdCxTVkdUcmFuc2Zvcm1MaXN0LFNvdXJjZUJ1ZmZlckxpc3QsU3R5bGVTaGVldExpc3QsVGV4dFRyYWNrQ3VlTGlzdCwnICtcbiAgJ1RleHRUcmFja0xpc3QsVG91Y2hMaXN0Jykuc3BsaXQoJywnKTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCBET01JdGVyYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBET01JdGVyYWJsZXNbaV07XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgcHJvdG8gPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICBpZiAocHJvdG8gJiYgIXByb3RvW1RPX1NUUklOR19UQUddKSBoaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgSXRlcmF0b3JzW05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChmYWN0b3J5KChnbG9iYWwuSW1tdXRhYmxlID0ge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gVXNlZCBmb3Igc2V0dGluZyBwcm90b3R5cGUgbWV0aG9kcyB0aGF0IElFOCBjaG9rZXMgb24uXG4gIHZhciBERUxFVEUgPSAnZGVsZXRlJztcblxuICAvLyBDb25zdGFudHMgZGVzY3JpYmluZyB0aGUgc2l6ZSBvZiB0cmllIG5vZGVzLlxuICB2YXIgU0hJRlQgPSA1OyAvLyBSZXN1bHRlZCBpbiBiZXN0IHBlcmZvcm1hbmNlIGFmdGVyIF9fX19fXz9cbiAgdmFyIFNJWkUgPSAxIDw8IFNISUZUO1xuICB2YXIgTUFTSyA9IFNJWkUgLSAxO1xuXG4gIC8vIEEgY29uc2lzdGVudCBzaGFyZWQgdmFsdWUgcmVwcmVzZW50aW5nIFwibm90IHNldFwiIHdoaWNoIGVxdWFscyBub3RoaW5nIG90aGVyXG4gIC8vIHRoYW4gaXRzZWxmLCBhbmQgbm90aGluZyB0aGF0IGNvdWxkIGJlIHByb3ZpZGVkIGV4dGVybmFsbHkuXG4gIHZhciBOT1RfU0VUID0ge307XG5cbiAgLy8gQm9vbGVhbiByZWZlcmVuY2VzLCBSb3VnaCBlcXVpdmFsZW50IG9mIGBib29sICZgLlxuICBmdW5jdGlvbiBNYWtlUmVmKCkge1xuICAgIHJldHVybiB7IHZhbHVlOiBmYWxzZSB9O1xuICB9XG5cbiAgZnVuY3Rpb24gU2V0UmVmKHJlZikge1xuICAgIGlmIChyZWYpIHtcbiAgICAgIHJlZi52YWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gQSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgdmFsdWUgcmVwcmVzZW50aW5nIGFuIFwib3duZXJcIiBmb3IgdHJhbnNpZW50IHdyaXRlc1xuICAvLyB0byB0cmllcy4gVGhlIHJldHVybiB2YWx1ZSB3aWxsIG9ubHkgZXZlciBlcXVhbCBpdHNlbGYsIGFuZCB3aWxsIG5vdCBlcXVhbFxuICAvLyB0aGUgcmV0dXJuIG9mIGFueSBzdWJzZXF1ZW50IGNhbGwgb2YgdGhpcyBmdW5jdGlvbi5cbiAgZnVuY3Rpb24gT3duZXJJRCgpIHt9XG5cbiAgZnVuY3Rpb24gZW5zdXJlU2l6ZShpdGVyKSB7XG4gICAgaWYgKGl0ZXIuc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpdGVyLnNpemUgPSBpdGVyLl9faXRlcmF0ZShyZXR1cm5UcnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZXIuc2l6ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBJbmRleChpdGVyLCBpbmRleCkge1xuICAgIC8vIFRoaXMgaW1wbGVtZW50cyBcImlzIGFycmF5IGluZGV4XCIgd2hpY2ggdGhlIEVDTUFTdHJpbmcgc3BlYyBkZWZpbmVzIGFzOlxuICAgIC8vXG4gICAgLy8gICAgIEEgU3RyaW5nIHByb3BlcnR5IG5hbWUgUCBpcyBhbiBhcnJheSBpbmRleCBpZiBhbmQgb25seSBpZlxuICAgIC8vICAgICBUb1N0cmluZyhUb1VpbnQzMihQKSkgaXMgZXF1YWwgdG8gUCBhbmQgVG9VaW50MzIoUCkgaXMgbm90IGVxdWFsXG4gICAgLy8gICAgIHRvIDJeMzLiiJIxLlxuICAgIC8vXG4gICAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWFycmF5LWV4b3RpYy1vYmplY3RzXG4gICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHZhciB1aW50MzJJbmRleCA9IGluZGV4ID4+PiAwOyAvLyBOID4+PiAwIGlzIHNob3J0aGFuZCBmb3IgVG9VaW50MzJcbiAgICAgIGlmICgnJyArIHVpbnQzMkluZGV4ICE9PSBpbmRleCB8fCB1aW50MzJJbmRleCA9PT0gNDI5NDk2NzI5NSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfVxuICAgICAgaW5kZXggPSB1aW50MzJJbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4IDwgMCA/IGVuc3VyZVNpemUoaXRlcikgKyBpbmRleCA6IGluZGV4O1xuICB9XG5cbiAgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgc2l6ZSkge1xuICAgIHJldHVybiAoXG4gICAgICAoKGJlZ2luID09PSAwICYmICFpc05lZyhiZWdpbikpIHx8XG4gICAgICAgIChzaXplICE9PSB1bmRlZmluZWQgJiYgYmVnaW4gPD0gLXNpemUpKSAmJlxuICAgICAgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IChzaXplICE9PSB1bmRlZmluZWQgJiYgZW5kID49IHNpemUpKVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlQmVnaW4oYmVnaW4sIHNpemUpIHtcbiAgICByZXR1cm4gcmVzb2x2ZUluZGV4KGJlZ2luLCBzaXplLCAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVFbmQoZW5kLCBzaXplKSB7XG4gICAgcmV0dXJuIHJlc29sdmVJbmRleChlbmQsIHNpemUsIHNpemUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUluZGV4KGluZGV4LCBzaXplLCBkZWZhdWx0SW5kZXgpIHtcbiAgICAvLyBTYW5pdGl6ZSBpbmRpY2VzIHVzaW5nIHRoaXMgc2hvcnRoYW5kIGZvciBUb0ludDMyKGFyZ3VtZW50KVxuICAgIC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2ludDMyXG4gICAgcmV0dXJuIGluZGV4ID09PSB1bmRlZmluZWRcbiAgICAgID8gZGVmYXVsdEluZGV4XG4gICAgICA6IGlzTmVnKGluZGV4KVxuICAgICAgICA/IHNpemUgPT09IEluZmluaXR5XG4gICAgICAgICAgPyBzaXplXG4gICAgICAgICAgOiBNYXRoLm1heCgwLCBzaXplICsgaW5kZXgpIHwgMFxuICAgICAgICA6IHNpemUgPT09IHVuZGVmaW5lZCB8fCBzaXplID09PSBpbmRleFxuICAgICAgICAgID8gaW5kZXhcbiAgICAgICAgICA6IE1hdGgubWluKHNpemUsIGluZGV4KSB8IDA7XG4gIH1cblxuICBmdW5jdGlvbiBpc05lZyh2YWx1ZSkge1xuICAgIC8vIEFjY291bnQgZm9yIC0wIHdoaWNoIGlzIG5lZ2F0aXZlLCBidXQgbm90IGxlc3MgdGhhbiAwLlxuICAgIHJldHVybiB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA9PT0gLUluZmluaXR5KTtcbiAgfVxuXG4gIC8vIE5vdGU6IHZhbHVlIGlzIHVuY2hhbmdlZCB0byBub3QgYnJlYWsgaW1tdXRhYmxlLWRldnRvb2xzLlxuICB2YXIgSVNfQ09MTEVDVElPTl9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9JVEVSQUJMRV9fQEAnO1xuXG4gIGZ1bmN0aW9uIGlzQ29sbGVjdGlvbihtYXliZUNvbGxlY3Rpb24pIHtcbiAgICByZXR1cm4gQm9vbGVhbihtYXliZUNvbGxlY3Rpb24gJiYgbWF5YmVDb2xsZWN0aW9uW0lTX0NPTExFQ1RJT05fU1lNQk9MXSk7XG4gIH1cblxuICB2YXIgSVNfS0VZRURfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfS0VZRURfX0BAJztcblxuICBmdW5jdGlvbiBpc0tleWVkKG1heWJlS2V5ZWQpIHtcbiAgICByZXR1cm4gQm9vbGVhbihtYXliZUtleWVkICYmIG1heWJlS2V5ZWRbSVNfS0VZRURfU1lNQk9MXSk7XG4gIH1cblxuICB2YXIgSVNfSU5ERVhFRF9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9JTkRFWEVEX19AQCc7XG5cbiAgZnVuY3Rpb24gaXNJbmRleGVkKG1heWJlSW5kZXhlZCkge1xuICAgIHJldHVybiBCb29sZWFuKG1heWJlSW5kZXhlZCAmJiBtYXliZUluZGV4ZWRbSVNfSU5ERVhFRF9TWU1CT0xdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQXNzb2NpYXRpdmUobWF5YmVBc3NvY2lhdGl2ZSkge1xuICAgIHJldHVybiBpc0tleWVkKG1heWJlQXNzb2NpYXRpdmUpIHx8IGlzSW5kZXhlZChtYXliZUFzc29jaWF0aXZlKTtcbiAgfVxuXG4gIHZhciBDb2xsZWN0aW9uID0gZnVuY3Rpb24gQ29sbGVjdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBpc0NvbGxlY3Rpb24odmFsdWUpID8gdmFsdWUgOiBTZXEodmFsdWUpO1xuICB9O1xuXG4gIHZhciBLZXllZENvbGxlY3Rpb24gPSAoZnVuY3Rpb24gKENvbGxlY3Rpb24pIHtcbiAgICBmdW5jdGlvbiBLZXllZENvbGxlY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0tleWVkKHZhbHVlKSA/IHZhbHVlIDogS2V5ZWRTZXEodmFsdWUpO1xuICAgIH1cblxuICAgIGlmICggQ29sbGVjdGlvbiApIEtleWVkQ29sbGVjdGlvbi5fX3Byb3RvX18gPSBDb2xsZWN0aW9uO1xuICAgIEtleWVkQ29sbGVjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlICk7XG4gICAgS2V5ZWRDb2xsZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtleWVkQ29sbGVjdGlvbjtcblxuICAgIHJldHVybiBLZXllZENvbGxlY3Rpb247XG4gIH0oQ29sbGVjdGlvbikpO1xuXG4gIHZhciBJbmRleGVkQ29sbGVjdGlvbiA9IChmdW5jdGlvbiAoQ29sbGVjdGlvbikge1xuICAgIGZ1bmN0aW9uIEluZGV4ZWRDb2xsZWN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNJbmRleGVkKHZhbHVlKSA/IHZhbHVlIDogSW5kZXhlZFNlcSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKCBDb2xsZWN0aW9uICkgSW5kZXhlZENvbGxlY3Rpb24uX19wcm90b19fID0gQ29sbGVjdGlvbjtcbiAgICBJbmRleGVkQ29sbGVjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlICk7XG4gICAgSW5kZXhlZENvbGxlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW5kZXhlZENvbGxlY3Rpb247XG5cbiAgICByZXR1cm4gSW5kZXhlZENvbGxlY3Rpb247XG4gIH0oQ29sbGVjdGlvbikpO1xuXG4gIHZhciBTZXRDb2xsZWN0aW9uID0gKGZ1bmN0aW9uIChDb2xsZWN0aW9uKSB7XG4gICAgZnVuY3Rpb24gU2V0Q29sbGVjdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQ29sbGVjdGlvbih2YWx1ZSkgJiYgIWlzQXNzb2NpYXRpdmUodmFsdWUpID8gdmFsdWUgOiBTZXRTZXEodmFsdWUpO1xuICAgIH1cblxuICAgIGlmICggQ29sbGVjdGlvbiApIFNldENvbGxlY3Rpb24uX19wcm90b19fID0gQ29sbGVjdGlvbjtcbiAgICBTZXRDb2xsZWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGUgKTtcbiAgICBTZXRDb2xsZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNldENvbGxlY3Rpb247XG5cbiAgICByZXR1cm4gU2V0Q29sbGVjdGlvbjtcbiAgfShDb2xsZWN0aW9uKSk7XG5cbiAgQ29sbGVjdGlvbi5LZXllZCA9IEtleWVkQ29sbGVjdGlvbjtcbiAgQ29sbGVjdGlvbi5JbmRleGVkID0gSW5kZXhlZENvbGxlY3Rpb247XG4gIENvbGxlY3Rpb24uU2V0ID0gU2V0Q29sbGVjdGlvbjtcblxuICB2YXIgSVNfU0VRX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX1NFUV9fQEAnO1xuXG4gIGZ1bmN0aW9uIGlzU2VxKG1heWJlU2VxKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4obWF5YmVTZXEgJiYgbWF5YmVTZXFbSVNfU0VRX1NZTUJPTF0pO1xuICB9XG5cbiAgdmFyIElTX1JFQ09SRF9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9SRUNPUkRfX0BAJztcblxuICBmdW5jdGlvbiBpc1JlY29yZChtYXliZVJlY29yZCkge1xuICAgIHJldHVybiBCb29sZWFuKG1heWJlUmVjb3JkICYmIG1heWJlUmVjb3JkW0lTX1JFQ09SRF9TWU1CT0xdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSW1tdXRhYmxlKG1heWJlSW1tdXRhYmxlKSB7XG4gICAgcmV0dXJuIGlzQ29sbGVjdGlvbihtYXliZUltbXV0YWJsZSkgfHwgaXNSZWNvcmQobWF5YmVJbW11dGFibGUpO1xuICB9XG5cbiAgdmFyIElTX09SREVSRURfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfT1JERVJFRF9fQEAnO1xuXG4gIGZ1bmN0aW9uIGlzT3JkZXJlZChtYXliZU9yZGVyZWQpIHtcbiAgICByZXR1cm4gQm9vbGVhbihtYXliZU9yZGVyZWQgJiYgbWF5YmVPcmRlcmVkW0lTX09SREVSRURfU1lNQk9MXSk7XG4gIH1cblxuICB2YXIgSVRFUkFURV9LRVlTID0gMDtcbiAgdmFyIElURVJBVEVfVkFMVUVTID0gMTtcbiAgdmFyIElURVJBVEVfRU5UUklFUyA9IDI7XG5cbiAgdmFyIFJFQUxfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcblxuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gUkVBTF9JVEVSQVRPUl9TWU1CT0wgfHwgRkFVWF9JVEVSQVRPUl9TWU1CT0w7XG5cbiAgdmFyIEl0ZXJhdG9yID0gZnVuY3Rpb24gSXRlcmF0b3IobmV4dCkge1xuICAgIHRoaXMubmV4dCA9IG5leHQ7XG4gIH07XG5cbiAgSXRlcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiAnW0l0ZXJhdG9yXSc7XG4gIH07XG5cbiAgSXRlcmF0b3IuS0VZUyA9IElURVJBVEVfS0VZUztcbiAgSXRlcmF0b3IuVkFMVUVTID0gSVRFUkFURV9WQUxVRVM7XG4gIEl0ZXJhdG9yLkVOVFJJRVMgPSBJVEVSQVRFX0VOVFJJRVM7XG5cbiAgSXRlcmF0b3IucHJvdG90eXBlLmluc3BlY3QgPSBJdGVyYXRvci5wcm90b3R5cGUudG9Tb3VyY2UgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuICBJdGVyYXRvci5wcm90b3R5cGVbSVRFUkFUT1JfU1lNQk9MXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGl0ZXJhdG9yVmFsdWUodHlwZSwgaywgdiwgaXRlcmF0b3JSZXN1bHQpIHtcbiAgICB2YXIgdmFsdWUgPSB0eXBlID09PSAwID8gayA6IHR5cGUgPT09IDEgPyB2IDogW2ssIHZdO1xuICAgIGl0ZXJhdG9yUmVzdWx0XG4gICAgICA/IChpdGVyYXRvclJlc3VsdC52YWx1ZSA9IHZhbHVlKVxuICAgICAgOiAoaXRlcmF0b3JSZXN1bHQgPSB7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0b3JSZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBpdGVyYXRvckRvbmUoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzSXRlcmF0b3IobWF5YmVJdGVyYWJsZSkge1xuICAgIHJldHVybiAhIWdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0l0ZXJhdG9yKG1heWJlSXRlcmF0b3IpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvciAmJiB0eXBlb2YgbWF5YmVJdGVyYXRvci5uZXh0ID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3IoaXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oaXRlcmFibGUpO1xuICAgIHJldHVybiBpdGVyYXRvckZuICYmIGl0ZXJhdG9yRm4uY2FsbChpdGVyYWJsZSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKGl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPVxuICAgICAgaXRlcmFibGUgJiZcbiAgICAgICgoUkVBTF9JVEVSQVRPUl9TWU1CT0wgJiYgaXRlcmFibGVbUkVBTF9JVEVSQVRPUl9TWU1CT0xdKSB8fFxuICAgICAgICBpdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgdmFsdWUgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIE51bWJlci5pc0ludGVnZXIodmFsdWUubGVuZ3RoKSAmJlxuICAgICAgdmFsdWUubGVuZ3RoID49IDAgJiZcbiAgICAgICh2YWx1ZS5sZW5ndGggPT09IDBcbiAgICAgICAgPyAvLyBPbmx5IHtsZW5ndGg6IDB9IGlzIGNvbnNpZGVyZWQgQXJyYXktbGlrZS5cbiAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAxXG4gICAgICAgIDogLy8gQW4gb2JqZWN0IGlzIG9ubHkgQXJyYXktbGlrZSBpZiBpdCBoYXMgYSBwcm9wZXJ0eSB3aGVyZSB0aGUgbGFzdCB2YWx1ZVxuICAgICAgICAgIC8vIGluIHRoZSBhcnJheS1saWtlIG1heSBiZSBmb3VuZCAod2hpY2ggY291bGQgYmUgdW5kZWZpbmVkKS5cbiAgICAgICAgICB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZS5sZW5ndGggLSAxKSlcbiAgICApO1xuICB9XG5cbiAgdmFyIFNlcSA9IChmdW5jdGlvbiAoQ29sbGVjdGlvbiQkMSkge1xuICAgIGZ1bmN0aW9uIFNlcSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBlbXB0eVNlcXVlbmNlKClcbiAgICAgICAgOiBpc0ltbXV0YWJsZSh2YWx1ZSlcbiAgICAgICAgICA/IHZhbHVlLnRvU2VxKClcbiAgICAgICAgICA6IHNlcUZyb21WYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKCBDb2xsZWN0aW9uJCQxICkgU2VxLl9fcHJvdG9fXyA9IENvbGxlY3Rpb24kJDE7XG4gICAgU2VxLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENvbGxlY3Rpb24kJDEgJiYgQ29sbGVjdGlvbiQkMS5wcm90b3R5cGUgKTtcbiAgICBTZXEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2VxO1xuXG4gICAgU2VxLnByb3RvdHlwZS50b1NlcSA9IGZ1bmN0aW9uIHRvU2VxICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBTZXEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnU2VxIHsnLCAnfScpO1xuICAgIH07XG5cbiAgICBTZXEucHJvdG90eXBlLmNhY2hlUmVzdWx0ID0gZnVuY3Rpb24gY2FjaGVSZXN1bHQgKCkge1xuICAgICAgaWYgKCF0aGlzLl9jYWNoZSAmJiB0aGlzLl9faXRlcmF0ZVVuY2FjaGVkKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlID0gdGhpcy5lbnRyeVNlcSgpLnRvQXJyYXkoKTtcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5fY2FjaGUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8vIGFic3RyYWN0IF9faXRlcmF0ZVVuY2FjaGVkKGZuLCByZXZlcnNlKVxuXG4gICAgU2VxLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdmFyIGNhY2hlID0gdGhpcy5fY2FjaGU7XG4gICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgdmFyIHNpemUgPSBjYWNoZS5sZW5ndGg7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgIT09IHNpemUpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBjYWNoZVtyZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrK107XG4gICAgICAgICAgaWYgKGZuKGVudHJ5WzFdLCBlbnRyeVswXSwgdGhpcyQxKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9faXRlcmF0ZVVuY2FjaGVkKGZuLCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgLy8gYWJzdHJhY3QgX19pdGVyYXRvclVuY2FjaGVkKHR5cGUsIHJldmVyc2UpXG5cbiAgICBTZXEucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgY2FjaGUgPSB0aGlzLl9jYWNoZTtcbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICB2YXIgc2l6ZSA9IGNhY2hlLmxlbmd0aDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZW50cnkgPSBjYWNoZVtyZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrK107XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdG9yVW5jYWNoZWQodHlwZSwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXE7XG4gIH0oQ29sbGVjdGlvbikpO1xuXG4gIHZhciBLZXllZFNlcSA9IChmdW5jdGlvbiAoU2VxKSB7XG4gICAgZnVuY3Rpb24gS2V5ZWRTZXEodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gZW1wdHlTZXF1ZW5jZSgpLnRvS2V5ZWRTZXEoKVxuICAgICAgICA6IGlzQ29sbGVjdGlvbih2YWx1ZSlcbiAgICAgICAgICA/IGlzS2V5ZWQodmFsdWUpXG4gICAgICAgICAgICA/IHZhbHVlLnRvU2VxKClcbiAgICAgICAgICAgIDogdmFsdWUuZnJvbUVudHJ5U2VxKClcbiAgICAgICAgICA6IGlzUmVjb3JkKHZhbHVlKVxuICAgICAgICAgICAgPyB2YWx1ZS50b1NlcSgpXG4gICAgICAgICAgICA6IGtleWVkU2VxRnJvbVZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoIFNlcSApIEtleWVkU2VxLl9fcHJvdG9fXyA9IFNlcTtcbiAgICBLZXllZFNlcS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTZXEgJiYgU2VxLnByb3RvdHlwZSApO1xuICAgIEtleWVkU2VxLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtleWVkU2VxO1xuXG4gICAgS2V5ZWRTZXEucHJvdG90eXBlLnRvS2V5ZWRTZXEgPSBmdW5jdGlvbiB0b0tleWVkU2VxICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICByZXR1cm4gS2V5ZWRTZXE7XG4gIH0oU2VxKSk7XG5cbiAgdmFyIEluZGV4ZWRTZXEgPSAoZnVuY3Rpb24gKFNlcSkge1xuICAgIGZ1bmN0aW9uIEluZGV4ZWRTZXEodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gZW1wdHlTZXF1ZW5jZSgpXG4gICAgICAgIDogaXNDb2xsZWN0aW9uKHZhbHVlKVxuICAgICAgICAgID8gaXNLZXllZCh2YWx1ZSlcbiAgICAgICAgICAgID8gdmFsdWUuZW50cnlTZXEoKVxuICAgICAgICAgICAgOiB2YWx1ZS50b0luZGV4ZWRTZXEoKVxuICAgICAgICAgIDogaXNSZWNvcmQodmFsdWUpXG4gICAgICAgICAgICA/IHZhbHVlLnRvU2VxKCkuZW50cnlTZXEoKVxuICAgICAgICAgICAgOiBpbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoIFNlcSApIEluZGV4ZWRTZXEuX19wcm90b19fID0gU2VxO1xuICAgIEluZGV4ZWRTZXEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2VxICYmIFNlcS5wcm90b3R5cGUgKTtcbiAgICBJbmRleGVkU2VxLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEluZGV4ZWRTZXE7XG5cbiAgICBJbmRleGVkU2VxLm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiBJbmRleGVkU2VxKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIEluZGV4ZWRTZXEucHJvdG90eXBlLnRvSW5kZXhlZFNlcSA9IGZ1bmN0aW9uIHRvSW5kZXhlZFNlcSAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgSW5kZXhlZFNlcS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdTZXEgWycsICddJyk7XG4gICAgfTtcblxuICAgIHJldHVybiBJbmRleGVkU2VxO1xuICB9KFNlcSkpO1xuXG4gIHZhciBTZXRTZXEgPSAoZnVuY3Rpb24gKFNlcSkge1xuICAgIGZ1bmN0aW9uIFNldFNlcSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIChpc0NvbGxlY3Rpb24odmFsdWUpICYmICFpc0Fzc29jaWF0aXZlKHZhbHVlKVxuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogSW5kZXhlZFNlcSh2YWx1ZSlcbiAgICAgICkudG9TZXRTZXEoKTtcbiAgICB9XG5cbiAgICBpZiAoIFNlcSApIFNldFNlcS5fX3Byb3RvX18gPSBTZXE7XG4gICAgU2V0U2VxLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNlcSAmJiBTZXEucHJvdG90eXBlICk7XG4gICAgU2V0U2VxLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNldFNlcTtcblxuICAgIFNldFNlcS5vZiA9IGZ1bmN0aW9uIG9mICgvKi4uLnZhbHVlcyovKSB7XG4gICAgICByZXR1cm4gU2V0U2VxKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIFNldFNlcS5wcm90b3R5cGUudG9TZXRTZXEgPSBmdW5jdGlvbiB0b1NldFNlcSAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldFNlcTtcbiAgfShTZXEpKTtcblxuICBTZXEuaXNTZXEgPSBpc1NlcTtcbiAgU2VxLktleWVkID0gS2V5ZWRTZXE7XG4gIFNlcS5TZXQgPSBTZXRTZXE7XG4gIFNlcS5JbmRleGVkID0gSW5kZXhlZFNlcTtcblxuICBTZXEucHJvdG90eXBlW0lTX1NFUV9TWU1CT0xdID0gdHJ1ZTtcblxuICAvLyAjcHJhZ21hIFJvb3QgU2VxdWVuY2VzXG5cbiAgdmFyIEFycmF5U2VxID0gKGZ1bmN0aW9uIChJbmRleGVkU2VxKSB7XG4gICAgZnVuY3Rpb24gQXJyYXlTZXEoYXJyYXkpIHtcbiAgICAgIHRoaXMuX2FycmF5ID0gYXJyYXk7XG4gICAgICB0aGlzLnNpemUgPSBhcnJheS5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKCBJbmRleGVkU2VxICkgQXJyYXlTZXEuX19wcm90b19fID0gSW5kZXhlZFNlcTtcbiAgICBBcnJheVNlcS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkU2VxICYmIEluZGV4ZWRTZXEucHJvdG90eXBlICk7XG4gICAgQXJyYXlTZXEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXJyYXlTZXE7XG5cbiAgICBBcnJheVNlcS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhpbmRleCkgPyB0aGlzLl9hcnJheVt3cmFwSW5kZXgodGhpcywgaW5kZXgpXSA6IG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICBBcnJheVNlcS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHZhciBhcnJheSA9IHRoaXMuX2FycmF5O1xuICAgICAgdmFyIHNpemUgPSBhcnJheS5sZW5ndGg7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAoaSAhPT0gc2l6ZSkge1xuICAgICAgICB2YXIgaWkgPSByZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrKztcbiAgICAgICAgaWYgKGZuKGFycmF5W2lpXSwgaWksIHRoaXMkMSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpO1xuICAgIH07XG5cbiAgICBBcnJheVNlcS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuX2FycmF5O1xuICAgICAgdmFyIHNpemUgPSBhcnJheS5sZW5ndGg7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGkgPT09IHNpemUpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlpID0gcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKys7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGlpLCBhcnJheVtpaV0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBBcnJheVNlcTtcbiAgfShJbmRleGVkU2VxKSk7XG5cbiAgdmFyIE9iamVjdFNlcSA9IChmdW5jdGlvbiAoS2V5ZWRTZXEpIHtcbiAgICBmdW5jdGlvbiBPYmplY3RTZXEob2JqZWN0KSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgICB0aGlzLl9vYmplY3QgPSBvYmplY3Q7XG4gICAgICB0aGlzLl9rZXlzID0ga2V5cztcbiAgICAgIHRoaXMuc2l6ZSA9IGtleXMubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmICggS2V5ZWRTZXEgKSBPYmplY3RTZXEuX19wcm90b19fID0gS2V5ZWRTZXE7XG4gICAgT2JqZWN0U2VxLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEtleWVkU2VxICYmIEtleWVkU2VxLnByb3RvdHlwZSApO1xuICAgIE9iamVjdFNlcS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPYmplY3RTZXE7XG5cbiAgICBPYmplY3RTZXEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoa2V5LCBub3RTZXRWYWx1ZSkge1xuICAgICAgaWYgKG5vdFNldFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIXRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX29iamVjdFtrZXldO1xuICAgIH07XG5cbiAgICBPYmplY3RTZXEucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9vYmplY3QsIGtleSk7XG4gICAgfTtcblxuICAgIE9iamVjdFNlcS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHZhciBvYmplY3QgPSB0aGlzLl9vYmplY3Q7XG4gICAgICB2YXIga2V5cyA9IHRoaXMuX2tleXM7XG4gICAgICB2YXIgc2l6ZSA9IGtleXMubGVuZ3RoO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUgKGkgIT09IHNpemUpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKytdO1xuICAgICAgICBpZiAoZm4ob2JqZWN0W2tleV0sIGtleSwgdGhpcyQxKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGk7XG4gICAgfTtcblxuICAgIE9iamVjdFNlcS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBvYmplY3QgPSB0aGlzLl9vYmplY3Q7XG4gICAgICB2YXIga2V5cyA9IHRoaXMuX2tleXM7XG4gICAgICB2YXIgc2l6ZSA9IGtleXMubGVuZ3RoO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpID09PSBzaXplKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW3JldmVyc2UgPyBzaXplIC0gKytpIDogaSsrXTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwga2V5LCBvYmplY3Rba2V5XSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE9iamVjdFNlcTtcbiAgfShLZXllZFNlcSkpO1xuICBPYmplY3RTZXEucHJvdG90eXBlW0lTX09SREVSRURfU1lNQk9MXSA9IHRydWU7XG5cbiAgdmFyIENvbGxlY3Rpb25TZXEgPSAoZnVuY3Rpb24gKEluZGV4ZWRTZXEpIHtcbiAgICBmdW5jdGlvbiBDb2xsZWN0aW9uU2VxKGNvbGxlY3Rpb24pIHtcbiAgICAgIHRoaXMuX2NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgICAgdGhpcy5zaXplID0gY29sbGVjdGlvbi5sZW5ndGggfHwgY29sbGVjdGlvbi5zaXplO1xuICAgIH1cblxuICAgIGlmICggSW5kZXhlZFNlcSApIENvbGxlY3Rpb25TZXEuX19wcm90b19fID0gSW5kZXhlZFNlcTtcbiAgICBDb2xsZWN0aW9uU2VxLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEluZGV4ZWRTZXEgJiYgSW5kZXhlZFNlcS5wcm90b3R5cGUgKTtcbiAgICBDb2xsZWN0aW9uU2VxLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbGxlY3Rpb25TZXE7XG5cbiAgICBDb2xsZWN0aW9uU2VxLnByb3RvdHlwZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIF9faXRlcmF0ZVVuY2FjaGVkIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcy5fY29sbGVjdGlvbjtcbiAgICAgIHZhciBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGNvbGxlY3Rpb24pO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgaWYgKGlzSXRlcmF0b3IoaXRlcmF0b3IpKSB7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGZuKHN0ZXAudmFsdWUsIGl0ZXJhdGlvbnMrKywgdGhpcyQxKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcblxuICAgIENvbGxlY3Rpb25TZXEucHJvdG90eXBlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uIF9faXRlcmF0b3JVbmNhY2hlZCAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLl9jb2xsZWN0aW9uO1xuICAgICAgdmFyIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoY29sbGVjdGlvbik7XG4gICAgICBpZiAoIWlzSXRlcmF0b3IoaXRlcmF0b3IpKSB7XG4gICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoaXRlcmF0b3JEb25lKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHN0ZXAuZG9uZSA/IHN0ZXAgOiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgc3RlcC52YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENvbGxlY3Rpb25TZXE7XG4gIH0oSW5kZXhlZFNlcSkpO1xuXG4gIC8vICMgcHJhZ21hIEhlbHBlciBmdW5jdGlvbnNcblxuICB2YXIgRU1QVFlfU0VRO1xuXG4gIGZ1bmN0aW9uIGVtcHR5U2VxdWVuY2UoKSB7XG4gICAgcmV0dXJuIEVNUFRZX1NFUSB8fCAoRU1QVFlfU0VRID0gbmV3IEFycmF5U2VxKFtdKSk7XG4gIH1cblxuICBmdW5jdGlvbiBrZXllZFNlcUZyb21WYWx1ZSh2YWx1ZSkge1xuICAgIHZhciBzZXEgPSBBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgICAgPyBuZXcgQXJyYXlTZXEodmFsdWUpXG4gICAgICA6IGhhc0l0ZXJhdG9yKHZhbHVlKVxuICAgICAgICA/IG5ldyBDb2xsZWN0aW9uU2VxKHZhbHVlKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBpZiAoc2VxKSB7XG4gICAgICByZXR1cm4gc2VxLmZyb21FbnRyeVNlcSgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIG5ldyBPYmplY3RTZXEodmFsdWUpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ0V4cGVjdGVkIEFycmF5IG9yIGNvbGxlY3Rpb24gb2JqZWN0IG9mIFtrLCB2XSBlbnRyaWVzLCBvciBrZXllZCBvYmplY3Q6ICcgK1xuICAgICAgICB2YWx1ZVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBpbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKSB7XG4gICAgdmFyIHNlcSA9IG1heWJlSW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSk7XG4gICAgaWYgKHNlcSkge1xuICAgICAgcmV0dXJuIHNlcTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdFeHBlY3RlZCBBcnJheSBvciBjb2xsZWN0aW9uIG9iamVjdCBvZiB2YWx1ZXM6ICcgKyB2YWx1ZVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXFGcm9tVmFsdWUodmFsdWUpIHtcbiAgICB2YXIgc2VxID0gbWF5YmVJbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKTtcbiAgICBpZiAoc2VxKSB7XG4gICAgICByZXR1cm4gc2VxO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIG5ldyBPYmplY3RTZXEodmFsdWUpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ0V4cGVjdGVkIEFycmF5IG9yIGNvbGxlY3Rpb24gb2JqZWN0IG9mIHZhbHVlcywgb3Iga2V5ZWQgb2JqZWN0OiAnICsgdmFsdWVcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF5YmVJbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQXJyYXlMaWtlKHZhbHVlKVxuICAgICAgPyBuZXcgQXJyYXlTZXEodmFsdWUpXG4gICAgICA6IGhhc0l0ZXJhdG9yKHZhbHVlKVxuICAgICAgICA/IG5ldyBDb2xsZWN0aW9uU2VxKHZhbHVlKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBJU19NQVBfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfTUFQX19AQCc7XG5cbiAgZnVuY3Rpb24gaXNNYXAobWF5YmVNYXApIHtcbiAgICByZXR1cm4gQm9vbGVhbihtYXliZU1hcCAmJiBtYXliZU1hcFtJU19NQVBfU1lNQk9MXSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc09yZGVyZWRNYXAobWF5YmVPcmRlcmVkTWFwKSB7XG4gICAgcmV0dXJuIGlzTWFwKG1heWJlT3JkZXJlZE1hcCkgJiYgaXNPcmRlcmVkKG1heWJlT3JkZXJlZE1hcCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc1ZhbHVlT2JqZWN0KG1heWJlVmFsdWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbihcbiAgICAgIG1heWJlVmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIG1heWJlVmFsdWUuZXF1YWxzID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIHR5cGVvZiBtYXliZVZhbHVlLmhhc2hDb2RlID09PSAnZnVuY3Rpb24nXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBleHRlbnNpb24gb2YgdGhlIFwic2FtZS12YWx1ZVwiIGFsZ29yaXRobSBhcyBbZGVzY3JpYmVkIGZvciB1c2UgYnkgRVM2IE1hcFxuICAgKiBhbmQgU2V0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXAjS2V5X2VxdWFsaXR5KVxuICAgKlxuICAgKiBOYU4gaXMgY29uc2lkZXJlZCB0aGUgc2FtZSBhcyBOYU4sIGhvd2V2ZXIgLTAgYW5kIDAgYXJlIGNvbnNpZGVyZWQgdGhlIHNhbWVcbiAgICogdmFsdWUsIHdoaWNoIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBhbGdvcml0aG0gZGVzY3JpYmVkIGJ5XG4gICAqIFtgT2JqZWN0LmlzYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzKS5cbiAgICpcbiAgICogVGhpcyBpcyBleHRlbmRlZCBmdXJ0aGVyIHRvIGFsbG93IE9iamVjdHMgdG8gZGVzY3JpYmUgdGhlIHZhbHVlcyB0aGV5XG4gICAqIHJlcHJlc2VudCwgYnkgd2F5IG9mIGB2YWx1ZU9mYCBvciBgZXF1YWxzYCAoYW5kIGBoYXNoQ29kZWApLlxuICAgKlxuICAgKiBOb3RlOiBiZWNhdXNlIG9mIHRoaXMgZXh0ZW5zaW9uLCB0aGUga2V5IGVxdWFsaXR5IG9mIEltbXV0YWJsZS5NYXAgYW5kIHRoZVxuICAgKiB2YWx1ZSBlcXVhbGl0eSBvZiBJbW11dGFibGUuU2V0IHdpbGwgZGlmZmVyIGZyb20gRVM2IE1hcCBhbmQgU2V0LlxuICAgKlxuICAgKiAjIyMgRGVmaW5pbmcgY3VzdG9tIHZhbHVlc1xuICAgKlxuICAgKiBUaGUgZWFzaWVzdCB3YXkgdG8gZGVzY3JpYmUgdGhlIHZhbHVlIGFuIG9iamVjdCByZXByZXNlbnRzIGlzIGJ5IGltcGxlbWVudGluZ1xuICAgKiBgdmFsdWVPZmAuIEZvciBleGFtcGxlLCBgRGF0ZWAgcmVwcmVzZW50cyBhIHZhbHVlIGJ5IHJldHVybmluZyBhIHVuaXhcbiAgICogdGltZXN0YW1wIGZvciBgdmFsdWVPZmA6XG4gICAqXG4gICAqICAgICB2YXIgZGF0ZTEgPSBuZXcgRGF0ZSgxMjM0NTY3ODkwMDAwKTsgLy8gRnJpIEZlYiAxMyAyMDA5IC4uLlxuICAgKiAgICAgdmFyIGRhdGUyID0gbmV3IERhdGUoMTIzNDU2Nzg5MDAwMCk7XG4gICAqICAgICBkYXRlMS52YWx1ZU9mKCk7IC8vIDEyMzQ1Njc4OTAwMDBcbiAgICogICAgIGFzc2VydCggZGF0ZTEgIT09IGRhdGUyICk7XG4gICAqICAgICBhc3NlcnQoIEltbXV0YWJsZS5pcyggZGF0ZTEsIGRhdGUyICkgKTtcbiAgICpcbiAgICogTm90ZTogb3ZlcnJpZGluZyBgdmFsdWVPZmAgbWF5IGhhdmUgb3RoZXIgaW1wbGljYXRpb25zIGlmIHlvdSB1c2UgdGhpcyBvYmplY3RcbiAgICogd2hlcmUgSmF2YVNjcmlwdCBleHBlY3RzIGEgcHJpbWl0aXZlLCBzdWNoIGFzIGltcGxpY2l0IHN0cmluZyBjb2VyY2lvbi5cbiAgICpcbiAgICogRm9yIG1vcmUgY29tcGxleCB0eXBlcywgZXNwZWNpYWxseSBjb2xsZWN0aW9ucywgaW1wbGVtZW50aW5nIGB2YWx1ZU9mYCBtYXlcbiAgICogbm90IGJlIHBlcmZvcm1hbnQuIEFuIGFsdGVybmF0aXZlIGlzIHRvIGltcGxlbWVudCBgZXF1YWxzYCBhbmQgYGhhc2hDb2RlYC5cbiAgICpcbiAgICogYGVxdWFsc2AgdGFrZXMgYW5vdGhlciBvYmplY3QsIHByZXN1bWFibHkgb2Ygc2ltaWxhciB0eXBlLCBhbmQgcmV0dXJucyB0cnVlXG4gICAqIGlmIGl0IGlzIGVxdWFsLiBFcXVhbGl0eSBpcyBzeW1tZXRyaWNhbCwgc28gdGhlIHNhbWUgcmVzdWx0IHNob3VsZCBiZVxuICAgKiByZXR1cm5lZCBpZiB0aGlzIGFuZCB0aGUgYXJndW1lbnQgYXJlIGZsaXBwZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQoIGEuZXF1YWxzKGIpID09PSBiLmVxdWFscyhhKSApO1xuICAgKlxuICAgKiBgaGFzaENvZGVgIHJldHVybnMgYSAzMmJpdCBpbnRlZ2VyIG51bWJlciByZXByZXNlbnRpbmcgdGhlIG9iamVjdCB3aGljaCB3aWxsXG4gICAqIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGhvdyB0byBzdG9yZSB0aGUgdmFsdWUgb2JqZWN0IGluIGEgTWFwIG9yIFNldC4gWW91IG11c3RcbiAgICogcHJvdmlkZSBib3RoIG9yIG5laXRoZXIgbWV0aG9kcywgb25lIG11c3Qgbm90IGV4aXN0IHdpdGhvdXQgdGhlIG90aGVyLlxuICAgKlxuICAgKiBBbHNvLCBhbiBpbXBvcnRhbnQgcmVsYXRpb25zaGlwIGJldHdlZW4gdGhlc2UgbWV0aG9kcyBtdXN0IGJlIHVwaGVsZDogaWYgdHdvXG4gICAqIHZhbHVlcyBhcmUgZXF1YWwsIHRoZXkgKm11c3QqIHJldHVybiB0aGUgc2FtZSBoYXNoQ29kZS4gSWYgdGhlIHZhbHVlcyBhcmUgbm90XG4gICAqIGVxdWFsLCB0aGV5IG1pZ2h0IGhhdmUgdGhlIHNhbWUgaGFzaENvZGU7IHRoaXMgaXMgY2FsbGVkIGEgaGFzaCBjb2xsaXNpb24sXG4gICAqIGFuZCB3aGlsZSB1bmRlc2lyYWJsZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgaXQgaXMgYWNjZXB0YWJsZS5cbiAgICpcbiAgICogICAgIGlmIChhLmVxdWFscyhiKSkge1xuICAgKiAgICAgICBhc3NlcnQoIGEuaGFzaENvZGUoKSA9PT0gYi5oYXNoQ29kZSgpICk7XG4gICAqICAgICB9XG4gICAqXG4gICAqIEFsbCBJbW11dGFibGUgY29sbGVjdGlvbnMgYXJlIFZhbHVlIE9iamVjdHM6IHRoZXkgaW1wbGVtZW50IGBlcXVhbHMoKWBcbiAgICogYW5kIGBoYXNoQ29kZSgpYC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzKHZhbHVlQSwgdmFsdWVCKSB7XG4gICAgaWYgKHZhbHVlQSA9PT0gdmFsdWVCIHx8ICh2YWx1ZUEgIT09IHZhbHVlQSAmJiB2YWx1ZUIgIT09IHZhbHVlQikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXZhbHVlQSB8fCAhdmFsdWVCKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHR5cGVvZiB2YWx1ZUEudmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIHZhbHVlQi52YWx1ZU9mID09PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICB2YWx1ZUEgPSB2YWx1ZUEudmFsdWVPZigpO1xuICAgICAgdmFsdWVCID0gdmFsdWVCLnZhbHVlT2YoKTtcbiAgICAgIGlmICh2YWx1ZUEgPT09IHZhbHVlQiB8fCAodmFsdWVBICE9PSB2YWx1ZUEgJiYgdmFsdWVCICE9PSB2YWx1ZUIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCF2YWx1ZUEgfHwgIXZhbHVlQikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhIShcbiAgICAgIGlzVmFsdWVPYmplY3QodmFsdWVBKSAmJlxuICAgICAgaXNWYWx1ZU9iamVjdCh2YWx1ZUIpICYmXG4gICAgICB2YWx1ZUEuZXF1YWxzKHZhbHVlQilcbiAgICApO1xuICB9XG5cbiAgdmFyIGltdWwgPVxuICAgIHR5cGVvZiBNYXRoLmltdWwgPT09ICdmdW5jdGlvbicgJiYgTWF0aC5pbXVsKDB4ZmZmZmZmZmYsIDIpID09PSAtMlxuICAgICAgPyBNYXRoLmltdWxcbiAgICAgIDogZnVuY3Rpb24gaW11bChhLCBiKSB7XG4gICAgICAgICAgYSB8PSAwOyAvLyBpbnRcbiAgICAgICAgICBiIHw9IDA7IC8vIGludFxuICAgICAgICAgIHZhciBjID0gYSAmIDB4ZmZmZjtcbiAgICAgICAgICB2YXIgZCA9IGIgJiAweGZmZmY7XG4gICAgICAgICAgLy8gU2hpZnQgYnkgMCBmaXhlcyB0aGUgc2lnbiBvbiB0aGUgaGlnaCBwYXJ0LlxuICAgICAgICAgIHJldHVybiAoYyAqIGQgKyAoKCgoYSA+Pj4gMTYpICogZCArIGMgKiAoYiA+Pj4gMTYpKSA8PCAxNikgPj4+IDApKSB8IDA7IC8vIGludFxuICAgICAgICB9O1xuXG4gIC8vIHY4IGhhcyBhbiBvcHRpbWl6YXRpb24gZm9yIHN0b3JpbmcgMzEtYml0IHNpZ25lZCBudW1iZXJzLlxuICAvLyBWYWx1ZXMgd2hpY2ggaGF2ZSBlaXRoZXIgMDAgb3IgMTEgYXMgdGhlIGhpZ2ggb3JkZXIgYml0cyBxdWFsaWZ5LlxuICAvLyBUaGlzIGZ1bmN0aW9uIGRyb3BzIHRoZSBoaWdoZXN0IG9yZGVyIGJpdCBpbiBhIHNpZ25lZCBudW1iZXIsIG1haW50YWluaW5nXG4gIC8vIHRoZSBzaWduIGJpdC5cbiAgZnVuY3Rpb24gc21pKGkzMikge1xuICAgIHJldHVybiAoKGkzMiA+Pj4gMSkgJiAweDQwMDAwMDAwKSB8IChpMzIgJiAweGJmZmZmZmZmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc2gobykge1xuICAgIGlmIChvID09PSBmYWxzZSB8fCBvID09PSBudWxsIHx8IG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygby52YWx1ZU9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvID0gby52YWx1ZU9mKCk7XG4gICAgICBpZiAobyA9PT0gZmFsc2UgfHwgbyA9PT0gbnVsbCB8fCBvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgbztcbiAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChvICE9PSBvIHx8IG8gPT09IEluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgdmFyIGggPSBvIHwgMDtcbiAgICAgIGlmIChoICE9PSBvKSB7XG4gICAgICAgIGggXj0gbyAqIDB4ZmZmZmZmZmY7XG4gICAgICB9XG4gICAgICB3aGlsZSAobyA+IDB4ZmZmZmZmZmYpIHtcbiAgICAgICAgbyAvPSAweGZmZmZmZmZmO1xuICAgICAgICBoIF49IG87XG4gICAgICB9XG4gICAgICByZXR1cm4gc21pKGgpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBvLmxlbmd0aCA+IFNUUklOR19IQVNIX0NBQ0hFX01JTl9TVFJMRU5cbiAgICAgICAgPyBjYWNoZWRIYXNoU3RyaW5nKG8pXG4gICAgICAgIDogaGFzaFN0cmluZyhvKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvLmhhc2hDb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBEcm9wIGFueSBoaWdoIGJpdHMgZnJvbSBhY2NpZGVudGFsbHkgbG9uZyBoYXNoIGNvZGVzLlxuICAgICAgcmV0dXJuIHNtaShvLmhhc2hDb2RlKCkpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGhhc2hKU09iaihvKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvLnRvU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaGFzaFN0cmluZyhvLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHR5cGUgJyArIHR5cGUgKyAnIGNhbm5vdCBiZSBoYXNoZWQuJyk7XG4gIH1cblxuICBmdW5jdGlvbiBjYWNoZWRIYXNoU3RyaW5nKHN0cmluZykge1xuICAgIHZhciBoYXNoZWQgPSBzdHJpbmdIYXNoQ2FjaGVbc3RyaW5nXTtcbiAgICBpZiAoaGFzaGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGhhc2hlZCA9IGhhc2hTdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChTVFJJTkdfSEFTSF9DQUNIRV9TSVpFID09PSBTVFJJTkdfSEFTSF9DQUNIRV9NQVhfU0laRSkge1xuICAgICAgICBTVFJJTkdfSEFTSF9DQUNIRV9TSVpFID0gMDtcbiAgICAgICAgc3RyaW5nSGFzaENhY2hlID0ge307XG4gICAgICB9XG4gICAgICBTVFJJTkdfSEFTSF9DQUNIRV9TSVpFKys7XG4gICAgICBzdHJpbmdIYXNoQ2FjaGVbc3RyaW5nXSA9IGhhc2hlZDtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2hlZDtcbiAgfVxuXG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2hhc2hpbmctc3RyaW5nc1xuICBmdW5jdGlvbiBoYXNoU3RyaW5nKHN0cmluZykge1xuICAgIC8vIFRoaXMgaXMgdGhlIGhhc2ggZnJvbSBKVk1cbiAgICAvLyBUaGUgaGFzaCBjb2RlIGZvciBhIHN0cmluZyBpcyBjb21wdXRlZCBhc1xuICAgIC8vIHNbMF0gKiAzMSBeIChuIC0gMSkgKyBzWzFdICogMzEgXiAobiAtIDIpICsgLi4uICsgc1tuIC0gMV0sXG4gICAgLy8gd2hlcmUgc1tpXSBpcyB0aGUgaXRoIGNoYXJhY3RlciBvZiB0aGUgc3RyaW5nIGFuZCBuIGlzIHRoZSBsZW5ndGggb2ZcbiAgICAvLyB0aGUgc3RyaW5nLiBXZSBcIm1vZFwiIHRoZSByZXN1bHQgdG8gbWFrZSBpdCBiZXR3ZWVuIDAgKGluY2x1c2l2ZSkgYW5kIDJeMzFcbiAgICAvLyAoZXhjbHVzaXZlKSBieSBkcm9wcGluZyBoaWdoIGJpdHMuXG4gICAgdmFyIGhhc2hlZCA9IDA7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHN0cmluZy5sZW5ndGg7IGlpKyspIHtcbiAgICAgIGhhc2hlZCA9ICgzMSAqIGhhc2hlZCArIHN0cmluZy5jaGFyQ29kZUF0KGlpKSkgfCAwO1xuICAgIH1cbiAgICByZXR1cm4gc21pKGhhc2hlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNoSlNPYmoob2JqKSB7XG4gICAgdmFyIGhhc2hlZDtcbiAgICBpZiAodXNpbmdXZWFrTWFwKSB7XG4gICAgICBoYXNoZWQgPSB3ZWFrTWFwLmdldChvYmopO1xuICAgICAgaWYgKGhhc2hlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBoYXNoZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFzaGVkID0gb2JqW1VJRF9IQVNIX0tFWV07XG4gICAgaWYgKGhhc2hlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gaGFzaGVkO1xuICAgIH1cblxuICAgIGlmICghY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIGhhc2hlZCA9IG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZSAmJiBvYmoucHJvcGVydHlJc0VudW1lcmFibGVbVUlEX0hBU0hfS0VZXTtcbiAgICAgIGlmIChoYXNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaGFzaGVkO1xuICAgICAgfVxuXG4gICAgICBoYXNoZWQgPSBnZXRJRU5vZGVIYXNoKG9iaik7XG4gICAgICBpZiAoaGFzaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGhhc2hlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNoZWQgPSArK29iakhhc2hVSUQ7XG4gICAgaWYgKG9iakhhc2hVSUQgJiAweDQwMDAwMDAwKSB7XG4gICAgICBvYmpIYXNoVUlEID0gMDtcbiAgICB9XG5cbiAgICBpZiAodXNpbmdXZWFrTWFwKSB7XG4gICAgICB3ZWFrTWFwLnNldChvYmosIGhhc2hlZCk7XG4gICAgfSBlbHNlIGlmIChpc0V4dGVuc2libGUgIT09IHVuZGVmaW5lZCAmJiBpc0V4dGVuc2libGUob2JqKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm9uLWV4dGVuc2libGUgb2JqZWN0cyBhcmUgbm90IGFsbG93ZWQgYXMga2V5cy4nKTtcbiAgICB9IGVsc2UgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBVSURfSEFTSF9LRVksIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IGhhc2hlZCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBvYmoucHJvcGVydHlJc0VudW1lcmFibGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlID09PSBvYmouY29uc3RydWN0b3IucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlXG4gICAgKSB7XG4gICAgICAvLyBTaW5jZSB3ZSBjYW4ndCBkZWZpbmUgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBvbiB0aGUgb2JqZWN0XG4gICAgICAvLyB3ZSdsbCBoaWphY2sgb25lIG9mIHRoZSBsZXNzLXVzZWQgbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyB0b1xuICAgICAgLy8gc2F2ZSBvdXIgaGFzaCBvbiBpdC4gU2luY2UgdGhpcyBpcyBhIGZ1bmN0aW9uIGl0IHdpbGwgbm90IHNob3cgdXAgaW5cbiAgICAgIC8vIGBKU09OLnN0cmluZ2lmeWAgd2hpY2ggaXMgd2hhdCB3ZSB3YW50LlxuICAgICAgb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5hcHBseShcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIGFyZ3VtZW50c1xuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZVtVSURfSEFTSF9LRVldID0gaGFzaGVkO1xuICAgIH0gZWxzZSBpZiAob2JqLm5vZGVUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgY291bGRuJ3QgZ2V0IHRoZSBJRSBgdW5pcXVlSURgIHRvIHVzZSBhcyBhIGhhc2hcbiAgICAgIC8vIGFuZCB3ZSBjb3VsZG4ndCB1c2UgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSB0byBleHBsb2l0IHRoZVxuICAgICAgLy8gZG9udEVudW0gYnVnIHNvIHdlIHNpbXBseSBhZGQgdGhlIGBVSURfSEFTSF9LRVlgIG9uIHRoZSBub2RlXG4gICAgICAvLyBpdHNlbGYuXG4gICAgICBvYmpbVUlEX0hBU0hfS0VZXSA9IGhhc2hlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gc2V0IGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgb24gb2JqZWN0LicpO1xuICAgIH1cblxuICAgIHJldHVybiBoYXNoZWQ7XG4gIH1cblxuICAvLyBHZXQgcmVmZXJlbmNlcyB0byBFUzUgb2JqZWN0IG1ldGhvZHMuXG4gIHZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xuXG4gIC8vIFRydWUgaWYgT2JqZWN0LmRlZmluZVByb3BlcnR5IHdvcmtzIGFzIGV4cGVjdGVkLiBJRTggZmFpbHMgdGhpcyB0ZXN0LlxuICB2YXIgY2FuRGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ0AnLCB7fSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KSgpO1xuXG4gIC8vIElFIGhhcyBhIGB1bmlxdWVJRGAgcHJvcGVydHkgb24gRE9NIG5vZGVzLiBXZSBjYW4gY29uc3RydWN0IHRoZSBoYXNoIGZyb20gaXRcbiAgLy8gYW5kIGF2b2lkIG1lbW9yeSBsZWFrcyBmcm9tIHRoZSBJRSBjbG9uZU5vZGUgYnVnLlxuICBmdW5jdGlvbiBnZXRJRU5vZGVIYXNoKG5vZGUpIHtcbiAgICBpZiAobm9kZSAmJiBub2RlLm5vZGVUeXBlID4gMCkge1xuICAgICAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgICAgIGNhc2UgMTogLy8gRWxlbWVudFxuICAgICAgICAgIHJldHVybiBub2RlLnVuaXF1ZUlEO1xuICAgICAgICBjYXNlIDk6IC8vIERvY3VtZW50XG4gICAgICAgICAgcmV0dXJuIG5vZGUuZG9jdW1lbnRFbGVtZW50ICYmIG5vZGUuZG9jdW1lbnRFbGVtZW50LnVuaXF1ZUlEO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHBvc3NpYmxlLCB1c2UgYSBXZWFrTWFwLlxuICB2YXIgdXNpbmdXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbic7XG4gIHZhciB3ZWFrTWFwO1xuICBpZiAodXNpbmdXZWFrTWFwKSB7XG4gICAgd2Vha01hcCA9IG5ldyBXZWFrTWFwKCk7XG4gIH1cblxuICB2YXIgb2JqSGFzaFVJRCA9IDA7XG5cbiAgdmFyIFVJRF9IQVNIX0tFWSA9ICdfX2ltbXV0YWJsZWhhc2hfXyc7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gICAgVUlEX0hBU0hfS0VZID0gU3ltYm9sKFVJRF9IQVNIX0tFWSk7XG4gIH1cblxuICB2YXIgU1RSSU5HX0hBU0hfQ0FDSEVfTUlOX1NUUkxFTiA9IDE2O1xuICB2YXIgU1RSSU5HX0hBU0hfQ0FDSEVfTUFYX1NJWkUgPSAyNTU7XG4gIHZhciBTVFJJTkdfSEFTSF9DQUNIRV9TSVpFID0gMDtcbiAgdmFyIHN0cmluZ0hhc2hDYWNoZSA9IHt9O1xuXG4gIHZhciBUb0tleWVkU2VxdWVuY2UgPSAoZnVuY3Rpb24gKEtleWVkU2VxJCQxKSB7XG4gICAgZnVuY3Rpb24gVG9LZXllZFNlcXVlbmNlKGluZGV4ZWQsIHVzZUtleXMpIHtcbiAgICAgIHRoaXMuX2l0ZXIgPSBpbmRleGVkO1xuICAgICAgdGhpcy5fdXNlS2V5cyA9IHVzZUtleXM7XG4gICAgICB0aGlzLnNpemUgPSBpbmRleGVkLnNpemU7XG4gICAgfVxuXG4gICAgaWYgKCBLZXllZFNlcSQkMSApIFRvS2V5ZWRTZXF1ZW5jZS5fX3Byb3RvX18gPSBLZXllZFNlcSQkMTtcbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggS2V5ZWRTZXEkJDEgJiYgS2V5ZWRTZXEkJDEucHJvdG90eXBlICk7XG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvS2V5ZWRTZXF1ZW5jZTtcblxuICAgIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci5nZXQoa2V5LCBub3RTZXRWYWx1ZSk7XG4gICAgfTtcblxuICAgIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLmhhcyhrZXkpO1xuICAgIH07XG5cbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLnZhbHVlU2VxID0gZnVuY3Rpb24gdmFsdWVTZXEgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIudmFsdWVTZXEoKTtcbiAgICB9O1xuXG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZSAoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdmFyIHJldmVyc2VkU2VxdWVuY2UgPSByZXZlcnNlRmFjdG9yeSh0aGlzLCB0cnVlKTtcbiAgICAgIGlmICghdGhpcy5fdXNlS2V5cykge1xuICAgICAgICByZXZlcnNlZFNlcXVlbmNlLnZhbHVlU2VxID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLl9pdGVyLnRvU2VxKCkucmV2ZXJzZSgpOyB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldmVyc2VkU2VxdWVuY2U7XG4gICAgfTtcblxuICAgIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB2YXIgbWFwcGVkU2VxdWVuY2UgPSBtYXBGYWN0b3J5KHRoaXMsIG1hcHBlciwgY29udGV4dCk7XG4gICAgICBpZiAoIXRoaXMuX3VzZUtleXMpIHtcbiAgICAgICAgbWFwcGVkU2VxdWVuY2UudmFsdWVTZXEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuX2l0ZXIudG9TZXEoKS5tYXAobWFwcGVyLCBjb250ZXh0KTsgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXBwZWRTZXF1ZW5jZTtcbiAgICB9O1xuXG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBmbih2LCBrLCB0aGlzJDEpOyB9LCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRvS2V5ZWRTZXF1ZW5jZTtcbiAgfShLZXllZFNlcSkpO1xuICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlW0lTX09SREVSRURfU1lNQk9MXSA9IHRydWU7XG5cbiAgdmFyIFRvSW5kZXhlZFNlcXVlbmNlID0gKGZ1bmN0aW9uIChJbmRleGVkU2VxJCQxKSB7XG4gICAgZnVuY3Rpb24gVG9JbmRleGVkU2VxdWVuY2UoaXRlcikge1xuICAgICAgdGhpcy5faXRlciA9IGl0ZXI7XG4gICAgICB0aGlzLnNpemUgPSBpdGVyLnNpemU7XG4gICAgfVxuXG4gICAgaWYgKCBJbmRleGVkU2VxJCQxICkgVG9JbmRleGVkU2VxdWVuY2UuX19wcm90b19fID0gSW5kZXhlZFNlcSQkMTtcbiAgICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkU2VxJCQxICYmIEluZGV4ZWRTZXEkJDEucHJvdG90eXBlICk7XG4gICAgVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9JbmRleGVkU2VxdWVuY2U7XG5cbiAgICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLmluY2x1ZGVzKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICByZXZlcnNlICYmIGVuc3VyZVNpemUodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci5fX2l0ZXJhdGUoXG4gICAgICAgIGZ1bmN0aW9uICh2KSB7IHJldHVybiBmbih2LCByZXZlcnNlID8gdGhpcyQxLnNpemUgLSArK2kgOiBpKyssIHRoaXMkMSk7IH0sXG4gICAgICAgIHJldmVyc2VcbiAgICAgICk7XG4gICAgfTtcblxuICAgIFRvSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX2l0ZXIuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICByZXZlcnNlICYmIGVuc3VyZVNpemUodGhpcyk7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBzdGVwLmRvbmVcbiAgICAgICAgICA/IHN0ZXBcbiAgICAgICAgICA6IGl0ZXJhdG9yVmFsdWUoXG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIHJldmVyc2UgPyB0aGlzJDEuc2l6ZSAtICsraSA6IGkrKyxcbiAgICAgICAgICAgICAgc3RlcC52YWx1ZSxcbiAgICAgICAgICAgICAgc3RlcFxuICAgICAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gVG9JbmRleGVkU2VxdWVuY2U7XG4gIH0oSW5kZXhlZFNlcSkpO1xuXG4gIHZhciBUb1NldFNlcXVlbmNlID0gKGZ1bmN0aW9uIChTZXRTZXEkJDEpIHtcbiAgICBmdW5jdGlvbiBUb1NldFNlcXVlbmNlKGl0ZXIpIHtcbiAgICAgIHRoaXMuX2l0ZXIgPSBpdGVyO1xuICAgICAgdGhpcy5zaXplID0gaXRlci5zaXplO1xuICAgIH1cblxuICAgIGlmICggU2V0U2VxJCQxICkgVG9TZXRTZXF1ZW5jZS5fX3Byb3RvX18gPSBTZXRTZXEkJDE7XG4gICAgVG9TZXRTZXF1ZW5jZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTZXRTZXEkJDEgJiYgU2V0U2VxJCQxLnByb3RvdHlwZSApO1xuICAgIFRvU2V0U2VxdWVuY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9TZXRTZXF1ZW5jZTtcblxuICAgIFRvU2V0U2VxdWVuY2UucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci5pbmNsdWRlcyhrZXkpO1xuICAgIH07XG5cbiAgICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uICh2KSB7IHJldHVybiBmbih2LCB2LCB0aGlzJDEpOyB9LCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgVG9TZXRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX2l0ZXIuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBzdGVwLmRvbmVcbiAgICAgICAgICA/IHN0ZXBcbiAgICAgICAgICA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgc3RlcC52YWx1ZSwgc3RlcC52YWx1ZSwgc3RlcCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRvU2V0U2VxdWVuY2U7XG4gIH0oU2V0U2VxKSk7XG5cbiAgdmFyIEZyb21FbnRyaWVzU2VxdWVuY2UgPSAoZnVuY3Rpb24gKEtleWVkU2VxJCQxKSB7XG4gICAgZnVuY3Rpb24gRnJvbUVudHJpZXNTZXF1ZW5jZShlbnRyaWVzKSB7XG4gICAgICB0aGlzLl9pdGVyID0gZW50cmllcztcbiAgICAgIHRoaXMuc2l6ZSA9IGVudHJpZXMuc2l6ZTtcbiAgICB9XG5cbiAgICBpZiAoIEtleWVkU2VxJCQxICkgRnJvbUVudHJpZXNTZXF1ZW5jZS5fX3Byb3RvX18gPSBLZXllZFNlcSQkMTtcbiAgICBGcm9tRW50cmllc1NlcXVlbmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEtleWVkU2VxJCQxICYmIEtleWVkU2VxJCQxLnByb3RvdHlwZSApO1xuICAgIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRnJvbUVudHJpZXNTZXF1ZW5jZTtcblxuICAgIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLmVudHJ5U2VxID0gZnVuY3Rpb24gZW50cnlTZXEgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIudG9TZXEoKTtcbiAgICB9O1xuXG4gICAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0ZShmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgZW50cnkgZXhpc3RzIGZpcnN0IHNvIGFycmF5IGFjY2VzcyBkb2Vzbid0IHRocm93IGZvciBob2xlc1xuICAgICAgICAvLyBpbiB0aGUgcGFyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFsaWRhdGVFbnRyeShlbnRyeSk7XG4gICAgICAgICAgdmFyIGluZGV4ZWRDb2xsZWN0aW9uID0gaXNDb2xsZWN0aW9uKGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gZm4oXG4gICAgICAgICAgICBpbmRleGVkQ29sbGVjdGlvbiA/IGVudHJ5LmdldCgxKSA6IGVudHJ5WzFdLFxuICAgICAgICAgICAgaW5kZXhlZENvbGxlY3Rpb24gPyBlbnRyeS5nZXQoMCkgOiBlbnRyeVswXSxcbiAgICAgICAgICAgIHRoaXMkMVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBGcm9tRW50cmllc1NlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlci5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIC8vIENoZWNrIGlmIGVudHJ5IGV4aXN0cyBmaXJzdCBzbyBhcnJheSBhY2Nlc3MgZG9lc24ndCB0aHJvdyBmb3IgaG9sZXNcbiAgICAgICAgICAvLyBpbiB0aGUgcGFyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRW50cnkoZW50cnkpO1xuICAgICAgICAgICAgdmFyIGluZGV4ZWRDb2xsZWN0aW9uID0gaXNDb2xsZWN0aW9uKGVudHJ5KTtcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBpbmRleGVkQ29sbGVjdGlvbiA/IGVudHJ5LmdldCgwKSA6IGVudHJ5WzBdLFxuICAgICAgICAgICAgICBpbmRleGVkQ29sbGVjdGlvbiA/IGVudHJ5LmdldCgxKSA6IGVudHJ5WzFdLFxuICAgICAgICAgICAgICBzdGVwXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBGcm9tRW50cmllc1NlcXVlbmNlO1xuICB9KEtleWVkU2VxKSk7XG5cbiAgVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlLmNhY2hlUmVzdWx0ID0gVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9IFRvU2V0U2VxdWVuY2UucHJvdG90eXBlLmNhY2hlUmVzdWx0ID0gRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuY2FjaGVSZXN1bHQgPSBjYWNoZVJlc3VsdFRocm91Z2g7XG5cbiAgZnVuY3Rpb24gZmxpcEZhY3RvcnkoY29sbGVjdGlvbikge1xuICAgIHZhciBmbGlwU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gICAgZmxpcFNlcXVlbmNlLl9pdGVyID0gY29sbGVjdGlvbjtcbiAgICBmbGlwU2VxdWVuY2Uuc2l6ZSA9IGNvbGxlY3Rpb24uc2l6ZTtcbiAgICBmbGlwU2VxdWVuY2UuZmxpcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbGxlY3Rpb247IH07XG4gICAgZmxpcFNlcXVlbmNlLnJldmVyc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXZlcnNlZFNlcXVlbmNlID0gY29sbGVjdGlvbi5yZXZlcnNlLmFwcGx5KHRoaXMpOyAvLyBzdXBlci5yZXZlcnNlKClcbiAgICAgIHJldmVyc2VkU2VxdWVuY2UuZmxpcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbGxlY3Rpb24ucmV2ZXJzZSgpOyB9O1xuICAgICAgcmV0dXJuIHJldmVyc2VkU2VxdWVuY2U7XG4gICAgfTtcbiAgICBmbGlwU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY29sbGVjdGlvbi5pbmNsdWRlcyhrZXkpOyB9O1xuICAgIGZsaXBTZXF1ZW5jZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGNvbGxlY3Rpb24uaGFzKGtleSk7IH07XG4gICAgZmxpcFNlcXVlbmNlLmNhY2hlUmVzdWx0ID0gY2FjaGVSZXN1bHRUaHJvdWdoO1xuICAgIGZsaXBTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBmbihrLCB2LCB0aGlzJDEpICE9PSBmYWxzZTsgfSwgcmV2ZXJzZSk7XG4gICAgfTtcbiAgICBmbGlwU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHR5cGUgPT09IElURVJBVEVfRU5UUklFUykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmICghc3RlcC5kb25lKSB7XG4gICAgICAgICAgICB2YXIgayA9IHN0ZXAudmFsdWVbMF07XG4gICAgICAgICAgICBzdGVwLnZhbHVlWzBdID0gc3RlcC52YWx1ZVsxXTtcbiAgICAgICAgICAgIHN0ZXAudmFsdWVbMV0gPSBrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKFxuICAgICAgICB0eXBlID09PSBJVEVSQVRFX1ZBTFVFUyA/IElURVJBVEVfS0VZUyA6IElURVJBVEVfVkFMVUVTLFxuICAgICAgICByZXZlcnNlXG4gICAgICApO1xuICAgIH07XG4gICAgcmV0dXJuIGZsaXBTZXF1ZW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcEZhY3RvcnkoY29sbGVjdGlvbiwgbWFwcGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIG1hcHBlZFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGNvbGxlY3Rpb24pO1xuICAgIG1hcHBlZFNlcXVlbmNlLnNpemUgPSBjb2xsZWN0aW9uLnNpemU7XG4gICAgbWFwcGVkU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY29sbGVjdGlvbi5oYXMoa2V5KTsgfTtcbiAgICBtYXBwZWRTZXF1ZW5jZS5nZXQgPSBmdW5jdGlvbiAoa2V5LCBub3RTZXRWYWx1ZSkge1xuICAgICAgdmFyIHYgPSBjb2xsZWN0aW9uLmdldChrZXksIE5PVF9TRVQpO1xuICAgICAgcmV0dXJuIHYgPT09IE5PVF9TRVRcbiAgICAgICAgPyBub3RTZXRWYWx1ZVxuICAgICAgICA6IG1hcHBlci5jYWxsKGNvbnRleHQsIHYsIGtleSwgY29sbGVjdGlvbik7XG4gICAgfTtcbiAgICBtYXBwZWRTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uX19pdGVyYXRlKFxuICAgICAgICBmdW5jdGlvbiAodiwgaywgYykgeyByZXR1cm4gZm4obWFwcGVyLmNhbGwoY29udGV4dCwgdiwgaywgYyksIGssIHRoaXMkMSkgIT09IGZhbHNlOyB9LFxuICAgICAgICByZXZlcnNlXG4gICAgICApO1xuICAgIH07XG4gICAgbWFwcGVkU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICB2YXIga2V5ID0gZW50cnlbMF07XG4gICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIG1hcHBlci5jYWxsKGNvbnRleHQsIGVudHJ5WzFdLCBrZXksIGNvbGxlY3Rpb24pLFxuICAgICAgICAgIHN0ZXBcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIG1hcHBlZFNlcXVlbmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmV2ZXJzZUZhY3RvcnkoY29sbGVjdGlvbiwgdXNlS2V5cykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJldmVyc2VkU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5faXRlciA9IGNvbGxlY3Rpb247XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5zaXplID0gY29sbGVjdGlvbi5zaXplO1xuICAgIHJldmVyc2VkU2VxdWVuY2UucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbGxlY3Rpb247IH07XG4gICAgaWYgKGNvbGxlY3Rpb24uZmxpcCkge1xuICAgICAgcmV2ZXJzZWRTZXF1ZW5jZS5mbGlwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmbGlwU2VxdWVuY2UgPSBmbGlwRmFjdG9yeShjb2xsZWN0aW9uKTtcbiAgICAgICAgZmxpcFNlcXVlbmNlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2xsZWN0aW9uLmZsaXAoKTsgfTtcbiAgICAgICAgcmV0dXJuIGZsaXBTZXF1ZW5jZTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldmVyc2VkU2VxdWVuY2UuZ2V0ID0gZnVuY3Rpb24gKGtleSwgbm90U2V0VmFsdWUpIHsgcmV0dXJuIGNvbGxlY3Rpb24uZ2V0KHVzZUtleXMgPyBrZXkgOiAtMSAtIGtleSwgbm90U2V0VmFsdWUpOyB9O1xuICAgIHJldmVyc2VkU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY29sbGVjdGlvbi5oYXModXNlS2V5cyA/IGtleSA6IC0xIC0ga2V5KTsgfTtcbiAgICByZXZlcnNlZFNlcXVlbmNlLmluY2x1ZGVzID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBjb2xsZWN0aW9uLmluY2x1ZGVzKHZhbHVlKTsgfTtcbiAgICByZXZlcnNlZFNlcXVlbmNlLmNhY2hlUmVzdWx0ID0gY2FjaGVSZXN1bHRUaHJvdWdoO1xuICAgIHJldmVyc2VkU2VxdWVuY2UuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICByZXZlcnNlICYmIGVuc3VyZVNpemUoY29sbGVjdGlvbik7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5fX2l0ZXJhdGUoXG4gICAgICAgIGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBmbih2LCB1c2VLZXlzID8gayA6IHJldmVyc2UgPyB0aGlzJDEuc2l6ZSAtICsraSA6IGkrKywgdGhpcyQxKTsgfSxcbiAgICAgICAgIXJldmVyc2VcbiAgICAgICk7XG4gICAgfTtcbiAgICByZXZlcnNlZFNlcXVlbmNlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgcmV2ZXJzZSAmJiBlbnN1cmVTaXplKGNvbGxlY3Rpb24pO1xuICAgICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgIXJldmVyc2UpO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICB1c2VLZXlzID8gZW50cnlbMF0gOiByZXZlcnNlID8gdGhpcyQxLnNpemUgLSArK2kgOiBpKyssXG4gICAgICAgICAgZW50cnlbMV0sXG4gICAgICAgICAgc3RlcFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gcmV2ZXJzZWRTZXF1ZW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbHRlckZhY3RvcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBjb250ZXh0LCB1c2VLZXlzKSB7XG4gICAgdmFyIGZpbHRlclNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGNvbGxlY3Rpb24pO1xuICAgIGlmICh1c2VLZXlzKSB7XG4gICAgICBmaWx0ZXJTZXF1ZW5jZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB2ID0gY29sbGVjdGlvbi5nZXQoa2V5LCBOT1RfU0VUKTtcbiAgICAgICAgcmV0dXJuIHYgIT09IE5PVF9TRVQgJiYgISFwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICAgIGZpbHRlclNlcXVlbmNlLmdldCA9IGZ1bmN0aW9uIChrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgICAgIHZhciB2ID0gY29sbGVjdGlvbi5nZXQoa2V5LCBOT1RfU0VUKTtcbiAgICAgICAgcmV0dXJuIHYgIT09IE5PVF9TRVQgJiYgcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwga2V5LCBjb2xsZWN0aW9uKVxuICAgICAgICAgID8gdlxuICAgICAgICAgIDogbm90U2V0VmFsdWU7XG4gICAgICB9O1xuICAgIH1cbiAgICBmaWx0ZXJTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGssIGMpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpKSB7XG4gICAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICAgIHJldHVybiBmbih2LCB1c2VLZXlzID8gayA6IGl0ZXJhdGlvbnMgLSAxLCB0aGlzJDEpO1xuICAgICAgICB9XG4gICAgICB9LCByZXZlcnNlKTtcbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG4gICAgZmlsdGVyU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIga2V5ID0gZW50cnlbMF07XG4gICAgICAgICAgdmFyIHZhbHVlID0gZW50cnlbMV07XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCB1c2VLZXlzID8ga2V5IDogaXRlcmF0aW9ucysrLCB2YWx1ZSwgc3RlcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBmaWx0ZXJTZXF1ZW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvdW50QnlGYWN0b3J5KGNvbGxlY3Rpb24sIGdyb3VwZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgZ3JvdXBzID0gTWFwKCkuYXNNdXRhYmxlKCk7XG4gICAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgIGdyb3Vwcy51cGRhdGUoZ3JvdXBlci5jYWxsKGNvbnRleHQsIHYsIGssIGNvbGxlY3Rpb24pLCAwLCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSArIDE7IH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBncm91cHMuYXNJbW11dGFibGUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdyb3VwQnlGYWN0b3J5KGNvbGxlY3Rpb24sIGdyb3VwZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgaXNLZXllZEl0ZXIgPSBpc0tleWVkKGNvbGxlY3Rpb24pO1xuICAgIHZhciBncm91cHMgPSAoaXNPcmRlcmVkKGNvbGxlY3Rpb24pID8gT3JkZXJlZE1hcCgpIDogTWFwKCkpLmFzTXV0YWJsZSgpO1xuICAgIGNvbGxlY3Rpb24uX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICBncm91cHMudXBkYXRlKFxuICAgICAgICBncm91cGVyLmNhbGwoY29udGV4dCwgdiwgaywgY29sbGVjdGlvbiksXG4gICAgICAgIGZ1bmN0aW9uIChhKSB7IHJldHVybiAoKGEgPSBhIHx8IFtdKSwgYS5wdXNoKGlzS2V5ZWRJdGVyID8gW2ssIHZdIDogdiksIGEpOyB9XG4gICAgICApO1xuICAgIH0pO1xuICAgIHZhciBjb2VyY2UgPSBjb2xsZWN0aW9uQ2xhc3MoY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIGdyb3Vwcy5tYXAoZnVuY3Rpb24gKGFycikgeyByZXR1cm4gcmVpZnkoY29sbGVjdGlvbiwgY29lcmNlKGFycikpOyB9KS5hc0ltbXV0YWJsZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2xpY2VGYWN0b3J5KGNvbGxlY3Rpb24sIGJlZ2luLCBlbmQsIHVzZUtleXMpIHtcbiAgICB2YXIgb3JpZ2luYWxTaXplID0gY29sbGVjdGlvbi5zaXplO1xuXG4gICAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgb3JpZ2luYWxTaXplKSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuXG4gICAgdmFyIHJlc29sdmVkQmVnaW4gPSByZXNvbHZlQmVnaW4oYmVnaW4sIG9yaWdpbmFsU2l6ZSk7XG4gICAgdmFyIHJlc29sdmVkRW5kID0gcmVzb2x2ZUVuZChlbmQsIG9yaWdpbmFsU2l6ZSk7XG5cbiAgICAvLyBiZWdpbiBvciBlbmQgd2lsbCBiZSBOYU4gaWYgdGhleSB3ZXJlIHByb3ZpZGVkIGFzIG5lZ2F0aXZlIG51bWJlcnMgYW5kXG4gICAgLy8gdGhpcyBjb2xsZWN0aW9uJ3Mgc2l6ZSBpcyB1bmtub3duLiBJbiB0aGF0IGNhc2UsIGNhY2hlIGZpcnN0IHNvIHRoZXJlIGlzXG4gICAgLy8gYSBrbm93biBzaXplIGFuZCB0aGVzZSBkbyBub3QgcmVzb2x2ZSB0byBOYU4uXG4gICAgaWYgKHJlc29sdmVkQmVnaW4gIT09IHJlc29sdmVkQmVnaW4gfHwgcmVzb2x2ZWRFbmQgIT09IHJlc29sdmVkRW5kKSB7XG4gICAgICByZXR1cm4gc2xpY2VGYWN0b3J5KGNvbGxlY3Rpb24udG9TZXEoKS5jYWNoZVJlc3VsdCgpLCBiZWdpbiwgZW5kLCB1c2VLZXlzKTtcbiAgICB9XG5cbiAgICAvLyBOb3RlOiByZXNvbHZlZEVuZCBpcyB1bmRlZmluZWQgd2hlbiB0aGUgb3JpZ2luYWwgc2VxdWVuY2UncyBsZW5ndGggaXNcbiAgICAvLyB1bmtub3duIGFuZCB0aGlzIHNsaWNlIGRpZCBub3Qgc3VwcGx5IGFuIGVuZCBhbmQgc2hvdWxkIGNvbnRhaW4gYWxsXG4gICAgLy8gZWxlbWVudHMgYWZ0ZXIgcmVzb2x2ZWRCZWdpbi5cbiAgICAvLyBJbiB0aGF0IGNhc2UsIHJlc29sdmVkU2l6ZSB3aWxsIGJlIE5hTiBhbmQgc2xpY2VTaXplIHdpbGwgcmVtYWluIHVuZGVmaW5lZC5cbiAgICB2YXIgcmVzb2x2ZWRTaXplID0gcmVzb2x2ZWRFbmQgLSByZXNvbHZlZEJlZ2luO1xuICAgIHZhciBzbGljZVNpemU7XG4gICAgaWYgKHJlc29sdmVkU2l6ZSA9PT0gcmVzb2x2ZWRTaXplKSB7XG4gICAgICBzbGljZVNpemUgPSByZXNvbHZlZFNpemUgPCAwID8gMCA6IHJlc29sdmVkU2l6ZTtcbiAgICB9XG5cbiAgICB2YXIgc2xpY2VTZXEgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG5cbiAgICAvLyBJZiBjb2xsZWN0aW9uLnNpemUgaXMgdW5kZWZpbmVkLCB0aGUgc2l6ZSBvZiB0aGUgcmVhbGl6ZWQgc2xpY2VTZXEgaXNcbiAgICAvLyB1bmtub3duIGF0IHRoaXMgcG9pbnQgdW5sZXNzIHRoZSBudW1iZXIgb2YgaXRlbXMgdG8gc2xpY2UgaXMgMFxuICAgIHNsaWNlU2VxLnNpemUgPVxuICAgICAgc2xpY2VTaXplID09PSAwID8gc2xpY2VTaXplIDogKGNvbGxlY3Rpb24uc2l6ZSAmJiBzbGljZVNpemUpIHx8IHVuZGVmaW5lZDtcblxuICAgIGlmICghdXNlS2V5cyAmJiBpc1NlcShjb2xsZWN0aW9uKSAmJiBzbGljZVNpemUgPj0gMCkge1xuICAgICAgc2xpY2VTZXEuZ2V0ID0gZnVuY3Rpb24oaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgJiYgaW5kZXggPCBzbGljZVNpemVcbiAgICAgICAgICA/IGNvbGxlY3Rpb24uZ2V0KGluZGV4ICsgcmVzb2x2ZWRCZWdpbiwgbm90U2V0VmFsdWUpXG4gICAgICAgICAgOiBub3RTZXRWYWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgc2xpY2VTZXEuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIGlmIChzbGljZVNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgc2tpcHBlZCA9IDA7XG4gICAgICB2YXIgaXNTa2lwcGluZyA9IHRydWU7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICBjb2xsZWN0aW9uLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykge1xuICAgICAgICBpZiAoIShpc1NraXBwaW5nICYmIChpc1NraXBwaW5nID0gc2tpcHBlZCsrIDwgcmVzb2x2ZWRCZWdpbikpKSB7XG4gICAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBmbih2LCB1c2VLZXlzID8gayA6IGl0ZXJhdGlvbnMgLSAxLCB0aGlzJDEpICE9PSBmYWxzZSAmJlxuICAgICAgICAgICAgaXRlcmF0aW9ucyAhPT0gc2xpY2VTaXplXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuXG4gICAgc2xpY2VTZXEuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHNsaWNlU2l6ZSAhPT0gMCAmJiByZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIC8vIERvbid0IGJvdGhlciBpbnN0YW50aWF0aW5nIHBhcmVudCBpdGVyYXRvciBpZiB0YWtpbmcgMC5cbiAgICAgIGlmIChzbGljZVNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihpdGVyYXRvckRvbmUpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgdmFyIHNraXBwZWQgPSAwO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlIChza2lwcGVkKysgPCByZXNvbHZlZEJlZ2luKSB7XG4gICAgICAgICAgaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgrK2l0ZXJhdGlvbnMgPiBzbGljZVNpemUpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmICh1c2VLZXlzIHx8IHR5cGUgPT09IElURVJBVEVfVkFMVUVTIHx8IHN0ZXAuZG9uZSkge1xuICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBJVEVSQVRFX0tFWVMpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zIC0gMSwgdW5kZWZpbmVkLCBzdGVwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zIC0gMSwgc3RlcC52YWx1ZVsxXSwgc3RlcCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNsaWNlU2VxO1xuICB9XG5cbiAgZnVuY3Rpb24gdGFrZVdoaWxlRmFjdG9yeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgdGFrZVNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGNvbGxlY3Rpb24pO1xuICAgIHRha2VTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoXG4gICAgICAgIGZ1bmN0aW9uICh2LCBrLCBjKSB7IHJldHVybiBwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSAmJiArK2l0ZXJhdGlvbnMgJiYgZm4odiwgaywgdGhpcyQxKTsgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG4gICAgdGFrZVNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCByZXZlcnNlKTtcbiAgICAgIHZhciBpdGVyYXRpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXRlcmF0aW5nKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgdmFyIGsgPSBlbnRyeVswXTtcbiAgICAgICAgdmFyIHYgPSBlbnRyeVsxXTtcbiAgICAgICAgaWYgKCFwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCB0aGlzJDEpKSB7XG4gICAgICAgICAgaXRlcmF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlID09PSBJVEVSQVRFX0VOVFJJRVMgPyBzdGVwIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCBrLCB2LCBzdGVwKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHRha2VTZXF1ZW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBXaGlsZUZhY3RvcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBjb250ZXh0LCB1c2VLZXlzKSB7XG4gICAgdmFyIHNraXBTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgICBza2lwU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1NraXBwaW5nID0gdHJ1ZTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIGNvbGxlY3Rpb24uX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrLCBjKSB7XG4gICAgICAgIGlmICghKGlzU2tpcHBpbmcgJiYgKGlzU2tpcHBpbmcgPSBwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSkpKSB7XG4gICAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICAgIHJldHVybiBmbih2LCB1c2VLZXlzID8gayA6IGl0ZXJhdGlvbnMgLSAxLCB0aGlzJDEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG4gICAgc2tpcFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCByZXZlcnNlKTtcbiAgICAgIHZhciBza2lwcGluZyA9IHRydWU7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgIHZhciBrO1xuICAgICAgICB2YXIgdjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgICAgaWYgKHVzZUtleXMgfHwgdHlwZSA9PT0gSVRFUkFURV9WQUxVRVMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gSVRFUkFURV9LRVlTKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgdW5kZWZpbmVkLCBzdGVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgc3RlcC52YWx1ZVsxXSwgc3RlcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgayA9IGVudHJ5WzBdO1xuICAgICAgICAgIHYgPSBlbnRyeVsxXTtcbiAgICAgICAgICBza2lwcGluZyAmJiAoc2tpcHBpbmcgPSBwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCB0aGlzJDEpKTtcbiAgICAgICAgfSB3aGlsZSAoc2tpcHBpbmcpO1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTID8gc3RlcCA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaywgdiwgc3RlcCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBza2lwU2VxdWVuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBjb25jYXRGYWN0b3J5KGNvbGxlY3Rpb24sIHZhbHVlcykge1xuICAgIHZhciBpc0tleWVkQ29sbGVjdGlvbiA9IGlzS2V5ZWQoY29sbGVjdGlvbik7XG4gICAgdmFyIGl0ZXJzID0gW2NvbGxlY3Rpb25dXG4gICAgICAuY29uY2F0KHZhbHVlcylcbiAgICAgIC5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKCFpc0NvbGxlY3Rpb24odikpIHtcbiAgICAgICAgICB2ID0gaXNLZXllZENvbGxlY3Rpb25cbiAgICAgICAgICAgID8ga2V5ZWRTZXFGcm9tVmFsdWUodilcbiAgICAgICAgICAgIDogaW5kZXhlZFNlcUZyb21WYWx1ZShBcnJheS5pc0FycmF5KHYpID8gdiA6IFt2XSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNLZXllZENvbGxlY3Rpb24pIHtcbiAgICAgICAgICB2ID0gS2V5ZWRDb2xsZWN0aW9uKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYuc2l6ZSAhPT0gMDsgfSk7XG5cbiAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgc2luZ2xldG9uID0gaXRlcnNbMF07XG4gICAgICBpZiAoXG4gICAgICAgIHNpbmdsZXRvbiA9PT0gY29sbGVjdGlvbiB8fFxuICAgICAgICAoaXNLZXllZENvbGxlY3Rpb24gJiYgaXNLZXllZChzaW5nbGV0b24pKSB8fFxuICAgICAgICAoaXNJbmRleGVkKGNvbGxlY3Rpb24pICYmIGlzSW5kZXhlZChzaW5nbGV0b24pKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBzaW5nbGV0b247XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNvbmNhdFNlcSA9IG5ldyBBcnJheVNlcShpdGVycyk7XG4gICAgaWYgKGlzS2V5ZWRDb2xsZWN0aW9uKSB7XG4gICAgICBjb25jYXRTZXEgPSBjb25jYXRTZXEudG9LZXllZFNlcSgpO1xuICAgIH0gZWxzZSBpZiAoIWlzSW5kZXhlZChjb2xsZWN0aW9uKSkge1xuICAgICAgY29uY2F0U2VxID0gY29uY2F0U2VxLnRvU2V0U2VxKCk7XG4gICAgfVxuICAgIGNvbmNhdFNlcSA9IGNvbmNhdFNlcS5mbGF0dGVuKHRydWUpO1xuICAgIGNvbmNhdFNlcS5zaXplID0gaXRlcnMucmVkdWNlKGZ1bmN0aW9uIChzdW0sIHNlcSkge1xuICAgICAgaWYgKHN1bSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBzaXplID0gc2VxLnNpemU7XG4gICAgICAgIGlmIChzaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gc3VtICsgc2l6ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIDApO1xuICAgIHJldHVybiBjb25jYXRTZXE7XG4gIH1cblxuICBmdW5jdGlvbiBmbGF0dGVuRmFjdG9yeShjb2xsZWN0aW9uLCBkZXB0aCwgdXNlS2V5cykge1xuICAgIHZhciBmbGF0U2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gICAgZmxhdFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBzdG9wcGVkID0gZmFsc2U7XG4gICAgICBmdW5jdGlvbiBmbGF0RGVlcChpdGVyLCBjdXJyZW50RGVwdGgpIHtcbiAgICAgICAgaXRlci5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICBpZiAoKCFkZXB0aCB8fCBjdXJyZW50RGVwdGggPCBkZXB0aCkgJiYgaXNDb2xsZWN0aW9uKHYpKSB7XG4gICAgICAgICAgICBmbGF0RGVlcCh2LCBjdXJyZW50RGVwdGggKyAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICAgICAgaWYgKGZuKHYsIHVzZUtleXMgPyBrIDogaXRlcmF0aW9ucyAtIDEsIGZsYXRTZXF1ZW5jZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gIXN0b3BwZWQ7XG4gICAgICAgIH0sIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgZmxhdERlZXAoY29sbGVjdGlvbiwgMCk7XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuICAgIGZsYXRTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAoaXRlcmF0b3IpIHtcbiAgICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoc3RlcC5kb25lICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaXRlcmF0b3IgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdiA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IElURVJBVEVfRU5UUklFUykge1xuICAgICAgICAgICAgdiA9IHZbMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgoIWRlcHRoIHx8IHN0YWNrLmxlbmd0aCA8IGRlcHRoKSAmJiBpc0NvbGxlY3Rpb24odikpIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goaXRlcmF0b3IpO1xuICAgICAgICAgICAgaXRlcmF0b3IgPSB2Ll9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VLZXlzID8gc3RlcCA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCB2LCBzdGVwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gZmxhdFNlcXVlbmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmxhdE1hcEZhY3RvcnkoY29sbGVjdGlvbiwgbWFwcGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIGNvZXJjZSA9IGNvbGxlY3Rpb25DbGFzcyhjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gY29sbGVjdGlvblxuICAgICAgLnRvU2VxKClcbiAgICAgIC5tYXAoZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIGNvZXJjZShtYXBwZXIuY2FsbChjb250ZXh0LCB2LCBrLCBjb2xsZWN0aW9uKSk7IH0pXG4gICAgICAuZmxhdHRlbih0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVycG9zZUZhY3RvcnkoY29sbGVjdGlvbiwgc2VwYXJhdG9yKSB7XG4gICAgdmFyIGludGVycG9zZWRTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgICBpbnRlcnBvc2VkU2VxdWVuY2Uuc2l6ZSA9IGNvbGxlY3Rpb24uc2l6ZSAmJiBjb2xsZWN0aW9uLnNpemUgKiAyIC0gMTtcbiAgICBpbnRlcnBvc2VkU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIGNvbGxlY3Rpb24uX19pdGVyYXRlKFxuICAgICAgICBmdW5jdGlvbiAodikgeyByZXR1cm4gKCFpdGVyYXRpb25zIHx8IGZuKHNlcGFyYXRvciwgaXRlcmF0aW9ucysrLCB0aGlzJDEpICE9PSBmYWxzZSkgJiZcbiAgICAgICAgICBmbih2LCBpdGVyYXRpb25zKyssIHRoaXMkMSkgIT09IGZhbHNlOyB9LFxuICAgICAgICByZXZlcnNlXG4gICAgICApO1xuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcbiAgICBpbnRlcnBvc2VkU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghc3RlcCB8fCBpdGVyYXRpb25zICUgMikge1xuICAgICAgICAgIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVyYXRpb25zICUgMlxuICAgICAgICAgID8gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHNlcGFyYXRvcilcbiAgICAgICAgICA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCBzdGVwLnZhbHVlLCBzdGVwKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIGludGVycG9zZWRTZXF1ZW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNvcnRGYWN0b3J5KGNvbGxlY3Rpb24sIGNvbXBhcmF0b3IsIG1hcHBlcikge1xuICAgIGlmICghY29tcGFyYXRvcikge1xuICAgICAgY29tcGFyYXRvciA9IGRlZmF1bHRDb21wYXJhdG9yO1xuICAgIH1cbiAgICB2YXIgaXNLZXllZENvbGxlY3Rpb24gPSBpc0tleWVkKGNvbGxlY3Rpb24pO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGVudHJpZXMgPSBjb2xsZWN0aW9uXG4gICAgICAudG9TZXEoKVxuICAgICAgLm1hcChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gW2ssIHYsIGluZGV4KyssIG1hcHBlciA/IG1hcHBlcih2LCBrLCBjb2xsZWN0aW9uKSA6IHZdOyB9KVxuICAgICAgLnZhbHVlU2VxKClcbiAgICAgIC50b0FycmF5KCk7XG4gICAgZW50cmllcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBjb21wYXJhdG9yKGFbM10sIGJbM10pIHx8IGFbMl0gLSBiWzJdOyB9KS5mb3JFYWNoKFxuICAgICAgaXNLZXllZENvbGxlY3Rpb25cbiAgICAgICAgPyBmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICAgICAgZW50cmllc1tpXS5sZW5ndGggPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgOiBmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICAgICAgZW50cmllc1tpXSA9IHZbMV07XG4gICAgICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGlzS2V5ZWRDb2xsZWN0aW9uXG4gICAgICA/IEtleWVkU2VxKGVudHJpZXMpXG4gICAgICA6IGlzSW5kZXhlZChjb2xsZWN0aW9uKVxuICAgICAgICA/IEluZGV4ZWRTZXEoZW50cmllcylcbiAgICAgICAgOiBTZXRTZXEoZW50cmllcyk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXhGYWN0b3J5KGNvbGxlY3Rpb24sIGNvbXBhcmF0b3IsIG1hcHBlcikge1xuICAgIGlmICghY29tcGFyYXRvcikge1xuICAgICAgY29tcGFyYXRvciA9IGRlZmF1bHRDb21wYXJhdG9yO1xuICAgIH1cbiAgICBpZiAobWFwcGVyKSB7XG4gICAgICB2YXIgZW50cnkgPSBjb2xsZWN0aW9uXG4gICAgICAgIC50b1NlcSgpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIFt2LCBtYXBwZXIodiwgaywgY29sbGVjdGlvbildOyB9KVxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAobWF4Q29tcGFyZShjb21wYXJhdG9yLCBhWzFdLCBiWzFdKSA/IGIgOiBhKTsgfSk7XG4gICAgICByZXR1cm4gZW50cnkgJiYgZW50cnlbMF07XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gKG1heENvbXBhcmUoY29tcGFyYXRvciwgYSwgYikgPyBiIDogYSk7IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF4Q29tcGFyZShjb21wYXJhdG9yLCBhLCBiKSB7XG4gICAgdmFyIGNvbXAgPSBjb21wYXJhdG9yKGIsIGEpO1xuICAgIC8vIGIgaXMgY29uc2lkZXJlZCB0aGUgbmV3IG1heCBpZiB0aGUgY29tcGFyYXRvciBkZWNsYXJlcyB0aGVtIGVxdWFsLCBidXRcbiAgICAvLyB0aGV5IGFyZSBub3QgZXF1YWwgYW5kIGIgaXMgaW4gZmFjdCBhIG51bGxpc2ggdmFsdWUuXG4gICAgcmV0dXJuIChcbiAgICAgIChjb21wID09PSAwICYmIGIgIT09IGEgJiYgKGIgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgIT09IGIpKSB8fFxuICAgICAgY29tcCA+IDBcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gemlwV2l0aEZhY3Rvcnkoa2V5SXRlciwgemlwcGVyLCBpdGVycywgemlwQWxsKSB7XG4gICAgdmFyIHppcFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGtleUl0ZXIpO1xuICAgIHZhciBzaXplcyA9IG5ldyBBcnJheVNlcShpdGVycykubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLnNpemU7IH0pO1xuICAgIHppcFNlcXVlbmNlLnNpemUgPSB6aXBBbGwgPyBzaXplcy5tYXgoKSA6IHNpemVzLm1pbigpO1xuICAgIC8vIE5vdGU6IHRoaXMgYSBnZW5lcmljIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgX19pdGVyYXRlIGluIHRlcm1zIG9mXG4gICAgLy8gX19pdGVyYXRvciB3aGljaCBtYXkgYmUgbW9yZSBnZW5lcmljYWxseSB1c2VmdWwgaW4gdGhlIGZ1dHVyZS5cbiAgICB6aXBTZXF1ZW5jZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIC8qIGdlbmVyaWM6XG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCByZXZlcnNlKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgIGlmIChmbihzdGVwLnZhbHVlWzFdLCBzdGVwLnZhbHVlWzBdLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgICAqL1xuICAgICAgLy8gaW5kZXhlZDpcbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgaWYgKGZuKHN0ZXAudmFsdWUsIGl0ZXJhdGlvbnMrKywgdGhpcyQxKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcbiAgICB6aXBTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JzID0gaXRlcnMubWFwKFxuICAgICAgICBmdW5jdGlvbiAoaSkgeyByZXR1cm4gKChpID0gQ29sbGVjdGlvbihpKSksIGdldEl0ZXJhdG9yKHJldmVyc2UgPyBpLnJldmVyc2UoKSA6IGkpKTsgfVxuICAgICAgKTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBpc0RvbmUgPSBmYWxzZTtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RlcHM7XG4gICAgICAgIGlmICghaXNEb25lKSB7XG4gICAgICAgICAgc3RlcHMgPSBpdGVyYXRvcnMubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLm5leHQoKTsgfSk7XG4gICAgICAgICAgaXNEb25lID0gemlwQWxsID8gc3RlcHMuZXZlcnkoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMuZG9uZTsgfSkgOiBzdGVwcy5zb21lKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLmRvbmU7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RvbmUpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBpdGVyYXRpb25zKyssXG4gICAgICAgICAgemlwcGVyLmFwcGx5KG51bGwsIHN0ZXBzLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcy52YWx1ZTsgfSkpXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiB6aXBTZXF1ZW5jZTtcbiAgfVxuXG4gIC8vICNwcmFnbWEgSGVscGVyIEZ1bmN0aW9uc1xuXG4gIGZ1bmN0aW9uIHJlaWZ5KGl0ZXIsIHNlcSkge1xuICAgIHJldHVybiBpdGVyID09PSBzZXEgPyBpdGVyIDogaXNTZXEoaXRlcikgPyBzZXEgOiBpdGVyLmNvbnN0cnVjdG9yKHNlcSk7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZUVudHJ5KGVudHJ5KSB7XG4gICAgaWYgKGVudHJ5ICE9PSBPYmplY3QoZW50cnkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBbSywgVl0gdHVwbGU6ICcgKyBlbnRyeSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29sbGVjdGlvbkNsYXNzKGNvbGxlY3Rpb24pIHtcbiAgICByZXR1cm4gaXNLZXllZChjb2xsZWN0aW9uKVxuICAgICAgPyBLZXllZENvbGxlY3Rpb25cbiAgICAgIDogaXNJbmRleGVkKGNvbGxlY3Rpb24pXG4gICAgICAgID8gSW5kZXhlZENvbGxlY3Rpb25cbiAgICAgICAgOiBTZXRDb2xsZWN0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZVNlcXVlbmNlKGNvbGxlY3Rpb24pIHtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShcbiAgICAgIChpc0tleWVkKGNvbGxlY3Rpb24pXG4gICAgICAgID8gS2V5ZWRTZXFcbiAgICAgICAgOiBpc0luZGV4ZWQoY29sbGVjdGlvbilcbiAgICAgICAgICA/IEluZGV4ZWRTZXFcbiAgICAgICAgICA6IFNldFNlcVxuICAgICAgKS5wcm90b3R5cGVcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FjaGVSZXN1bHRUaHJvdWdoKCkge1xuICAgIGlmICh0aGlzLl9pdGVyLmNhY2hlUmVzdWx0KSB7XG4gICAgICB0aGlzLl9pdGVyLmNhY2hlUmVzdWx0KCk7XG4gICAgICB0aGlzLnNpemUgPSB0aGlzLl9pdGVyLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNlcS5wcm90b3R5cGUuY2FjaGVSZXN1bHQuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRDb21wYXJhdG9yKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbiAgfVxuXG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2NvcHktYXJyYXktaW5saW5lXG4gIGZ1bmN0aW9uIGFyckNvcHkoYXJyLCBvZmZzZXQpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICB2YXIgbGVuID0gTWF0aC5tYXgoMCwgYXJyLmxlbmd0aCAtIG9mZnNldCk7XG4gICAgdmFyIG5ld0FyciA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBsZW47IGlpKyspIHtcbiAgICAgIG5ld0FycltpaV0gPSBhcnJbaWkgKyBvZmZzZXRdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3QXJyO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZXJyb3IpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikgeyB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb3RJbmZpbml0ZShzaXplKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgc2l6ZSAhPT0gSW5maW5pdHksXG4gICAgICAnQ2Fubm90IHBlcmZvcm0gdGhpcyBhY3Rpb24gd2l0aCBhbiBpbmZpbml0ZSBzaXplLidcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY29lcmNlS2V5UGF0aChrZXlQYXRoKSB7XG4gICAgaWYgKGlzQXJyYXlMaWtlKGtleVBhdGgpICYmIHR5cGVvZiBrZXlQYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGtleVBhdGg7XG4gICAgfVxuICAgIGlmIChpc09yZGVyZWQoa2V5UGF0aCkpIHtcbiAgICAgIHJldHVybiBrZXlQYXRoLnRvQXJyYXkoKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdJbnZhbGlkIGtleVBhdGg6IGV4cGVjdGVkIE9yZGVyZWQgQ29sbGVjdGlvbiBvciBBcnJheTogJyArIGtleVBhdGhcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNQbGFpbk9iaih2YWx1ZSkge1xuICAgIHJldHVybiAoXG4gICAgICB2YWx1ZSAmJlxuICAgICAgKCh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0JykgfHxcbiAgICAgICAgdmFsdWUuY29uc3RydWN0b3IgPT09IHVuZGVmaW5lZClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBwb3RlbnRpYWxseS1wZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJlLCBlaXRoZXJcbiAgICogcHJvdmlkZWQgYnkgSW1tdXRhYmxlLmpzIG9yIGEgcGxhaW4gQXJyYXkgb3IgT2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gaXNEYXRhU3RydWN0dXJlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIChpc0ltbXV0YWJsZSh2YWx1ZSkgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iaih2YWx1ZSkpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHZhbHVlIHRvIGEgc3RyaW5nLCBhZGRpbmcgcXVvdGVzIGlmIGEgc3RyaW5nIHdhcyBwcm92aWRlZC5cbiAgICovXG4gIGZ1bmN0aW9uIHF1b3RlU3RyaW5nKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogU3RyaW5nKHZhbHVlKTtcbiAgICB9IGNhdGNoIChfaWdub3JlRXJyb3IpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFzKGNvbGxlY3Rpb24sIGtleSkge1xuICAgIHJldHVybiBpc0ltbXV0YWJsZShjb2xsZWN0aW9uKVxuICAgICAgPyBjb2xsZWN0aW9uLmhhcyhrZXkpXG4gICAgICA6IGlzRGF0YVN0cnVjdHVyZShjb2xsZWN0aW9uKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbGxlY3Rpb24sIGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXQoY29sbGVjdGlvbiwga2V5LCBub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiBpc0ltbXV0YWJsZShjb2xsZWN0aW9uKVxuICAgICAgPyBjb2xsZWN0aW9uLmdldChrZXksIG5vdFNldFZhbHVlKVxuICAgICAgOiAhaGFzKGNvbGxlY3Rpb24sIGtleSlcbiAgICAgICAgPyBub3RTZXRWYWx1ZVxuICAgICAgICA6IHR5cGVvZiBjb2xsZWN0aW9uLmdldCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gY29sbGVjdGlvbi5nZXQoa2V5KVxuICAgICAgICAgIDogY29sbGVjdGlvbltrZXldO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hhbGxvd0NvcHkoZnJvbSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZyb20pKSB7XG4gICAgICByZXR1cm4gYXJyQ29weShmcm9tKTtcbiAgICB9XG4gICAgdmFyIHRvID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcbiAgICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlKGNvbGxlY3Rpb24sIGtleSkge1xuICAgIGlmICghaXNEYXRhU3RydWN0dXJlKGNvbGxlY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnQ2Fubm90IHVwZGF0ZSBub24tZGF0YS1zdHJ1Y3R1cmUgdmFsdWU6ICcgKyBjb2xsZWN0aW9uXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoaXNJbW11dGFibGUoY29sbGVjdGlvbikpIHtcbiAgICAgIGlmICghY29sbGVjdGlvbi5yZW1vdmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnQ2Fubm90IHVwZGF0ZSBpbW11dGFibGUgdmFsdWUgd2l0aG91dCAucmVtb3ZlKCkgbWV0aG9kOiAnICsgY29sbGVjdGlvblxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24ucmVtb3ZlKGtleSk7XG4gICAgfVxuICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChjb2xsZWN0aW9uLCBrZXkpKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgdmFyIGNvbGxlY3Rpb25Db3B5ID0gc2hhbGxvd0NvcHkoY29sbGVjdGlvbik7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29sbGVjdGlvbkNvcHkpKSB7XG4gICAgICBjb2xsZWN0aW9uQ29weS5zcGxpY2Uoa2V5LCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIGNvbGxlY3Rpb25Db3B5W2tleV07XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uQ29weTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldChjb2xsZWN0aW9uLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKCFpc0RhdGFTdHJ1Y3R1cmUoY29sbGVjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdDYW5ub3QgdXBkYXRlIG5vbi1kYXRhLXN0cnVjdHVyZSB2YWx1ZTogJyArIGNvbGxlY3Rpb25cbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpc0ltbXV0YWJsZShjb2xsZWN0aW9uKSkge1xuICAgICAgaWYgKCFjb2xsZWN0aW9uLnNldCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdDYW5ub3QgdXBkYXRlIGltbXV0YWJsZSB2YWx1ZSB3aXRob3V0IC5zZXQoKSBtZXRob2Q6ICcgKyBjb2xsZWN0aW9uXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbGxlY3Rpb24sIGtleSkgJiYgdmFsdWUgPT09IGNvbGxlY3Rpb25ba2V5XSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIHZhciBjb2xsZWN0aW9uQ29weSA9IHNoYWxsb3dDb3B5KGNvbGxlY3Rpb24pO1xuICAgIGNvbGxlY3Rpb25Db3B5W2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gY29sbGVjdGlvbkNvcHk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVJbihjb2xsZWN0aW9uLCBrZXlQYXRoLCBub3RTZXRWYWx1ZSwgdXBkYXRlcikge1xuICAgIGlmICghdXBkYXRlcikge1xuICAgICAgdXBkYXRlciA9IG5vdFNldFZhbHVlO1xuICAgICAgbm90U2V0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHZhciB1cGRhdGVkVmFsdWUgPSB1cGRhdGVJbkRlZXBseShcbiAgICAgIGlzSW1tdXRhYmxlKGNvbGxlY3Rpb24pLFxuICAgICAgY29sbGVjdGlvbixcbiAgICAgIGNvZXJjZUtleVBhdGgoa2V5UGF0aCksXG4gICAgICAwLFxuICAgICAgbm90U2V0VmFsdWUsXG4gICAgICB1cGRhdGVyXG4gICAgKTtcbiAgICByZXR1cm4gdXBkYXRlZFZhbHVlID09PSBOT1RfU0VUID8gbm90U2V0VmFsdWUgOiB1cGRhdGVkVmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVJbkRlZXBseShcbiAgICBpbkltbXV0YWJsZSxcbiAgICBleGlzdGluZyxcbiAgICBrZXlQYXRoLFxuICAgIGksXG4gICAgbm90U2V0VmFsdWUsXG4gICAgdXBkYXRlclxuICApIHtcbiAgICB2YXIgd2FzTm90U2V0ID0gZXhpc3RpbmcgPT09IE5PVF9TRVQ7XG4gICAgaWYgKGkgPT09IGtleVBhdGgubGVuZ3RoKSB7XG4gICAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IHdhc05vdFNldCA/IG5vdFNldFZhbHVlIDogZXhpc3Rpbmc7XG4gICAgICB2YXIgbmV3VmFsdWUgPSB1cGRhdGVyKGV4aXN0aW5nVmFsdWUpO1xuICAgICAgcmV0dXJuIG5ld1ZhbHVlID09PSBleGlzdGluZ1ZhbHVlID8gZXhpc3RpbmcgOiBuZXdWYWx1ZTtcbiAgICB9XG4gICAgaWYgKCF3YXNOb3RTZXQgJiYgIWlzRGF0YVN0cnVjdHVyZShleGlzdGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdDYW5ub3QgdXBkYXRlIHdpdGhpbiBub24tZGF0YS1zdHJ1Y3R1cmUgdmFsdWUgaW4gcGF0aCBbJyArXG4gICAgICAgICAga2V5UGF0aC5zbGljZSgwLCBpKS5tYXAocXVvdGVTdHJpbmcpICtcbiAgICAgICAgICAnXTogJyArXG4gICAgICAgICAgZXhpc3RpbmdcbiAgICAgICk7XG4gICAgfVxuICAgIHZhciBrZXkgPSBrZXlQYXRoW2ldO1xuICAgIHZhciBuZXh0RXhpc3RpbmcgPSB3YXNOb3RTZXQgPyBOT1RfU0VUIDogZ2V0KGV4aXN0aW5nLCBrZXksIE5PVF9TRVQpO1xuICAgIHZhciBuZXh0VXBkYXRlZCA9IHVwZGF0ZUluRGVlcGx5KFxuICAgICAgbmV4dEV4aXN0aW5nID09PSBOT1RfU0VUID8gaW5JbW11dGFibGUgOiBpc0ltbXV0YWJsZShuZXh0RXhpc3RpbmcpLFxuICAgICAgbmV4dEV4aXN0aW5nLFxuICAgICAga2V5UGF0aCxcbiAgICAgIGkgKyAxLFxuICAgICAgbm90U2V0VmFsdWUsXG4gICAgICB1cGRhdGVyXG4gICAgKTtcbiAgICByZXR1cm4gbmV4dFVwZGF0ZWQgPT09IG5leHRFeGlzdGluZ1xuICAgICAgPyBleGlzdGluZ1xuICAgICAgOiBuZXh0VXBkYXRlZCA9PT0gTk9UX1NFVFxuICAgICAgICA/IHJlbW92ZShleGlzdGluZywga2V5KVxuICAgICAgICA6IHNldChcbiAgICAgICAgICAgIHdhc05vdFNldCA/IChpbkltbXV0YWJsZSA/IGVtcHR5TWFwKCkgOiB7fSkgOiBleGlzdGluZyxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIG5leHRVcGRhdGVkXG4gICAgICAgICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEluKGNvbGxlY3Rpb24sIGtleVBhdGgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZUluKGNvbGxlY3Rpb24sIGtleVBhdGgsIE5PVF9TRVQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEluJDEoa2V5UGF0aCwgdikge1xuICAgIHJldHVybiBzZXRJbih0aGlzLCBrZXlQYXRoLCB2KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUluKGNvbGxlY3Rpb24sIGtleVBhdGgpIHtcbiAgICByZXR1cm4gdXBkYXRlSW4oY29sbGVjdGlvbiwga2V5UGF0aCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gTk9UX1NFVDsgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVJbihrZXlQYXRoKSB7XG4gICAgcmV0dXJuIHJlbW92ZUluKHRoaXMsIGtleVBhdGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlKGNvbGxlY3Rpb24sIGtleSwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpIHtcbiAgICByZXR1cm4gdXBkYXRlSW4oY29sbGVjdGlvbiwgW2tleV0sIG5vdFNldFZhbHVlLCB1cGRhdGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZSQxKGtleSwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgICAgPyBrZXkodGhpcylcbiAgICAgIDogdXBkYXRlKHRoaXMsIGtleSwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlSW4kMShrZXlQYXRoLCBub3RTZXRWYWx1ZSwgdXBkYXRlcikge1xuICAgIHJldHVybiB1cGRhdGVJbih0aGlzLCBrZXlQYXRoLCBub3RTZXRWYWx1ZSwgdXBkYXRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZSgpIHtcbiAgICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHJldHVybiBtZXJnZUludG9LZXllZFdpdGgodGhpcywgaXRlcnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VXaXRoKG1lcmdlcikge1xuICAgIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoIGxlbi0tID4gMCApIGl0ZXJzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gICAgaWYgKHR5cGVvZiBtZXJnZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWVyZ2VyIGZ1bmN0aW9uOiAnICsgbWVyZ2VyKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlSW50b0tleWVkV2l0aCh0aGlzLCBpdGVycywgbWVyZ2VyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlSW50b0tleWVkV2l0aChjb2xsZWN0aW9uLCBjb2xsZWN0aW9ucywgbWVyZ2VyKSB7XG4gICAgdmFyIGl0ZXJzID0gW107XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGNvbGxlY3Rpb25zLmxlbmd0aDsgaWkrKykge1xuICAgICAgdmFyIGNvbGxlY3Rpb24kMSA9IEtleWVkQ29sbGVjdGlvbihjb2xsZWN0aW9uc1tpaV0pO1xuICAgICAgaWYgKGNvbGxlY3Rpb24kMS5zaXplICE9PSAwKSB7XG4gICAgICAgIGl0ZXJzLnB1c2goY29sbGVjdGlvbiQxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmIChcbiAgICAgIGNvbGxlY3Rpb24udG9TZXEoKS5zaXplID09PSAwICYmXG4gICAgICAhY29sbGVjdGlvbi5fX293bmVySUQgJiZcbiAgICAgIGl0ZXJzLmxlbmd0aCA9PT0gMVxuICAgICkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uY29uc3RydWN0b3IoaXRlcnNbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbi53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgbWVyZ2VJbnRvQ29sbGVjdGlvbiA9IG1lcmdlclxuICAgICAgICA/IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICB1cGRhdGUoXG4gICAgICAgICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgTk9UX1NFVCxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKG9sZFZhbCkgeyByZXR1cm4gKG9sZFZhbCA9PT0gTk9UX1NFVCA/IHZhbHVlIDogbWVyZ2VyKG9sZFZhbCwgdmFsdWUsIGtleSkpOyB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgOiBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgY29sbGVjdGlvbi5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfTtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBpdGVycy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgaXRlcnNbaWldLmZvckVhY2gobWVyZ2VJbnRvQ29sbGVjdGlvbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZSQxKGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgc291cmNlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoIGxlbi0tID4gMCApIHNvdXJjZXNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgICByZXR1cm4gbWVyZ2VXaXRoU291cmNlcyhjb2xsZWN0aW9uLCBzb3VyY2VzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlV2l0aCQxKG1lcmdlciwgY29sbGVjdGlvbikge1xuICAgIHZhciBzb3VyY2VzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgIHdoaWxlICggbGVuLS0gPiAwICkgc291cmNlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDIgXTtcblxuICAgIHJldHVybiBtZXJnZVdpdGhTb3VyY2VzKGNvbGxlY3Rpb24sIHNvdXJjZXMsIG1lcmdlcik7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZURlZXAoY29sbGVjdGlvbikge1xuICAgIHZhciBzb3VyY2VzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgIHdoaWxlICggbGVuLS0gPiAwICkgc291cmNlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICAgIHJldHVybiBtZXJnZURlZXBXaXRoU291cmNlcyhjb2xsZWN0aW9uLCBzb3VyY2VzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcFdpdGgobWVyZ2VyLCBjb2xsZWN0aW9uKSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgd2hpbGUgKCBsZW4tLSA+IDAgKSBzb3VyY2VzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMiBdO1xuXG4gICAgcmV0dXJuIG1lcmdlRGVlcFdpdGhTb3VyY2VzKGNvbGxlY3Rpb24sIHNvdXJjZXMsIG1lcmdlcik7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZURlZXBXaXRoU291cmNlcyhjb2xsZWN0aW9uLCBzb3VyY2VzLCBtZXJnZXIpIHtcbiAgICByZXR1cm4gbWVyZ2VXaXRoU291cmNlcyhjb2xsZWN0aW9uLCBzb3VyY2VzLCBkZWVwTWVyZ2VyV2l0aChtZXJnZXIpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlV2l0aFNvdXJjZXMoY29sbGVjdGlvbiwgc291cmNlcywgbWVyZ2VyKSB7XG4gICAgaWYgKCFpc0RhdGFTdHJ1Y3R1cmUoY29sbGVjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdDYW5ub3QgbWVyZ2UgaW50byBub24tZGF0YS1zdHJ1Y3R1cmUgdmFsdWU6ICcgKyBjb2xsZWN0aW9uXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoaXNJbW11dGFibGUoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgbWVyZ2VyID09PSAnZnVuY3Rpb24nICYmIGNvbGxlY3Rpb24ubWVyZ2VXaXRoXG4gICAgICAgID8gY29sbGVjdGlvbi5tZXJnZVdpdGguYXBwbHkoY29sbGVjdGlvbiwgWyBtZXJnZXIgXS5jb25jYXQoIHNvdXJjZXMgKSlcbiAgICAgICAgOiBjb2xsZWN0aW9uLm1lcmdlXG4gICAgICAgICAgPyBjb2xsZWN0aW9uLm1lcmdlLmFwcGx5KGNvbGxlY3Rpb24sIHNvdXJjZXMpXG4gICAgICAgICAgOiBjb2xsZWN0aW9uLmNvbmNhdC5hcHBseShjb2xsZWN0aW9uLCBzb3VyY2VzKTtcbiAgICB9XG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGNvbGxlY3Rpb24pO1xuICAgIHZhciBtZXJnZWQgPSBjb2xsZWN0aW9uO1xuICAgIHZhciBDb2xsZWN0aW9uJCQxID0gaXNBcnJheSA/IEluZGV4ZWRDb2xsZWN0aW9uIDogS2V5ZWRDb2xsZWN0aW9uO1xuICAgIHZhciBtZXJnZUl0ZW0gPSBpc0FycmF5XG4gICAgICA/IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIC8vIENvcHkgb24gd3JpdGVcbiAgICAgICAgICBpZiAobWVyZ2VkID09PSBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICBtZXJnZWQgPSBzaGFsbG93Q29weShtZXJnZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZXJnZWQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIDogZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICB2YXIgaGFzVmFsID0gaGFzT3duUHJvcGVydHkuY2FsbChtZXJnZWQsIGtleSk7XG4gICAgICAgICAgdmFyIG5leHRWYWwgPVxuICAgICAgICAgICAgaGFzVmFsICYmIG1lcmdlciA/IG1lcmdlcihtZXJnZWRba2V5XSwgdmFsdWUsIGtleSkgOiB2YWx1ZTtcbiAgICAgICAgICBpZiAoIWhhc1ZhbCB8fCBuZXh0VmFsICE9PSBtZXJnZWRba2V5XSkge1xuICAgICAgICAgICAgLy8gQ29weSBvbiB3cml0ZVxuICAgICAgICAgICAgaWYgKG1lcmdlZCA9PT0gY29sbGVjdGlvbikge1xuICAgICAgICAgICAgICBtZXJnZWQgPSBzaGFsbG93Q29weShtZXJnZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVyZ2VkW2tleV0gPSBuZXh0VmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIENvbGxlY3Rpb24kJDEoc291cmNlc1tpXSkuZm9yRWFjaChtZXJnZUl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVlcE1lcmdlcldpdGgobWVyZ2VyKSB7XG4gICAgZnVuY3Rpb24gZGVlcE1lcmdlcihvbGRWYWx1ZSwgbmV3VmFsdWUsIGtleSkge1xuICAgICAgcmV0dXJuIGlzRGF0YVN0cnVjdHVyZShvbGRWYWx1ZSkgJiYgaXNEYXRhU3RydWN0dXJlKG5ld1ZhbHVlKVxuICAgICAgICA/IG1lcmdlV2l0aFNvdXJjZXMob2xkVmFsdWUsIFtuZXdWYWx1ZV0sIGRlZXBNZXJnZXIpXG4gICAgICAgIDogbWVyZ2VyXG4gICAgICAgICAgPyBtZXJnZXIob2xkVmFsdWUsIG5ld1ZhbHVlLCBrZXkpXG4gICAgICAgICAgOiBuZXdWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZXBNZXJnZXI7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZURlZXAkMSgpIHtcbiAgICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHJldHVybiBtZXJnZURlZXBXaXRoU291cmNlcyh0aGlzLCBpdGVycyk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZURlZXBXaXRoJDEobWVyZ2VyKSB7XG4gICAgdmFyIGl0ZXJzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgIHdoaWxlICggbGVuLS0gPiAwICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgICByZXR1cm4gbWVyZ2VEZWVwV2l0aFNvdXJjZXModGhpcywgaXRlcnMsIG1lcmdlcik7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUluKGtleVBhdGgpIHtcbiAgICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKCBsZW4tLSA+IDAgKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICAgIHJldHVybiB1cGRhdGVJbih0aGlzLCBrZXlQYXRoLCBlbXB0eU1hcCgpLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gbWVyZ2VXaXRoU291cmNlcyhtLCBpdGVycyk7IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VEZWVwSW4oa2V5UGF0aCkge1xuICAgIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoIGxlbi0tID4gMCApIGl0ZXJzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gICAgcmV0dXJuIHVwZGF0ZUluKHRoaXMsIGtleVBhdGgsIGVtcHR5TWFwKCksIGZ1bmN0aW9uIChtKSB7IHJldHVybiBtZXJnZURlZXBXaXRoU291cmNlcyhtLCBpdGVycyk7IH1cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gd2l0aE11dGF0aW9ucyhmbikge1xuICAgIHZhciBtdXRhYmxlID0gdGhpcy5hc011dGFibGUoKTtcbiAgICBmbihtdXRhYmxlKTtcbiAgICByZXR1cm4gbXV0YWJsZS53YXNBbHRlcmVkKCkgPyBtdXRhYmxlLl9fZW5zdXJlT3duZXIodGhpcy5fX293bmVySUQpIDogdGhpcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzTXV0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX293bmVySUQgPyB0aGlzIDogdGhpcy5fX2Vuc3VyZU93bmVyKG5ldyBPd25lcklEKCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNJbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19lbnN1cmVPd25lcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FzQWx0ZXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2FsdGVyZWQ7XG4gIH1cblxuICB2YXIgTWFwID0gKGZ1bmN0aW9uIChLZXllZENvbGxlY3Rpb24kJDEpIHtcbiAgICBmdW5jdGlvbiBNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gZW1wdHlNYXAoKVxuICAgICAgICA6IGlzTWFwKHZhbHVlKSAmJiAhaXNPcmRlcmVkKHZhbHVlKVxuICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICA6IGVtcHR5TWFwKCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICAgIHZhciBpdGVyID0gS2V5ZWRDb2xsZWN0aW9uJCQxKHZhbHVlKTtcbiAgICAgICAgICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgICAgICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBtYXAuc2V0KGssIHYpOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICggS2V5ZWRDb2xsZWN0aW9uJCQxICkgTWFwLl9fcHJvdG9fXyA9IEtleWVkQ29sbGVjdGlvbiQkMTtcbiAgICBNYXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggS2V5ZWRDb2xsZWN0aW9uJCQxICYmIEtleWVkQ29sbGVjdGlvbiQkMS5wcm90b3R5cGUgKTtcbiAgICBNYXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWFwO1xuXG4gICAgTWFwLm9mID0gZnVuY3Rpb24gb2YgKCkge1xuICAgICAgdmFyIGtleVZhbHVlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIGtleVZhbHVlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICByZXR1cm4gZW1wdHlNYXAoKS53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlWYWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICBpZiAoaSArIDEgPj0ga2V5VmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHZhbHVlIGZvciBrZXk6ICcgKyBrZXlWYWx1ZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXAuc2V0KGtleVZhbHVlc1tpXSwga2V5VmFsdWVzW2kgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnTWFwIHsnLCAnfScpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIEFjY2Vzc1xuXG4gICAgTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGssIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcm9vdFxuICAgICAgICA/IHRoaXMuX3Jvb3QuZ2V0KDAsIHVuZGVmaW5lZCwgaywgbm90U2V0VmFsdWUpXG4gICAgICAgIDogbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgICBNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoaywgdikge1xuICAgICAgcmV0dXJuIHVwZGF0ZU1hcCh0aGlzLCBrLCB2KTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKGspIHtcbiAgICAgIHJldHVybiB1cGRhdGVNYXAodGhpcywgaywgTk9UX1NFVCk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuZGVsZXRlQWxsID0gZnVuY3Rpb24gZGVsZXRlQWxsIChrZXlzKSB7XG4gICAgICB2YXIgY29sbGVjdGlvbiA9IENvbGxlY3Rpb24oa2V5cyk7XG5cbiAgICAgIGlmIChjb2xsZWN0aW9uLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICBjb2xsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gbWFwLnJlbW92ZShrZXkpOyB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlNYXAoKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBDb21wb3NpdGlvblxuXG4gICAgTWFwLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gc29ydCAoY29tcGFyYXRvcikge1xuICAgICAgLy8gTGF0ZSBiaW5kaW5nXG4gICAgICByZXR1cm4gT3JkZXJlZE1hcChzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yKSk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuc29ydEJ5ID0gZnVuY3Rpb24gc29ydEJ5IChtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICAgIC8vIExhdGUgYmluZGluZ1xuICAgICAgcmV0dXJuIE9yZGVyZWRNYXAoc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvciwgbWFwcGVyKSk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICBtYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgIG1hcC5zZXQoa2V5LCBtYXBwZXIuY2FsbChjb250ZXh0LCB2YWx1ZSwga2V5LCBtYXApKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBNdXRhYmlsaXR5XG5cbiAgICBNYXAucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKHRoaXMsIHR5cGUsIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB0aGlzLl9yb290ICYmXG4gICAgICAgIHRoaXMuX3Jvb3QuaXRlcmF0ZShmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgICAgcmV0dXJuIGZuKGVudHJ5WzFdLCBlbnRyeVswXSwgdGhpcyQxKTtcbiAgICAgICAgfSwgcmV2ZXJzZSk7XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24gX19lbnN1cmVPd25lciAob3duZXJJRCkge1xuICAgICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKCFvd25lcklEKSB7XG4gICAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZW1wdHlNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VNYXAodGhpcy5zaXplLCB0aGlzLl9yb290LCBvd25lcklELCB0aGlzLl9faGFzaCk7XG4gICAgfTtcblxuICAgIHJldHVybiBNYXA7XG4gIH0oS2V5ZWRDb2xsZWN0aW9uKSk7XG5cbiAgTWFwLmlzTWFwID0gaXNNYXA7XG5cbiAgdmFyIE1hcFByb3RvdHlwZSA9IE1hcC5wcm90b3R5cGU7XG4gIE1hcFByb3RvdHlwZVtJU19NQVBfU1lNQk9MXSA9IHRydWU7XG4gIE1hcFByb3RvdHlwZVtERUxFVEVdID0gTWFwUHJvdG90eXBlLnJlbW92ZTtcbiAgTWFwUHJvdG90eXBlLnJlbW92ZUFsbCA9IE1hcFByb3RvdHlwZS5kZWxldGVBbGw7XG4gIE1hcFByb3RvdHlwZS5zZXRJbiA9IHNldEluJDE7XG4gIE1hcFByb3RvdHlwZS5yZW1vdmVJbiA9IE1hcFByb3RvdHlwZS5kZWxldGVJbiA9IGRlbGV0ZUluO1xuICBNYXBQcm90b3R5cGUudXBkYXRlID0gdXBkYXRlJDE7XG4gIE1hcFByb3RvdHlwZS51cGRhdGVJbiA9IHVwZGF0ZUluJDE7XG4gIE1hcFByb3RvdHlwZS5tZXJnZSA9IE1hcFByb3RvdHlwZS5jb25jYXQgPSBtZXJnZTtcbiAgTWFwUHJvdG90eXBlLm1lcmdlV2l0aCA9IG1lcmdlV2l0aDtcbiAgTWFwUHJvdG90eXBlLm1lcmdlRGVlcCA9IG1lcmdlRGVlcCQxO1xuICBNYXBQcm90b3R5cGUubWVyZ2VEZWVwV2l0aCA9IG1lcmdlRGVlcFdpdGgkMTtcbiAgTWFwUHJvdG90eXBlLm1lcmdlSW4gPSBtZXJnZUluO1xuICBNYXBQcm90b3R5cGUubWVyZ2VEZWVwSW4gPSBtZXJnZURlZXBJbjtcbiAgTWFwUHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSB3aXRoTXV0YXRpb25zO1xuICBNYXBQcm90b3R5cGUud2FzQWx0ZXJlZCA9IHdhc0FsdGVyZWQ7XG4gIE1hcFByb3RvdHlwZS5hc0ltbXV0YWJsZSA9IGFzSW1tdXRhYmxlO1xuICBNYXBQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBNYXBQcm90b3R5cGUuYXNNdXRhYmxlID0gYXNNdXRhYmxlO1xuICBNYXBQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGFycikge1xuICAgIHJldHVybiByZXN1bHQuc2V0KGFyclswXSwgYXJyWzFdKTtcbiAgfTtcbiAgTWFwUHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqLmFzSW1tdXRhYmxlKCk7XG4gIH07XG5cbiAgLy8gI3ByYWdtYSBUcmllIE5vZGVzXG5cbiAgdmFyIEFycmF5TWFwTm9kZSA9IGZ1bmN0aW9uIEFycmF5TWFwTm9kZShvd25lcklELCBlbnRyaWVzKSB7XG4gICAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICB9O1xuXG4gIEFycmF5TWFwTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICAgIGZvciAodmFyIGlpID0gMCwgbGVuID0gZW50cmllcy5sZW5ndGg7IGlpIDwgbGVuOyBpaSsrKSB7XG4gICAgICBpZiAoaXMoa2V5LCBlbnRyaWVzW2lpXVswXSkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJpZXNbaWldWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm90U2V0VmFsdWU7XG4gIH07XG5cbiAgQXJyYXlNYXBOb2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuICAgIHZhciByZW1vdmVkID0gdmFsdWUgPT09IE5PVF9TRVQ7XG5cbiAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgICB2YXIgaWR4ID0gMDtcbiAgICB2YXIgbGVuID0gZW50cmllcy5sZW5ndGg7XG4gICAgZm9yICg7IGlkeCA8IGxlbjsgaWR4KyspIHtcbiAgICAgIGlmIChpcyhrZXksIGVudHJpZXNbaWR4XVswXSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBleGlzdHMgPSBpZHggPCBsZW47XG5cbiAgICBpZiAoZXhpc3RzID8gZW50cmllc1tpZHhdWzFdID09PSB2YWx1ZSA6IHJlbW92ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIFNldFJlZihkaWRBbHRlcik7XG4gICAgKHJlbW92ZWQgfHwgIWV4aXN0cykgJiYgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuXG4gICAgaWYgKHJlbW92ZWQgJiYgZW50cmllcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgaWYgKCFleGlzdHMgJiYgIXJlbW92ZWQgJiYgZW50cmllcy5sZW5ndGggPj0gTUFYX0FSUkFZX01BUF9TSVpFKSB7XG4gICAgICByZXR1cm4gY3JlYXRlTm9kZXMob3duZXJJRCwgZW50cmllcywga2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgdmFyIGlzRWRpdGFibGUgPSBvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRDtcbiAgICB2YXIgbmV3RW50cmllcyA9IGlzRWRpdGFibGUgPyBlbnRyaWVzIDogYXJyQ29weShlbnRyaWVzKTtcblxuICAgIGlmIChleGlzdHMpIHtcbiAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgIGlkeCA9PT0gbGVuIC0gMVxuICAgICAgICAgID8gbmV3RW50cmllcy5wb3AoKVxuICAgICAgICAgIDogKG5ld0VudHJpZXNbaWR4XSA9IG5ld0VudHJpZXMucG9wKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3RW50cmllc1tpZHhdID0gW2tleSwgdmFsdWVdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdFbnRyaWVzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICB9XG5cbiAgICBpZiAoaXNFZGl0YWJsZSkge1xuICAgICAgdGhpcy5lbnRyaWVzID0gbmV3RW50cmllcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQXJyYXlNYXBOb2RlKG93bmVySUQsIG5ld0VudHJpZXMpO1xuICB9O1xuXG4gIHZhciBCaXRtYXBJbmRleGVkTm9kZSA9IGZ1bmN0aW9uIEJpdG1hcEluZGV4ZWROb2RlKG93bmVySUQsIGJpdG1hcCwgbm9kZXMpIHtcbiAgICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuICAgIHRoaXMuYml0bWFwID0gYml0bWFwO1xuICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgfTtcblxuICBCaXRtYXBJbmRleGVkTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICAgIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gICAgfVxuICAgIHZhciBiaXQgPSAxIDw8ICgoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSyk7XG4gICAgdmFyIGJpdG1hcCA9IHRoaXMuYml0bWFwO1xuICAgIHJldHVybiAoYml0bWFwICYgYml0KSA9PT0gMFxuICAgICAgPyBub3RTZXRWYWx1ZVxuICAgICAgOiB0aGlzLm5vZGVzW3BvcENvdW50KGJpdG1hcCAmIChiaXQgLSAxKSldLmdldChcbiAgICAgICAgICBzaGlmdCArIFNISUZULFxuICAgICAgICAgIGtleUhhc2gsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIG5vdFNldFZhbHVlXG4gICAgICAgICk7XG4gIH07XG5cbiAgQml0bWFwSW5kZXhlZE5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gICAgaWYgKGtleUhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5SGFzaCA9IGhhc2goa2V5KTtcbiAgICB9XG4gICAgdmFyIGtleUhhc2hGcmFnID0gKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG4gICAgdmFyIGJpdCA9IDEgPDwga2V5SGFzaEZyYWc7XG4gICAgdmFyIGJpdG1hcCA9IHRoaXMuYml0bWFwO1xuICAgIHZhciBleGlzdHMgPSAoYml0bWFwICYgYml0KSAhPT0gMDtcblxuICAgIGlmICghZXhpc3RzICYmIHZhbHVlID09PSBOT1RfU0VUKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgaWR4ID0gcG9wQ291bnQoYml0bWFwICYgKGJpdCAtIDEpKTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICAgIHZhciBub2RlID0gZXhpc3RzID8gbm9kZXNbaWR4XSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbmV3Tm9kZSA9IHVwZGF0ZU5vZGUoXG4gICAgICBub2RlLFxuICAgICAgb3duZXJJRCxcbiAgICAgIHNoaWZ0ICsgU0hJRlQsXG4gICAgICBrZXlIYXNoLFxuICAgICAga2V5LFxuICAgICAgdmFsdWUsXG4gICAgICBkaWRDaGFuZ2VTaXplLFxuICAgICAgZGlkQWx0ZXJcbiAgICApO1xuXG4gICAgaWYgKG5ld05vZGUgPT09IG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICghZXhpc3RzICYmIG5ld05vZGUgJiYgbm9kZXMubGVuZ3RoID49IE1BWF9CSVRNQVBfSU5ERVhFRF9TSVpFKSB7XG4gICAgICByZXR1cm4gZXhwYW5kTm9kZXMob3duZXJJRCwgbm9kZXMsIGJpdG1hcCwga2V5SGFzaEZyYWcsIG5ld05vZGUpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGV4aXN0cyAmJlxuICAgICAgIW5ld05vZGUgJiZcbiAgICAgIG5vZGVzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgaXNMZWFmTm9kZShub2Rlc1tpZHggXiAxXSlcbiAgICApIHtcbiAgICAgIHJldHVybiBub2Rlc1tpZHggXiAxXTtcbiAgICB9XG5cbiAgICBpZiAoZXhpc3RzICYmIG5ld05vZGUgJiYgbm9kZXMubGVuZ3RoID09PSAxICYmIGlzTGVhZk5vZGUobmV3Tm9kZSkpIHtcbiAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgIH1cblxuICAgIHZhciBpc0VkaXRhYmxlID0gb3duZXJJRCAmJiBvd25lcklEID09PSB0aGlzLm93bmVySUQ7XG4gICAgdmFyIG5ld0JpdG1hcCA9IGV4aXN0cyA/IChuZXdOb2RlID8gYml0bWFwIDogYml0bWFwIF4gYml0KSA6IGJpdG1hcCB8IGJpdDtcbiAgICB2YXIgbmV3Tm9kZXMgPSBleGlzdHNcbiAgICAgID8gbmV3Tm9kZVxuICAgICAgICA/IHNldEF0KG5vZGVzLCBpZHgsIG5ld05vZGUsIGlzRWRpdGFibGUpXG4gICAgICAgIDogc3BsaWNlT3V0KG5vZGVzLCBpZHgsIGlzRWRpdGFibGUpXG4gICAgICA6IHNwbGljZUluKG5vZGVzLCBpZHgsIG5ld05vZGUsIGlzRWRpdGFibGUpO1xuXG4gICAgaWYgKGlzRWRpdGFibGUpIHtcbiAgICAgIHRoaXMuYml0bWFwID0gbmV3Qml0bWFwO1xuICAgICAgdGhpcy5ub2RlcyA9IG5ld05vZGVzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCBuZXdCaXRtYXAsIG5ld05vZGVzKTtcbiAgfTtcblxuICB2YXIgSGFzaEFycmF5TWFwTm9kZSA9IGZ1bmN0aW9uIEhhc2hBcnJheU1hcE5vZGUob3duZXJJRCwgY291bnQsIG5vZGVzKSB7XG4gICAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICB9O1xuXG4gIEhhc2hBcnJheU1hcE5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXlIYXNoID0gaGFzaChrZXkpO1xuICAgIH1cbiAgICB2YXIgaWR4ID0gKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVzW2lkeF07XG4gICAgcmV0dXJuIG5vZGVcbiAgICAgID8gbm9kZS5nZXQoc2hpZnQgKyBTSElGVCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSlcbiAgICAgIDogbm90U2V0VmFsdWU7XG4gIH07XG5cbiAgSGFzaEFycmF5TWFwTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXlIYXNoID0gaGFzaChrZXkpO1xuICAgIH1cbiAgICB2YXIgaWR4ID0gKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG4gICAgdmFyIHJlbW92ZWQgPSB2YWx1ZSA9PT0gTk9UX1NFVDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICAgIHZhciBub2RlID0gbm9kZXNbaWR4XTtcblxuICAgIGlmIChyZW1vdmVkICYmICFub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgbmV3Tm9kZSA9IHVwZGF0ZU5vZGUoXG4gICAgICBub2RlLFxuICAgICAgb3duZXJJRCxcbiAgICAgIHNoaWZ0ICsgU0hJRlQsXG4gICAgICBrZXlIYXNoLFxuICAgICAga2V5LFxuICAgICAgdmFsdWUsXG4gICAgICBkaWRDaGFuZ2VTaXplLFxuICAgICAgZGlkQWx0ZXJcbiAgICApO1xuICAgIGlmIChuZXdOb2RlID09PSBub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgbmV3Q291bnQgPSB0aGlzLmNvdW50O1xuICAgIGlmICghbm9kZSkge1xuICAgICAgbmV3Q291bnQrKztcbiAgICB9IGVsc2UgaWYgKCFuZXdOb2RlKSB7XG4gICAgICBuZXdDb3VudC0tO1xuICAgICAgaWYgKG5ld0NvdW50IDwgTUlOX0hBU0hfQVJSQVlfTUFQX1NJWkUpIHtcbiAgICAgICAgcmV0dXJuIHBhY2tOb2Rlcyhvd25lcklELCBub2RlcywgbmV3Q291bnQsIGlkeCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGlzRWRpdGFibGUgPSBvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRDtcbiAgICB2YXIgbmV3Tm9kZXMgPSBzZXRBdChub2RlcywgaWR4LCBuZXdOb2RlLCBpc0VkaXRhYmxlKTtcblxuICAgIGlmIChpc0VkaXRhYmxlKSB7XG4gICAgICB0aGlzLmNvdW50ID0gbmV3Q291bnQ7XG4gICAgICB0aGlzLm5vZGVzID0gbmV3Tm9kZXM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEhhc2hBcnJheU1hcE5vZGUob3duZXJJRCwgbmV3Q291bnQsIG5ld05vZGVzKTtcbiAgfTtcblxuICB2YXIgSGFzaENvbGxpc2lvbk5vZGUgPSBmdW5jdGlvbiBIYXNoQ29sbGlzaW9uTm9kZShvd25lcklELCBrZXlIYXNoLCBlbnRyaWVzKSB7XG4gICAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgICB0aGlzLmtleUhhc2ggPSBrZXlIYXNoO1xuICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gIH07XG5cbiAgSGFzaENvbGxpc2lvbk5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgICBmb3IgKHZhciBpaSA9IDAsIGxlbiA9IGVudHJpZXMubGVuZ3RoOyBpaSA8IGxlbjsgaWkrKykge1xuICAgICAgaWYgKGlzKGtleSwgZW50cmllc1tpaV1bMF0pKSB7XG4gICAgICAgIHJldHVybiBlbnRyaWVzW2lpXVsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICB9O1xuXG4gIEhhc2hDb2xsaXNpb25Ob2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuICAgIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gICAgfVxuXG4gICAgdmFyIHJlbW92ZWQgPSB2YWx1ZSA9PT0gTk9UX1NFVDtcblxuICAgIGlmIChrZXlIYXNoICE9PSB0aGlzLmtleUhhc2gpIHtcbiAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgICAgIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcbiAgICAgIHJldHVybiBtZXJnZUludG9Ob2RlKHRoaXMsIG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBba2V5LCB2YWx1ZV0pO1xuICAgIH1cblxuICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICAgIHZhciBpZHggPSAwO1xuICAgIHZhciBsZW4gPSBlbnRyaWVzLmxlbmd0aDtcbiAgICBmb3IgKDsgaWR4IDwgbGVuOyBpZHgrKykge1xuICAgICAgaWYgKGlzKGtleSwgZW50cmllc1tpZHhdWzBdKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGV4aXN0cyA9IGlkeCA8IGxlbjtcblxuICAgIGlmIChleGlzdHMgPyBlbnRyaWVzW2lkeF1bMV0gPT09IHZhbHVlIDogcmVtb3ZlZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgICAocmVtb3ZlZCB8fCAhZXhpc3RzKSAmJiBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG5cbiAgICBpZiAocmVtb3ZlZCAmJiBsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBuZXcgVmFsdWVOb2RlKG93bmVySUQsIHRoaXMua2V5SGFzaCwgZW50cmllc1tpZHggXiAxXSk7XG4gICAgfVxuXG4gICAgdmFyIGlzRWRpdGFibGUgPSBvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRDtcbiAgICB2YXIgbmV3RW50cmllcyA9IGlzRWRpdGFibGUgPyBlbnRyaWVzIDogYXJyQ29weShlbnRyaWVzKTtcblxuICAgIGlmIChleGlzdHMpIHtcbiAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgIGlkeCA9PT0gbGVuIC0gMVxuICAgICAgICAgID8gbmV3RW50cmllcy5wb3AoKVxuICAgICAgICAgIDogKG5ld0VudHJpZXNbaWR4XSA9IG5ld0VudHJpZXMucG9wKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3RW50cmllc1tpZHhdID0gW2tleSwgdmFsdWVdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdFbnRyaWVzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICB9XG5cbiAgICBpZiAoaXNFZGl0YWJsZSkge1xuICAgICAgdGhpcy5lbnRyaWVzID0gbmV3RW50cmllcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSGFzaENvbGxpc2lvbk5vZGUob3duZXJJRCwgdGhpcy5rZXlIYXNoLCBuZXdFbnRyaWVzKTtcbiAgfTtcblxuICB2YXIgVmFsdWVOb2RlID0gZnVuY3Rpb24gVmFsdWVOb2RlKG93bmVySUQsIGtleUhhc2gsIGVudHJ5KSB7XG4gICAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgICB0aGlzLmtleUhhc2ggPSBrZXlIYXNoO1xuICAgIHRoaXMuZW50cnkgPSBlbnRyeTtcbiAgfTtcblxuICBWYWx1ZU5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gaXMoa2V5LCB0aGlzLmVudHJ5WzBdKSA/IHRoaXMuZW50cnlbMV0gOiBub3RTZXRWYWx1ZTtcbiAgfTtcblxuICBWYWx1ZU5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gICAgdmFyIHJlbW92ZWQgPSB2YWx1ZSA9PT0gTk9UX1NFVDtcbiAgICB2YXIga2V5TWF0Y2ggPSBpcyhrZXksIHRoaXMuZW50cnlbMF0pO1xuICAgIGlmIChrZXlNYXRjaCA/IHZhbHVlID09PSB0aGlzLmVudHJ5WzFdIDogcmVtb3ZlZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgU2V0UmVmKGRpZEFsdGVyKTtcblxuICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG4gICAgICByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGlmIChrZXlNYXRjaCkge1xuICAgICAgaWYgKG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEKSB7XG4gICAgICAgIHRoaXMuZW50cnlbMV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFZhbHVlTm9kZShvd25lcklELCB0aGlzLmtleUhhc2gsIFtrZXksIHZhbHVlXSk7XG4gICAgfVxuXG4gICAgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuICAgIHJldHVybiBtZXJnZUludG9Ob2RlKHRoaXMsIG93bmVySUQsIHNoaWZ0LCBoYXNoKGtleSksIFtrZXksIHZhbHVlXSk7XG4gIH07XG5cbiAgLy8gI3ByYWdtYSBJdGVyYXRvcnNcblxuICBBcnJheU1hcE5vZGUucHJvdG90eXBlLml0ZXJhdGUgPSBIYXNoQ29sbGlzaW9uTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9IGZ1bmN0aW9uKFxuICAgIGZuLFxuICAgIHJldmVyc2VcbiAgKSB7XG4gICAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gICAgZm9yICh2YXIgaWkgPSAwLCBtYXhJbmRleCA9IGVudHJpZXMubGVuZ3RoIC0gMTsgaWkgPD0gbWF4SW5kZXg7IGlpKyspIHtcbiAgICAgIGlmIChmbihlbnRyaWVzW3JldmVyc2UgPyBtYXhJbmRleCAtIGlpIDogaWldKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBCaXRtYXBJbmRleGVkTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9IEhhc2hBcnJheU1hcE5vZGUucHJvdG90eXBlLml0ZXJhdGUgPSBmdW5jdGlvbihcbiAgICBmbixcbiAgICByZXZlcnNlXG4gICkge1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gICAgZm9yICh2YXIgaWkgPSAwLCBtYXhJbmRleCA9IG5vZGVzLmxlbmd0aCAtIDE7IGlpIDw9IG1heEluZGV4OyBpaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW3JldmVyc2UgPyBtYXhJbmRleCAtIGlpIDogaWldO1xuICAgICAgaWYgKG5vZGUgJiYgbm9kZS5pdGVyYXRlKGZuLCByZXZlcnNlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgVmFsdWVOb2RlLnByb3RvdHlwZS5pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICByZXR1cm4gZm4odGhpcy5lbnRyeSk7XG4gIH07XG5cbiAgdmFyIE1hcEl0ZXJhdG9yID0gKGZ1bmN0aW9uIChJdGVyYXRvciQkMSkge1xuICAgIGZ1bmN0aW9uIE1hcEl0ZXJhdG9yKG1hcCwgdHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLl9yZXZlcnNlID0gcmV2ZXJzZTtcbiAgICAgIHRoaXMuX3N0YWNrID0gbWFwLl9yb290ICYmIG1hcEl0ZXJhdG9yRnJhbWUobWFwLl9yb290KTtcbiAgICB9XG5cbiAgICBpZiAoIEl0ZXJhdG9yJCQxICkgTWFwSXRlcmF0b3IuX19wcm90b19fID0gSXRlcmF0b3IkJDE7XG4gICAgTWFwSXRlcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSXRlcmF0b3IkJDEgJiYgSXRlcmF0b3IkJDEucHJvdG90eXBlICk7XG4gICAgTWFwSXRlcmF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWFwSXRlcmF0b3I7XG5cbiAgICBNYXBJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIG5leHQgKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHZhciB0eXBlID0gdGhpcy5fdHlwZTtcbiAgICAgIHZhciBzdGFjayA9IHRoaXMuX3N0YWNrO1xuICAgICAgd2hpbGUgKHN0YWNrKSB7XG4gICAgICAgIHZhciBub2RlID0gc3RhY2subm9kZTtcbiAgICAgICAgdmFyIGluZGV4ID0gc3RhY2suaW5kZXgrKztcbiAgICAgICAgdmFyIG1heEluZGV4ID0gKHZvaWQgMCk7XG4gICAgICAgIGlmIChub2RlLmVudHJ5KSB7XG4gICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwSXRlcmF0b3JWYWx1ZSh0eXBlLCBub2RlLmVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgbWF4SW5kZXggPSBub2RlLmVudHJpZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpZiAoaW5kZXggPD0gbWF4SW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXBJdGVyYXRvclZhbHVlKFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBub2RlLmVudHJpZXNbdGhpcyQxLl9yZXZlcnNlID8gbWF4SW5kZXggLSBpbmRleCA6IGluZGV4XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF4SW5kZXggPSBub2RlLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgaWYgKGluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgc3ViTm9kZSA9IG5vZGUubm9kZXNbdGhpcyQxLl9yZXZlcnNlID8gbWF4SW5kZXggLSBpbmRleCA6IGluZGV4XTtcbiAgICAgICAgICAgIGlmIChzdWJOb2RlKSB7XG4gICAgICAgICAgICAgIGlmIChzdWJOb2RlLmVudHJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcEl0ZXJhdG9yVmFsdWUodHlwZSwgc3ViTm9kZS5lbnRyeSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhY2sgPSB0aGlzJDEuX3N0YWNrID0gbWFwSXRlcmF0b3JGcmFtZShzdWJOb2RlLCBzdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sgPSB0aGlzJDEuX3N0YWNrID0gdGhpcyQxLl9zdGFjay5fX3ByZXY7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBNYXBJdGVyYXRvcjtcbiAgfShJdGVyYXRvcikpO1xuXG4gIGZ1bmN0aW9uIG1hcEl0ZXJhdG9yVmFsdWUodHlwZSwgZW50cnkpIHtcbiAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwSXRlcmF0b3JGcmFtZShub2RlLCBwcmV2KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGU6IG5vZGUsXG4gICAgICBpbmRleDogMCxcbiAgICAgIF9fcHJldjogcHJldixcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZU1hcChzaXplLCByb290LCBvd25lcklELCBoYXNoJCQxKSB7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUoTWFwUHJvdG90eXBlKTtcbiAgICBtYXAuc2l6ZSA9IHNpemU7XG4gICAgbWFwLl9yb290ID0gcm9vdDtcbiAgICBtYXAuX19vd25lcklEID0gb3duZXJJRDtcbiAgICBtYXAuX19oYXNoID0gaGFzaCQkMTtcbiAgICBtYXAuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuXG4gIHZhciBFTVBUWV9NQVA7XG4gIGZ1bmN0aW9uIGVtcHR5TWFwKCkge1xuICAgIHJldHVybiBFTVBUWV9NQVAgfHwgKEVNUFRZX01BUCA9IG1ha2VNYXAoMCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTWFwKG1hcCwgaywgdikge1xuICAgIHZhciBuZXdSb290O1xuICAgIHZhciBuZXdTaXplO1xuICAgIGlmICghbWFwLl9yb290KSB7XG4gICAgICBpZiAodiA9PT0gTk9UX1NFVCkge1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgfVxuICAgICAgbmV3U2l6ZSA9IDE7XG4gICAgICBuZXdSb290ID0gbmV3IEFycmF5TWFwTm9kZShtYXAuX19vd25lcklELCBbW2ssIHZdXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaWRDaGFuZ2VTaXplID0gTWFrZVJlZigpO1xuICAgICAgdmFyIGRpZEFsdGVyID0gTWFrZVJlZigpO1xuICAgICAgbmV3Um9vdCA9IHVwZGF0ZU5vZGUoXG4gICAgICAgIG1hcC5fcm9vdCxcbiAgICAgICAgbWFwLl9fb3duZXJJRCxcbiAgICAgICAgMCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBrLFxuICAgICAgICB2LFxuICAgICAgICBkaWRDaGFuZ2VTaXplLFxuICAgICAgICBkaWRBbHRlclxuICAgICAgKTtcbiAgICAgIGlmICghZGlkQWx0ZXIudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgIH1cbiAgICAgIG5ld1NpemUgPSBtYXAuc2l6ZSArIChkaWRDaGFuZ2VTaXplLnZhbHVlID8gKHYgPT09IE5PVF9TRVQgPyAtMSA6IDEpIDogMCk7XG4gICAgfVxuICAgIGlmIChtYXAuX19vd25lcklEKSB7XG4gICAgICBtYXAuc2l6ZSA9IG5ld1NpemU7XG4gICAgICBtYXAuX3Jvb3QgPSBuZXdSb290O1xuICAgICAgbWFwLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgIG1hcC5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1Jvb3QgPyBtYWtlTWFwKG5ld1NpemUsIG5ld1Jvb3QpIDogZW1wdHlNYXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZU5vZGUoXG4gICAgbm9kZSxcbiAgICBvd25lcklELFxuICAgIHNoaWZ0LFxuICAgIGtleUhhc2gsXG4gICAga2V5LFxuICAgIHZhbHVlLFxuICAgIGRpZENoYW5nZVNpemUsXG4gICAgZGlkQWx0ZXJcbiAgKSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IE5PVF9TRVQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuICAgICAgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuICAgICAgcmV0dXJuIG5ldyBWYWx1ZU5vZGUob3duZXJJRCwga2V5SGFzaCwgW2tleSwgdmFsdWVdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUudXBkYXRlKFxuICAgICAgb3duZXJJRCxcbiAgICAgIHNoaWZ0LFxuICAgICAga2V5SGFzaCxcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlLFxuICAgICAgZGlkQ2hhbmdlU2l6ZSxcbiAgICAgIGRpZEFsdGVyXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTGVhZk5vZGUobm9kZSkge1xuICAgIHJldHVybiAoXG4gICAgICBub2RlLmNvbnN0cnVjdG9yID09PSBWYWx1ZU5vZGUgfHwgbm9kZS5jb25zdHJ1Y3RvciA9PT0gSGFzaENvbGxpc2lvbk5vZGVcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VJbnRvTm9kZShub2RlLCBvd25lcklELCBzaGlmdCwga2V5SGFzaCwgZW50cnkpIHtcbiAgICBpZiAobm9kZS5rZXlIYXNoID09PSBrZXlIYXNoKSB7XG4gICAgICByZXR1cm4gbmV3IEhhc2hDb2xsaXNpb25Ob2RlKG93bmVySUQsIGtleUhhc2gsIFtub2RlLmVudHJ5LCBlbnRyeV0pO1xuICAgIH1cblxuICAgIHZhciBpZHgxID0gKHNoaWZ0ID09PSAwID8gbm9kZS5rZXlIYXNoIDogbm9kZS5rZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLO1xuICAgIHZhciBpZHgyID0gKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG5cbiAgICB2YXIgbmV3Tm9kZTtcbiAgICB2YXIgbm9kZXMgPVxuICAgICAgaWR4MSA9PT0gaWR4MlxuICAgICAgICA/IFttZXJnZUludG9Ob2RlKG5vZGUsIG93bmVySUQsIHNoaWZ0ICsgU0hJRlQsIGtleUhhc2gsIGVudHJ5KV1cbiAgICAgICAgOiAoKG5ld05vZGUgPSBuZXcgVmFsdWVOb2RlKG93bmVySUQsIGtleUhhc2gsIGVudHJ5KSksXG4gICAgICAgICAgaWR4MSA8IGlkeDIgPyBbbm9kZSwgbmV3Tm9kZV0gOiBbbmV3Tm9kZSwgbm9kZV0pO1xuXG4gICAgcmV0dXJuIG5ldyBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCAoMSA8PCBpZHgxKSB8ICgxIDw8IGlkeDIpLCBub2Rlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2Rlcyhvd25lcklELCBlbnRyaWVzLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKCFvd25lcklEKSB7XG4gICAgICBvd25lcklEID0gbmV3IE93bmVySUQoKTtcbiAgICB9XG4gICAgdmFyIG5vZGUgPSBuZXcgVmFsdWVOb2RlKG93bmVySUQsIGhhc2goa2V5KSwgW2tleSwgdmFsdWVdKTtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgZW50cmllcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaWldO1xuICAgICAgbm9kZSA9IG5vZGUudXBkYXRlKG93bmVySUQsIDAsIHVuZGVmaW5lZCwgZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBwYWNrTm9kZXMob3duZXJJRCwgbm9kZXMsIGNvdW50LCBleGNsdWRpbmcpIHtcbiAgICB2YXIgYml0bWFwID0gMDtcbiAgICB2YXIgcGFja2VkSUkgPSAwO1xuICAgIHZhciBwYWNrZWROb2RlcyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yICh2YXIgaWkgPSAwLCBiaXQgPSAxLCBsZW4gPSBub2Rlcy5sZW5ndGg7IGlpIDwgbGVuOyBpaSsrLCBiaXQgPDw9IDEpIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaWldO1xuICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCAmJiBpaSAhPT0gZXhjbHVkaW5nKSB7XG4gICAgICAgIGJpdG1hcCB8PSBiaXQ7XG4gICAgICAgIHBhY2tlZE5vZGVzW3BhY2tlZElJKytdID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCBiaXRtYXAsIHBhY2tlZE5vZGVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cGFuZE5vZGVzKG93bmVySUQsIG5vZGVzLCBiaXRtYXAsIGluY2x1ZGluZywgbm9kZSkge1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGV4cGFuZGVkTm9kZXMgPSBuZXcgQXJyYXkoU0laRSk7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBiaXRtYXAgIT09IDA7IGlpKyssIGJpdG1hcCA+Pj49IDEpIHtcbiAgICAgIGV4cGFuZGVkTm9kZXNbaWldID0gYml0bWFwICYgMSA/IG5vZGVzW2NvdW50KytdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBleHBhbmRlZE5vZGVzW2luY2x1ZGluZ10gPSBub2RlO1xuICAgIHJldHVybiBuZXcgSGFzaEFycmF5TWFwTm9kZShvd25lcklELCBjb3VudCArIDEsIGV4cGFuZGVkTm9kZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wQ291bnQoeCkge1xuICAgIHggLT0gKHggPj4gMSkgJiAweDU1NTU1NTU1O1xuICAgIHggPSAoeCAmIDB4MzMzMzMzMzMpICsgKCh4ID4+IDIpICYgMHgzMzMzMzMzMyk7XG4gICAgeCA9ICh4ICsgKHggPj4gNCkpICYgMHgwZjBmMGYwZjtcbiAgICB4ICs9IHggPj4gODtcbiAgICB4ICs9IHggPj4gMTY7XG4gICAgcmV0dXJuIHggJiAweDdmO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0QXQoYXJyYXksIGlkeCwgdmFsLCBjYW5FZGl0KSB7XG4gICAgdmFyIG5ld0FycmF5ID0gY2FuRWRpdCA/IGFycmF5IDogYXJyQ29weShhcnJheSk7XG4gICAgbmV3QXJyYXlbaWR4XSA9IHZhbDtcbiAgICByZXR1cm4gbmV3QXJyYXk7XG4gIH1cblxuICBmdW5jdGlvbiBzcGxpY2VJbihhcnJheSwgaWR4LCB2YWwsIGNhbkVkaXQpIHtcbiAgICB2YXIgbmV3TGVuID0gYXJyYXkubGVuZ3RoICsgMTtcbiAgICBpZiAoY2FuRWRpdCAmJiBpZHggKyAxID09PSBuZXdMZW4pIHtcbiAgICAgIGFycmF5W2lkeF0gPSB2YWw7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIHZhciBuZXdBcnJheSA9IG5ldyBBcnJheShuZXdMZW4pO1xuICAgIHZhciBhZnRlciA9IDA7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG5ld0xlbjsgaWkrKykge1xuICAgICAgaWYgKGlpID09PSBpZHgpIHtcbiAgICAgICAgbmV3QXJyYXlbaWldID0gdmFsO1xuICAgICAgICBhZnRlciA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3QXJyYXlbaWldID0gYXJyYXlbaWkgKyBhZnRlcl07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwbGljZU91dChhcnJheSwgaWR4LCBjYW5FZGl0KSB7XG4gICAgdmFyIG5ld0xlbiA9IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgaWYgKGNhbkVkaXQgJiYgaWR4ID09PSBuZXdMZW4pIHtcbiAgICAgIGFycmF5LnBvcCgpO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgICB2YXIgbmV3QXJyYXkgPSBuZXcgQXJyYXkobmV3TGVuKTtcbiAgICB2YXIgYWZ0ZXIgPSAwO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBuZXdMZW47IGlpKyspIHtcbiAgICAgIGlmIChpaSA9PT0gaWR4KSB7XG4gICAgICAgIGFmdGVyID0gMTtcbiAgICAgIH1cbiAgICAgIG5ld0FycmF5W2lpXSA9IGFycmF5W2lpICsgYWZ0ZXJdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3QXJyYXk7XG4gIH1cblxuICB2YXIgTUFYX0FSUkFZX01BUF9TSVpFID0gU0laRSAvIDQ7XG4gIHZhciBNQVhfQklUTUFQX0lOREVYRURfU0laRSA9IFNJWkUgLyAyO1xuICB2YXIgTUlOX0hBU0hfQVJSQVlfTUFQX1NJWkUgPSBTSVpFIC8gNDtcblxuICB2YXIgSVNfTElTVF9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9MSVNUX19AQCc7XG5cbiAgZnVuY3Rpb24gaXNMaXN0KG1heWJlTGlzdCkge1xuICAgIHJldHVybiBCb29sZWFuKG1heWJlTGlzdCAmJiBtYXliZUxpc3RbSVNfTElTVF9TWU1CT0xdKTtcbiAgfVxuXG4gIHZhciBMaXN0ID0gKGZ1bmN0aW9uIChJbmRleGVkQ29sbGVjdGlvbiQkMSkge1xuICAgIGZ1bmN0aW9uIExpc3QodmFsdWUpIHtcbiAgICAgIHZhciBlbXB0eSA9IGVtcHR5TGlzdCgpO1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgICAgfVxuICAgICAgaWYgKGlzTGlzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXIgPSBJbmRleGVkQ29sbGVjdGlvbiQkMSh2YWx1ZSk7XG4gICAgICB2YXIgc2l6ZSA9IGl0ZXIuc2l6ZTtcbiAgICAgIGlmIChzaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICAgIH1cbiAgICAgIGFzc2VydE5vdEluZmluaXRlKHNpemUpO1xuICAgICAgaWYgKHNpemUgPiAwICYmIHNpemUgPCBTSVpFKSB7XG4gICAgICAgIHJldHVybiBtYWtlTGlzdCgwLCBzaXplLCBTSElGVCwgbnVsbCwgbmV3IFZOb2RlKGl0ZXIudG9BcnJheSgpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICBsaXN0LnNldFNpemUoc2l6ZSk7XG4gICAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkgeyByZXR1cm4gbGlzdC5zZXQoaSwgdik7IH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCBJbmRleGVkQ29sbGVjdGlvbiQkMSApIExpc3QuX19wcm90b19fID0gSW5kZXhlZENvbGxlY3Rpb24kJDE7XG4gICAgTGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkQ29sbGVjdGlvbiQkMSAmJiBJbmRleGVkQ29sbGVjdGlvbiQkMS5wcm90b3R5cGUgKTtcbiAgICBMaXN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpc3Q7XG5cbiAgICBMaXN0Lm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnTGlzdCBbJywgJ10nKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICAgIExpc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgICBpbmRleCA9IHdyYXBJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuc2l6ZSkge1xuICAgICAgICBpbmRleCArPSB0aGlzLl9vcmlnaW47XG4gICAgICAgIHZhciBub2RlID0gbGlzdE5vZGVGb3IodGhpcywgaW5kZXgpO1xuICAgICAgICByZXR1cm4gbm9kZSAmJiBub2RlLmFycmF5W2luZGV4ICYgTUFTS107XG4gICAgICB9XG4gICAgICByZXR1cm4gbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgICBMaXN0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKGluZGV4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHVwZGF0ZUxpc3QodGhpcywgaW5kZXgsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlIChpbmRleCkge1xuICAgICAgcmV0dXJuICF0aGlzLmhhcyhpbmRleClcbiAgICAgICAgPyB0aGlzXG4gICAgICAgIDogaW5kZXggPT09IDBcbiAgICAgICAgICA/IHRoaXMuc2hpZnQoKVxuICAgICAgICAgIDogaW5kZXggPT09IHRoaXMuc2l6ZSAtIDFcbiAgICAgICAgICAgID8gdGhpcy5wb3AoKVxuICAgICAgICAgICAgOiB0aGlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIGluc2VydCAoaW5kZXgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGxpY2UoaW5kZXgsIDAsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuX29yaWdpbiA9IHRoaXMuX2NhcGFjaXR5ID0gMDtcbiAgICAgICAgdGhpcy5fbGV2ZWwgPSBTSElGVDtcbiAgICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuX3RhaWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eUxpc3QoKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgb2xkU2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgc2V0TGlzdEJvdW5kcyhsaXN0LCAwLCBvbGRTaXplICsgdmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCB2YWx1ZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgbGlzdC5zZXQob2xkU2l6ZSArIGlpLCB2YWx1ZXNbaWldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uIHBvcCAoKSB7XG4gICAgICByZXR1cm4gc2V0TGlzdEJvdW5kcyh0aGlzLCAwLCAtMSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0ICgvKi4uLnZhbHVlcyovKSB7XG4gICAgICB2YXIgdmFsdWVzID0gYXJndW1lbnRzO1xuICAgICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICBzZXRMaXN0Qm91bmRzKGxpc3QsIC12YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHZhbHVlcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICBsaXN0LnNldChpaSwgdmFsdWVzW2lpXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIHNoaWZ0ICgpIHtcbiAgICAgIHJldHVybiBzZXRMaXN0Qm91bmRzKHRoaXMsIDEpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIENvbXBvc2l0aW9uXG5cbiAgICBMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKC8qLi4uY29sbGVjdGlvbnMqLykge1xuICAgICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgICB2YXIgc2VxcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGFyZ3VtZW50ID0gYXJndW1lbnRzJDFbaV07XG4gICAgICAgIHZhciBzZXEgPSBJbmRleGVkQ29sbGVjdGlvbiQkMShcbiAgICAgICAgICB0eXBlb2YgYXJndW1lbnQgIT09ICdzdHJpbmcnICYmIGhhc0l0ZXJhdG9yKGFyZ3VtZW50KVxuICAgICAgICAgICAgPyBhcmd1bWVudFxuICAgICAgICAgICAgOiBbYXJndW1lbnRdXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzZXEuc2l6ZSAhPT0gMCkge1xuICAgICAgICAgIHNlcXMucHVzaChzZXEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2Vxcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwICYmICF0aGlzLl9fb3duZXJJRCAmJiBzZXFzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RvcihzZXFzWzBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgc2Vxcy5mb3JFYWNoKGZ1bmN0aW9uIChzZXEpIHsgcmV0dXJuIHNlcS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbGlzdC5wdXNoKHZhbHVlKTsgfSk7IH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbiBzZXRTaXplIChzaXplKSB7XG4gICAgICByZXR1cm4gc2V0TGlzdEJvdW5kcyh0aGlzLCAwLCBzaXplKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcyQxLnNpemU7IGkrKykge1xuICAgICAgICAgIGxpc3Quc2V0KGksIG1hcHBlci5jYWxsKGNvbnRleHQsIGxpc3QuZ2V0KGkpLCBpLCBsaXN0KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIEl0ZXJhdGlvblxuXG4gICAgTGlzdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoYmVnaW4sIGVuZCkge1xuICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgICBpZiAod2hvbGVTbGljZShiZWdpbiwgZW5kLCBzaXplKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXRMaXN0Qm91bmRzKFxuICAgICAgICB0aGlzLFxuICAgICAgICByZXNvbHZlQmVnaW4oYmVnaW4sIHNpemUpLFxuICAgICAgICByZXNvbHZlRW5kKGVuZCwgc2l6ZSlcbiAgICAgICk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaW5kZXggPSByZXZlcnNlID8gdGhpcy5zaXplIDogMDtcbiAgICAgIHZhciB2YWx1ZXMgPSBpdGVyYXRlTGlzdCh0aGlzLCByZXZlcnNlKTtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXMoKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBET05FXG4gICAgICAgICAgPyBpdGVyYXRvckRvbmUoKVxuICAgICAgICAgIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCByZXZlcnNlID8gLS1pbmRleCA6IGluZGV4KyssIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdmFyIGluZGV4ID0gcmV2ZXJzZSA/IHRoaXMuc2l6ZSA6IDA7XG4gICAgICB2YXIgdmFsdWVzID0gaXRlcmF0ZUxpc3QodGhpcywgcmV2ZXJzZSk7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICB3aGlsZSAoKHZhbHVlID0gdmFsdWVzKCkpICE9PSBET05FKSB7XG4gICAgICAgIGlmIChmbih2YWx1ZSwgcmV2ZXJzZSA/IC0taW5kZXggOiBpbmRleCsrLCB0aGlzJDEpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbiBfX2Vuc3VyZU93bmVyIChvd25lcklEKSB7XG4gICAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBlbXB0eUxpc3QoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VMaXN0KFxuICAgICAgICB0aGlzLl9vcmlnaW4sXG4gICAgICAgIHRoaXMuX2NhcGFjaXR5LFxuICAgICAgICB0aGlzLl9sZXZlbCxcbiAgICAgICAgdGhpcy5fcm9vdCxcbiAgICAgICAgdGhpcy5fdGFpbCxcbiAgICAgICAgb3duZXJJRCxcbiAgICAgICAgdGhpcy5fX2hhc2hcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBMaXN0O1xuICB9KEluZGV4ZWRDb2xsZWN0aW9uKSk7XG5cbiAgTGlzdC5pc0xpc3QgPSBpc0xpc3Q7XG5cbiAgdmFyIExpc3RQcm90b3R5cGUgPSBMaXN0LnByb3RvdHlwZTtcbiAgTGlzdFByb3RvdHlwZVtJU19MSVNUX1NZTUJPTF0gPSB0cnVlO1xuICBMaXN0UHJvdG90eXBlW0RFTEVURV0gPSBMaXN0UHJvdG90eXBlLnJlbW92ZTtcbiAgTGlzdFByb3RvdHlwZS5tZXJnZSA9IExpc3RQcm90b3R5cGUuY29uY2F0O1xuICBMaXN0UHJvdG90eXBlLnNldEluID0gc2V0SW4kMTtcbiAgTGlzdFByb3RvdHlwZS5kZWxldGVJbiA9IExpc3RQcm90b3R5cGUucmVtb3ZlSW4gPSBkZWxldGVJbjtcbiAgTGlzdFByb3RvdHlwZS51cGRhdGUgPSB1cGRhdGUkMTtcbiAgTGlzdFByb3RvdHlwZS51cGRhdGVJbiA9IHVwZGF0ZUluJDE7XG4gIExpc3RQcm90b3R5cGUubWVyZ2VJbiA9IG1lcmdlSW47XG4gIExpc3RQcm90b3R5cGUubWVyZ2VEZWVwSW4gPSBtZXJnZURlZXBJbjtcbiAgTGlzdFByb3RvdHlwZS53aXRoTXV0YXRpb25zID0gd2l0aE11dGF0aW9ucztcbiAgTGlzdFByb3RvdHlwZS53YXNBbHRlcmVkID0gd2FzQWx0ZXJlZDtcbiAgTGlzdFByb3RvdHlwZS5hc0ltbXV0YWJsZSA9IGFzSW1tdXRhYmxlO1xuICBMaXN0UHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gTGlzdFByb3RvdHlwZS5hc011dGFibGUgPSBhc011dGFibGU7XG4gIExpc3RQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGFycikge1xuICAgIHJldHVybiByZXN1bHQucHVzaChhcnIpO1xuICB9O1xuICBMaXN0UHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqLmFzSW1tdXRhYmxlKCk7XG4gIH07XG5cbiAgdmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUoYXJyYXksIG93bmVySUQpIHtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gICAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgfTtcblxuICAvLyBUT0RPOiBzZWVtcyBsaWtlIHRoZXNlIG1ldGhvZHMgYXJlIHZlcnkgc2ltaWxhclxuXG4gIFZOb2RlLnByb3RvdHlwZS5yZW1vdmVCZWZvcmUgPSBmdW5jdGlvbiByZW1vdmVCZWZvcmUgKG93bmVySUQsIGxldmVsLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gbGV2ZWwgPyAxIDw8IGxldmVsIDogdGhpcy5hcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgb3JpZ2luSW5kZXggPSAoaW5kZXggPj4+IGxldmVsKSAmIE1BU0s7XG4gICAgaWYgKG9yaWdpbkluZGV4ID49IHRoaXMuYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmV3IFZOb2RlKFtdLCBvd25lcklEKTtcbiAgICB9XG4gICAgdmFyIHJlbW92aW5nRmlyc3QgPSBvcmlnaW5JbmRleCA9PT0gMDtcbiAgICB2YXIgbmV3Q2hpbGQ7XG4gICAgaWYgKGxldmVsID4gMCkge1xuICAgICAgdmFyIG9sZENoaWxkID0gdGhpcy5hcnJheVtvcmlnaW5JbmRleF07XG4gICAgICBuZXdDaGlsZCA9XG4gICAgICAgIG9sZENoaWxkICYmIG9sZENoaWxkLnJlbW92ZUJlZm9yZShvd25lcklELCBsZXZlbCAtIFNISUZULCBpbmRleCk7XG4gICAgICBpZiAobmV3Q2hpbGQgPT09IG9sZENoaWxkICYmIHJlbW92aW5nRmlyc3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZW1vdmluZ0ZpcnN0ICYmICFuZXdDaGlsZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBlZGl0YWJsZSA9IGVkaXRhYmxlVk5vZGUodGhpcywgb3duZXJJRCk7XG4gICAgaWYgKCFyZW1vdmluZ0ZpcnN0KSB7XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgb3JpZ2luSW5kZXg7IGlpKyspIHtcbiAgICAgICAgZWRpdGFibGUuYXJyYXlbaWldID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3Q2hpbGQpIHtcbiAgICAgIGVkaXRhYmxlLmFycmF5W29yaWdpbkluZGV4XSA9IG5ld0NoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gZWRpdGFibGU7XG4gIH07XG5cbiAgVk5vZGUucHJvdG90eXBlLnJlbW92ZUFmdGVyID0gZnVuY3Rpb24gcmVtb3ZlQWZ0ZXIgKG93bmVySUQsIGxldmVsLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gKGxldmVsID8gMSA8PCBsZXZlbCA6IDApIHx8IHRoaXMuYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIHNpemVJbmRleCA9ICgoaW5kZXggLSAxKSA+Pj4gbGV2ZWwpICYgTUFTSztcbiAgICBpZiAoc2l6ZUluZGV4ID49IHRoaXMuYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgbmV3Q2hpbGQ7XG4gICAgaWYgKGxldmVsID4gMCkge1xuICAgICAgdmFyIG9sZENoaWxkID0gdGhpcy5hcnJheVtzaXplSW5kZXhdO1xuICAgICAgbmV3Q2hpbGQgPVxuICAgICAgICBvbGRDaGlsZCAmJiBvbGRDaGlsZC5yZW1vdmVBZnRlcihvd25lcklELCBsZXZlbCAtIFNISUZULCBpbmRleCk7XG4gICAgICBpZiAobmV3Q2hpbGQgPT09IG9sZENoaWxkICYmIHNpemVJbmRleCA9PT0gdGhpcy5hcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBlZGl0YWJsZSA9IGVkaXRhYmxlVk5vZGUodGhpcywgb3duZXJJRCk7XG4gICAgZWRpdGFibGUuYXJyYXkuc3BsaWNlKHNpemVJbmRleCArIDEpO1xuICAgIGlmIChuZXdDaGlsZCkge1xuICAgICAgZWRpdGFibGUuYXJyYXlbc2l6ZUluZGV4XSA9IG5ld0NoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gZWRpdGFibGU7XG4gIH07XG5cbiAgdmFyIERPTkUgPSB7fTtcblxuICBmdW5jdGlvbiBpdGVyYXRlTGlzdChsaXN0LCByZXZlcnNlKSB7XG4gICAgdmFyIGxlZnQgPSBsaXN0Ll9vcmlnaW47XG4gICAgdmFyIHJpZ2h0ID0gbGlzdC5fY2FwYWNpdHk7XG4gICAgdmFyIHRhaWxQb3MgPSBnZXRUYWlsT2Zmc2V0KHJpZ2h0KTtcbiAgICB2YXIgdGFpbCA9IGxpc3QuX3RhaWw7XG5cbiAgICByZXR1cm4gaXRlcmF0ZU5vZGVPckxlYWYobGlzdC5fcm9vdCwgbGlzdC5fbGV2ZWwsIDApO1xuXG4gICAgZnVuY3Rpb24gaXRlcmF0ZU5vZGVPckxlYWYobm9kZSwgbGV2ZWwsIG9mZnNldCkge1xuICAgICAgcmV0dXJuIGxldmVsID09PSAwXG4gICAgICAgID8gaXRlcmF0ZUxlYWYobm9kZSwgb2Zmc2V0KVxuICAgICAgICA6IGl0ZXJhdGVOb2RlKG5vZGUsIGxldmVsLCBvZmZzZXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGl0ZXJhdGVMZWFmKG5vZGUsIG9mZnNldCkge1xuICAgICAgdmFyIGFycmF5ID0gb2Zmc2V0ID09PSB0YWlsUG9zID8gdGFpbCAmJiB0YWlsLmFycmF5IDogbm9kZSAmJiBub2RlLmFycmF5O1xuICAgICAgdmFyIGZyb20gPSBvZmZzZXQgPiBsZWZ0ID8gMCA6IGxlZnQgLSBvZmZzZXQ7XG4gICAgICB2YXIgdG8gPSByaWdodCAtIG9mZnNldDtcbiAgICAgIGlmICh0byA+IFNJWkUpIHtcbiAgICAgICAgdG8gPSBTSVpFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgICAgcmV0dXJuIERPTkU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlkeCA9IHJldmVyc2UgPyAtLXRvIDogZnJvbSsrO1xuICAgICAgICByZXR1cm4gYXJyYXkgJiYgYXJyYXlbaWR4XTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXRlcmF0ZU5vZGUobm9kZSwgbGV2ZWwsIG9mZnNldCkge1xuICAgICAgdmFyIHZhbHVlcztcbiAgICAgIHZhciBhcnJheSA9IG5vZGUgJiYgbm9kZS5hcnJheTtcbiAgICAgIHZhciBmcm9tID0gb2Zmc2V0ID4gbGVmdCA/IDAgOiAobGVmdCAtIG9mZnNldCkgPj4gbGV2ZWw7XG4gICAgICB2YXIgdG8gPSAoKHJpZ2h0IC0gb2Zmc2V0KSA+PiBsZXZlbCkgKyAxO1xuICAgICAgaWYgKHRvID4gU0laRSkge1xuICAgICAgICB0byA9IFNJWkU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlcygpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBET05FKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlcyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgICAgICAgcmV0dXJuIERPTkU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpZHggPSByZXZlcnNlID8gLS10byA6IGZyb20rKztcbiAgICAgICAgICB2YWx1ZXMgPSBpdGVyYXRlTm9kZU9yTGVhZihcbiAgICAgICAgICAgIGFycmF5ICYmIGFycmF5W2lkeF0sXG4gICAgICAgICAgICBsZXZlbCAtIFNISUZULFxuICAgICAgICAgICAgb2Zmc2V0ICsgKGlkeCA8PCBsZXZlbClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VMaXN0KG9yaWdpbiwgY2FwYWNpdHksIGxldmVsLCByb290LCB0YWlsLCBvd25lcklELCBoYXNoKSB7XG4gICAgdmFyIGxpc3QgPSBPYmplY3QuY3JlYXRlKExpc3RQcm90b3R5cGUpO1xuICAgIGxpc3Quc2l6ZSA9IGNhcGFjaXR5IC0gb3JpZ2luO1xuICAgIGxpc3QuX29yaWdpbiA9IG9yaWdpbjtcbiAgICBsaXN0Ll9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgIGxpc3QuX2xldmVsID0gbGV2ZWw7XG4gICAgbGlzdC5fcm9vdCA9IHJvb3Q7XG4gICAgbGlzdC5fdGFpbCA9IHRhaWw7XG4gICAgbGlzdC5fX293bmVySUQgPSBvd25lcklEO1xuICAgIGxpc3QuX19oYXNoID0gaGFzaDtcbiAgICBsaXN0Ll9fYWx0ZXJlZCA9IGZhbHNlO1xuICAgIHJldHVybiBsaXN0O1xuICB9XG5cbiAgdmFyIEVNUFRZX0xJU1Q7XG4gIGZ1bmN0aW9uIGVtcHR5TGlzdCgpIHtcbiAgICByZXR1cm4gRU1QVFlfTElTVCB8fCAoRU1QVFlfTElTVCA9IG1ha2VMaXN0KDAsIDAsIFNISUZUKSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMaXN0KGxpc3QsIGluZGV4LCB2YWx1ZSkge1xuICAgIGluZGV4ID0gd3JhcEluZGV4KGxpc3QsIGluZGV4KTtcblxuICAgIGlmIChpbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuICAgIGlmIChpbmRleCA+PSBsaXN0LnNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gbGlzdC53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgIGluZGV4IDwgMFxuICAgICAgICAgID8gc2V0TGlzdEJvdW5kcyhsaXN0LCBpbmRleCkuc2V0KDAsIHZhbHVlKVxuICAgICAgICAgIDogc2V0TGlzdEJvdW5kcyhsaXN0LCAwLCBpbmRleCArIDEpLnNldChpbmRleCwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaW5kZXggKz0gbGlzdC5fb3JpZ2luO1xuXG4gICAgdmFyIG5ld1RhaWwgPSBsaXN0Ll90YWlsO1xuICAgIHZhciBuZXdSb290ID0gbGlzdC5fcm9vdDtcbiAgICB2YXIgZGlkQWx0ZXIgPSBNYWtlUmVmKCk7XG4gICAgaWYgKGluZGV4ID49IGdldFRhaWxPZmZzZXQobGlzdC5fY2FwYWNpdHkpKSB7XG4gICAgICBuZXdUYWlsID0gdXBkYXRlVk5vZGUobmV3VGFpbCwgbGlzdC5fX293bmVySUQsIDAsIGluZGV4LCB2YWx1ZSwgZGlkQWx0ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdSb290ID0gdXBkYXRlVk5vZGUoXG4gICAgICAgIG5ld1Jvb3QsXG4gICAgICAgIGxpc3QuX19vd25lcklELFxuICAgICAgICBsaXN0Ll9sZXZlbCxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkaWRBbHRlclxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWRpZEFsdGVyLnZhbHVlKSB7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICBpZiAobGlzdC5fX293bmVySUQpIHtcbiAgICAgIGxpc3QuX3Jvb3QgPSBuZXdSb290O1xuICAgICAgbGlzdC5fdGFpbCA9IG5ld1RhaWw7XG4gICAgICBsaXN0Ll9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgIGxpc3QuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgICByZXR1cm4gbWFrZUxpc3QobGlzdC5fb3JpZ2luLCBsaXN0Ll9jYXBhY2l0eSwgbGlzdC5fbGV2ZWwsIG5ld1Jvb3QsIG5ld1RhaWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVk5vZGUobm9kZSwgb3duZXJJRCwgbGV2ZWwsIGluZGV4LCB2YWx1ZSwgZGlkQWx0ZXIpIHtcbiAgICB2YXIgaWR4ID0gKGluZGV4ID4+PiBsZXZlbCkgJiBNQVNLO1xuICAgIHZhciBub2RlSGFzID0gbm9kZSAmJiBpZHggPCBub2RlLmFycmF5Lmxlbmd0aDtcbiAgICBpZiAoIW5vZGVIYXMgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgdmFyIG5ld05vZGU7XG5cbiAgICBpZiAobGV2ZWwgPiAwKSB7XG4gICAgICB2YXIgbG93ZXJOb2RlID0gbm9kZSAmJiBub2RlLmFycmF5W2lkeF07XG4gICAgICB2YXIgbmV3TG93ZXJOb2RlID0gdXBkYXRlVk5vZGUoXG4gICAgICAgIGxvd2VyTm9kZSxcbiAgICAgICAgb3duZXJJRCxcbiAgICAgICAgbGV2ZWwgLSBTSElGVCxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkaWRBbHRlclxuICAgICAgKTtcbiAgICAgIGlmIChuZXdMb3dlck5vZGUgPT09IGxvd2VyTm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIG5ld05vZGUgPSBlZGl0YWJsZVZOb2RlKG5vZGUsIG93bmVySUQpO1xuICAgICAgbmV3Tm9kZS5hcnJheVtpZHhdID0gbmV3TG93ZXJOb2RlO1xuICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGVIYXMgJiYgbm9kZS5hcnJheVtpZHhdID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgaWYgKGRpZEFsdGVyKSB7XG4gICAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuICAgIH1cblxuICAgIG5ld05vZGUgPSBlZGl0YWJsZVZOb2RlKG5vZGUsIG93bmVySUQpO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGlkeCA9PT0gbmV3Tm9kZS5hcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICBuZXdOb2RlLmFycmF5LnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdOb2RlLmFycmF5W2lkeF0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBlZGl0YWJsZVZOb2RlKG5vZGUsIG93bmVySUQpIHtcbiAgICBpZiAob3duZXJJRCAmJiBub2RlICYmIG93bmVySUQgPT09IG5vZGUub3duZXJJRCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZSA/IG5vZGUuYXJyYXkuc2xpY2UoKSA6IFtdLCBvd25lcklEKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpc3ROb2RlRm9yKGxpc3QsIHJhd0luZGV4KSB7XG4gICAgaWYgKHJhd0luZGV4ID49IGdldFRhaWxPZmZzZXQobGlzdC5fY2FwYWNpdHkpKSB7XG4gICAgICByZXR1cm4gbGlzdC5fdGFpbDtcbiAgICB9XG4gICAgaWYgKHJhd0luZGV4IDwgMSA8PCAobGlzdC5fbGV2ZWwgKyBTSElGVCkpIHtcbiAgICAgIHZhciBub2RlID0gbGlzdC5fcm9vdDtcbiAgICAgIHZhciBsZXZlbCA9IGxpc3QuX2xldmVsO1xuICAgICAgd2hpbGUgKG5vZGUgJiYgbGV2ZWwgPiAwKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLmFycmF5WyhyYXdJbmRleCA+Pj4gbGV2ZWwpICYgTUFTS107XG4gICAgICAgIGxldmVsIC09IFNISUZUO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0TGlzdEJvdW5kcyhsaXN0LCBiZWdpbiwgZW5kKSB7XG4gICAgLy8gU2FuaXRpemUgYmVnaW4gJiBlbmQgdXNpbmcgdGhpcyBzaG9ydGhhbmQgZm9yIFRvSW50MzIoYXJndW1lbnQpXG4gICAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvaW50MzJcbiAgICBpZiAoYmVnaW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgYmVnaW4gfD0gMDtcbiAgICB9XG4gICAgaWYgKGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmQgfD0gMDtcbiAgICB9XG4gICAgdmFyIG93bmVyID0gbGlzdC5fX293bmVySUQgfHwgbmV3IE93bmVySUQoKTtcbiAgICB2YXIgb2xkT3JpZ2luID0gbGlzdC5fb3JpZ2luO1xuICAgIHZhciBvbGRDYXBhY2l0eSA9IGxpc3QuX2NhcGFjaXR5O1xuICAgIHZhciBuZXdPcmlnaW4gPSBvbGRPcmlnaW4gKyBiZWdpbjtcbiAgICB2YXIgbmV3Q2FwYWNpdHkgPVxuICAgICAgZW5kID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBvbGRDYXBhY2l0eVxuICAgICAgICA6IGVuZCA8IDBcbiAgICAgICAgICA/IG9sZENhcGFjaXR5ICsgZW5kXG4gICAgICAgICAgOiBvbGRPcmlnaW4gKyBlbmQ7XG4gICAgaWYgKG5ld09yaWdpbiA9PT0gb2xkT3JpZ2luICYmIG5ld0NhcGFjaXR5ID09PSBvbGRDYXBhY2l0eSkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgLy8gSWYgaXQncyBnb2luZyB0byBlbmQgYWZ0ZXIgaXQgc3RhcnRzLCBpdCdzIGVtcHR5LlxuICAgIGlmIChuZXdPcmlnaW4gPj0gbmV3Q2FwYWNpdHkpIHtcbiAgICAgIHJldHVybiBsaXN0LmNsZWFyKCk7XG4gICAgfVxuXG4gICAgdmFyIG5ld0xldmVsID0gbGlzdC5fbGV2ZWw7XG4gICAgdmFyIG5ld1Jvb3QgPSBsaXN0Ll9yb290O1xuXG4gICAgLy8gTmV3IG9yaWdpbiBtaWdodCBuZWVkIGNyZWF0aW5nIGEgaGlnaGVyIHJvb3QuXG4gICAgdmFyIG9mZnNldFNoaWZ0ID0gMDtcbiAgICB3aGlsZSAobmV3T3JpZ2luICsgb2Zmc2V0U2hpZnQgPCAwKSB7XG4gICAgICBuZXdSb290ID0gbmV3IFZOb2RlKFxuICAgICAgICBuZXdSb290ICYmIG5ld1Jvb3QuYXJyYXkubGVuZ3RoID8gW3VuZGVmaW5lZCwgbmV3Um9vdF0gOiBbXSxcbiAgICAgICAgb3duZXJcbiAgICAgICk7XG4gICAgICBuZXdMZXZlbCArPSBTSElGVDtcbiAgICAgIG9mZnNldFNoaWZ0ICs9IDEgPDwgbmV3TGV2ZWw7XG4gICAgfVxuICAgIGlmIChvZmZzZXRTaGlmdCkge1xuICAgICAgbmV3T3JpZ2luICs9IG9mZnNldFNoaWZ0O1xuICAgICAgb2xkT3JpZ2luICs9IG9mZnNldFNoaWZ0O1xuICAgICAgbmV3Q2FwYWNpdHkgKz0gb2Zmc2V0U2hpZnQ7XG4gICAgICBvbGRDYXBhY2l0eSArPSBvZmZzZXRTaGlmdDtcbiAgICB9XG5cbiAgICB2YXIgb2xkVGFpbE9mZnNldCA9IGdldFRhaWxPZmZzZXQob2xkQ2FwYWNpdHkpO1xuICAgIHZhciBuZXdUYWlsT2Zmc2V0ID0gZ2V0VGFpbE9mZnNldChuZXdDYXBhY2l0eSk7XG5cbiAgICAvLyBOZXcgc2l6ZSBtaWdodCBuZWVkIGNyZWF0aW5nIGEgaGlnaGVyIHJvb3QuXG4gICAgd2hpbGUgKG5ld1RhaWxPZmZzZXQgPj0gMSA8PCAobmV3TGV2ZWwgKyBTSElGVCkpIHtcbiAgICAgIG5ld1Jvb3QgPSBuZXcgVk5vZGUoXG4gICAgICAgIG5ld1Jvb3QgJiYgbmV3Um9vdC5hcnJheS5sZW5ndGggPyBbbmV3Um9vdF0gOiBbXSxcbiAgICAgICAgb3duZXJcbiAgICAgICk7XG4gICAgICBuZXdMZXZlbCArPSBTSElGVDtcbiAgICB9XG5cbiAgICAvLyBMb2NhdGUgb3IgY3JlYXRlIHRoZSBuZXcgdGFpbC5cbiAgICB2YXIgb2xkVGFpbCA9IGxpc3QuX3RhaWw7XG4gICAgdmFyIG5ld1RhaWwgPVxuICAgICAgbmV3VGFpbE9mZnNldCA8IG9sZFRhaWxPZmZzZXRcbiAgICAgICAgPyBsaXN0Tm9kZUZvcihsaXN0LCBuZXdDYXBhY2l0eSAtIDEpXG4gICAgICAgIDogbmV3VGFpbE9mZnNldCA+IG9sZFRhaWxPZmZzZXRcbiAgICAgICAgICA/IG5ldyBWTm9kZShbXSwgb3duZXIpXG4gICAgICAgICAgOiBvbGRUYWlsO1xuXG4gICAgLy8gTWVyZ2UgVGFpbCBpbnRvIHRyZWUuXG4gICAgaWYgKFxuICAgICAgb2xkVGFpbCAmJlxuICAgICAgbmV3VGFpbE9mZnNldCA+IG9sZFRhaWxPZmZzZXQgJiZcbiAgICAgIG5ld09yaWdpbiA8IG9sZENhcGFjaXR5ICYmXG4gICAgICBvbGRUYWlsLmFycmF5Lmxlbmd0aFxuICAgICkge1xuICAgICAgbmV3Um9vdCA9IGVkaXRhYmxlVk5vZGUobmV3Um9vdCwgb3duZXIpO1xuICAgICAgdmFyIG5vZGUgPSBuZXdSb290O1xuICAgICAgZm9yICh2YXIgbGV2ZWwgPSBuZXdMZXZlbDsgbGV2ZWwgPiBTSElGVDsgbGV2ZWwgLT0gU0hJRlQpIHtcbiAgICAgICAgdmFyIGlkeCA9IChvbGRUYWlsT2Zmc2V0ID4+PiBsZXZlbCkgJiBNQVNLO1xuICAgICAgICBub2RlID0gbm9kZS5hcnJheVtpZHhdID0gZWRpdGFibGVWTm9kZShub2RlLmFycmF5W2lkeF0sIG93bmVyKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuYXJyYXlbKG9sZFRhaWxPZmZzZXQgPj4+IFNISUZUKSAmIE1BU0tdID0gb2xkVGFpbDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgc2l6ZSBoYXMgYmVlbiByZWR1Y2VkLCB0aGVyZSdzIGEgY2hhbmNlIHRoZSB0YWlsIG5lZWRzIHRvIGJlIHRyaW1tZWQuXG4gICAgaWYgKG5ld0NhcGFjaXR5IDwgb2xkQ2FwYWNpdHkpIHtcbiAgICAgIG5ld1RhaWwgPSBuZXdUYWlsICYmIG5ld1RhaWwucmVtb3ZlQWZ0ZXIob3duZXIsIDAsIG5ld0NhcGFjaXR5KTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbmV3IG9yaWdpbiBpcyB3aXRoaW4gdGhlIHRhaWwsIHRoZW4gd2UgZG8gbm90IG5lZWQgYSByb290LlxuICAgIGlmIChuZXdPcmlnaW4gPj0gbmV3VGFpbE9mZnNldCkge1xuICAgICAgbmV3T3JpZ2luIC09IG5ld1RhaWxPZmZzZXQ7XG4gICAgICBuZXdDYXBhY2l0eSAtPSBuZXdUYWlsT2Zmc2V0O1xuICAgICAgbmV3TGV2ZWwgPSBTSElGVDtcbiAgICAgIG5ld1Jvb3QgPSBudWxsO1xuICAgICAgbmV3VGFpbCA9IG5ld1RhaWwgJiYgbmV3VGFpbC5yZW1vdmVCZWZvcmUob3duZXIsIDAsIG5ld09yaWdpbik7XG5cbiAgICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlIHJvb3QgaGFzIGJlZW4gdHJpbW1lZCwgZ2FyYmFnZSBjb2xsZWN0LlxuICAgIH0gZWxzZSBpZiAobmV3T3JpZ2luID4gb2xkT3JpZ2luIHx8IG5ld1RhaWxPZmZzZXQgPCBvbGRUYWlsT2Zmc2V0KSB7XG4gICAgICBvZmZzZXRTaGlmdCA9IDA7XG5cbiAgICAgIC8vIElkZW50aWZ5IHRoZSBuZXcgdG9wIHJvb3Qgbm9kZSBvZiB0aGUgc3VidHJlZSBvZiB0aGUgb2xkIHJvb3QuXG4gICAgICB3aGlsZSAobmV3Um9vdCkge1xuICAgICAgICB2YXIgYmVnaW5JbmRleCA9IChuZXdPcmlnaW4gPj4+IG5ld0xldmVsKSAmIE1BU0s7XG4gICAgICAgIGlmICgoYmVnaW5JbmRleCAhPT0gbmV3VGFpbE9mZnNldCA+Pj4gbmV3TGV2ZWwpICYgTUFTSykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiZWdpbkluZGV4KSB7XG4gICAgICAgICAgb2Zmc2V0U2hpZnQgKz0gKDEgPDwgbmV3TGV2ZWwpICogYmVnaW5JbmRleDtcbiAgICAgICAgfVxuICAgICAgICBuZXdMZXZlbCAtPSBTSElGVDtcbiAgICAgICAgbmV3Um9vdCA9IG5ld1Jvb3QuYXJyYXlbYmVnaW5JbmRleF07XG4gICAgICB9XG5cbiAgICAgIC8vIFRyaW0gdGhlIG5ldyBzaWRlcyBvZiB0aGUgbmV3IHJvb3QuXG4gICAgICBpZiAobmV3Um9vdCAmJiBuZXdPcmlnaW4gPiBvbGRPcmlnaW4pIHtcbiAgICAgICAgbmV3Um9vdCA9IG5ld1Jvb3QucmVtb3ZlQmVmb3JlKG93bmVyLCBuZXdMZXZlbCwgbmV3T3JpZ2luIC0gb2Zmc2V0U2hpZnQpO1xuICAgICAgfVxuICAgICAgaWYgKG5ld1Jvb3QgJiYgbmV3VGFpbE9mZnNldCA8IG9sZFRhaWxPZmZzZXQpIHtcbiAgICAgICAgbmV3Um9vdCA9IG5ld1Jvb3QucmVtb3ZlQWZ0ZXIoXG4gICAgICAgICAgb3duZXIsXG4gICAgICAgICAgbmV3TGV2ZWwsXG4gICAgICAgICAgbmV3VGFpbE9mZnNldCAtIG9mZnNldFNoaWZ0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAob2Zmc2V0U2hpZnQpIHtcbiAgICAgICAgbmV3T3JpZ2luIC09IG9mZnNldFNoaWZ0O1xuICAgICAgICBuZXdDYXBhY2l0eSAtPSBvZmZzZXRTaGlmdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGlzdC5fX293bmVySUQpIHtcbiAgICAgIGxpc3Quc2l6ZSA9IG5ld0NhcGFjaXR5IC0gbmV3T3JpZ2luO1xuICAgICAgbGlzdC5fb3JpZ2luID0gbmV3T3JpZ2luO1xuICAgICAgbGlzdC5fY2FwYWNpdHkgPSBuZXdDYXBhY2l0eTtcbiAgICAgIGxpc3QuX2xldmVsID0gbmV3TGV2ZWw7XG4gICAgICBsaXN0Ll9yb290ID0gbmV3Um9vdDtcbiAgICAgIGxpc3QuX3RhaWwgPSBuZXdUYWlsO1xuICAgICAgbGlzdC5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICBsaXN0Ll9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VMaXN0KG5ld09yaWdpbiwgbmV3Q2FwYWNpdHksIG5ld0xldmVsLCBuZXdSb290LCBuZXdUYWlsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRhaWxPZmZzZXQoc2l6ZSkge1xuICAgIHJldHVybiBzaXplIDwgU0laRSA/IDAgOiAoKHNpemUgLSAxKSA+Pj4gU0hJRlQpIDw8IFNISUZUO1xuICB9XG5cbiAgdmFyIE9yZGVyZWRNYXAgPSAoZnVuY3Rpb24gKE1hcCQkMSkge1xuICAgIGZ1bmN0aW9uIE9yZGVyZWRNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gZW1wdHlPcmRlcmVkTWFwKClcbiAgICAgICAgOiBpc09yZGVyZWRNYXAodmFsdWUpXG4gICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgIDogZW1wdHlPcmRlcmVkTWFwKCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICAgIHZhciBpdGVyID0gS2V5ZWRDb2xsZWN0aW9uKHZhbHVlKTtcbiAgICAgICAgICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgICAgICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBtYXAuc2V0KGssIHYpOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICggTWFwJCQxICkgT3JkZXJlZE1hcC5fX3Byb3RvX18gPSBNYXAkJDE7XG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXAkJDEgJiYgTWFwJCQxLnByb3RvdHlwZSApO1xuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT3JkZXJlZE1hcDtcblxuICAgIE9yZGVyZWRNYXAub2YgPSBmdW5jdGlvbiBvZiAoLyouLi52YWx1ZXMqLykge1xuICAgICAgcmV0dXJuIHRoaXMoYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdPcmRlcmVkTWFwIHsnLCAnfScpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIEFjY2Vzc1xuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChrLCBub3RTZXRWYWx1ZSkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fbWFwLmdldChrKTtcbiAgICAgIHJldHVybiBpbmRleCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fbGlzdC5nZXQoaW5kZXgpWzFdIDogbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgdGhpcy5fbWFwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2xpc3QuY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlPcmRlcmVkTWFwKCk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoaywgdikge1xuICAgICAgcmV0dXJuIHVwZGF0ZU9yZGVyZWRNYXAodGhpcywgaywgdik7XG4gICAgfTtcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoaykge1xuICAgICAgcmV0dXJuIHVwZGF0ZU9yZGVyZWRNYXAodGhpcywgaywgTk9UX1NFVCk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLndhc0FsdGVyZWQgPSBmdW5jdGlvbiB3YXNBbHRlcmVkICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAud2FzQWx0ZXJlZCgpIHx8IHRoaXMuX2xpc3Qud2FzQWx0ZXJlZCgpO1xuICAgIH07XG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMuX2xpc3QuX19pdGVyYXRlKFxuICAgICAgICBmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5ICYmIGZuKGVudHJ5WzFdLCBlbnRyeVswXSwgdGhpcyQxKTsgfSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9saXN0LmZyb21FbnRyeVNlcSgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbiBfX2Vuc3VyZU93bmVyIChvd25lcklEKSB7XG4gICAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgbmV3TWFwID0gdGhpcy5fbWFwLl9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgICB2YXIgbmV3TGlzdCA9IHRoaXMuX2xpc3QuX19lbnN1cmVPd25lcihvd25lcklEKTtcbiAgICAgIGlmICghb3duZXJJRCkge1xuICAgICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGVtcHR5T3JkZXJlZE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3TWFwO1xuICAgICAgICB0aGlzLl9saXN0ID0gbmV3TGlzdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZU9yZGVyZWRNYXAobmV3TWFwLCBuZXdMaXN0LCBvd25lcklELCB0aGlzLl9faGFzaCk7XG4gICAgfTtcblxuICAgIHJldHVybiBPcmRlcmVkTWFwO1xuICB9KE1hcCkpO1xuXG4gIE9yZGVyZWRNYXAuaXNPcmRlcmVkTWFwID0gaXNPcmRlcmVkTWFwO1xuXG4gIE9yZGVyZWRNYXAucHJvdG90eXBlW0lTX09SREVSRURfU1lNQk9MXSA9IHRydWU7XG4gIE9yZGVyZWRNYXAucHJvdG90eXBlW0RFTEVURV0gPSBPcmRlcmVkTWFwLnByb3RvdHlwZS5yZW1vdmU7XG5cbiAgZnVuY3Rpb24gbWFrZU9yZGVyZWRNYXAobWFwLCBsaXN0LCBvd25lcklELCBoYXNoKSB7XG4gICAgdmFyIG9tYXAgPSBPYmplY3QuY3JlYXRlKE9yZGVyZWRNYXAucHJvdG90eXBlKTtcbiAgICBvbWFwLnNpemUgPSBtYXAgPyBtYXAuc2l6ZSA6IDA7XG4gICAgb21hcC5fbWFwID0gbWFwO1xuICAgIG9tYXAuX2xpc3QgPSBsaXN0O1xuICAgIG9tYXAuX19vd25lcklEID0gb3duZXJJRDtcbiAgICBvbWFwLl9faGFzaCA9IGhhc2g7XG4gICAgcmV0dXJuIG9tYXA7XG4gIH1cblxuICB2YXIgRU1QVFlfT1JERVJFRF9NQVA7XG4gIGZ1bmN0aW9uIGVtcHR5T3JkZXJlZE1hcCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgRU1QVFlfT1JERVJFRF9NQVAgfHxcbiAgICAgIChFTVBUWV9PUkRFUkVEX01BUCA9IG1ha2VPcmRlcmVkTWFwKGVtcHR5TWFwKCksIGVtcHR5TGlzdCgpKSlcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlT3JkZXJlZE1hcChvbWFwLCBrLCB2KSB7XG4gICAgdmFyIG1hcCA9IG9tYXAuX21hcDtcbiAgICB2YXIgbGlzdCA9IG9tYXAuX2xpc3Q7XG4gICAgdmFyIGkgPSBtYXAuZ2V0KGspO1xuICAgIHZhciBoYXMgPSBpICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIG5ld01hcDtcbiAgICB2YXIgbmV3TGlzdDtcbiAgICBpZiAodiA9PT0gTk9UX1NFVCkge1xuICAgICAgLy8gcmVtb3ZlZFxuICAgICAgaWYgKCFoYXMpIHtcbiAgICAgICAgcmV0dXJuIG9tYXA7XG4gICAgICB9XG4gICAgICBpZiAobGlzdC5zaXplID49IFNJWkUgJiYgbGlzdC5zaXplID49IG1hcC5zaXplICogMikge1xuICAgICAgICBuZXdMaXN0ID0gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5LCBpZHgpIHsgcmV0dXJuIGVudHJ5ICE9PSB1bmRlZmluZWQgJiYgaSAhPT0gaWR4OyB9KTtcbiAgICAgICAgbmV3TWFwID0gbmV3TGlzdFxuICAgICAgICAgIC50b0tleWVkU2VxKClcbiAgICAgICAgICAubWFwKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnlbMF07IH0pXG4gICAgICAgICAgLmZsaXAoKVxuICAgICAgICAgIC50b01hcCgpO1xuICAgICAgICBpZiAob21hcC5fX293bmVySUQpIHtcbiAgICAgICAgICBuZXdNYXAuX19vd25lcklEID0gbmV3TGlzdC5fX293bmVySUQgPSBvbWFwLl9fb3duZXJJRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3TWFwID0gbWFwLnJlbW92ZShrKTtcbiAgICAgICAgbmV3TGlzdCA9IGkgPT09IGxpc3Quc2l6ZSAtIDEgPyBsaXN0LnBvcCgpIDogbGlzdC5zZXQoaSwgdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhhcykge1xuICAgICAgaWYgKHYgPT09IGxpc3QuZ2V0KGkpWzFdKSB7XG4gICAgICAgIHJldHVybiBvbWFwO1xuICAgICAgfVxuICAgICAgbmV3TWFwID0gbWFwO1xuICAgICAgbmV3TGlzdCA9IGxpc3Quc2V0KGksIFtrLCB2XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld01hcCA9IG1hcC5zZXQoaywgbGlzdC5zaXplKTtcbiAgICAgIG5ld0xpc3QgPSBsaXN0LnNldChsaXN0LnNpemUsIFtrLCB2XSk7XG4gICAgfVxuICAgIGlmIChvbWFwLl9fb3duZXJJRCkge1xuICAgICAgb21hcC5zaXplID0gbmV3TWFwLnNpemU7XG4gICAgICBvbWFwLl9tYXAgPSBuZXdNYXA7XG4gICAgICBvbWFwLl9saXN0ID0gbmV3TGlzdDtcbiAgICAgIG9tYXAuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIG9tYXA7XG4gICAgfVxuICAgIHJldHVybiBtYWtlT3JkZXJlZE1hcChuZXdNYXAsIG5ld0xpc3QpO1xuICB9XG5cbiAgdmFyIElTX1NUQUNLX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX1NUQUNLX19AQCc7XG5cbiAgZnVuY3Rpb24gaXNTdGFjayhtYXliZVN0YWNrKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4obWF5YmVTdGFjayAmJiBtYXliZVN0YWNrW0lTX1NUQUNLX1NZTUJPTF0pO1xuICB9XG5cbiAgdmFyIFN0YWNrID0gKGZ1bmN0aW9uIChJbmRleGVkQ29sbGVjdGlvbiQkMSkge1xuICAgIGZ1bmN0aW9uIFN0YWNrKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGVtcHR5U3RhY2soKVxuICAgICAgICA6IGlzU3RhY2sodmFsdWUpXG4gICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgIDogZW1wdHlTdGFjaygpLnB1c2hBbGwodmFsdWUpO1xuICAgIH1cblxuICAgIGlmICggSW5kZXhlZENvbGxlY3Rpb24kJDEgKSBTdGFjay5fX3Byb3RvX18gPSBJbmRleGVkQ29sbGVjdGlvbiQkMTtcbiAgICBTdGFjay5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkQ29sbGVjdGlvbiQkMSAmJiBJbmRleGVkQ29sbGVjdGlvbiQkMS5wcm90b3R5cGUgKTtcbiAgICBTdGFjay5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdGFjaztcblxuICAgIFN0YWNrLm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ1N0YWNrIFsnLCAnXScpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIEFjY2Vzc1xuXG4gICAgU3RhY2sucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgICBpbmRleCA9IHdyYXBJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgICB3aGlsZSAoaGVhZCAmJiBpbmRleC0tKSB7XG4gICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGVhZCA/IGhlYWQudmFsdWUgOiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiBwZWVrICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oZWFkICYmIHRoaXMuX2hlYWQudmFsdWU7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgICBTdGFjay5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgbmV3U2l6ZSA9IHRoaXMuc2l6ZSArIGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgICBmb3IgKHZhciBpaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpaSA+PSAwOyBpaS0tKSB7XG4gICAgICAgIGhlYWQgPSB7XG4gICAgICAgICAgdmFsdWU6IGFyZ3VtZW50cyQxW2lpXSxcbiAgICAgICAgICBuZXh0OiBoZWFkLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG5ld1NpemU7XG4gICAgICAgIHRoaXMuX2hlYWQgPSBoZWFkO1xuICAgICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlU3RhY2sobmV3U2l6ZSwgaGVhZCk7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS5wdXNoQWxsID0gZnVuY3Rpb24gcHVzaEFsbCAoaXRlcikge1xuICAgICAgaXRlciA9IEluZGV4ZWRDb2xsZWN0aW9uJCQxKGl0ZXIpO1xuICAgICAgaWYgKGl0ZXIuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDAgJiYgaXNTdGFjayhpdGVyKSkge1xuICAgICAgICByZXR1cm4gaXRlcjtcbiAgICAgIH1cbiAgICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgICB2YXIgbmV3U2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgIHZhciBoZWFkID0gdGhpcy5faGVhZDtcbiAgICAgIGl0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBuZXdTaXplKys7XG4gICAgICAgIGhlYWQgPSB7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIG5leHQ6IGhlYWQsXG4gICAgICAgIH07XG4gICAgICB9LCAvKiByZXZlcnNlICovIHRydWUpO1xuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG5ld1NpemU7XG4gICAgICAgIHRoaXMuX2hlYWQgPSBoZWFkO1xuICAgICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlU3RhY2sobmV3U2l6ZSwgaGVhZCk7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiBwb3AgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoMSk7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgdGhpcy5faGVhZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlTdGFjaygpO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoYmVnaW4sIGVuZCkge1xuICAgICAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgdGhpcy5zaXplKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciByZXNvbHZlZEJlZ2luID0gcmVzb2x2ZUJlZ2luKGJlZ2luLCB0aGlzLnNpemUpO1xuICAgICAgdmFyIHJlc29sdmVkRW5kID0gcmVzb2x2ZUVuZChlbmQsIHRoaXMuc2l6ZSk7XG4gICAgICBpZiAocmVzb2x2ZWRFbmQgIT09IHRoaXMuc2l6ZSkge1xuICAgICAgICAvLyBzdXBlci5zbGljZShiZWdpbiwgZW5kKTtcbiAgICAgICAgcmV0dXJuIEluZGV4ZWRDb2xsZWN0aW9uJCQxLnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1NpemUgPSB0aGlzLnNpemUgLSByZXNvbHZlZEJlZ2luO1xuICAgICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgICAgd2hpbGUgKHJlc29sdmVkQmVnaW4tLSkge1xuICAgICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG5ld1NpemU7XG4gICAgICAgIHRoaXMuX2hlYWQgPSBoZWFkO1xuICAgICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlU3RhY2sobmV3U2l6ZSwgaGVhZCk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTXV0YWJpbGl0eVxuXG4gICAgU3RhY2sucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbiBfX2Vuc3VyZU93bmVyIChvd25lcklEKSB7XG4gICAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBlbXB0eVN0YWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgICAgICB0aGlzLl9fYWx0ZXJlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlU3RhY2sodGhpcy5zaXplLCB0aGlzLl9oZWFkLCBvd25lcklELCB0aGlzLl9faGFzaCk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgSXRlcmF0aW9uXG5cbiAgICBTdGFjay5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlTZXEodGhpcy50b0FycmF5KCkpLl9faXRlcmF0ZShcbiAgICAgICAgICBmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gZm4odiwgaywgdGhpcyQxKTsgfSxcbiAgICAgICAgICByZXZlcnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuX2hlYWQ7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAoZm4obm9kZS52YWx1ZSwgaXRlcmF0aW9ucysrLCB0aGlzJDEpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5U2VxKHRoaXMudG9BcnJheSgpKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLl9oZWFkO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gU3RhY2s7XG4gIH0oSW5kZXhlZENvbGxlY3Rpb24pKTtcblxuICBTdGFjay5pc1N0YWNrID0gaXNTdGFjaztcblxuICB2YXIgU3RhY2tQcm90b3R5cGUgPSBTdGFjay5wcm90b3R5cGU7XG4gIFN0YWNrUHJvdG90eXBlW0lTX1NUQUNLX1NZTUJPTF0gPSB0cnVlO1xuICBTdGFja1Byb3RvdHlwZS5zaGlmdCA9IFN0YWNrUHJvdG90eXBlLnBvcDtcbiAgU3RhY2tQcm90b3R5cGUudW5zaGlmdCA9IFN0YWNrUHJvdG90eXBlLnB1c2g7XG4gIFN0YWNrUHJvdG90eXBlLnVuc2hpZnRBbGwgPSBTdGFja1Byb3RvdHlwZS5wdXNoQWxsO1xuICBTdGFja1Byb3RvdHlwZS53aXRoTXV0YXRpb25zID0gd2l0aE11dGF0aW9ucztcbiAgU3RhY2tQcm90b3R5cGUud2FzQWx0ZXJlZCA9IHdhc0FsdGVyZWQ7XG4gIFN0YWNrUHJvdG90eXBlLmFzSW1tdXRhYmxlID0gYXNJbW11dGFibGU7XG4gIFN0YWNrUHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gU3RhY2tQcm90b3R5cGUuYXNNdXRhYmxlID0gYXNNdXRhYmxlO1xuICBTdGFja1Byb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKHJlc3VsdCwgYXJyKSB7XG4gICAgcmV0dXJuIHJlc3VsdC51bnNoaWZ0KGFycik7XG4gIH07XG4gIFN0YWNrUHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqLmFzSW1tdXRhYmxlKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZVN0YWNrKHNpemUsIGhlYWQsIG93bmVySUQsIGhhc2gpIHtcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShTdGFja1Byb3RvdHlwZSk7XG4gICAgbWFwLnNpemUgPSBzaXplO1xuICAgIG1hcC5faGVhZCA9IGhlYWQ7XG4gICAgbWFwLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgbWFwLl9faGFzaCA9IGhhc2g7XG4gICAgbWFwLl9fYWx0ZXJlZCA9IGZhbHNlO1xuICAgIHJldHVybiBtYXA7XG4gIH1cblxuICB2YXIgRU1QVFlfU1RBQ0s7XG4gIGZ1bmN0aW9uIGVtcHR5U3RhY2soKSB7XG4gICAgcmV0dXJuIEVNUFRZX1NUQUNLIHx8IChFTVBUWV9TVEFDSyA9IG1ha2VTdGFjaygwKSk7XG4gIH1cblxuICB2YXIgSVNfU0VUX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX1NFVF9fQEAnO1xuXG4gIGZ1bmN0aW9uIGlzU2V0KG1heWJlU2V0KSB7XG4gICAgcmV0dXJuIEJvb2xlYW4obWF5YmVTZXQgJiYgbWF5YmVTZXRbSVNfU0VUX1NZTUJPTF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNPcmRlcmVkU2V0KG1heWJlT3JkZXJlZFNldCkge1xuICAgIHJldHVybiBpc1NldChtYXliZU9yZGVyZWRTZXQpICYmIGlzT3JkZXJlZChtYXliZU9yZGVyZWRTZXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgIWlzQ29sbGVjdGlvbihiKSB8fFxuICAgICAgKGEuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGIuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGEuc2l6ZSAhPT0gYi5zaXplKSB8fFxuICAgICAgKGEuX19oYXNoICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgYi5fX2hhc2ggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBhLl9faGFzaCAhPT0gYi5fX2hhc2gpIHx8XG4gICAgICBpc0tleWVkKGEpICE9PSBpc0tleWVkKGIpIHx8XG4gICAgICBpc0luZGV4ZWQoYSkgIT09IGlzSW5kZXhlZChiKSB8fFxuICAgICAgaXNPcmRlcmVkKGEpICE9PSBpc09yZGVyZWQoYilcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYS5zaXplID09PSAwICYmIGIuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIG5vdEFzc29jaWF0aXZlID0gIWlzQXNzb2NpYXRpdmUoYSk7XG5cbiAgICBpZiAoaXNPcmRlcmVkKGEpKSB7XG4gICAgICB2YXIgZW50cmllcyA9IGEuZW50cmllcygpO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgYi5ldmVyeShmdW5jdGlvbiAodiwgaykge1xuICAgICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXMubmV4dCgpLnZhbHVlO1xuICAgICAgICAgIHJldHVybiBlbnRyeSAmJiBpcyhlbnRyeVsxXSwgdikgJiYgKG5vdEFzc29jaWF0aXZlIHx8IGlzKGVudHJ5WzBdLCBrKSk7XG4gICAgICAgIH0pICYmIGVudHJpZXMubmV4dCgpLmRvbmVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGZsaXBwZWQgPSBmYWxzZTtcblxuICAgIGlmIChhLnNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGIuc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYS5jYWNoZVJlc3VsdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGEuY2FjaGVSZXN1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmxpcHBlZCA9IHRydWU7XG4gICAgICAgIHZhciBfID0gYTtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGIgPSBfO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhbGxFcXVhbCA9IHRydWU7XG4gICAgdmFyIGJTaXplID0gYi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgIGlmIChcbiAgICAgICAgbm90QXNzb2NpYXRpdmVcbiAgICAgICAgICA/ICFhLmhhcyh2KVxuICAgICAgICAgIDogZmxpcHBlZFxuICAgICAgICAgICAgPyAhaXModiwgYS5nZXQoaywgTk9UX1NFVCkpXG4gICAgICAgICAgICA6ICFpcyhhLmdldChrLCBOT1RfU0VUKSwgdilcbiAgICAgICkge1xuICAgICAgICBhbGxFcXVhbCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYWxsRXF1YWwgJiYgYS5zaXplID09PSBiU2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb250cmlidXRlcyBhZGRpdGlvbmFsIG1ldGhvZHMgdG8gYSBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gbWl4aW4oY3RvciwgbWV0aG9kcykge1xuICAgIHZhciBrZXlDb3BpZXIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBjdG9yLnByb3RvdHlwZVtrZXldID0gbWV0aG9kc1trZXldO1xuICAgIH07XG4gICAgT2JqZWN0LmtleXMobWV0aG9kcykuZm9yRWFjaChrZXlDb3BpZXIpO1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiZcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobWV0aG9kcykuZm9yRWFjaChrZXlDb3BpZXIpO1xuICAgIHJldHVybiBjdG9yO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9KUyh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoIWlzQ29sbGVjdGlvbih2YWx1ZSkpIHtcbiAgICAgIGlmICghaXNEYXRhU3RydWN0dXJlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IFNlcSh2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChpc0tleWVkKHZhbHVlKSkge1xuICAgICAgdmFyIHJlc3VsdCQxID0ge307XG4gICAgICB2YWx1ZS5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgcmVzdWx0JDFba10gPSB0b0pTKHYpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0JDE7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YWx1ZS5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHRvSlModikpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgU2V0ID0gKGZ1bmN0aW9uIChTZXRDb2xsZWN0aW9uJCQxKSB7XG4gICAgZnVuY3Rpb24gU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGVtcHR5U2V0KClcbiAgICAgICAgOiBpc1NldCh2YWx1ZSkgJiYgIWlzT3JkZXJlZCh2YWx1ZSlcbiAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgOiBlbXB0eVNldCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKHNldCkge1xuICAgICAgICAgICAgICB2YXIgaXRlciA9IFNldENvbGxlY3Rpb24kJDEodmFsdWUpO1xuICAgICAgICAgICAgICBhc3NlcnROb3RJbmZpbml0ZShpdGVyLnNpemUpO1xuICAgICAgICAgICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHNldC5hZGQodik7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCBTZXRDb2xsZWN0aW9uJCQxICkgU2V0Ll9fcHJvdG9fXyA9IFNldENvbGxlY3Rpb24kJDE7XG4gICAgU2V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNldENvbGxlY3Rpb24kJDEgJiYgU2V0Q29sbGVjdGlvbiQkMS5wcm90b3R5cGUgKTtcbiAgICBTZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2V0O1xuXG4gICAgU2V0Lm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIFNldC5mcm9tS2V5cyA9IGZ1bmN0aW9uIGZyb21LZXlzICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMoS2V5ZWRDb2xsZWN0aW9uKHZhbHVlKS5rZXlTZXEoKSk7XG4gICAgfTtcblxuICAgIFNldC5pbnRlcnNlY3QgPSBmdW5jdGlvbiBpbnRlcnNlY3QgKHNldHMpIHtcbiAgICAgIHNldHMgPSBDb2xsZWN0aW9uKHNldHMpLnRvQXJyYXkoKTtcbiAgICAgIHJldHVybiBzZXRzLmxlbmd0aFxuICAgICAgICA/IFNldFByb3RvdHlwZS5pbnRlcnNlY3QuYXBwbHkoU2V0KHNldHMucG9wKCkpLCBzZXRzKVxuICAgICAgICA6IGVtcHR5U2V0KCk7XG4gICAgfTtcblxuICAgIFNldC51bmlvbiA9IGZ1bmN0aW9uIHVuaW9uIChzZXRzKSB7XG4gICAgICBzZXRzID0gQ29sbGVjdGlvbihzZXRzKS50b0FycmF5KCk7XG4gICAgICByZXR1cm4gc2V0cy5sZW5ndGhcbiAgICAgICAgPyBTZXRQcm90b3R5cGUudW5pb24uYXBwbHkoU2V0KHNldHMucG9wKCkpLCBzZXRzKVxuICAgICAgICA6IGVtcHR5U2V0KCk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdTZXQgeycsICd9Jyk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHVwZGF0ZVNldCh0aGlzLCB0aGlzLl9tYXAuc2V0KHZhbHVlLCB2YWx1ZSkpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAodmFsdWUpIHtcbiAgICAgIHJldHVybiB1cGRhdGVTZXQodGhpcywgdGhpcy5fbWFwLnJlbW92ZSh2YWx1ZSkpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgcmV0dXJuIHVwZGF0ZVNldCh0aGlzLCB0aGlzLl9tYXAuY2xlYXIoKSk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQ29tcG9zaXRpb25cblxuICAgIFNldC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdXBkYXRlU2V0KHRoaXMsIHRoaXMuX21hcC5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG1hcHBlcih2LCB2LCB0aGlzJDEpOyB9LCBjb250ZXh0KSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUudW5pb24gPSBmdW5jdGlvbiB1bmlvbiAoKSB7XG4gICAgICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICBpdGVycyA9IGl0ZXJzLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5zaXplICE9PSAwOyB9KTtcbiAgICAgIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwICYmICF0aGlzLl9fb3duZXJJRCAmJiBpdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IoaXRlcnNbMF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBpdGVycy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICBTZXRDb2xsZWN0aW9uJCQxKGl0ZXJzW2lpXSkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHNldC5hZGQodmFsdWUpOyB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24gaW50ZXJzZWN0ICgpIHtcbiAgICAgIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIGl0ZXJzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpdGVycyA9IGl0ZXJzLm1hcChmdW5jdGlvbiAoaXRlcikgeyByZXR1cm4gU2V0Q29sbGVjdGlvbiQkMShpdGVyKTsgfSk7XG4gICAgICB2YXIgdG9SZW1vdmUgPSBbXTtcbiAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpdGVycy5ldmVyeShmdW5jdGlvbiAoaXRlcikgeyByZXR1cm4gaXRlci5pbmNsdWRlcyh2YWx1ZSk7IH0pKSB7XG4gICAgICAgICAgdG9SZW1vdmUucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgIHRvUmVtb3ZlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgc2V0LnJlbW92ZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdCAoKSB7XG4gICAgICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaXRlcnMgPSBpdGVycy5tYXAoZnVuY3Rpb24gKGl0ZXIpIHsgcmV0dXJuIFNldENvbGxlY3Rpb24kJDEoaXRlcik7IH0pO1xuICAgICAgdmFyIHRvUmVtb3ZlID0gW107XG4gICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChpdGVycy5zb21lKGZ1bmN0aW9uIChpdGVyKSB7IHJldHVybiBpdGVyLmluY2x1ZGVzKHZhbHVlKTsgfSkpIHtcbiAgICAgICAgICB0b1JlbW92ZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgICAgdG9SZW1vdmUuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBzZXQucmVtb3ZlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gc29ydCAoY29tcGFyYXRvcikge1xuICAgICAgLy8gTGF0ZSBiaW5kaW5nXG4gICAgICByZXR1cm4gT3JkZXJlZFNldChzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yKSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuc29ydEJ5ID0gZnVuY3Rpb24gc29ydEJ5IChtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICAgIC8vIExhdGUgYmluZGluZ1xuICAgICAgcmV0dXJuIE9yZGVyZWRTZXQoc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvciwgbWFwcGVyKSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUud2FzQWx0ZXJlZCA9IGZ1bmN0aW9uIHdhc0FsdGVyZWQgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hcC53YXNBbHRlcmVkKCk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLl9tYXAuX19pdGVyYXRlKGZ1bmN0aW9uIChrKSB7IHJldHVybiBmbihrLCBrLCB0aGlzJDEpOyB9LCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hcC5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbiBfX2Vuc3VyZU93bmVyIChvd25lcklEKSB7XG4gICAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgbmV3TWFwID0gdGhpcy5fbWFwLl9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9fZW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ld01hcDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fX21ha2UobmV3TWFwLCBvd25lcklEKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfShTZXRDb2xsZWN0aW9uKSk7XG5cbiAgU2V0LmlzU2V0ID0gaXNTZXQ7XG5cbiAgdmFyIFNldFByb3RvdHlwZSA9IFNldC5wcm90b3R5cGU7XG4gIFNldFByb3RvdHlwZVtJU19TRVRfU1lNQk9MXSA9IHRydWU7XG4gIFNldFByb3RvdHlwZVtERUxFVEVdID0gU2V0UHJvdG90eXBlLnJlbW92ZTtcbiAgU2V0UHJvdG90eXBlLm1lcmdlID0gU2V0UHJvdG90eXBlLmNvbmNhdCA9IFNldFByb3RvdHlwZS51bmlvbjtcbiAgU2V0UHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSB3aXRoTXV0YXRpb25zO1xuICBTZXRQcm90b3R5cGUuYXNJbW11dGFibGUgPSBhc0ltbXV0YWJsZTtcbiAgU2V0UHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gU2V0UHJvdG90eXBlLmFzTXV0YWJsZSA9IGFzTXV0YWJsZTtcbiAgU2V0UHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24ocmVzdWx0LCBhcnIpIHtcbiAgICByZXR1cm4gcmVzdWx0LmFkZChhcnIpO1xuICB9O1xuICBTZXRQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmouYXNJbW11dGFibGUoKTtcbiAgfTtcblxuICBTZXRQcm90b3R5cGUuX19lbXB0eSA9IGVtcHR5U2V0O1xuICBTZXRQcm90b3R5cGUuX19tYWtlID0gbWFrZVNldDtcblxuICBmdW5jdGlvbiB1cGRhdGVTZXQoc2V0LCBuZXdNYXApIHtcbiAgICBpZiAoc2V0Ll9fb3duZXJJRCkge1xuICAgICAgc2V0LnNpemUgPSBuZXdNYXAuc2l6ZTtcbiAgICAgIHNldC5fbWFwID0gbmV3TWFwO1xuICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgcmV0dXJuIG5ld01hcCA9PT0gc2V0Ll9tYXBcbiAgICAgID8gc2V0XG4gICAgICA6IG5ld01hcC5zaXplID09PSAwXG4gICAgICAgID8gc2V0Ll9fZW1wdHkoKVxuICAgICAgICA6IHNldC5fX21ha2UobmV3TWFwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VTZXQobWFwLCBvd25lcklEKSB7XG4gICAgdmFyIHNldCA9IE9iamVjdC5jcmVhdGUoU2V0UHJvdG90eXBlKTtcbiAgICBzZXQuc2l6ZSA9IG1hcCA/IG1hcC5zaXplIDogMDtcbiAgICBzZXQuX21hcCA9IG1hcDtcbiAgICBzZXQuX19vd25lcklEID0gb3duZXJJRDtcbiAgICByZXR1cm4gc2V0O1xuICB9XG5cbiAgdmFyIEVNUFRZX1NFVDtcbiAgZnVuY3Rpb24gZW1wdHlTZXQoKSB7XG4gICAgcmV0dXJuIEVNUFRZX1NFVCB8fCAoRU1QVFlfU0VUID0gbWFrZVNldChlbXB0eU1hcCgpKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxhenkgc2VxIG9mIG51bXMgZnJvbSBzdGFydCAoaW5jbHVzaXZlKSB0byBlbmRcbiAgICogKGV4Y2x1c2l2ZSksIGJ5IHN0ZXAsIHdoZXJlIHN0YXJ0IGRlZmF1bHRzIHRvIDAsIHN0ZXAgdG8gMSwgYW5kIGVuZCB0b1xuICAgKiBpbmZpbml0eS4gV2hlbiBzdGFydCBpcyBlcXVhbCB0byBlbmQsIHJldHVybnMgZW1wdHkgbGlzdC5cbiAgICovXG4gIHZhciBSYW5nZSA9IChmdW5jdGlvbiAoSW5kZXhlZFNlcSQkMSkge1xuICAgIGZ1bmN0aW9uIFJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSYW5nZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kLCBzdGVwKTtcbiAgICAgIH1cbiAgICAgIGludmFyaWFudChzdGVwICE9PSAwLCAnQ2Fubm90IHN0ZXAgYSBSYW5nZSBieSAwJyk7XG4gICAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gSW5maW5pdHk7XG4gICAgICB9XG4gICAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gMSA6IE1hdGguYWJzKHN0ZXApO1xuICAgICAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIHN0ZXAgPSAtc3RlcDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0YXJ0ID0gc3RhcnQ7XG4gICAgICB0aGlzLl9lbmQgPSBlbmQ7XG4gICAgICB0aGlzLl9zdGVwID0gc3RlcDtcbiAgICAgIHRoaXMuc2l6ZSA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgoZW5kIC0gc3RhcnQpIC8gc3RlcCAtIDEpICsgMSk7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIGlmIChFTVBUWV9SQU5HRSkge1xuICAgICAgICAgIHJldHVybiBFTVBUWV9SQU5HRTtcbiAgICAgICAgfVxuICAgICAgICBFTVBUWV9SQU5HRSA9IHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCBJbmRleGVkU2VxJCQxICkgUmFuZ2UuX19wcm90b19fID0gSW5kZXhlZFNlcSQkMTtcbiAgICBSYW5nZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkU2VxJCQxICYmIEluZGV4ZWRTZXEkJDEucHJvdG90eXBlICk7XG4gICAgUmFuZ2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmFuZ2U7XG5cbiAgICBSYW5nZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnUmFuZ2UgW10nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgJ1JhbmdlIFsgJyArXG4gICAgICAgIHRoaXMuX3N0YXJ0ICtcbiAgICAgICAgJy4uLicgK1xuICAgICAgICB0aGlzLl9lbmQgK1xuICAgICAgICAodGhpcy5fc3RlcCAhPT0gMSA/ICcgYnkgJyArIHRoaXMuX3N0ZXAgOiAnJykgK1xuICAgICAgICAnIF0nXG4gICAgICApO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhpbmRleClcbiAgICAgICAgPyB0aGlzLl9zdGFydCArIHdyYXBJbmRleCh0aGlzLCBpbmRleCkgKiB0aGlzLl9zdGVwXG4gICAgICAgIDogbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIFJhbmdlLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzIChzZWFyY2hWYWx1ZSkge1xuICAgICAgdmFyIHBvc3NpYmxlSW5kZXggPSAoc2VhcmNoVmFsdWUgLSB0aGlzLl9zdGFydCkgLyB0aGlzLl9zdGVwO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgcG9zc2libGVJbmRleCA+PSAwICYmXG4gICAgICAgIHBvc3NpYmxlSW5kZXggPCB0aGlzLnNpemUgJiZcbiAgICAgICAgcG9zc2libGVJbmRleCA9PT0gTWF0aC5mbG9vcihwb3NzaWJsZUluZGV4KVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKGJlZ2luLCBlbmQpIHtcbiAgICAgIGlmICh3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIHRoaXMuc2l6ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBiZWdpbiA9IHJlc29sdmVCZWdpbihiZWdpbiwgdGhpcy5zaXplKTtcbiAgICAgIGVuZCA9IHJlc29sdmVFbmQoZW5kLCB0aGlzLnNpemUpO1xuICAgICAgaWYgKGVuZCA8PSBiZWdpbikge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKDAsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZShcbiAgICAgICAgdGhpcy5nZXQoYmVnaW4sIHRoaXMuX2VuZCksXG4gICAgICAgIHRoaXMuZ2V0KGVuZCwgdGhpcy5fZW5kKSxcbiAgICAgICAgdGhpcy5fc3RlcFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mIChzZWFyY2hWYWx1ZSkge1xuICAgICAgdmFyIG9mZnNldFZhbHVlID0gc2VhcmNoVmFsdWUgLSB0aGlzLl9zdGFydDtcbiAgICAgIGlmIChvZmZzZXRWYWx1ZSAlIHRoaXMuX3N0ZXAgPT09IDApIHtcbiAgICAgICAgdmFyIGluZGV4ID0gb2Zmc2V0VmFsdWUgLyB0aGlzLl9zdGVwO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuc2l6ZSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAoc2VhcmNoVmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmluZGV4T2Yoc2VhcmNoVmFsdWUpO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHZhciBzaXplID0gdGhpcy5zaXplO1xuICAgICAgdmFyIHN0ZXAgPSB0aGlzLl9zdGVwO1xuICAgICAgdmFyIHZhbHVlID0gcmV2ZXJzZSA/IHRoaXMuX3N0YXJ0ICsgKHNpemUgLSAxKSAqIHN0ZXAgOiB0aGlzLl9zdGFydDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpICE9PSBzaXplKSB7XG4gICAgICAgIGlmIChmbih2YWx1ZSwgcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKyssIHRoaXMkMSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgKz0gcmV2ZXJzZSA/IC1zdGVwIDogc3RlcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBzaXplID0gdGhpcy5zaXplO1xuICAgICAgdmFyIHN0ZXAgPSB0aGlzLl9zdGVwO1xuICAgICAgdmFyIHZhbHVlID0gcmV2ZXJzZSA/IHRoaXMuX3N0YXJ0ICsgKHNpemUgLSAxKSAqIHN0ZXAgOiB0aGlzLl9zdGFydDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaSA9PT0gc2l6ZSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdiA9IHZhbHVlO1xuICAgICAgICB2YWx1ZSArPSByZXZlcnNlID8gLXN0ZXAgOiBzdGVwO1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCByZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrKywgdik7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAob3RoZXIpIHtcbiAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFJhbmdlXG4gICAgICAgID8gdGhpcy5fc3RhcnQgPT09IG90aGVyLl9zdGFydCAmJlxuICAgICAgICAgICAgdGhpcy5fZW5kID09PSBvdGhlci5fZW5kICYmXG4gICAgICAgICAgICB0aGlzLl9zdGVwID09PSBvdGhlci5fc3RlcFxuICAgICAgICA6IGRlZXBFcXVhbCh0aGlzLCBvdGhlcik7XG4gICAgfTtcblxuICAgIHJldHVybiBSYW5nZTtcbiAgfShJbmRleGVkU2VxKSk7XG5cbiAgdmFyIEVNUFRZX1JBTkdFO1xuXG4gIGZ1bmN0aW9uIGdldEluKGNvbGxlY3Rpb24sIHNlYXJjaEtleVBhdGgsIG5vdFNldFZhbHVlKSB7XG4gICAgdmFyIGtleVBhdGggPSBjb2VyY2VLZXlQYXRoKHNlYXJjaEtleVBhdGgpO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSAhPT0ga2V5UGF0aC5sZW5ndGgpIHtcbiAgICAgIGNvbGxlY3Rpb24gPSBnZXQoY29sbGVjdGlvbiwga2V5UGF0aFtpKytdLCBOT1RfU0VUKTtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09PSBOT1RfU0VUKSB7XG4gICAgICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJbiQxKHNlYXJjaEtleVBhdGgsIG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIGdldEluKHRoaXMsIHNlYXJjaEtleVBhdGgsIG5vdFNldFZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0luKGNvbGxlY3Rpb24sIGtleVBhdGgpIHtcbiAgICByZXR1cm4gZ2V0SW4oY29sbGVjdGlvbiwga2V5UGF0aCwgTk9UX1NFVCkgIT09IE5PVF9TRVQ7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNJbiQxKHNlYXJjaEtleVBhdGgpIHtcbiAgICByZXR1cm4gaGFzSW4odGhpcywgc2VhcmNoS2V5UGF0aCk7XG4gIH1cblxuICBmdW5jdGlvbiB0b09iamVjdCgpIHtcbiAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykge1xuICAgICAgb2JqZWN0W2tdID0gdjtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgLy8gTm90ZTogYWxsIG9mIHRoZXNlIG1ldGhvZHMgYXJlIGRlcHJlY2F0ZWQuXG4gIENvbGxlY3Rpb24uaXNJdGVyYWJsZSA9IGlzQ29sbGVjdGlvbjtcbiAgQ29sbGVjdGlvbi5pc0tleWVkID0gaXNLZXllZDtcbiAgQ29sbGVjdGlvbi5pc0luZGV4ZWQgPSBpc0luZGV4ZWQ7XG4gIENvbGxlY3Rpb24uaXNBc3NvY2lhdGl2ZSA9IGlzQXNzb2NpYXRpdmU7XG4gIENvbGxlY3Rpb24uaXNPcmRlcmVkID0gaXNPcmRlcmVkO1xuXG4gIENvbGxlY3Rpb24uSXRlcmF0b3IgPSBJdGVyYXRvcjtcblxuICBtaXhpbihDb2xsZWN0aW9uLCB7XG4gICAgLy8gIyMjIENvbnZlcnNpb24gdG8gb3RoZXIgdHlwZXNcblxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgICAgdmFyIGFycmF5ID0gbmV3IEFycmF5KHRoaXMuc2l6ZSB8fCAwKTtcbiAgICAgIHZhciB1c2VUdXBsZXMgPSBpc0tleWVkKHRoaXMpO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgLy8gS2V5ZWQgY29sbGVjdGlvbnMgcHJvZHVjZSBhbiBhcnJheSBvZiB0dXBsZXMuXG4gICAgICAgIGFycmF5W2krK10gPSB1c2VUdXBsZXMgPyBbaywgdl0gOiB2O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfSxcblxuICAgIHRvSW5kZXhlZFNlcTogZnVuY3Rpb24gdG9JbmRleGVkU2VxKCkge1xuICAgICAgcmV0dXJuIG5ldyBUb0luZGV4ZWRTZXF1ZW5jZSh0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9KUzogZnVuY3Rpb24gdG9KUyQxKCkge1xuICAgICAgcmV0dXJuIHRvSlModGhpcyk7XG4gICAgfSxcblxuICAgIHRvS2V5ZWRTZXE6IGZ1bmN0aW9uIHRvS2V5ZWRTZXEoKSB7XG4gICAgICByZXR1cm4gbmV3IFRvS2V5ZWRTZXF1ZW5jZSh0aGlzLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgdG9NYXA6IGZ1bmN0aW9uIHRvTWFwKCkge1xuICAgICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgICAgcmV0dXJuIE1hcCh0aGlzLnRvS2V5ZWRTZXEoKSk7XG4gICAgfSxcblxuICAgIHRvT2JqZWN0OiB0b09iamVjdCxcblxuICAgIHRvT3JkZXJlZE1hcDogZnVuY3Rpb24gdG9PcmRlcmVkTWFwKCkge1xuICAgICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgICAgcmV0dXJuIE9yZGVyZWRNYXAodGhpcy50b0tleWVkU2VxKCkpO1xuICAgIH0sXG5cbiAgICB0b09yZGVyZWRTZXQ6IGZ1bmN0aW9uIHRvT3JkZXJlZFNldCgpIHtcbiAgICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICAgIHJldHVybiBPcmRlcmVkU2V0KGlzS2V5ZWQodGhpcykgPyB0aGlzLnZhbHVlU2VxKCkgOiB0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9TZXQ6IGZ1bmN0aW9uIHRvU2V0KCkge1xuICAgICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgICAgcmV0dXJuIFNldChpc0tleWVkKHRoaXMpID8gdGhpcy52YWx1ZVNlcSgpIDogdGhpcyk7XG4gICAgfSxcblxuICAgIHRvU2V0U2VxOiBmdW5jdGlvbiB0b1NldFNlcSgpIHtcbiAgICAgIHJldHVybiBuZXcgVG9TZXRTZXF1ZW5jZSh0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9TZXE6IGZ1bmN0aW9uIHRvU2VxKCkge1xuICAgICAgcmV0dXJuIGlzSW5kZXhlZCh0aGlzKVxuICAgICAgICA/IHRoaXMudG9JbmRleGVkU2VxKClcbiAgICAgICAgOiBpc0tleWVkKHRoaXMpXG4gICAgICAgICAgPyB0aGlzLnRvS2V5ZWRTZXEoKVxuICAgICAgICAgIDogdGhpcy50b1NldFNlcSgpO1xuICAgIH0sXG5cbiAgICB0b1N0YWNrOiBmdW5jdGlvbiB0b1N0YWNrKCkge1xuICAgICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgICAgcmV0dXJuIFN0YWNrKGlzS2V5ZWQodGhpcykgPyB0aGlzLnZhbHVlU2VxKCkgOiB0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9MaXN0OiBmdW5jdGlvbiB0b0xpc3QoKSB7XG4gICAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgICByZXR1cm4gTGlzdChpc0tleWVkKHRoaXMpID8gdGhpcy52YWx1ZVNlcSgpIDogdGhpcyk7XG4gICAgfSxcblxuICAgIC8vICMjIyBDb21tb24gSmF2YVNjcmlwdCBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ1tDb2xsZWN0aW9uXSc7XG4gICAgfSxcblxuICAgIF9fdG9TdHJpbmc6IGZ1bmN0aW9uIF9fdG9TdHJpbmcoaGVhZCwgdGFpbCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gKFxuICAgICAgICBoZWFkICtcbiAgICAgICAgJyAnICtcbiAgICAgICAgdGhpcy50b1NlcSgpXG4gICAgICAgICAgLm1hcCh0aGlzLl9fdG9TdHJpbmdNYXBwZXIpXG4gICAgICAgICAgLmpvaW4oJywgJykgK1xuICAgICAgICAnICcgK1xuICAgICAgICB0YWlsXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvLyAjIyMgRVM2IENvbGxlY3Rpb24gbWV0aG9kcyAoRVM2IEFycmF5IGFuZCBNYXApXG5cbiAgICBjb25jYXQ6IGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSB2YWx1ZXNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGNvbmNhdEZhY3RvcnkodGhpcywgdmFsdWVzKSk7XG4gICAgfSxcblxuICAgIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc29tZShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGlzKHZhbHVlLCBzZWFyY2hWYWx1ZSk7IH0pO1xuICAgIH0sXG5cbiAgICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMpO1xuICAgIH0sXG5cbiAgICBldmVyeTogZnVuY3Rpb24gZXZlcnkocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgICAgdmFyIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrLCBjKSB7XG4gICAgICAgIGlmICghcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykpIHtcbiAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfSxcblxuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZpbHRlckZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0LCB0cnVlKSk7XG4gICAgfSxcblxuICAgIGZpbmQ6IGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSkge1xuICAgICAgdmFyIGVudHJ5ID0gdGhpcy5maW5kRW50cnkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBlbnRyeSA/IGVudHJ5WzFdIDogbm90U2V0VmFsdWU7XG4gICAgfSxcblxuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goc2lkZUVmZmVjdCwgY29udGV4dCkge1xuICAgICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcbiAgICAgIHJldHVybiB0aGlzLl9faXRlcmF0ZShjb250ZXh0ID8gc2lkZUVmZmVjdC5iaW5kKGNvbnRleHQpIDogc2lkZUVmZmVjdCk7XG4gICAgfSxcblxuICAgIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7XG4gICAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgICAgc2VwYXJhdG9yID0gc2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyAnJyArIHNlcGFyYXRvciA6ICcsJztcbiAgICAgIHZhciBqb2luZWQgPSAnJztcbiAgICAgIHZhciBpc0ZpcnN0ID0gdHJ1ZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlzRmlyc3QgPyAoaXNGaXJzdCA9IGZhbHNlKSA6IChqb2luZWQgKz0gc2VwYXJhdG9yKTtcbiAgICAgICAgam9pbmVkICs9IHYgIT09IG51bGwgJiYgdiAhPT0gdW5kZWZpbmVkID8gdi50b1N0cmluZygpIDogJyc7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBqb2luZWQ7XG4gICAgfSxcblxuICAgIGtleXM6IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfS0VZUyk7XG4gICAgfSxcblxuICAgIG1hcDogZnVuY3Rpb24gbWFwKG1hcHBlciwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIG1hcEZhY3RvcnkodGhpcywgbWFwcGVyLCBjb250ZXh0KSk7XG4gICAgfSxcblxuICAgIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlJDEocmVkdWNlciwgaW5pdGlhbFJlZHVjdGlvbiwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlZHVjZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgcmVkdWNlcixcbiAgICAgICAgaW5pdGlhbFJlZHVjdGlvbixcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA8IDIsXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgIH0sXG5cbiAgICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQocmVkdWNlciwgaW5pdGlhbFJlZHVjdGlvbiwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlZHVjZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgcmVkdWNlcixcbiAgICAgICAgaW5pdGlhbFJlZHVjdGlvbixcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA8IDIsXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfSxcblxuICAgIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgcmV2ZXJzZUZhY3RvcnkodGhpcywgdHJ1ZSkpO1xuICAgIH0sXG5cbiAgICBzbGljZTogZnVuY3Rpb24gc2xpY2UoYmVnaW4sIGVuZCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHNsaWNlRmFjdG9yeSh0aGlzLCBiZWdpbiwgZW5kLCB0cnVlKSk7XG4gICAgfSxcblxuICAgIHNvbWU6IGZ1bmN0aW9uIHNvbWUocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gIXRoaXMuZXZlcnkobm90KHByZWRpY2F0ZSksIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yKSk7XG4gICAgfSxcblxuICAgIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUyk7XG4gICAgfSxcblxuICAgIC8vICMjIyBNb3JlIHNlcXVlbnRpYWwgbWV0aG9kc1xuXG4gICAgYnV0TGFzdDogZnVuY3Rpb24gYnV0TGFzdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNsaWNlKDAsIC0xKTtcbiAgICB9LFxuXG4gICAgaXNFbXB0eTogZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNpemUgIT09IHVuZGVmaW5lZCA/IHRoaXMuc2l6ZSA9PT0gMCA6ICF0aGlzLnNvbWUoZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG4gICAgfSxcblxuICAgIGNvdW50OiBmdW5jdGlvbiBjb3VudChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiBlbnN1cmVTaXplKFxuICAgICAgICBwcmVkaWNhdGUgPyB0aGlzLnRvU2VxKCkuZmlsdGVyKHByZWRpY2F0ZSwgY29udGV4dCkgOiB0aGlzXG4gICAgICApO1xuICAgIH0sXG5cbiAgICBjb3VudEJ5OiBmdW5jdGlvbiBjb3VudEJ5KGdyb3VwZXIsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiBjb3VudEJ5RmFjdG9yeSh0aGlzLCBncm91cGVyLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICAgIHJldHVybiBkZWVwRXF1YWwodGhpcywgb3RoZXIpO1xuICAgIH0sXG5cbiAgICBlbnRyeVNlcTogZnVuY3Rpb24gZW50cnlTZXEoKSB7XG4gICAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICBpZiAoY29sbGVjdGlvbi5fY2FjaGUpIHtcbiAgICAgICAgLy8gV2UgY2FjaGUgYXMgYW4gZW50cmllcyBhcnJheSwgc28gd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBjYWNoZSFcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheVNlcShjb2xsZWN0aW9uLl9jYWNoZSk7XG4gICAgICB9XG4gICAgICB2YXIgZW50cmllc1NlcXVlbmNlID0gY29sbGVjdGlvblxuICAgICAgICAudG9TZXEoKVxuICAgICAgICAubWFwKGVudHJ5TWFwcGVyKVxuICAgICAgICAudG9JbmRleGVkU2VxKCk7XG4gICAgICBlbnRyaWVzU2VxdWVuY2UuZnJvbUVudHJ5U2VxID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29sbGVjdGlvbi50b1NlcSgpOyB9O1xuICAgICAgcmV0dXJuIGVudHJpZXNTZXF1ZW5jZTtcbiAgICB9LFxuXG4gICAgZmlsdGVyTm90OiBmdW5jdGlvbiBmaWx0ZXJOb3QocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIobm90KHByZWRpY2F0ZSksIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBmaW5kRW50cnk6IGZ1bmN0aW9uIGZpbmRFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKSB7XG4gICAgICB2YXIgZm91bmQgPSBub3RTZXRWYWx1ZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrLCBjKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSkge1xuICAgICAgICAgIGZvdW5kID0gW2ssIHZdO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfSxcblxuICAgIGZpbmRLZXk6IGZ1bmN0aW9uIGZpbmRLZXkocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgZW50cnkgPSB0aGlzLmZpbmRFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5WzBdO1xuICAgIH0sXG5cbiAgICBmaW5kTGFzdDogZnVuY3Rpb24gZmluZExhc3QocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9LZXllZFNlcSgpXG4gICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgLmZpbmQocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSk7XG4gICAgfSxcblxuICAgIGZpbmRMYXN0RW50cnk6IGZ1bmN0aW9uIGZpbmRMYXN0RW50cnkocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9LZXllZFNlcSgpXG4gICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgLmZpbmRFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKTtcbiAgICB9LFxuXG4gICAgZmluZExhc3RLZXk6IGZ1bmN0aW9uIGZpbmRMYXN0S2V5KHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9LZXllZFNlcSgpXG4gICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgLmZpbmRLZXkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0KG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kKHJldHVyblRydWUsIG51bGwsIG5vdFNldFZhbHVlKTtcbiAgICB9LFxuXG4gICAgZmxhdE1hcDogZnVuY3Rpb24gZmxhdE1hcChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBmbGF0TWFwRmFjdG9yeSh0aGlzLCBtYXBwZXIsIGNvbnRleHQpKTtcbiAgICB9LFxuXG4gICAgZmxhdHRlbjogZnVuY3Rpb24gZmxhdHRlbihkZXB0aCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZsYXR0ZW5GYWN0b3J5KHRoaXMsIGRlcHRoLCB0cnVlKSk7XG4gICAgfSxcblxuICAgIGZyb21FbnRyeVNlcTogZnVuY3Rpb24gZnJvbUVudHJ5U2VxKCkge1xuICAgICAgcmV0dXJuIG5ldyBGcm9tRW50cmllc1NlcXVlbmNlKHRoaXMpO1xuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldChzZWFyY2hLZXksIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kKGZ1bmN0aW9uIChfLCBrZXkpIHsgcmV0dXJuIGlzKGtleSwgc2VhcmNoS2V5KTsgfSwgdW5kZWZpbmVkLCBub3RTZXRWYWx1ZSk7XG4gICAgfSxcblxuICAgIGdldEluOiBnZXRJbiQxLFxuXG4gICAgZ3JvdXBCeTogZnVuY3Rpb24gZ3JvdXBCeShncm91cGVyLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gZ3JvdXBCeUZhY3RvcnkodGhpcywgZ3JvdXBlciwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIGhhczogZnVuY3Rpb24gaGFzKHNlYXJjaEtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KHNlYXJjaEtleSwgTk9UX1NFVCkgIT09IE5PVF9TRVQ7XG4gICAgfSxcblxuICAgIGhhc0luOiBoYXNJbiQxLFxuXG4gICAgaXNTdWJzZXQ6IGZ1bmN0aW9uIGlzU3Vic2V0KGl0ZXIpIHtcbiAgICAgIGl0ZXIgPSB0eXBlb2YgaXRlci5pbmNsdWRlcyA9PT0gJ2Z1bmN0aW9uJyA/IGl0ZXIgOiBDb2xsZWN0aW9uKGl0ZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuZXZlcnkoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBpdGVyLmluY2x1ZGVzKHZhbHVlKTsgfSk7XG4gICAgfSxcblxuICAgIGlzU3VwZXJzZXQ6IGZ1bmN0aW9uIGlzU3VwZXJzZXQoaXRlcikge1xuICAgICAgaXRlciA9IHR5cGVvZiBpdGVyLmlzU3Vic2V0ID09PSAnZnVuY3Rpb24nID8gaXRlciA6IENvbGxlY3Rpb24oaXRlcik7XG4gICAgICByZXR1cm4gaXRlci5pc1N1YnNldCh0aGlzKTtcbiAgICB9LFxuXG4gICAga2V5T2Y6IGZ1bmN0aW9uIGtleU9mKHNlYXJjaFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kS2V5KGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gaXModmFsdWUsIHNlYXJjaFZhbHVlKTsgfSk7XG4gICAgfSxcblxuICAgIGtleVNlcTogZnVuY3Rpb24ga2V5U2VxKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9TZXEoKVxuICAgICAgICAubWFwKGtleU1hcHBlcilcbiAgICAgICAgLnRvSW5kZXhlZFNlcSgpO1xuICAgIH0sXG5cbiAgICBsYXN0OiBmdW5jdGlvbiBsYXN0KG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1NlcSgpXG4gICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgLmZpcnN0KG5vdFNldFZhbHVlKTtcbiAgICB9LFxuXG4gICAgbGFzdEtleU9mOiBmdW5jdGlvbiBsYXN0S2V5T2Yoc2VhcmNoVmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvS2V5ZWRTZXEoKVxuICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgIC5rZXlPZihzZWFyY2hWYWx1ZSk7XG4gICAgfSxcblxuICAgIG1heDogZnVuY3Rpb24gbWF4KGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiBtYXhGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IpO1xuICAgIH0sXG5cbiAgICBtYXhCeTogZnVuY3Rpb24gbWF4QnkobWFwcGVyLCBjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gbWF4RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yLCBtYXBwZXIpO1xuICAgIH0sXG5cbiAgICBtaW46IGZ1bmN0aW9uIG1pbihjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gbWF4RmFjdG9yeShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgY29tcGFyYXRvciA/IG5lZyhjb21wYXJhdG9yKSA6IGRlZmF1bHROZWdDb21wYXJhdG9yXG4gICAgICApO1xuICAgIH0sXG5cbiAgICBtaW5CeTogZnVuY3Rpb24gbWluQnkobWFwcGVyLCBjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gbWF4RmFjdG9yeShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgY29tcGFyYXRvciA/IG5lZyhjb21wYXJhdG9yKSA6IGRlZmF1bHROZWdDb21wYXJhdG9yLFxuICAgICAgICBtYXBwZXJcbiAgICAgICk7XG4gICAgfSxcblxuICAgIHJlc3Q6IGZ1bmN0aW9uIHJlc3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zbGljZSgxKTtcbiAgICB9LFxuXG4gICAgc2tpcDogZnVuY3Rpb24gc2tpcChhbW91bnQpIHtcbiAgICAgIHJldHVybiBhbW91bnQgPT09IDAgPyB0aGlzIDogdGhpcy5zbGljZShNYXRoLm1heCgwLCBhbW91bnQpKTtcbiAgICB9LFxuXG4gICAgc2tpcExhc3Q6IGZ1bmN0aW9uIHNraXBMYXN0KGFtb3VudCkge1xuICAgICAgcmV0dXJuIGFtb3VudCA9PT0gMCA/IHRoaXMgOiB0aGlzLnNsaWNlKDAsIC1NYXRoLm1heCgwLCBhbW91bnQpKTtcbiAgICB9LFxuXG4gICAgc2tpcFdoaWxlOiBmdW5jdGlvbiBza2lwV2hpbGUocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgc2tpcFdoaWxlRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQsIHRydWUpKTtcbiAgICB9LFxuXG4gICAgc2tpcFVudGlsOiBmdW5jdGlvbiBza2lwVW50aWwocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5za2lwV2hpbGUobm90KHByZWRpY2F0ZSksIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBzb3J0Qnk6IGZ1bmN0aW9uIHNvcnRCeShtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yLCBtYXBwZXIpKTtcbiAgICB9LFxuXG4gICAgdGFrZTogZnVuY3Rpb24gdGFrZShhbW91bnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNsaWNlKDAsIE1hdGgubWF4KDAsIGFtb3VudCkpO1xuICAgIH0sXG5cbiAgICB0YWtlTGFzdDogZnVuY3Rpb24gdGFrZUxhc3QoYW1vdW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5zbGljZSgtTWF0aC5tYXgoMCwgYW1vdW50KSk7XG4gICAgfSxcblxuICAgIHRha2VXaGlsZTogZnVuY3Rpb24gdGFrZVdoaWxlKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHRha2VXaGlsZUZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0KSk7XG4gICAgfSxcblxuICAgIHRha2VVbnRpbDogZnVuY3Rpb24gdGFrZVVudGlsKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMudGFrZVdoaWxlKG5vdChwcmVkaWNhdGUpLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoZm4pIHtcbiAgICAgIHJldHVybiBmbih0aGlzKTtcbiAgICB9LFxuXG4gICAgdmFsdWVTZXE6IGZ1bmN0aW9uIHZhbHVlU2VxKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9JbmRleGVkU2VxKCk7XG4gICAgfSxcblxuICAgIC8vICMjIyBIYXNoYWJsZSBPYmplY3RcblxuICAgIGhhc2hDb2RlOiBmdW5jdGlvbiBoYXNoQ29kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9faGFzaCB8fCAodGhpcy5fX2hhc2ggPSBoYXNoQ29sbGVjdGlvbih0aGlzKSk7XG4gICAgfSxcblxuICAgIC8vICMjIyBJbnRlcm5hbFxuXG4gICAgLy8gYWJzdHJhY3QgX19pdGVyYXRlKGZuLCByZXZlcnNlKVxuXG4gICAgLy8gYWJzdHJhY3QgX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKVxuICB9KTtcblxuICB2YXIgQ29sbGVjdGlvblByb3RvdHlwZSA9IENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICBDb2xsZWN0aW9uUHJvdG90eXBlW0lTX0NPTExFQ1RJT05fU1lNQk9MXSA9IHRydWU7XG4gIENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JfU1lNQk9MXSA9IENvbGxlY3Rpb25Qcm90b3R5cGUudmFsdWVzO1xuICBDb2xsZWN0aW9uUHJvdG90eXBlLnRvSlNPTiA9IENvbGxlY3Rpb25Qcm90b3R5cGUudG9BcnJheTtcbiAgQ29sbGVjdGlvblByb3RvdHlwZS5fX3RvU3RyaW5nTWFwcGVyID0gcXVvdGVTdHJpbmc7XG4gIENvbGxlY3Rpb25Qcm90b3R5cGUuaW5zcGVjdCA9IENvbGxlY3Rpb25Qcm90b3R5cGUudG9Tb3VyY2UgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuICBDb2xsZWN0aW9uUHJvdG90eXBlLmNoYWluID0gQ29sbGVjdGlvblByb3RvdHlwZS5mbGF0TWFwO1xuICBDb2xsZWN0aW9uUHJvdG90eXBlLmNvbnRhaW5zID0gQ29sbGVjdGlvblByb3RvdHlwZS5pbmNsdWRlcztcblxuICBtaXhpbihLZXllZENvbGxlY3Rpb24sIHtcbiAgICAvLyAjIyMgTW9yZSBzZXF1ZW50aWFsIG1ldGhvZHNcblxuICAgIGZsaXA6IGZ1bmN0aW9uIGZsaXAoKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgZmxpcEZhY3RvcnkodGhpcykpO1xuICAgIH0sXG5cbiAgICBtYXBFbnRyaWVzOiBmdW5jdGlvbiBtYXBFbnRyaWVzKG1hcHBlciwgY29udGV4dCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHJldHVybiByZWlmeShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy50b1NlcSgpXG4gICAgICAgICAgLm1hcChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gbWFwcGVyLmNhbGwoY29udGV4dCwgW2ssIHZdLCBpdGVyYXRpb25zKyssIHRoaXMkMSk7IH0pXG4gICAgICAgICAgLmZyb21FbnRyeVNlcSgpXG4gICAgICApO1xuICAgIH0sXG5cbiAgICBtYXBLZXlzOiBmdW5jdGlvbiBtYXBLZXlzKG1hcHBlciwgY29udGV4dCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiByZWlmeShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy50b1NlcSgpXG4gICAgICAgICAgLmZsaXAoKVxuICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGssIHYpIHsgcmV0dXJuIG1hcHBlci5jYWxsKGNvbnRleHQsIGssIHYsIHRoaXMkMSk7IH0pXG4gICAgICAgICAgLmZsaXAoKVxuICAgICAgKTtcbiAgICB9LFxuICB9KTtcblxuICB2YXIgS2V5ZWRDb2xsZWN0aW9uUHJvdG90eXBlID0gS2V5ZWRDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgS2V5ZWRDb2xsZWN0aW9uUHJvdG90eXBlW0lTX0tFWUVEX1NZTUJPTF0gPSB0cnVlO1xuICBLZXllZENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JfU1lNQk9MXSA9IENvbGxlY3Rpb25Qcm90b3R5cGUuZW50cmllcztcbiAgS2V5ZWRDb2xsZWN0aW9uUHJvdG90eXBlLnRvSlNPTiA9IHRvT2JqZWN0O1xuICBLZXllZENvbGxlY3Rpb25Qcm90b3R5cGUuX190b1N0cmluZ01hcHBlciA9IGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBxdW90ZVN0cmluZyhrKSArICc6ICcgKyBxdW90ZVN0cmluZyh2KTsgfTtcblxuICBtaXhpbihJbmRleGVkQ29sbGVjdGlvbiwge1xuICAgIC8vICMjIyBDb252ZXJzaW9uIHRvIG90aGVyIHR5cGVzXG5cbiAgICB0b0tleWVkU2VxOiBmdW5jdGlvbiB0b0tleWVkU2VxKCkge1xuICAgICAgcmV0dXJuIG5ldyBUb0tleWVkU2VxdWVuY2UodGhpcywgZmFsc2UpO1xuICAgIH0sXG5cbiAgICAvLyAjIyMgRVM2IENvbGxlY3Rpb24gbWV0aG9kcyAoRVM2IEFycmF5IGFuZCBNYXApXG5cbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBmaWx0ZXJGYWN0b3J5KHRoaXMsIHByZWRpY2F0ZSwgY29udGV4dCwgZmFsc2UpKTtcbiAgICB9LFxuXG4gICAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgZW50cnkgPSB0aGlzLmZpbmRFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIGVudHJ5ID8gZW50cnlbMF0gOiAtMTtcbiAgICB9LFxuXG4gICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hWYWx1ZSkge1xuICAgICAgdmFyIGtleSA9IHRoaXMua2V5T2Yoc2VhcmNoVmFsdWUpO1xuICAgICAgcmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID8gLTEgOiBrZXk7XG4gICAgfSxcblxuICAgIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hWYWx1ZSkge1xuICAgICAgdmFyIGtleSA9IHRoaXMubGFzdEtleU9mKHNlYXJjaFZhbHVlKTtcbiAgICAgIHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/IC0xIDoga2V5O1xuICAgIH0sXG5cbiAgICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHJldmVyc2VGYWN0b3J5KHRoaXMsIGZhbHNlKSk7XG4gICAgfSxcblxuICAgIHNsaWNlOiBmdW5jdGlvbiBzbGljZShiZWdpbiwgZW5kKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgc2xpY2VGYWN0b3J5KHRoaXMsIGJlZ2luLCBlbmQsIGZhbHNlKSk7XG4gICAgfSxcblxuICAgIHNwbGljZTogZnVuY3Rpb24gc3BsaWNlKGluZGV4LCByZW1vdmVOdW0gLyosIC4uLnZhbHVlcyovKSB7XG4gICAgICB2YXIgbnVtQXJncyA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICByZW1vdmVOdW0gPSBNYXRoLm1heChyZW1vdmVOdW0gfHwgMCwgMCk7XG4gICAgICBpZiAobnVtQXJncyA9PT0gMCB8fCAobnVtQXJncyA9PT0gMiAmJiAhcmVtb3ZlTnVtKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIC8vIElmIGluZGV4IGlzIG5lZ2F0aXZlLCBpdCBzaG91bGQgcmVzb2x2ZSByZWxhdGl2ZSB0byB0aGUgc2l6ZSBvZiB0aGVcbiAgICAgIC8vIGNvbGxlY3Rpb24uIEhvd2V2ZXIgc2l6ZSBtYXkgYmUgZXhwZW5zaXZlIHRvIGNvbXB1dGUgaWYgbm90IGNhY2hlZCwgc29cbiAgICAgIC8vIG9ubHkgY2FsbCBjb3VudCgpIGlmIHRoZSBudW1iZXIgaXMgaW4gZmFjdCBuZWdhdGl2ZS5cbiAgICAgIGluZGV4ID0gcmVzb2x2ZUJlZ2luKGluZGV4LCBpbmRleCA8IDAgPyB0aGlzLmNvdW50KCkgOiB0aGlzLnNpemUpO1xuICAgICAgdmFyIHNwbGljZWQgPSB0aGlzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgIHJldHVybiByZWlmeShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgbnVtQXJncyA9PT0gMVxuICAgICAgICAgID8gc3BsaWNlZFxuICAgICAgICAgIDogc3BsaWNlZC5jb25jYXQoYXJyQ29weShhcmd1bWVudHMsIDIpLCB0aGlzLnNsaWNlKGluZGV4ICsgcmVtb3ZlTnVtKSlcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8vICMjIyBNb3JlIGNvbGxlY3Rpb24gbWV0aG9kc1xuXG4gICAgZmluZExhc3RJbmRleDogZnVuY3Rpb24gZmluZExhc3RJbmRleChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBlbnRyeSA9IHRoaXMuZmluZExhc3RFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIGVudHJ5ID8gZW50cnlbMF0gOiAtMTtcbiAgICB9LFxuXG4gICAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0KG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoMCwgbm90U2V0VmFsdWUpO1xuICAgIH0sXG5cbiAgICBmbGF0dGVuOiBmdW5jdGlvbiBmbGF0dGVuKGRlcHRoKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgZmxhdHRlbkZhY3RvcnkodGhpcywgZGVwdGgsIGZhbHNlKSk7XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24gZ2V0KGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgICAgaW5kZXggPSB3cmFwSW5kZXgodGhpcywgaW5kZXgpO1xuICAgICAgcmV0dXJuIGluZGV4IDwgMCB8fFxuICAgICAgICAodGhpcy5zaXplID09PSBJbmZpbml0eSB8fCAodGhpcy5zaXplICE9PSB1bmRlZmluZWQgJiYgaW5kZXggPiB0aGlzLnNpemUpKVxuICAgICAgICA/IG5vdFNldFZhbHVlXG4gICAgICAgIDogdGhpcy5maW5kKGZ1bmN0aW9uIChfLCBrZXkpIHsgcmV0dXJuIGtleSA9PT0gaW5kZXg7IH0sIHVuZGVmaW5lZCwgbm90U2V0VmFsdWUpO1xuICAgIH0sXG5cbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyhpbmRleCkge1xuICAgICAgaW5kZXggPSB3cmFwSW5kZXgodGhpcywgaW5kZXgpO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgaW5kZXggPj0gMCAmJlxuICAgICAgICAodGhpcy5zaXplICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHRoaXMuc2l6ZSA9PT0gSW5maW5pdHkgfHwgaW5kZXggPCB0aGlzLnNpemVcbiAgICAgICAgICA6IHRoaXMuaW5kZXhPZihpbmRleCkgIT09IC0xKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgaW50ZXJwb3NlOiBmdW5jdGlvbiBpbnRlcnBvc2Uoc2VwYXJhdG9yKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgaW50ZXJwb3NlRmFjdG9yeSh0aGlzLCBzZXBhcmF0b3IpKTtcbiAgICB9LFxuXG4gICAgaW50ZXJsZWF2ZTogZnVuY3Rpb24gaW50ZXJsZWF2ZSgvKi4uLmNvbGxlY3Rpb25zKi8pIHtcbiAgICAgIHZhciBjb2xsZWN0aW9ucyA9IFt0aGlzXS5jb25jYXQoYXJyQ29weShhcmd1bWVudHMpKTtcbiAgICAgIHZhciB6aXBwZWQgPSB6aXBXaXRoRmFjdG9yeSh0aGlzLnRvU2VxKCksIEluZGV4ZWRTZXEub2YsIGNvbGxlY3Rpb25zKTtcbiAgICAgIHZhciBpbnRlcmxlYXZlZCA9IHppcHBlZC5mbGF0dGVuKHRydWUpO1xuICAgICAgaWYgKHppcHBlZC5zaXplKSB7XG4gICAgICAgIGludGVybGVhdmVkLnNpemUgPSB6aXBwZWQuc2l6ZSAqIGNvbGxlY3Rpb25zLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBpbnRlcmxlYXZlZCk7XG4gICAgfSxcblxuICAgIGtleVNlcTogZnVuY3Rpb24ga2V5U2VxKCkge1xuICAgICAgcmV0dXJuIFJhbmdlKDAsIHRoaXMuc2l6ZSk7XG4gICAgfSxcblxuICAgIGxhc3Q6IGZ1bmN0aW9uIGxhc3Qobm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgtMSwgbm90U2V0VmFsdWUpO1xuICAgIH0sXG5cbiAgICBza2lwV2hpbGU6IGZ1bmN0aW9uIHNraXBXaGlsZShwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBza2lwV2hpbGVGYWN0b3J5KHRoaXMsIHByZWRpY2F0ZSwgY29udGV4dCwgZmFsc2UpKTtcbiAgICB9LFxuXG4gICAgemlwOiBmdW5jdGlvbiB6aXAoLyosIC4uLmNvbGxlY3Rpb25zICovKSB7XG4gICAgICB2YXIgY29sbGVjdGlvbnMgPSBbdGhpc10uY29uY2F0KGFyckNvcHkoYXJndW1lbnRzKSk7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgemlwV2l0aEZhY3RvcnkodGhpcywgZGVmYXVsdFppcHBlciwgY29sbGVjdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgemlwQWxsOiBmdW5jdGlvbiB6aXBBbGwoLyosIC4uLmNvbGxlY3Rpb25zICovKSB7XG4gICAgICB2YXIgY29sbGVjdGlvbnMgPSBbdGhpc10uY29uY2F0KGFyckNvcHkoYXJndW1lbnRzKSk7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgemlwV2l0aEZhY3RvcnkodGhpcywgZGVmYXVsdFppcHBlciwgY29sbGVjdGlvbnMsIHRydWUpKTtcbiAgICB9LFxuXG4gICAgemlwV2l0aDogZnVuY3Rpb24gemlwV2l0aCh6aXBwZXIgLyosIC4uLmNvbGxlY3Rpb25zICovKSB7XG4gICAgICB2YXIgY29sbGVjdGlvbnMgPSBhcnJDb3B5KGFyZ3VtZW50cyk7XG4gICAgICBjb2xsZWN0aW9uc1swXSA9IHRoaXM7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgemlwV2l0aEZhY3RvcnkodGhpcywgemlwcGVyLCBjb2xsZWN0aW9ucykpO1xuICAgIH0sXG4gIH0pO1xuXG4gIHZhciBJbmRleGVkQ29sbGVjdGlvblByb3RvdHlwZSA9IEluZGV4ZWRDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgSW5kZXhlZENvbGxlY3Rpb25Qcm90b3R5cGVbSVNfSU5ERVhFRF9TWU1CT0xdID0gdHJ1ZTtcbiAgSW5kZXhlZENvbGxlY3Rpb25Qcm90b3R5cGVbSVNfT1JERVJFRF9TWU1CT0xdID0gdHJ1ZTtcblxuICBtaXhpbihTZXRDb2xsZWN0aW9uLCB7XG4gICAgLy8gIyMjIEVTNiBDb2xsZWN0aW9uIG1ldGhvZHMgKEVTNiBBcnJheSBhbmQgTWFwKVxuXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQodmFsdWUsIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXModmFsdWUpID8gdmFsdWUgOiBub3RTZXRWYWx1ZTtcbiAgICB9LFxuXG4gICAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXModmFsdWUpO1xuICAgIH0sXG5cbiAgICAvLyAjIyMgTW9yZSBzZXF1ZW50aWFsIG1ldGhvZHNcblxuICAgIGtleVNlcTogZnVuY3Rpb24ga2V5U2VxKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVTZXEoKTtcbiAgICB9LFxuICB9KTtcblxuICBTZXRDb2xsZWN0aW9uLnByb3RvdHlwZS5oYXMgPSBDb2xsZWN0aW9uUHJvdG90eXBlLmluY2x1ZGVzO1xuICBTZXRDb2xsZWN0aW9uLnByb3RvdHlwZS5jb250YWlucyA9IFNldENvbGxlY3Rpb24ucHJvdG90eXBlLmluY2x1ZGVzO1xuXG4gIC8vIE1peGluIHN1YmNsYXNzZXNcblxuICBtaXhpbihLZXllZFNlcSwgS2V5ZWRDb2xsZWN0aW9uLnByb3RvdHlwZSk7XG4gIG1peGluKEluZGV4ZWRTZXEsIEluZGV4ZWRDb2xsZWN0aW9uLnByb3RvdHlwZSk7XG4gIG1peGluKFNldFNlcSwgU2V0Q29sbGVjdGlvbi5wcm90b3R5cGUpO1xuXG4gIC8vICNwcmFnbWEgSGVscGVyIGZ1bmN0aW9uc1xuXG4gIGZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCByZWR1Y2VyLCByZWR1Y3Rpb24sIGNvbnRleHQsIHVzZUZpcnN0LCByZXZlcnNlKSB7XG4gICAgYXNzZXJ0Tm90SW5maW5pdGUoY29sbGVjdGlvbi5zaXplKTtcbiAgICBjb2xsZWN0aW9uLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaywgYykge1xuICAgICAgaWYgKHVzZUZpcnN0KSB7XG4gICAgICAgIHVzZUZpcnN0ID0gZmFsc2U7XG4gICAgICAgIHJlZHVjdGlvbiA9IHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWR1Y3Rpb24gPSByZWR1Y2VyLmNhbGwoY29udGV4dCwgcmVkdWN0aW9uLCB2LCBrLCBjKTtcbiAgICAgIH1cbiAgICB9LCByZXZlcnNlKTtcbiAgICByZXR1cm4gcmVkdWN0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24ga2V5TWFwcGVyKHYsIGspIHtcbiAgICByZXR1cm4gaztcbiAgfVxuXG4gIGZ1bmN0aW9uIGVudHJ5TWFwcGVyKHYsIGspIHtcbiAgICByZXR1cm4gW2ssIHZdO1xuICB9XG5cbiAgZnVuY3Rpb24gbm90KHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5lZyhwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gLXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0WmlwcGVyKCkge1xuICAgIHJldHVybiBhcnJDb3B5KGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0TmVnQ29tcGFyYXRvcihhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gMSA6IGEgPiBiID8gLTEgOiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzaENvbGxlY3Rpb24oY29sbGVjdGlvbikge1xuICAgIGlmIChjb2xsZWN0aW9uLnNpemUgPT09IEluZmluaXR5KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIG9yZGVyZWQgPSBpc09yZGVyZWQoY29sbGVjdGlvbik7XG4gICAgdmFyIGtleWVkID0gaXNLZXllZChjb2xsZWN0aW9uKTtcbiAgICB2YXIgaCA9IG9yZGVyZWQgPyAxIDogMDtcbiAgICB2YXIgc2l6ZSA9IGNvbGxlY3Rpb24uX19pdGVyYXRlKFxuICAgICAga2V5ZWRcbiAgICAgICAgPyBvcmRlcmVkXG4gICAgICAgICAgPyBmdW5jdGlvbiAodiwgaykge1xuICAgICAgICAgICAgICBoID0gKDMxICogaCArIGhhc2hNZXJnZShoYXNoKHYpLCBoYXNoKGspKSkgfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIDogZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICAgICAgaCA9IChoICsgaGFzaE1lcmdlKGhhc2godiksIGhhc2goaykpKSB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIDogb3JkZXJlZFxuICAgICAgICAgID8gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgaCA9ICgzMSAqIGggKyBoYXNoKHYpKSB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICBoID0gKGggKyBoYXNoKHYpKSB8IDA7XG4gICAgICAgICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gbXVybXVySGFzaE9mU2l6ZShzaXplLCBoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG11cm11ckhhc2hPZlNpemUoc2l6ZSwgaCkge1xuICAgIGggPSBpbXVsKGgsIDB4Y2M5ZTJkNTEpO1xuICAgIGggPSBpbXVsKChoIDw8IDE1KSB8IChoID4+PiAtMTUpLCAweDFiODczNTkzKTtcbiAgICBoID0gaW11bCgoaCA8PCAxMykgfCAoaCA+Pj4gLTEzKSwgNSk7XG4gICAgaCA9ICgoaCArIDB4ZTY1NDZiNjQpIHwgMCkgXiBzaXplO1xuICAgIGggPSBpbXVsKGggXiAoaCA+Pj4gMTYpLCAweDg1ZWJjYTZiKTtcbiAgICBoID0gaW11bChoIF4gKGggPj4+IDEzKSwgMHhjMmIyYWUzNSk7XG4gICAgaCA9IHNtaShoIF4gKGggPj4+IDE2KSk7XG4gICAgcmV0dXJuIGg7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNoTWVyZ2UoYSwgYikge1xuICAgIHJldHVybiAoYSBeIChiICsgMHg5ZTM3NzliOSArIChhIDw8IDYpICsgKGEgPj4gMikpKSB8IDA7IC8vIGludFxuICB9XG5cbiAgdmFyIE9yZGVyZWRTZXQgPSAoZnVuY3Rpb24gKFNldCQkMSkge1xuICAgIGZ1bmN0aW9uIE9yZGVyZWRTZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gZW1wdHlPcmRlcmVkU2V0KClcbiAgICAgICAgOiBpc09yZGVyZWRTZXQodmFsdWUpXG4gICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgIDogZW1wdHlPcmRlcmVkU2V0KCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgICAgICAgIHZhciBpdGVyID0gU2V0Q29sbGVjdGlvbih2YWx1ZSk7XG4gICAgICAgICAgICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgICAgICAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbiAodikgeyByZXR1cm4gc2V0LmFkZCh2KTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIFNldCQkMSApIE9yZGVyZWRTZXQuX19wcm90b19fID0gU2V0JCQxO1xuICAgIE9yZGVyZWRTZXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2V0JCQxICYmIFNldCQkMS5wcm90b3R5cGUgKTtcbiAgICBPcmRlcmVkU2V0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE9yZGVyZWRTZXQ7XG5cbiAgICBPcmRlcmVkU2V0Lm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRTZXQuZnJvbUtleXMgPSBmdW5jdGlvbiBmcm9tS2V5cyAodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzKEtleWVkQ29sbGVjdGlvbih2YWx1ZSkua2V5U2VxKCkpO1xuICAgIH07XG5cbiAgICBPcmRlcmVkU2V0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ09yZGVyZWRTZXQgeycsICd9Jyk7XG4gICAgfTtcblxuICAgIHJldHVybiBPcmRlcmVkU2V0O1xuICB9KFNldCkpO1xuXG4gIE9yZGVyZWRTZXQuaXNPcmRlcmVkU2V0ID0gaXNPcmRlcmVkU2V0O1xuXG4gIHZhciBPcmRlcmVkU2V0UHJvdG90eXBlID0gT3JkZXJlZFNldC5wcm90b3R5cGU7XG4gIE9yZGVyZWRTZXRQcm90b3R5cGVbSVNfT1JERVJFRF9TWU1CT0xdID0gdHJ1ZTtcbiAgT3JkZXJlZFNldFByb3RvdHlwZS56aXAgPSBJbmRleGVkQ29sbGVjdGlvblByb3RvdHlwZS56aXA7XG4gIE9yZGVyZWRTZXRQcm90b3R5cGUuemlwV2l0aCA9IEluZGV4ZWRDb2xsZWN0aW9uUHJvdG90eXBlLnppcFdpdGg7XG5cbiAgT3JkZXJlZFNldFByb3RvdHlwZS5fX2VtcHR5ID0gZW1wdHlPcmRlcmVkU2V0O1xuICBPcmRlcmVkU2V0UHJvdG90eXBlLl9fbWFrZSA9IG1ha2VPcmRlcmVkU2V0O1xuXG4gIGZ1bmN0aW9uIG1ha2VPcmRlcmVkU2V0KG1hcCwgb3duZXJJRCkge1xuICAgIHZhciBzZXQgPSBPYmplY3QuY3JlYXRlKE9yZGVyZWRTZXRQcm90b3R5cGUpO1xuICAgIHNldC5zaXplID0gbWFwID8gbWFwLnNpemUgOiAwO1xuICAgIHNldC5fbWFwID0gbWFwO1xuICAgIHNldC5fX293bmVySUQgPSBvd25lcklEO1xuICAgIHJldHVybiBzZXQ7XG4gIH1cblxuICB2YXIgRU1QVFlfT1JERVJFRF9TRVQ7XG4gIGZ1bmN0aW9uIGVtcHR5T3JkZXJlZFNldCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgRU1QVFlfT1JERVJFRF9TRVQgfHwgKEVNUFRZX09SREVSRURfU0VUID0gbWFrZU9yZGVyZWRTZXQoZW1wdHlPcmRlcmVkTWFwKCkpKVxuICAgICk7XG4gIH1cblxuICB2YXIgUmVjb3JkID0gZnVuY3Rpb24gUmVjb3JkKGRlZmF1bHRWYWx1ZXMsIG5hbWUpIHtcbiAgICB2YXIgaGFzSW5pdGlhbGl6ZWQ7XG5cbiAgICB2YXIgUmVjb3JkVHlwZSA9IGZ1bmN0aW9uIFJlY29yZCh2YWx1ZXMpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUmVjb3JkVHlwZSkge1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfVxuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlY29yZFR5cGUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjb3JkVHlwZSh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKCFoYXNJbml0aWFsaXplZCkge1xuICAgICAgICBoYXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGVmYXVsdFZhbHVlcyk7XG4gICAgICAgIHZhciBpbmRpY2VzID0gKFJlY29yZFR5cGVQcm90b3R5cGUuX2luZGljZXMgPSB7fSk7XG4gICAgICAgIFJlY29yZFR5cGVQcm90b3R5cGUuX25hbWUgPSBuYW1lO1xuICAgICAgICBSZWNvcmRUeXBlUHJvdG90eXBlLl9rZXlzID0ga2V5cztcbiAgICAgICAgUmVjb3JkVHlwZVByb3RvdHlwZS5fZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRWYWx1ZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwcm9wTmFtZSA9IGtleXNbaV07XG4gICAgICAgICAgaW5kaWNlc1twcm9wTmFtZV0gPSBpO1xuICAgICAgICAgIGlmIChSZWNvcmRUeXBlUHJvdG90eXBlW3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybiAmJlxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgJ0Nhbm5vdCBkZWZpbmUgJyArXG4gICAgICAgICAgICAgICAgICByZWNvcmROYW1lKHRoaXMkMSkgK1xuICAgICAgICAgICAgICAgICAgJyB3aXRoIHByb3BlcnR5IFwiJyArXG4gICAgICAgICAgICAgICAgICBwcm9wTmFtZSArXG4gICAgICAgICAgICAgICAgICAnXCIgc2luY2UgdGhhdCBwcm9wZXJ0eSBuYW1lIGlzIHBhcnQgb2YgdGhlIFJlY29yZCBBUEkuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFByb3AoUmVjb3JkVHlwZVByb3RvdHlwZSwgcHJvcE5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fX293bmVySUQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl92YWx1ZXMgPSBMaXN0KCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobCkge1xuICAgICAgICBsLnNldFNpemUodGhpcyQxLl9rZXlzLmxlbmd0aCk7XG4gICAgICAgIEtleWVkQ29sbGVjdGlvbih2YWx1ZXMpLmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICBsLnNldCh0aGlzJDEuX2luZGljZXNba10sIHYgPT09IHRoaXMkMS5fZGVmYXVsdFZhbHVlc1trXSA/IHVuZGVmaW5lZCA6IHYpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgUmVjb3JkVHlwZVByb3RvdHlwZSA9IChSZWNvcmRUeXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoXG4gICAgICBSZWNvcmRQcm90b3R5cGVcbiAgICApKTtcbiAgICBSZWNvcmRUeXBlUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVjb3JkVHlwZTtcblxuICAgIHJldHVybiBSZWNvcmRUeXBlO1xuICB9O1xuXG4gIFJlY29yZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzdHIgPSByZWNvcmROYW1lKHRoaXMpICsgJyB7ICc7XG4gICAgdmFyIGtleXMgPSB0aGlzLl9rZXlzO1xuICAgIHZhciBrO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgIT09IGw7IGkrKykge1xuICAgICAgayA9IGtleXNbaV07XG4gICAgICBzdHIgKz0gKGkgPyAnLCAnIDogJycpICsgayArICc6ICcgKyBxdW90ZVN0cmluZyh0aGlzJDEuZ2V0KGspKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ciArICcgfSc7XG4gIH07XG5cbiAgUmVjb3JkLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKG90aGVyKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMgPT09IG90aGVyIHx8XG4gICAgICAob3RoZXIgJiZcbiAgICAgICAgdGhpcy5fa2V5cyA9PT0gb3RoZXIuX2tleXMgJiZcbiAgICAgICAgcmVjb3JkU2VxKHRoaXMpLmVxdWFscyhyZWNvcmRTZXEob3RoZXIpKSlcbiAgICApO1xuICB9O1xuXG4gIFJlY29yZC5wcm90b3R5cGUuaGFzaENvZGUgPSBmdW5jdGlvbiBoYXNoQ29kZSAoKSB7XG4gICAgcmV0dXJuIHJlY29yZFNlcSh0aGlzKS5oYXNoQ29kZSgpO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgUmVjb3JkLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGspIHtcbiAgICByZXR1cm4gdGhpcy5faW5kaWNlcy5oYXNPd25Qcm9wZXJ0eShrKTtcbiAgfTtcblxuICBSZWNvcmQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaywgbm90U2V0VmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuaGFzKGspKSB7XG4gICAgICByZXR1cm4gbm90U2V0VmFsdWU7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IHRoaXMuX2luZGljZXNba107XG4gICAgdmFyIHZhbHVlID0gdGhpcy5fdmFsdWVzLmdldChpbmRleCk7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB0aGlzLl9kZWZhdWx0VmFsdWVzW2tdIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICBSZWNvcmQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoaywgdikge1xuICAgIGlmICh0aGlzLmhhcyhrKSkge1xuICAgICAgdmFyIG5ld1ZhbHVlcyA9IHRoaXMuX3ZhbHVlcy5zZXQoXG4gICAgICAgIHRoaXMuX2luZGljZXNba10sXG4gICAgICAgIHYgPT09IHRoaXMuX2RlZmF1bHRWYWx1ZXNba10gPyB1bmRlZmluZWQgOiB2XG4gICAgICApO1xuICAgICAgaWYgKG5ld1ZhbHVlcyAhPT0gdGhpcy5fdmFsdWVzICYmICF0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICByZXR1cm4gbWFrZVJlY29yZCh0aGlzLCBuZXdWYWx1ZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBSZWNvcmQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoaykge1xuICAgIHJldHVybiB0aGlzLnNldChrKTtcbiAgfTtcblxuICBSZWNvcmQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgIHZhciBuZXdWYWx1ZXMgPSB0aGlzLl92YWx1ZXMuY2xlYXIoKS5zZXRTaXplKHRoaXMuX2tleXMubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5fX293bmVySUQgPyB0aGlzIDogbWFrZVJlY29yZCh0aGlzLCBuZXdWYWx1ZXMpO1xuICB9O1xuXG4gIFJlY29yZC5wcm90b3R5cGUud2FzQWx0ZXJlZCA9IGZ1bmN0aW9uIHdhc0FsdGVyZWQgKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZXMud2FzQWx0ZXJlZCgpO1xuICB9O1xuXG4gIFJlY29yZC5wcm90b3R5cGUudG9TZXEgPSBmdW5jdGlvbiB0b1NlcSAoKSB7XG4gICAgcmV0dXJuIHJlY29yZFNlcSh0aGlzKTtcbiAgfTtcblxuICBSZWNvcmQucHJvdG90eXBlLnRvSlMgPSBmdW5jdGlvbiB0b0pTJDEgKCkge1xuICAgIHJldHVybiB0b0pTKHRoaXMpO1xuICB9O1xuXG4gIFJlY29yZC5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uIGVudHJpZXMgKCkge1xuICAgIHJldHVybiB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTKTtcbiAgfTtcblxuICBSZWNvcmQucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgcmV0dXJuIHJlY29yZFNlcSh0aGlzKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICB9O1xuXG4gIFJlY29yZC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHJldHVybiByZWNvcmRTZXEodGhpcykuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgfTtcblxuICBSZWNvcmQucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbiBfX2Vuc3VyZU93bmVyIChvd25lcklEKSB7XG4gICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIG5ld1ZhbHVlcyA9IHRoaXMuX3ZhbHVlcy5fX2Vuc3VyZU93bmVyKG93bmVySUQpO1xuICAgIGlmICghb3duZXJJRCkge1xuICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgICAgdGhpcy5fdmFsdWVzID0gbmV3VmFsdWVzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBtYWtlUmVjb3JkKHRoaXMsIG5ld1ZhbHVlcywgb3duZXJJRCk7XG4gIH07XG5cbiAgUmVjb3JkLmlzUmVjb3JkID0gaXNSZWNvcmQ7XG4gIFJlY29yZC5nZXREZXNjcmlwdGl2ZU5hbWUgPSByZWNvcmROYW1lO1xuICB2YXIgUmVjb3JkUHJvdG90eXBlID0gUmVjb3JkLnByb3RvdHlwZTtcbiAgUmVjb3JkUHJvdG90eXBlW0lTX1JFQ09SRF9TWU1CT0xdID0gdHJ1ZTtcbiAgUmVjb3JkUHJvdG90eXBlW0RFTEVURV0gPSBSZWNvcmRQcm90b3R5cGUucmVtb3ZlO1xuICBSZWNvcmRQcm90b3R5cGUuZGVsZXRlSW4gPSBSZWNvcmRQcm90b3R5cGUucmVtb3ZlSW4gPSBkZWxldGVJbjtcbiAgUmVjb3JkUHJvdG90eXBlLmdldEluID0gZ2V0SW4kMTtcbiAgUmVjb3JkUHJvdG90eXBlLmhhc0luID0gQ29sbGVjdGlvblByb3RvdHlwZS5oYXNJbjtcbiAgUmVjb3JkUHJvdG90eXBlLm1lcmdlID0gbWVyZ2U7XG4gIFJlY29yZFByb3RvdHlwZS5tZXJnZVdpdGggPSBtZXJnZVdpdGg7XG4gIFJlY29yZFByb3RvdHlwZS5tZXJnZUluID0gbWVyZ2VJbjtcbiAgUmVjb3JkUHJvdG90eXBlLm1lcmdlRGVlcCA9IG1lcmdlRGVlcCQxO1xuICBSZWNvcmRQcm90b3R5cGUubWVyZ2VEZWVwV2l0aCA9IG1lcmdlRGVlcFdpdGgkMTtcbiAgUmVjb3JkUHJvdG90eXBlLm1lcmdlRGVlcEluID0gbWVyZ2VEZWVwSW47XG4gIFJlY29yZFByb3RvdHlwZS5zZXRJbiA9IHNldEluJDE7XG4gIFJlY29yZFByb3RvdHlwZS51cGRhdGUgPSB1cGRhdGUkMTtcbiAgUmVjb3JkUHJvdG90eXBlLnVwZGF0ZUluID0gdXBkYXRlSW4kMTtcbiAgUmVjb3JkUHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSB3aXRoTXV0YXRpb25zO1xuICBSZWNvcmRQcm90b3R5cGUuYXNNdXRhYmxlID0gYXNNdXRhYmxlO1xuICBSZWNvcmRQcm90b3R5cGUuYXNJbW11dGFibGUgPSBhc0ltbXV0YWJsZTtcbiAgUmVjb3JkUHJvdG90eXBlW0lURVJBVE9SX1NZTUJPTF0gPSBSZWNvcmRQcm90b3R5cGUuZW50cmllcztcbiAgUmVjb3JkUHJvdG90eXBlLnRvSlNPTiA9IFJlY29yZFByb3RvdHlwZS50b09iamVjdCA9XG4gICAgQ29sbGVjdGlvblByb3RvdHlwZS50b09iamVjdDtcbiAgUmVjb3JkUHJvdG90eXBlLmluc3BlY3QgPSBSZWNvcmRQcm90b3R5cGUudG9Tb3VyY2UgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VSZWNvcmQobGlrZVJlY29yZCwgdmFsdWVzLCBvd25lcklEKSB7XG4gICAgdmFyIHJlY29yZCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKGxpa2VSZWNvcmQpKTtcbiAgICByZWNvcmQuX3ZhbHVlcyA9IHZhbHVlcztcbiAgICByZWNvcmQuX19vd25lcklEID0gb3duZXJJRDtcbiAgICByZXR1cm4gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkTmFtZShyZWNvcmQpIHtcbiAgICByZXR1cm4gcmVjb3JkLl9uYW1lIHx8IHJlY29yZC5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdSZWNvcmQnO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkU2VxKHJlY29yZCkge1xuICAgIHJldHVybiBrZXllZFNlcUZyb21WYWx1ZShyZWNvcmQuX2tleXMubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBbaywgcmVjb3JkLmdldChrKV07IH0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFByb3AocHJvdG90eXBlLCBuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXQobmFtZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpbnZhcmlhbnQodGhpcy5fX293bmVySUQsICdDYW5ub3Qgc2V0IG9uIGFuIGltbXV0YWJsZSByZWNvcmQuJyk7XG4gICAgICAgICAgdGhpcy5zZXQobmFtZSwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBmYWlsZWQuIFByb2JhYmx5IElFOC5cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxhenkgU2VxIG9mIGB2YWx1ZWAgcmVwZWF0ZWQgYHRpbWVzYCB0aW1lcy4gV2hlbiBgdGltZXNgIGlzXG4gICAqIHVuZGVmaW5lZCwgcmV0dXJucyBhbiBpbmZpbml0ZSBzZXF1ZW5jZSBvZiBgdmFsdWVgLlxuICAgKi9cbiAgdmFyIFJlcGVhdCA9IChmdW5jdGlvbiAoSW5kZXhlZFNlcSQkMSkge1xuICAgIGZ1bmN0aW9uIFJlcGVhdCh2YWx1ZSwgdGltZXMpIHtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXBlYXQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVwZWF0KHZhbHVlLCB0aW1lcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5zaXplID0gdGltZXMgPT09IHVuZGVmaW5lZCA/IEluZmluaXR5IDogTWF0aC5tYXgoMCwgdGltZXMpO1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBpZiAoRU1QVFlfUkVQRUFUKSB7XG4gICAgICAgICAgcmV0dXJuIEVNUFRZX1JFUEVBVDtcbiAgICAgICAgfVxuICAgICAgICBFTVBUWV9SRVBFQVQgPSB0aGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICggSW5kZXhlZFNlcSQkMSApIFJlcGVhdC5fX3Byb3RvX18gPSBJbmRleGVkU2VxJCQxO1xuICAgIFJlcGVhdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkU2VxJCQxICYmIEluZGV4ZWRTZXEkJDEucHJvdG90eXBlICk7XG4gICAgUmVwZWF0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlcGVhdDtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnUmVwZWF0IFtdJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnUmVwZWF0IFsgJyArIHRoaXMuX3ZhbHVlICsgJyAnICsgdGhpcy5zaXplICsgJyB0aW1lcyBdJztcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKGluZGV4KSA/IHRoaXMuX3ZhbHVlIDogbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAoc2VhcmNoVmFsdWUpIHtcbiAgICAgIHJldHVybiBpcyh0aGlzLl92YWx1ZSwgc2VhcmNoVmFsdWUpO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKGJlZ2luLCBlbmQpIHtcbiAgICAgIHZhciBzaXplID0gdGhpcy5zaXplO1xuICAgICAgcmV0dXJuIHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgc2l6ZSlcbiAgICAgICAgPyB0aGlzXG4gICAgICAgIDogbmV3IFJlcGVhdChcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlLFxuICAgICAgICAgICAgcmVzb2x2ZUVuZChlbmQsIHNpemUpIC0gcmVzb2x2ZUJlZ2luKGJlZ2luLCBzaXplKVxuICAgICAgICAgICk7XG4gICAgfTtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UgKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHNlYXJjaFZhbHVlKSB7XG4gICAgICBpZiAoaXModGhpcy5fdmFsdWUsIHNlYXJjaFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mIChzZWFyY2hWYWx1ZSkge1xuICAgICAgaWYgKGlzKHRoaXMuX3ZhbHVlLCBzZWFyY2hWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAoaSAhPT0gc2l6ZSkge1xuICAgICAgICBpZiAoZm4odGhpcyQxLl92YWx1ZSwgcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKyssIHRoaXMkMSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBpID09PSBzaXplXG4gICAgICAgICAgICA/IGl0ZXJhdG9yRG9uZSgpXG4gICAgICAgICAgICA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKyssIHRoaXMkMS5fdmFsdWUpOyB9XG4gICAgICApO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAob3RoZXIpIHtcbiAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFJlcGVhdFxuICAgICAgICA/IGlzKHRoaXMuX3ZhbHVlLCBvdGhlci5fdmFsdWUpXG4gICAgICAgIDogZGVlcEVxdWFsKG90aGVyKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlcGVhdDtcbiAgfShJbmRleGVkU2VxKSk7XG5cbiAgdmFyIEVNUFRZX1JFUEVBVDtcblxuICBmdW5jdGlvbiBmcm9tSlModmFsdWUsIGNvbnZlcnRlcikge1xuICAgIHJldHVybiBmcm9tSlNXaXRoKFxuICAgICAgW10sXG4gICAgICBjb252ZXJ0ZXIgfHwgZGVmYXVsdENvbnZlcnRlcixcbiAgICAgIHZhbHVlLFxuICAgICAgJycsXG4gICAgICBjb252ZXJ0ZXIgJiYgY29udmVydGVyLmxlbmd0aCA+IDIgPyBbXSA6IHVuZGVmaW5lZCxcbiAgICAgIHsgJyc6IHZhbHVlIH1cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJvbUpTV2l0aChzdGFjaywgY29udmVydGVyLCB2YWx1ZSwga2V5LCBrZXlQYXRoLCBwYXJlbnRWYWx1ZSkge1xuICAgIHZhciB0b1NlcSA9IEFycmF5LmlzQXJyYXkodmFsdWUpXG4gICAgICA/IEluZGV4ZWRTZXFcbiAgICAgIDogaXNQbGFpbk9iaih2YWx1ZSlcbiAgICAgICAgPyBLZXllZFNlcVxuICAgICAgICA6IG51bGw7XG4gICAgaWYgKHRvU2VxKSB7XG4gICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGNpcmN1bGFyIHN0cnVjdHVyZSB0byBJbW11dGFibGUnKTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAga2V5UGF0aCAmJiBrZXkgIT09ICcnICYmIGtleVBhdGgucHVzaChrZXkpO1xuICAgICAgdmFyIGNvbnZlcnRlZCA9IGNvbnZlcnRlci5jYWxsKFxuICAgICAgICBwYXJlbnRWYWx1ZSxcbiAgICAgICAga2V5LFxuICAgICAgICB0b1NlcSh2YWx1ZSkubWFwKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBmcm9tSlNXaXRoKHN0YWNrLCBjb252ZXJ0ZXIsIHYsIGssIGtleVBhdGgsIHZhbHVlKTsgfVxuICAgICAgICApLFxuICAgICAgICBrZXlQYXRoICYmIGtleVBhdGguc2xpY2UoKVxuICAgICAgKTtcbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAga2V5UGF0aCAmJiBrZXlQYXRoLnBvcCgpO1xuICAgICAgcmV0dXJuIGNvbnZlcnRlZDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdENvbnZlcnRlcihrLCB2KSB7XG4gICAgcmV0dXJuIGlzS2V5ZWQodikgPyB2LnRvTWFwKCkgOiB2LnRvTGlzdCgpO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSBcIjQuMC4wLXJjLjEwXCI7XG5cbiAgdmFyIEltbXV0YWJsZSA9IHtcbiAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuXG4gICAgQ29sbGVjdGlvbjogQ29sbGVjdGlvbixcbiAgICAvLyBOb3RlOiBJdGVyYWJsZSBpcyBkZXByZWNhdGVkXG4gICAgSXRlcmFibGU6IENvbGxlY3Rpb24sXG5cbiAgICBTZXE6IFNlcSxcbiAgICBNYXA6IE1hcCxcbiAgICBPcmRlcmVkTWFwOiBPcmRlcmVkTWFwLFxuICAgIExpc3Q6IExpc3QsXG4gICAgU3RhY2s6IFN0YWNrLFxuICAgIFNldDogU2V0LFxuICAgIE9yZGVyZWRTZXQ6IE9yZGVyZWRTZXQsXG5cbiAgICBSZWNvcmQ6IFJlY29yZCxcbiAgICBSYW5nZTogUmFuZ2UsXG4gICAgUmVwZWF0OiBSZXBlYXQsXG5cbiAgICBpczogaXMsXG4gICAgZnJvbUpTOiBmcm9tSlMsXG4gICAgaGFzaDogaGFzaCxcblxuICAgIGlzSW1tdXRhYmxlOiBpc0ltbXV0YWJsZSxcbiAgICBpc0NvbGxlY3Rpb246IGlzQ29sbGVjdGlvbixcbiAgICBpc0tleWVkOiBpc0tleWVkLFxuICAgIGlzSW5kZXhlZDogaXNJbmRleGVkLFxuICAgIGlzQXNzb2NpYXRpdmU6IGlzQXNzb2NpYXRpdmUsXG4gICAgaXNPcmRlcmVkOiBpc09yZGVyZWQsXG4gICAgaXNWYWx1ZU9iamVjdDogaXNWYWx1ZU9iamVjdCxcbiAgICBpc1NlcTogaXNTZXEsXG4gICAgaXNMaXN0OiBpc0xpc3QsXG4gICAgaXNNYXA6IGlzTWFwLFxuICAgIGlzT3JkZXJlZE1hcDogaXNPcmRlcmVkTWFwLFxuICAgIGlzU3RhY2s6IGlzU3RhY2ssXG4gICAgaXNTZXQ6IGlzU2V0LFxuICAgIGlzT3JkZXJlZFNldDogaXNPcmRlcmVkU2V0LFxuICAgIGlzUmVjb3JkOiBpc1JlY29yZCxcblxuICAgIGdldDogZ2V0LFxuICAgIGdldEluOiBnZXRJbixcbiAgICBoYXM6IGhhcyxcbiAgICBoYXNJbjogaGFzSW4sXG4gICAgbWVyZ2U6IG1lcmdlJDEsXG4gICAgbWVyZ2VEZWVwOiBtZXJnZURlZXAsXG4gICAgbWVyZ2VXaXRoOiBtZXJnZVdpdGgkMSxcbiAgICBtZXJnZURlZXBXaXRoOiBtZXJnZURlZXBXaXRoLFxuICAgIHJlbW92ZTogcmVtb3ZlLFxuICAgIHJlbW92ZUluOiByZW1vdmVJbixcbiAgICBzZXQ6IHNldCxcbiAgICBzZXRJbjogc2V0SW4sXG4gICAgdXBkYXRlOiB1cGRhdGUsXG4gICAgdXBkYXRlSW46IHVwZGF0ZUluLFxuICB9O1xuXG4gIC8vIE5vdGU6IEl0ZXJhYmxlIGlzIGRlcHJlY2F0ZWRcbiAgdmFyIEl0ZXJhYmxlID0gQ29sbGVjdGlvbjtcblxuICBleHBvcnRzLmRlZmF1bHQgPSBJbW11dGFibGU7XG4gIGV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG4gIGV4cG9ydHMuQ29sbGVjdGlvbiA9IENvbGxlY3Rpb247XG4gIGV4cG9ydHMuSXRlcmFibGUgPSBJdGVyYWJsZTtcbiAgZXhwb3J0cy5TZXEgPSBTZXE7XG4gIGV4cG9ydHMuTWFwID0gTWFwO1xuICBleHBvcnRzLk9yZGVyZWRNYXAgPSBPcmRlcmVkTWFwO1xuICBleHBvcnRzLkxpc3QgPSBMaXN0O1xuICBleHBvcnRzLlN0YWNrID0gU3RhY2s7XG4gIGV4cG9ydHMuU2V0ID0gU2V0O1xuICBleHBvcnRzLk9yZGVyZWRTZXQgPSBPcmRlcmVkU2V0O1xuICBleHBvcnRzLlJlY29yZCA9IFJlY29yZDtcbiAgZXhwb3J0cy5SYW5nZSA9IFJhbmdlO1xuICBleHBvcnRzLlJlcGVhdCA9IFJlcGVhdDtcbiAgZXhwb3J0cy5pcyA9IGlzO1xuICBleHBvcnRzLmZyb21KUyA9IGZyb21KUztcbiAgZXhwb3J0cy5oYXNoID0gaGFzaDtcbiAgZXhwb3J0cy5pc0ltbXV0YWJsZSA9IGlzSW1tdXRhYmxlO1xuICBleHBvcnRzLmlzQ29sbGVjdGlvbiA9IGlzQ29sbGVjdGlvbjtcbiAgZXhwb3J0cy5pc0tleWVkID0gaXNLZXllZDtcbiAgZXhwb3J0cy5pc0luZGV4ZWQgPSBpc0luZGV4ZWQ7XG4gIGV4cG9ydHMuaXNBc3NvY2lhdGl2ZSA9IGlzQXNzb2NpYXRpdmU7XG4gIGV4cG9ydHMuaXNPcmRlcmVkID0gaXNPcmRlcmVkO1xuICBleHBvcnRzLmlzVmFsdWVPYmplY3QgPSBpc1ZhbHVlT2JqZWN0O1xuICBleHBvcnRzLmdldCA9IGdldDtcbiAgZXhwb3J0cy5nZXRJbiA9IGdldEluO1xuICBleHBvcnRzLmhhcyA9IGhhcztcbiAgZXhwb3J0cy5oYXNJbiA9IGhhc0luO1xuICBleHBvcnRzLm1lcmdlID0gbWVyZ2UkMTtcbiAgZXhwb3J0cy5tZXJnZURlZXAgPSBtZXJnZURlZXA7XG4gIGV4cG9ydHMubWVyZ2VXaXRoID0gbWVyZ2VXaXRoJDE7XG4gIGV4cG9ydHMubWVyZ2VEZWVwV2l0aCA9IG1lcmdlRGVlcFdpdGg7XG4gIGV4cG9ydHMucmVtb3ZlID0gcmVtb3ZlO1xuICBleHBvcnRzLnJlbW92ZUluID0gcmVtb3ZlSW47XG4gIGV4cG9ydHMuc2V0ID0gc2V0O1xuICBleHBvcnRzLnNldEluID0gc2V0SW47XG4gIGV4cG9ydHMudXBkYXRlID0gdXBkYXRlO1xuICBleHBvcnRzLnVwZGF0ZUluID0gdXBkYXRlSW47XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxuICAgICAgKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS1jb3JlanMyL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY2hhaW47XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS1jb3JlanMyL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9lbnN1cmVJdGVyYWJsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaW50ZXJuYWwvZW5zdXJlLWl0ZXJhYmxlXCIpKTtcblxudmFyIF9tYXJrZWQgPVxuLyojX19QVVJFX18qL1xuX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhjaGFpbik7XG5cbmZ1bmN0aW9uIGNoYWluKCkge1xuICB2YXIgX2xlbixcbiAgICAgIGFycmF5T2ZJdGVyLFxuICAgICAgX2tleSxcbiAgICAgIF9pLFxuICAgICAgaXRlcmFibGUsXG4gICAgICBfYXJncyA9IGFyZ3VtZW50cztcblxuICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBjaGFpbiQoX2NvbnRleHQpIHtcbiAgICB3aGlsZSAoMSkge1xuICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgZm9yIChfbGVuID0gX2FyZ3MubGVuZ3RoLCBhcnJheU9mSXRlciA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgIGFycmF5T2ZJdGVyW19rZXldID0gX2FyZ3NbX2tleV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2kgPSAwO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBpZiAoIShfaSA8IGFycmF5T2ZJdGVyLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA4O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaXRlcmFibGUgPSBhcnJheU9mSXRlcltfaV07XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmRlbGVnYXRlWWllbGQoKDAsIF9lbnN1cmVJdGVyYWJsZS5kZWZhdWx0KShpdGVyYWJsZSksIFwidDBcIiwgNSk7XG5cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIF9pKys7XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA4OlxuICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIF9tYXJrZWQsIHRoaXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY29tcG9zZTtcblxuZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZm5zLnJlZHVjZShmdW5jdGlvbiAoZiwgZykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZihnLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczIvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2hhaW4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NoYWluXCIpKTtcblxudmFyIF9kZWZhdWx0ID0gX2NoYWluLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczIvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBlbnRyaWVzO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczIvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgX2dldEl0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczIvY29yZS1qcy9nZXQtaXRlcmF0b3JcIikpO1xuXG52YXIgX21hcmtlZCA9XG4vKiNfX1BVUkVfXyovXG5fcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGVudHJpZXMpO1xuXG52YXIgZW1wdHlBcnIgPSBbXTtcblxuZnVuY3Rpb24gZW50cmllcyhlbnRyaWVzYWJsZSkge1xuICB2YXIga2V5O1xuICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBlbnRyaWVzJChfY29udGV4dCkge1xuICAgIHdoaWxlICgxKSB7XG4gICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBpZiAoIShlbnRyaWVzYWJsZSA9PSBudWxsKSkge1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsICgwLCBfZ2V0SXRlcmF0b3IyLmRlZmF1bHQpKGVtcHR5QXJyKSk7XG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGlmICghKHR5cGVvZiBlbnRyaWVzYWJsZS5lbnRyaWVzID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZGVsZWdhdGVZaWVsZChlbnRyaWVzYWJsZS5lbnRyaWVzKCksIFwidDBcIiwgNik7XG5cbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgaWYgKCEoKDAsIF90eXBlb2YyLmRlZmF1bHQpKGVudHJpZXNhYmxlKSA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfY29udGV4dC50MSA9IF9yZWdlbmVyYXRvci5kZWZhdWx0LmtleXMoZW50cmllc2FibGUpO1xuXG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgaWYgKChfY29udGV4dC50MiA9IF9jb250ZXh0LnQxKCkpLmRvbmUpIHtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGtleSA9IF9jb250ZXh0LnQyLnZhbHVlO1xuXG4gICAgICAgICAgaWYgKCFlbnRyaWVzYWJsZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTU7XG4gICAgICAgICAgcmV0dXJuIFtrZXksIGVudHJpZXNhYmxlW2tleV1dO1xuXG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEwO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTc6XG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgX21hcmtlZCwgdGhpcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczIvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjdXJyaWVkRmlsdGVyO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9jb3JlLWpzL2dldC1pdGVyYXRvclwiKSk7XG5cbnZhciBfZW5zdXJlSXRlcmFibGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ludGVybmFsL2Vuc3VyZS1pdGVyYWJsZVwiKSk7XG5cbnZhciBfbWFya2VkID1cbi8qI19fUFVSRV9fKi9cbl9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZmlsdGVyKTtcblxuZnVuY3Rpb24gZmlsdGVyKGZ1bmMsIGl0ZXJhYmxlKSB7XG4gIHZhciBjLCBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uLCBfZGlkSXRlcmF0b3JFcnJvciwgX2l0ZXJhdG9yRXJyb3IsIF9pdGVyYXRvciwgX3N0ZXAsIGl0ZW07XG5cbiAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gZmlsdGVyJChfY29udGV4dCkge1xuICAgIHdoaWxlICgxKSB7XG4gICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjID0gMDtcbiAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA0O1xuICAgICAgICAgIF9pdGVyYXRvciA9ICgwLCBfZ2V0SXRlcmF0b3IyLmRlZmF1bHQpKCgwLCBfZW5zdXJlSXRlcmFibGUuZGVmYXVsdCkoaXRlcmFibGUpKTtcblxuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpdGVtID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICBpZiAoIWZ1bmMoaXRlbSwgYysrKSkge1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgIHJldHVybiBpdGVtO1xuXG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTY7XG4gICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDQpO1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IF9jb250ZXh0LnQwO1xuXG4gICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgX2NvbnRleHQucHJldiA9IDIwO1xuICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyMTtcblxuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjM7XG5cbiAgICAgICAgICBpZiAoIV9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjY7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcblxuICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goMjMpO1xuXG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCgyMCk7XG5cbiAgICAgICAgY2FzZSAyODpcbiAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBfbWFya2VkLCB0aGlzLCBbWzQsIDE2LCAyMCwgMjhdLCBbMjEsLCAyMywgMjddXSk7XG59XG5cbmZ1bmN0aW9uIGN1cnJpZWRGaWx0ZXIoZnVuYywgaXRlcmFibGUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICByZXR1cm4gZmlsdGVyKGZ1bmMsIGl0ZXJhYmxlKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZpbHRlcihmdW5jLCBpdGVyYWJsZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczIvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjdXJyaWVkRmxhdDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczIvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2dldEl0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczIvY29yZS1qcy9nZXQtaXRlcmF0b3JcIikpO1xuXG52YXIgX2l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczIvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3JcIikpO1xuXG52YXIgX2Vuc3VyZUl0ZXJhYmxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbnRlcm5hbC9lbnN1cmUtaXRlcmFibGVcIikpO1xuXG52YXIgZGVmYXVsdFNob3VsZElGbGF0ID0gZnVuY3Rpb24gZGVmYXVsdFNob3VsZElGbGF0KGRlcHRoKSB7XG4gIGlmICh0eXBlb2YgZGVwdGggPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZGVwdGg7XG4gIH1cblxuICBpZiAodHlwZW9mIGRlcHRoID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY3VycmVudERlcHRoLCBpdGVyKSB7XG4gICAgICByZXR1cm4gY3VycmVudERlcHRoIDw9IGRlcHRoICYmIHR5cGVvZiBpdGVyW19pdGVyYXRvcjIuZGVmYXVsdF0gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGl0ZXIgIT09ICdzdHJpbmcnO1xuICAgIH07XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ2ZsYXQ6IFwiZGVwdGhcIiBjYW4gYmUgYSBmdW5jdGlvbiBvciBhIG51bWJlcicpO1xufTtcblxuZnVuY3Rpb24gZmxhdChzaG91bGRJRmxhdCwgaXRlcmFibGUpIHtcbiAgdmFyIF9tYXJrZWQgPVxuICAvKiNfX1BVUkVfXyovXG4gIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoX2ZsYXQpO1xuXG4gIGZ1bmN0aW9uIF9mbGF0KGN1cnJlbnREZXB0aCwgaXRlcmFibGUpIHtcbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiwgX2RpZEl0ZXJhdG9yRXJyb3IsIF9pdGVyYXRvckVycm9yLCBfaXRlcmF0b3IsIF9zdGVwLCBpdGVyO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2ZsYXQkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCFzaG91bGRJRmxhdChjdXJyZW50RGVwdGgsIGl0ZXJhYmxlKSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA0O1xuICAgICAgICAgICAgX2l0ZXJhdG9yID0gKDAsIF9nZXRJdGVyYXRvcjIuZGVmYXVsdCkoaXRlcmFibGUpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZXIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5kZWxlZ2F0ZVlpZWxkKF9mbGF0KGN1cnJlbnREZXB0aCArIDEsIGl0ZXIpLCBcInQwXCIsIDkpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxODtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxNDtcbiAgICAgICAgICAgIF9jb250ZXh0LnQxID0gX2NvbnRleHRbXCJjYXRjaFwiXSg0KTtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gX2NvbnRleHQudDE7XG5cbiAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE4O1xuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE5O1xuXG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjE7XG5cbiAgICAgICAgICAgIGlmICghX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG5cbiAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCgyMSk7XG5cbiAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCgxOCk7XG5cbiAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDMwO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI4OlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDMwO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuXG4gICAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX21hcmtlZCwgdGhpcywgW1s0LCAxNCwgMTgsIDI2XSwgWzE5LCwgMjEsIDI1XV0pO1xuICB9XG5cbiAgcmV0dXJuIF9mbGF0KDAsICgwLCBfZW5zdXJlSXRlcmFibGUuZGVmYXVsdCkoaXRlcmFibGUpKTtcbn1cblxuZnVuY3Rpb24gY3VycmllZEZsYXQoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICByZXR1cm4gZmxhdChkZWZhdWx0U2hvdWxkSUZsYXQoMSksIGl0ZXJhYmxlKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdW19pdGVyYXRvcjIuZGVmYXVsdF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBmbGF0KGRlZmF1bHRTaG91bGRJRmxhdCgxKSwgYXJnc1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIGZsYXQoZGVmYXVsdFNob3VsZElGbGF0KGFyZ3NbMF0pLCBpdGVyYWJsZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmxhdChkZWZhdWx0U2hvdWxkSUZsYXQoYXJnc1swXSksIGFyZ3NbMV0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczIvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS1jb3JlanMyL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9pdGVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczIvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3JcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczIvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIENpcmN1bGFyQnVmZmVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2lyY3VsYXJCdWZmZXIoc2l6ZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIENpcmN1bGFyQnVmZmVyKTtcbiAgICB0aGlzLmFycmF5ID0gbmV3IEFycmF5KHNpemUpO1xuICAgIHRoaXMuX3NpemUgPSBzaXplO1xuICAgIHRoaXMuY291bnRlciA9IDA7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShDaXJjdWxhckJ1ZmZlciwgW3tcbiAgICBrZXk6IFwicHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKG5ld0l0ZW0pIHtcbiAgICAgIHRoaXMuY291bnRlcisrO1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5jb3VudGVyICUgdGhpcy5fc2l6ZTtcbiAgICAgIHZhciBjdXJyZW50SXRlbSA9IHRoaXMuYXJyYXlbaW5kZXhdO1xuICAgICAgdGhpcy5hcnJheVtpbmRleF0gPSBuZXdJdGVtO1xuICAgICAgcmV0dXJuIGN1cnJlbnRJdGVtO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogX2l0ZXJhdG9yLmRlZmF1bHQsXG4gICAgdmFsdWU6XG4gICAgLyojX19QVVJFX18qL1xuICAgIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICB2YXIgY291bnRlciwgaTtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIHZhbHVlJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgY291bnRlciA9IHRoaXMuY291bnRlcjtcbiAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgaWYgKCEoaSA8IHRoaXMuX3NpemUpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcnJheVtjb3VudGVyICUgdGhpcy5fc2l6ZV07XG5cbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHZhbHVlLCB0aGlzKTtcbiAgICB9KVxuICB9XSk7XG4gIHJldHVybiBDaXJjdWxhckJ1ZmZlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ2lyY3VsYXJCdWZmZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS1jb3JlanMyL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZW5zdXJlSXRlcmFibGU7XG5cbnZhciBfaXRlcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS1jb3JlanMyL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yXCIpKTtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS1jb3JlanMyL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIpKTtcblxudmFyIGVtcHR5QXJyID0gW107XG5cbmZ1bmN0aW9uIGVuc3VyZUl0ZXJhYmxlKGkpIHtcbiAgaWYgKGkgPT0gbnVsbCkge1xuICAgIHJldHVybiAoMCwgX2dldEl0ZXJhdG9yMi5kZWZhdWx0KShlbXB0eUFycik7XG4gIH0gZWxzZSBpZiAoIWlbX2l0ZXJhdG9yLmRlZmF1bHRdKSB7XG4gICAgaWYgKHR5cGVvZiBpLm5leHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0l0ZXJhdG9ycyBhcmUgbm90IHN1cHBvcnRlZCBhcmd1bWVudHMgdG8gaXRlci10b29scy4gWW91IG11c3Qgd3JhcCB0aGVtIHVzaW5nIHRoZSBgaXRlcmFibGVgIG1ldGhvZC4nKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgYXJndW1lbnQgaXMgbm90IGFuIGl0ZXJhYmxlIG9yIG51bGwnKTtcbiAgfVxuXG4gIHJldHVybiBpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS1jb3JlanMyL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY3VycmllZEludGVycG9zZTtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczIvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2dldEl0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczIvY29yZS1qcy9nZXQtaXRlcmF0b3JcIikpO1xuXG52YXIgX2Vuc3VyZUl0ZXJhYmxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbnRlcm5hbC9lbnN1cmUtaXRlcmFibGVcIikpO1xuXG52YXIgX21hcmtlZCA9XG4vKiNfX1BVUkVfXyovXG5fcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGludGVycG9zZSk7XG5cbmZ1bmN0aW9uIGludGVycG9zZShpbnRlcnBvc2VJdGVtLCBpdGVyYWJsZSkge1xuICB2YXIgZmlyc3QsIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24sIF9kaWRJdGVyYXRvckVycm9yLCBfaXRlcmF0b3JFcnJvciwgX2l0ZXJhdG9yLCBfc3RlcCwgaXRlbTtcblxuICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBpbnRlcnBvc2UkKF9jb250ZXh0KSB7XG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA0O1xuICAgICAgICAgIF9pdGVyYXRvciA9ICgwLCBfZ2V0SXRlcmF0b3IyLmRlZmF1bHQpKCgwLCBfZW5zdXJlSXRlcmFibGUuZGVmYXVsdCkoaXRlcmFibGUpKTtcblxuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpdGVtID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJwb3NlSXRlbTtcblxuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMztcbiAgICAgICAgICByZXR1cm4gaXRlbTtcblxuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG5cbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxOTtcbiAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oNCk7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gX2NvbnRleHQudDA7XG5cbiAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjM7XG4gICAgICAgICAgX2NvbnRleHQucHJldiA9IDI0O1xuXG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyNjtcblxuICAgICAgICAgIGlmICghX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyOTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuXG4gICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCgyNik7XG5cbiAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDIzKTtcblxuICAgICAgICBjYXNlIDMxOlxuICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIF9tYXJrZWQsIHRoaXMsIFtbNCwgMTksIDIzLCAzMV0sIFsyNCwsIDI2LCAzMF1dKTtcbn1cblxuZnVuY3Rpb24gY3VycmllZEludGVycG9zZShpbnRlcnBvc2VJdGVtLCBpdGVyYWJsZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgIHJldHVybiBpbnRlcnBvc2UoaW50ZXJwb3NlSXRlbSwgaXRlcmFibGUpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gaW50ZXJwb3NlKGludGVycG9zZUl0ZW0sIGl0ZXJhYmxlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGtleXM7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS1jb3JlanMyL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9oZWxwZXJzL3R5cGVvZlwiKSk7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9jb3JlLWpzL2dldC1pdGVyYXRvclwiKSk7XG5cbnZhciBfbWFya2VkID1cbi8qI19fUFVSRV9fKi9cbl9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoa2V5cyk7XG5cbnZhciBlbXB0eUFyciA9IFtdO1xuXG5mdW5jdGlvbiBrZXlzKGtleXNhYmxlKSB7XG4gIHZhciBrZXk7XG4gIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIGtleXMkKF9jb250ZXh0KSB7XG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGlmICghKGtleXNhYmxlID09IG51bGwpKSB7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgKDAsIF9nZXRJdGVyYXRvcjIuZGVmYXVsdCkoZW1wdHlBcnIpKTtcblxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgaWYgKCEodHlwZW9mIGtleXNhYmxlLmtleXMgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gODtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBfY29udGV4dC5kZWxlZ2F0ZVlpZWxkKGtleXNhYmxlLmtleXMoKSwgXCJ0MFwiLCA2KTtcblxuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE3O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBpZiAoISgoMCwgX3R5cGVvZjIuZGVmYXVsdCkoa2V5c2FibGUpID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9jb250ZXh0LnQxID0gX3JlZ2VuZXJhdG9yLmRlZmF1bHQua2V5cyhrZXlzYWJsZSk7XG5cbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBpZiAoKF9jb250ZXh0LnQyID0gX2NvbnRleHQudDEoKSkuZG9uZSkge1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE3O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAga2V5ID0gX2NvbnRleHQudDIudmFsdWU7XG5cbiAgICAgICAgICBpZiAoIWtleXNhYmxlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNTtcbiAgICAgICAgICByZXR1cm4ga2V5O1xuXG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEwO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTc6XG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgX21hcmtlZCwgdGhpcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczIvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjdXJyaWVkTWFwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9jb3JlLWpzL2dldC1pdGVyYXRvclwiKSk7XG5cbnZhciBfZW5zdXJlSXRlcmFibGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ludGVybmFsL2Vuc3VyZS1pdGVyYWJsZVwiKSk7XG5cbnZhciBfbWFya2VkID1cbi8qI19fUFVSRV9fKi9cbl9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsobWFwKTtcblxuZnVuY3Rpb24gbWFwKGZ1bmMsIGl0ZXJhYmxlKSB7XG4gIHZhciBjLCBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uLCBfZGlkSXRlcmF0b3JFcnJvciwgX2l0ZXJhdG9yRXJyb3IsIF9pdGVyYXRvciwgX3N0ZXAsIGl0ZW07XG5cbiAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gbWFwJChfY29udGV4dCkge1xuICAgIHdoaWxlICgxKSB7XG4gICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjID0gMDtcbiAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA0O1xuICAgICAgICAgIF9pdGVyYXRvciA9ICgwLCBfZ2V0SXRlcmF0b3IyLmRlZmF1bHQpKCgwLCBfZW5zdXJlSXRlcmFibGUuZGVmYXVsdCkoaXRlcmFibGUpKTtcblxuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpdGVtID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEwO1xuICAgICAgICAgIHJldHVybiBmdW5jKGl0ZW0sIGMrKyk7XG5cbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxOTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxNTtcbiAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oNCk7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gX2NvbnRleHQudDA7XG5cbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTk7XG4gICAgICAgICAgX2NvbnRleHQucHJldiA9IDIwO1xuXG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyMjtcblxuICAgICAgICAgIGlmICghX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyNTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuXG4gICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCgyMik7XG5cbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDE5KTtcblxuICAgICAgICBjYXNlIDI3OlxuICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIF9tYXJrZWQsIHRoaXMsIFtbNCwgMTUsIDE5LCAyN10sIFsyMCwsIDIyLCAyNl1dKTtcbn1cblxuZnVuY3Rpb24gY3VycmllZE1hcChmdW5jLCBpdGVyYWJsZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgIHJldHVybiBtYXAoZnVuYywgaXRlcmFibGUpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gbWFwKGZ1bmMsIGl0ZXJhYmxlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJhbmdlO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczIvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgX21hcmtlZCA9XG4vKiNfX1BVUkVfXyovXG5fcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKHJhbmdlKTtcblxuZnVuY3Rpb24gcmFuZ2Uob3B0cykge1xuICB2YXIgc3RhcnQsIHN0ZXAsIGVuZCwgaTtcbiAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gcmFuZ2UkKF9jb250ZXh0KSB7XG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIG9wdHMgPSB0eXBlb2Ygb3B0cyA9PT0gJ251bWJlcicgPyB7XG4gICAgICAgICAgICBlbmQ6IG9wdHMsXG4gICAgICAgICAgICBzdGFydDogMFxuICAgICAgICAgIH0gOiAoMCwgX3R5cGVvZjIuZGVmYXVsdCkob3B0cykgPT09ICdvYmplY3QnID8gb3B0cyA6IHt9O1xuICAgICAgICAgIHN0ZXAgPSB0eXBlb2Ygb3B0cy5zdGVwID09PSAndW5kZWZpbmVkJyA/IDEgOiBvcHRzLnN0ZXA7XG4gICAgICAgICAgZW5kID0gdHlwZW9mIG9wdHMuZW5kID09PSAndW5kZWZpbmVkJyA/IHN0ZXAgPiAwID8gSW5maW5pdHkgOiAtSW5maW5pdHkgOiBvcHRzLmVuZDtcbiAgICAgICAgICBzdGFydCA9IG9wdHMuc3RhcnQgPyBvcHRzLnN0YXJ0IDogMDtcbiAgICAgICAgICBpID0gc3RhcnQ7XG5cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGlmICghKHN0ZXAgPiAwID8gaSA8IGVuZCA6IGkgPiBlbmQpKSB7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gODtcbiAgICAgICAgICByZXR1cm4gaTtcblxuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgaSArPSBzdGVwO1xuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgX21hcmtlZCwgdGhpcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczIvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjdXJyaWVkUmVkdWNlO1xuXG52YXIgX2l0ZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvclwiKSk7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9jb3JlLWpzL2dldC1pdGVyYXRvclwiKSk7XG5cbnZhciBfZW5zdXJlSXRlcmFibGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ludGVybmFsL2Vuc3VyZS1pdGVyYWJsZVwiKSk7XG5cbmZ1bmN0aW9uIHJlZHVjZShpbml0aWFsLCBmdW5jLCBpdGVyYWJsZSkge1xuICB2YXIgYyA9IDA7XG4gIHZhciBhY2MgPSBpbml0aWFsO1xuICB2YXIgaXRlcmF0b3IgPSAoMCwgX2dldEl0ZXJhdG9yMi5kZWZhdWx0KSgoMCwgX2Vuc3VyZUl0ZXJhYmxlLmRlZmF1bHQpKGl0ZXJhYmxlKSk7XG5cbiAgdHJ5IHtcbiAgICBpZiAoaW5pdGlhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZmlyc3RSZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG5cbiAgICAgIGlmIChmaXJzdFJlc3VsdC5kb25lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHVjZTogbm8gaW5pdGlhbCB2YWx1ZSBzcGVjaWZpZWQgYW5kIGl0ZXJhYmxlIHdhcyBlbXB0eScpO1xuICAgICAgfVxuXG4gICAgICBhY2MgPSBmaXJzdFJlc3VsdC52YWx1ZTtcbiAgICAgIGMgPSAxO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQ7XG5cbiAgICB3aGlsZSAoIShyZXN1bHQgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgIGFjYyA9IGZ1bmMoYWNjLCByZXN1bHQudmFsdWUsIGMrKyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBjbG9zZSB0aGUgaXRlcmFibGUgaW4gY2FzZSBvZiBleGNlcHRpb25zXG4gICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5yZXR1cm4gPT09ICdmdW5jdGlvbicpIGl0ZXJhYmxlLnJldHVybigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGN1cnJpZWRSZWR1Y2UoaW5pdGlhbCwgZnVuYywgaXRlcmFibGUpIHtcbiAgLy8gaXMgdGhpcyBjb21wbGV0ZT8gaGFzIGFuIGl0ZXJhYmxlIGJlZW4gc3BlY2lmaWVkPyAoZnVuYyBjYW4gbmV2ZXIgYmUgaXRlcmFibGUpXG4gIC8vICAgIGlzIHRoZXJlIGFuIGl0ZXJhYmxlIHRoYXQgY29tZXMgYWZ0ZXIgZnVuY1xuICAvLyAgICB3b3JrIGJhY2t3YXJkcyBmcm9tIHRoZXJlXG4gIHZhciBoYXNJdGVyYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgZnVuYyA9IGluaXRpYWw7XG4gICAgaW5pdGlhbCA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIChmdW5jID09IG51bGwgfHwgZnVuY1tfaXRlcmF0b3IuZGVmYXVsdF0pKSB7XG4gICAgaXRlcmFibGUgPSBmdW5jO1xuICAgIGZ1bmMgPSBpbml0aWFsO1xuICAgIGluaXRpYWwgPSB1bmRlZmluZWQ7XG4gICAgaGFzSXRlcmFibGUgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBoYXNJdGVyYWJsZSA9IHRydWU7XG4gIH1cblxuICBpZiAoIWhhc0l0ZXJhYmxlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgcmV0dXJuIHJlZHVjZShpbml0aWFsLCBmdW5jLCBpdGVyYWJsZSk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiByZWR1Y2UoaW5pdGlhbCwgZnVuYywgaXRlcmFibGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS1jb3JlanMyL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcmVwZWF0O1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfbWFya2VkID1cbi8qI19fUFVSRV9fKi9cbl9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsocmVwZWF0KTtcblxuZnVuY3Rpb24gcmVwZWF0KG9iaikge1xuICB2YXIgdGltZXMsXG4gICAgICBfYXJncyA9IGFyZ3VtZW50cztcbiAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gcmVwZWF0JChfY29udGV4dCkge1xuICAgIHdoaWxlICgxKSB7XG4gICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICB0aW1lcyA9IF9hcmdzLmxlbmd0aCA+IDEgJiYgX2FyZ3NbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzFdIDogSW5maW5pdHk7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmICghdGltZXMtLSkge1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICByZXR1cm4gb2JqO1xuXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDY6XG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgX21hcmtlZCwgdGhpcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczIvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBzaXplO1xuXG52YXIgX2dldEl0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczIvY29yZS1qcy9nZXQtaXRlcmF0b3JcIikpO1xuXG52YXIgX2Vuc3VyZUl0ZXJhYmxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbnRlcm5hbC9lbnN1cmUtaXRlcmFibGVcIikpO1xuXG5mdW5jdGlvbiBzaXplKGl0ZXJhYmxlKSB7XG4gIHZhciBzaXplID0gMDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gKDAsIF9nZXRJdGVyYXRvcjIuZGVmYXVsdCkoKDAsIF9lbnN1cmVJdGVyYWJsZS5kZWZhdWx0KShpdGVyYWJsZSkpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICB2YXIgXyA9IF9zdGVwLnZhbHVlO1xuICAgICAgc2l6ZSsrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzaXplO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS1jb3JlanMyL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY3VycmllZFNsaWNlO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9jb3JlLWpzL2dldC1pdGVyYXRvclwiKSk7XG5cbnZhciBfY2lyY3VsYXJCdWZmZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ludGVybmFsL2NpcmN1bGFyLWJ1ZmZlclwiKSk7XG5cbnZhciBfZW5zdXJlSXRlcmFibGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ludGVybmFsL2Vuc3VyZS1pdGVyYWJsZVwiKSk7XG5cbnZhciBfbWFya2VkID1cbi8qI19fUFVSRV9fKi9cbl9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoc2ltcGxlU2xpY2UpLFxuICAgIF9tYXJrZWQyID1cbi8qI19fUFVSRV9fKi9cbl9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoc2xpY2UpO1xuXG5mdW5jdGlvbiBidWZmZXJlZFNsaWNlKGl0ZXJhYmxlLCBzdGFydCwgZW5kLCBzdGVwKSB7XG4gIHZhciBidWZmZXJTaXplID0gTWF0aC5hYnMoc3RhcnQpO1xuICB2YXIgYnVmZmVyID0gbmV3IF9jaXJjdWxhckJ1ZmZlci5kZWZhdWx0KGJ1ZmZlclNpemUpO1xuICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSAoMCwgX2dldEl0ZXJhdG9yMi5kZWZhdWx0KShpdGVyYWJsZSksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgIHZhciBpdGVtID0gX3N0ZXAudmFsdWU7XG4gICAgICBidWZmZXIucHVzaChpdGVtKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbmV3RW5kO1xuXG4gIGlmIChpc0Zpbml0ZShlbmQpICYmIGVuZCA+IDApIHtcbiAgICBuZXdFbmQgPSBlbmQgLSAoYnVmZmVyLmNvdW50ZXIgLSBidWZmZXJTaXplKTtcbiAgICBpZiAobmV3RW5kIDwgMCkgcmV0dXJuIFtdO1xuICB9IGVsc2Uge1xuICAgIG5ld0VuZCA9IGVuZDtcbiAgfVxuXG4gIHJldHVybiBzaW1wbGVTbGljZShidWZmZXIsIDAsIG5ld0VuZCwgc3RlcCk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZVNsaWNlKGl0ZXJhYmxlLCBzdGFydCwgZW5kLCBzdGVwKSB7XG4gIHZhciBjdXJyZW50UG9zLCBuZXh0VmFsaWRQb3MsIGJ1ZmZlclNpemUsIGJ1ZmZlciwgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIsIF9kaWRJdGVyYXRvckVycm9yMiwgX2l0ZXJhdG9yRXJyb3IyLCBfaXRlcmF0b3IyLCBfc3RlcDIsIGl0ZW07XG5cbiAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gc2ltcGxlU2xpY2UkKF9jb250ZXh0KSB7XG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGN1cnJlbnRQb3MgPSAwO1xuICAgICAgICAgIG5leHRWYWxpZFBvcyA9IHN0YXJ0O1xuICAgICAgICAgIGJ1ZmZlclNpemUgPSBNYXRoLmFicyhlbmQpO1xuXG4gICAgICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBfY2lyY3VsYXJCdWZmZXIuZGVmYXVsdChidWZmZXJTaXplKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA3O1xuICAgICAgICAgIF9pdGVyYXRvcjIgPSAoMCwgX2dldEl0ZXJhdG9yMi5kZWZhdWx0KShpdGVyYWJsZSk7XG5cbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIGlmIChfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaXRlbSA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgIGlmICghYnVmZmVyKSB7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpdGVtID0gYnVmZmVyLnB1c2goaXRlbSk7XG5cbiAgICAgICAgICBpZiAoIShidWZmZXIuY291bnRlciA8PSBidWZmZXJTaXplKSkge1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcImNvbnRpbnVlXCIsIDIyKTtcblxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGlmICghKGN1cnJlbnRQb3MgPj0gZW5kICYmIGVuZCA+PSAwKSkge1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE3O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcImJyZWFrXCIsIDI1KTtcblxuICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgIGlmICghKG5leHRWYWxpZFBvcyA9PT0gY3VycmVudFBvcykpIHtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMDtcbiAgICAgICAgICByZXR1cm4gaXRlbTtcblxuICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgIG5leHRWYWxpZFBvcyArPSBzdGVwO1xuXG4gICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgY3VycmVudFBvcysrO1xuXG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDMxO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgX2NvbnRleHQucHJldiA9IDI3O1xuICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSg3KTtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yMiA9IF9jb250ZXh0LnQwO1xuXG4gICAgICAgIGNhc2UgMzE6XG4gICAgICAgICAgX2NvbnRleHQucHJldiA9IDMxO1xuICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAzMjtcblxuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMzQ7XG5cbiAgICAgICAgICBpZiAoIV9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM3O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuXG4gICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCgzNCk7XG5cbiAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDMxKTtcblxuICAgICAgICBjYXNlIDM5OlxuICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIF9tYXJrZWQsIHRoaXMsIFtbNywgMjcsIDMxLCAzOV0sIFszMiwsIDM0LCAzOF1dKTtcbn1cblxuZnVuY3Rpb24gc2xpY2Uob3B0cywgaXRlcmFibGUpIHtcbiAgdmFyIHN0YXJ0LCBzdGVwLCBlbmQ7XG4gIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIHNsaWNlJChfY29udGV4dDIpIHtcbiAgICB3aGlsZSAoMSkge1xuICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBvcHRzID0gdHlwZW9mIG9wdHMgPT09ICdudW1iZXInID8ge1xuICAgICAgICAgICAgZW5kOiBvcHRzLFxuICAgICAgICAgICAgc3RhcnQ6IDBcbiAgICAgICAgICB9IDogb3B0cztcbiAgICAgICAgICBzdGVwID0gdHlwZW9mIG9wdHMuc3RlcCA9PT0gJ3VuZGVmaW5lZCcgPyAxIDogb3B0cy5zdGVwO1xuICAgICAgICAgIGVuZCA9IHR5cGVvZiBvcHRzLmVuZCA9PT0gJ3VuZGVmaW5lZCcgPyBJbmZpbml0eSA6IG9wdHMuZW5kO1xuICAgICAgICAgIHN0YXJ0ID0gb3B0cy5zdGFydCA/IG9wdHMuc3RhcnQgOiAwO1xuICAgICAgICAgIGl0ZXJhYmxlID0gKDAsIF9lbnN1cmVJdGVyYWJsZS5kZWZhdWx0KShpdGVyYWJsZSk7XG5cbiAgICAgICAgICBpZiAoIShzdGVwIDw9IDApKSB7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3Qgc2xpY2Ugd2l0aCBzdGVwIDw9IDAnKTtcblxuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgaWYgKCEoc3RhcnQgPj0gMCkpIHtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmRlbGVnYXRlWWllbGQoc2ltcGxlU2xpY2UoaXRlcmFibGUsIHN0YXJ0LCBlbmQsIHN0ZXApLCBcInQwXCIsIDkpO1xuXG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEyO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5kZWxlZ2F0ZVlpZWxkKGJ1ZmZlcmVkU2xpY2UoaXRlcmFibGUsIHN0YXJ0LCBlbmQsIHN0ZXApLCBcInQxXCIsIDEyKTtcblxuICAgICAgICBjYXNlIDEyOlxuICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBfbWFya2VkMiwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIGN1cnJpZWRTbGljZShvcHRzLCBpdGVyYWJsZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgIHJldHVybiBzbGljZShvcHRzLCBpdGVyYWJsZSk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBzbGljZShvcHRzLCBpdGVyYWJsZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lLWNvcmVqczIvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjdXJyaWVkVGFwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9jb3JlLWpzL2dldC1pdGVyYXRvclwiKSk7XG5cbnZhciBfZW5zdXJlSXRlcmFibGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ludGVybmFsL2Vuc3VyZS1pdGVyYWJsZVwiKSk7XG5cbnZhciBfbWFya2VkID1cbi8qI19fUFVSRV9fKi9cbl9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsodGFwKTtcblxuZnVuY3Rpb24gdGFwKGZ1bmMsIGl0ZXJhYmxlKSB7XG4gIHZhciBjLCBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uLCBfZGlkSXRlcmF0b3JFcnJvciwgX2l0ZXJhdG9yRXJyb3IsIF9pdGVyYXRvciwgX3N0ZXAsIGl0ZW07XG5cbiAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gdGFwJChfY29udGV4dCkge1xuICAgIHdoaWxlICgxKSB7XG4gICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjID0gMDtcbiAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA0O1xuICAgICAgICAgIF9pdGVyYXRvciA9ICgwLCBfZ2V0SXRlcmF0b3IyLmRlZmF1bHQpKCgwLCBfZW5zdXJlSXRlcmFibGUuZGVmYXVsdCkoaXRlcmFibGUpKTtcblxuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpdGVtID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgZnVuYyhpdGVtLCBjKyspO1xuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICByZXR1cm4gaXRlbTtcblxuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIwO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgX2NvbnRleHQucHJldiA9IDE2O1xuICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSg0KTtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBfY29udGV4dC50MDtcblxuICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyMDtcbiAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjE7XG5cbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgX2NvbnRleHQucHJldiA9IDIzO1xuXG4gICAgICAgICAgaWYgKCFfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI2O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG5cbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDIzKTtcblxuICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goMjApO1xuXG4gICAgICAgIGNhc2UgMjg6XG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgX21hcmtlZCwgdGhpcywgW1s0LCAxNiwgMjAsIDI4XSwgWzIxLCwgMjMsIDI3XV0pO1xufVxuXG5mdW5jdGlvbiBjdXJyaWVkVGFwKGZ1bmMsIGl0ZXJhYmxlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgICAgcmV0dXJuIHRhcChmdW5jLCBpdGVyYWJsZSk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB0YXAoZnVuYywgaXRlcmFibGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS1jb3JlanMyL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3ppcExvbmdlc3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ppcC1sb25nZXN0XCIpKTtcblxudmFyIF9kZWZhdWx0ID0gX3ppcExvbmdlc3QuZGVmYXVsdDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHppcExvbmdlc3Q7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS1jb3JlanMyL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS1jb3JlanMyL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIpKTtcblxudmFyIF9lbnN1cmVJdGVyYWJsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaW50ZXJuYWwvZW5zdXJlLWl0ZXJhYmxlXCIpKTtcblxudmFyIF9tYXJrZWQgPVxuLyojX19QVVJFX18qL1xuX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayh6aXBMb25nZXN0KTtcblxuZnVuY3Rpb24gemlwTG9uZ2VzdCgpIHtcbiAgdmFyIF9sZW4sXG4gICAgICBpdGVyYWJsZXMsXG4gICAgICBfa2V5LFxuICAgICAgaXRlcnMsXG4gICAgICBudW1iZXJPZkV4aGF1c3RlZCxcbiAgICAgIHppcHBlZCxcbiAgICAgIGksXG4gICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uLFxuICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IsXG4gICAgICBfaXRlcmF0b3JFcnJvcixcbiAgICAgIF9pdGVyYXRvcixcbiAgICAgIF9zdGVwLFxuICAgICAgaXRlcixcbiAgICAgIF9pdGVyJG5leHQsXG4gICAgICBkb25lLFxuICAgICAgdmFsdWUsXG4gICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMixcbiAgICAgIF9kaWRJdGVyYXRvckVycm9yMixcbiAgICAgIF9pdGVyYXRvckVycm9yMixcbiAgICAgIF9pdGVyYXRvcjIsXG4gICAgICBfc3RlcDIsXG4gICAgICBfaXRlcixcbiAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuXG4gIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIHppcExvbmdlc3QkKF9jb250ZXh0KSB7XG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGZvciAoX2xlbiA9IF9hcmdzLmxlbmd0aCwgaXRlcmFibGVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgaXRlcmFibGVzW19rZXldID0gX2FyZ3NbX2tleV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaXRlcnMgPSBpdGVyYWJsZXMubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9nZXRJdGVyYXRvcjIuZGVmYXVsdCkoKDAsIF9lbnN1cmVJdGVyYWJsZS5kZWZhdWx0KShpKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX2NvbnRleHQucHJldiA9IDI7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGlmICghdHJ1ZSkge1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDMyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbnVtYmVyT2ZFeGhhdXN0ZWQgPSAwO1xuICAgICAgICAgIHppcHBlZCA9IG5ldyBBcnJheShpdGVyYWJsZXMubGVuZ3RoKTtcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxMDtcblxuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yID0gKDAsIF9nZXRJdGVyYXRvcjIuZGVmYXVsdCkoaXRlcnMpOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICAgIGl0ZXIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIF9pdGVyJG5leHQgPSBpdGVyLm5leHQoKSwgZG9uZSA9IF9pdGVyJG5leHQuZG9uZSwgdmFsdWUgPSBfaXRlciRuZXh0LnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICBudW1iZXJPZkV4aGF1c3RlZCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB6aXBwZWRbaSsrXSA9IGRvbmUgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTg7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTQ7XG4gICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDEwKTtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBfY29udGV4dC50MDtcblxuICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxODtcbiAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTk7XG5cbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgX2NvbnRleHQucHJldiA9IDIxO1xuXG4gICAgICAgICAgaWYgKCFfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG5cbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDIxKTtcblxuICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goMTgpO1xuXG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgaWYgKCEoaXRlcnMubGVuZ3RoID09PSBudW1iZXJPZkV4aGF1c3RlZCkpIHtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyODtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgY2FzZSAyODpcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMzA7XG4gICAgICAgICAgcmV0dXJuIHppcHBlZDtcblxuICAgICAgICBjYXNlIDMwOlxuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgX2NvbnRleHQucHJldiA9IDMyO1xuICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgX2NvbnRleHQucHJldiA9IDM2O1xuXG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IyID0gKDAsIF9nZXRJdGVyYXRvcjIuZGVmYXVsdCkoaXRlcnMpOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgICAgICBfaXRlciA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgX2l0ZXIucmV0dXJuID09PSAnZnVuY3Rpb24nKSBfaXRlci5yZXR1cm4oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICBfY29udGV4dC5wcmV2ID0gNDA7XG4gICAgICAgICAgX2NvbnRleHQudDEgPSBfY29udGV4dFtcImNhdGNoXCJdKDM2KTtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yMiA9IF9jb250ZXh0LnQxO1xuXG4gICAgICAgIGNhc2UgNDQ6XG4gICAgICAgICAgX2NvbnRleHQucHJldiA9IDQ0O1xuICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA0NTtcblxuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICBfY29udGV4dC5wcmV2ID0gNDc7XG5cbiAgICAgICAgICBpZiAoIV9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDUwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuXG4gICAgICAgIGNhc2UgNTA6XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCg0Nyk7XG5cbiAgICAgICAgY2FzZSA1MTpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDQ0KTtcblxuICAgICAgICBjYXNlIDUyOlxuICAgICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goMzIpO1xuXG4gICAgICAgIGNhc2UgNTM6XG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgX21hcmtlZCwgdGhpcywgW1syLCwgMzIsIDUzXSwgWzEwLCAxNCwgMTgsIDI2XSwgWzE5LCwgMjEsIDI1XSwgWzM2LCA0MCwgNDQsIDUyXSwgWzQ1LCwgNDcsIDUxXV0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS1jb3JlanMyL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gemlwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9jb3JlLWpzL2dldC1pdGVyYXRvclwiKSk7XG5cbnZhciBfZW5zdXJlSXRlcmFibGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ludGVybmFsL2Vuc3VyZS1pdGVyYWJsZVwiKSk7XG5cbnZhciBfbWFya2VkID1cbi8qI19fUFVSRV9fKi9cbl9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoemlwKTtcblxuZnVuY3Rpb24gY2xvc2VJdGVyYXRvcnMoaXRlcnMsIGV4Y2VwdCkge1xuICB2YXIgYyA9IDA7XG4gIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9ICgwLCBfZ2V0SXRlcmF0b3IyLmRlZmF1bHQpKGl0ZXJzKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgdmFyIGl0ZXIgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgaWYgKGMgPT09IGV4Y2VwdCkge1xuICAgICAgICBjKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXIucmV0dXJuID09PSAnZnVuY3Rpb24nKSBpdGVyLnJldHVybigpO1xuICAgICAgYysrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB6aXAoKSB7XG4gIHZhciBfbGVuLFxuICAgICAgaXRlcmFibGVzLFxuICAgICAgX2tleSxcbiAgICAgIGl0ZXJzLFxuICAgICAgemlwcGVkLFxuICAgICAgaSxcbiAgICAgIGMsXG4gICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMixcbiAgICAgIF9kaWRJdGVyYXRvckVycm9yMixcbiAgICAgIF9pdGVyYXRvckVycm9yMixcbiAgICAgIF9pdGVyYXRvcjIsXG4gICAgICBfc3RlcDIsXG4gICAgICBpdGVyLFxuICAgICAgX2l0ZXIkbmV4dCxcbiAgICAgIGRvbmUsXG4gICAgICB2YWx1ZSxcbiAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuXG4gIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIHppcCQoX2NvbnRleHQpIHtcbiAgICB3aGlsZSAoMSkge1xuICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgZm9yIChfbGVuID0gX2FyZ3MubGVuZ3RoLCBpdGVyYWJsZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICBpdGVyYWJsZXNbX2tleV0gPSBfYXJnc1tfa2V5XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpdGVycyA9IGl0ZXJhYmxlcy5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2dldEl0ZXJhdG9yMi5kZWZhdWx0KSgoMCwgX2Vuc3VyZUl0ZXJhYmxlLmRlZmF1bHQpKGkpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjtcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgaWYgKCF0cnVlKSB7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB6aXBwZWQgPSBuZXcgQXJyYXkoaXRlcmFibGVzLmxlbmd0aCk7XG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgYyA9IDA7XG4gICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTA7XG4gICAgICAgICAgX2l0ZXJhdG9yMiA9ICgwLCBfZ2V0SXRlcmF0b3IyLmRlZmF1bHQpKGl0ZXJzKTtcblxuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGlmIChfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaXRlciA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICBfaXRlciRuZXh0ID0gaXRlci5uZXh0KCksIGRvbmUgPSBfaXRlciRuZXh0LmRvbmUsIHZhbHVlID0gX2l0ZXIkbmV4dC52YWx1ZTtcblxuICAgICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE4O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2xvc2VJdGVyYXRvcnMoaXRlcnMsIGMpOyAvLyBjbGVhbiB1cCB1bmZpbmlzaGVkIGl0ZXJhdG9yc1xuXG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgIGMrKztcbiAgICAgICAgICB6aXBwZWRbaSsrXSA9IHZhbHVlO1xuXG4gICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyOTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyNTtcbiAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMTApO1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gX2NvbnRleHQudDA7XG5cbiAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjk7XG4gICAgICAgICAgX2NvbnRleHQucHJldiA9IDMwO1xuXG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAzMjtcblxuICAgICAgICAgIGlmICghX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMzU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG5cbiAgICAgICAgY2FzZSAzNTpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDMyKTtcblxuICAgICAgICBjYXNlIDM2OlxuICAgICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goMjkpO1xuXG4gICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM5O1xuICAgICAgICAgIHJldHVybiB6aXBwZWQ7XG5cbiAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDQxOlxuICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA0MTtcbiAgICAgICAgICBjbG9zZUl0ZXJhdG9ycyhpdGVycyk7XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCg0MSk7XG5cbiAgICAgICAgY2FzZSA0NDpcbiAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBfbWFya2VkLCB0aGlzLCBbWzIsLCA0MSwgNDRdLCBbMTAsIDI1LCAyOSwgMzddLCBbMzAsLCAzMiwgMzZdXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiLyoqXG4gKiBtYXJrZWQgLSBhIG1hcmtkb3duIHBhcnNlclxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTQsIENocmlzdG9waGVyIEplZmZyZXkuIChNSVQgTGljZW5zZWQpXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWFya2VkanMvbWFya2VkXG4gKi9cblxuOyhmdW5jdGlvbihyb290KSB7XG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQmxvY2stTGV2ZWwgR3JhbW1hclxuICovXG5cbnZhciBibG9jayA9IHtcbiAgbmV3bGluZTogL15cXG4rLyxcbiAgY29kZTogL14oIHs0fVteXFxuXStcXG4qKSsvLFxuICBmZW5jZXM6IG5vb3AsXG4gIGhyOiAvXiB7MCwzfSgoPzotICopezMsfXwoPzpfICopezMsfXwoPzpcXCogKil7Myx9KSg/Olxcbit8JCkvLFxuICBoZWFkaW5nOiAvXiAqKCN7MSw2fSkgKihbXlxcbl0rPykgKiMqICooPzpcXG4rfCQpLyxcbiAgbnB0YWJsZTogbm9vcCxcbiAgYmxvY2txdW90ZTogL14oIHswLDN9PiA/KHBhcmFncmFwaHxbXlxcbl0qKSg/OlxcbnwkKSkrLyxcbiAgbGlzdDogL14oICopKGJ1bGwpIFtcXHNcXFNdKz8oPzpocnxkZWZ8XFxuezIsfSg/ISApKD8hXFwxYnVsbCApXFxuKnxcXHMqJCkvLFxuICBodG1sOiAvXiAqKD86Y29tbWVudCAqKD86XFxufFxccyokKXxjbG9zZWQgKig/OlxcbnsyLH18XFxzKiQpfGNsb3NpbmcgKig/OlxcbnsyLH18XFxzKiQpKS8sXG4gIGRlZjogL14gezAsM31cXFsobGFiZWwpXFxdOiAqXFxuPyAqPD8oW15cXHM+XSspPj8oPzooPzogK1xcbj8gKnwgKlxcbiAqKSh0aXRsZSkpPyAqKD86XFxuK3wkKS8sXG4gIHRhYmxlOiBub29wLFxuICBsaGVhZGluZzogL14oW15cXG5dKylcXG4gKig9fC0pezIsfSAqKD86XFxuK3wkKS8sXG4gIHBhcmFncmFwaDogL14oW15cXG5dKyg/Olxcbj8oPyFocnxoZWFkaW5nfGxoZWFkaW5nfCB7MCwzfT58dGFnKVteXFxuXSspKykvLFxuICB0ZXh0OiAvXlteXFxuXSsvXG59O1xuXG5ibG9jay5fbGFiZWwgPSAvKD86XFxcXFtcXFtcXF1dfFteXFxbXFxdXSkrLztcbmJsb2NrLl90aXRsZSA9IC8oPzpcIig/OlxcXFxcInxbXlwiXXxcIlteXCJcXG5dKlwiKSpcInwnXFxuPyg/OlteJ1xcbl0rXFxuPykqJ3xcXChbXigpXSpcXCkpLztcbmJsb2NrLmRlZiA9IGVkaXQoYmxvY2suZGVmKVxuICAucmVwbGFjZSgnbGFiZWwnLCBibG9jay5fbGFiZWwpXG4gIC5yZXBsYWNlKCd0aXRsZScsIGJsb2NrLl90aXRsZSlcbiAgLmdldFJlZ2V4KCk7XG5cbmJsb2NrLmJ1bGxldCA9IC8oPzpbKistXXxcXGQrXFwuKS87XG5ibG9jay5pdGVtID0gL14oICopKGJ1bGwpIFteXFxuXSooPzpcXG4oPyFcXDFidWxsIClbXlxcbl0qKSovO1xuYmxvY2suaXRlbSA9IGVkaXQoYmxvY2suaXRlbSwgJ2dtJylcbiAgLnJlcGxhY2UoL2J1bGwvZywgYmxvY2suYnVsbGV0KVxuICAuZ2V0UmVnZXgoKTtcblxuYmxvY2subGlzdCA9IGVkaXQoYmxvY2subGlzdClcbiAgLnJlcGxhY2UoL2J1bGwvZywgYmxvY2suYnVsbGV0KVxuICAucmVwbGFjZSgnaHInLCAnXFxcXG4rKD89XFxcXDE/KD86KD86LSAqKXszLH18KD86XyAqKXszLH18KD86XFxcXCogKil7Myx9KSg/OlxcXFxuK3wkKSknKVxuICAucmVwbGFjZSgnZGVmJywgJ1xcXFxuKyg/PScgKyBibG9jay5kZWYuc291cmNlICsgJyknKVxuICAuZ2V0UmVnZXgoKTtcblxuYmxvY2suX3RhZyA9ICcoPyEoPzonXG4gICsgJ2F8ZW18c3Ryb25nfHNtYWxsfHN8Y2l0ZXxxfGRmbnxhYmJyfGRhdGF8dGltZXxjb2RlJ1xuICArICd8dmFyfHNhbXB8a2JkfHN1YnxzdXB8aXxifHV8bWFya3xydWJ5fHJ0fHJwfGJkaXxiZG8nXG4gICsgJ3xzcGFufGJyfHdicnxpbnN8ZGVsfGltZylcXFxcYilcXFxcdysoPyE6fFteXFxcXHdcXFxcc0BdKkApXFxcXGInO1xuXG5ibG9jay5odG1sID0gZWRpdChibG9jay5odG1sKVxuICAucmVwbGFjZSgnY29tbWVudCcsIC88IS0tW1xcc1xcU10qPy0tPi8pXG4gIC5yZXBsYWNlKCdjbG9zZWQnLCAvPCh0YWcpW1xcc1xcU10rPzxcXC9cXDE+LylcbiAgLnJlcGxhY2UoJ2Nsb3NpbmcnLCAvPHRhZyg/OlwiW15cIl0qXCJ8J1teJ10qJ3xcXHNbXidcIlxcLz5cXHNdKikqP1xcLz8+LylcbiAgLnJlcGxhY2UoL3RhZy9nLCBibG9jay5fdGFnKVxuICAuZ2V0UmVnZXgoKTtcblxuYmxvY2sucGFyYWdyYXBoID0gZWRpdChibG9jay5wYXJhZ3JhcGgpXG4gIC5yZXBsYWNlKCdocicsIGJsb2NrLmhyKVxuICAucmVwbGFjZSgnaGVhZGluZycsIGJsb2NrLmhlYWRpbmcpXG4gIC5yZXBsYWNlKCdsaGVhZGluZycsIGJsb2NrLmxoZWFkaW5nKVxuICAucmVwbGFjZSgndGFnJywgJzwnICsgYmxvY2suX3RhZylcbiAgLmdldFJlZ2V4KCk7XG5cbmJsb2NrLmJsb2NrcXVvdGUgPSBlZGl0KGJsb2NrLmJsb2NrcXVvdGUpXG4gIC5yZXBsYWNlKCdwYXJhZ3JhcGgnLCBibG9jay5wYXJhZ3JhcGgpXG4gIC5nZXRSZWdleCgpO1xuXG4vKipcbiAqIE5vcm1hbCBCbG9jayBHcmFtbWFyXG4gKi9cblxuYmxvY2subm9ybWFsID0gbWVyZ2Uoe30sIGJsb2NrKTtcblxuLyoqXG4gKiBHRk0gQmxvY2sgR3JhbW1hclxuICovXG5cbmJsb2NrLmdmbSA9IG1lcmdlKHt9LCBibG9jay5ub3JtYWwsIHtcbiAgZmVuY2VzOiAvXiAqKGB7Myx9fH57Myx9KVsgXFwuXSooXFxTKyk/ICpcXG4oW1xcc1xcU10qPylcXG4/ICpcXDEgKig/Olxcbit8JCkvLFxuICBwYXJhZ3JhcGg6IC9eLyxcbiAgaGVhZGluZzogL14gKigjezEsNn0pICsoW15cXG5dKz8pICojKiAqKD86XFxuK3wkKS9cbn0pO1xuXG5ibG9jay5nZm0ucGFyYWdyYXBoID0gZWRpdChibG9jay5wYXJhZ3JhcGgpXG4gIC5yZXBsYWNlKCcoPyEnLCAnKD8hJ1xuICAgICsgYmxvY2suZ2ZtLmZlbmNlcy5zb3VyY2UucmVwbGFjZSgnXFxcXDEnLCAnXFxcXDInKSArICd8J1xuICAgICsgYmxvY2subGlzdC5zb3VyY2UucmVwbGFjZSgnXFxcXDEnLCAnXFxcXDMnKSArICd8JylcbiAgLmdldFJlZ2V4KCk7XG5cbi8qKlxuICogR0ZNICsgVGFibGVzIEJsb2NrIEdyYW1tYXJcbiAqL1xuXG5ibG9jay50YWJsZXMgPSBtZXJnZSh7fSwgYmxvY2suZ2ZtLCB7XG4gIG5wdGFibGU6IC9eICooXFxTLipcXHwuKilcXG4gKihbLTpdKyAqXFx8Wy18IDpdKilcXG4oKD86LipcXHwuKig/OlxcbnwkKSkqKVxcbiovLFxuICB0YWJsZTogL14gKlxcfCguKylcXG4gKlxcfCggKlstOl0rWy18IDpdKilcXG4oKD86ICpcXHwuKig/OlxcbnwkKSkqKVxcbiovXG59KTtcblxuLyoqXG4gKiBCbG9jayBMZXhlclxuICovXG5cbmZ1bmN0aW9uIExleGVyKG9wdGlvbnMpIHtcbiAgdGhpcy50b2tlbnMgPSBbXTtcbiAgdGhpcy50b2tlbnMubGlua3MgPSB7fTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBtYXJrZWQuZGVmYXVsdHM7XG4gIHRoaXMucnVsZXMgPSBibG9jay5ub3JtYWw7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRhYmxlcykge1xuICAgICAgdGhpcy5ydWxlcyA9IGJsb2NrLnRhYmxlcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ydWxlcyA9IGJsb2NrLmdmbTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFeHBvc2UgQmxvY2sgUnVsZXNcbiAqL1xuXG5MZXhlci5ydWxlcyA9IGJsb2NrO1xuXG4vKipcbiAqIFN0YXRpYyBMZXggTWV0aG9kXG4gKi9cblxuTGV4ZXIubGV4ID0gZnVuY3Rpb24oc3JjLCBvcHRpb25zKSB7XG4gIHZhciBsZXhlciA9IG5ldyBMZXhlcihvcHRpb25zKTtcbiAgcmV0dXJuIGxleGVyLmxleChzcmMpO1xufTtcblxuLyoqXG4gKiBQcmVwcm9jZXNzaW5nXG4gKi9cblxuTGV4ZXIucHJvdG90eXBlLmxleCA9IGZ1bmN0aW9uKHNyYykge1xuICBzcmMgPSBzcmNcbiAgICAucmVwbGFjZSgvXFxyXFxufFxcci9nLCAnXFxuJylcbiAgICAucmVwbGFjZSgvXFx0L2csICcgICAgJylcbiAgICAucmVwbGFjZSgvXFx1MDBhMC9nLCAnICcpXG4gICAgLnJlcGxhY2UoL1xcdTI0MjQvZywgJ1xcbicpO1xuXG4gIHJldHVybiB0aGlzLnRva2VuKHNyYywgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIExleGluZ1xuICovXG5cbkxleGVyLnByb3RvdHlwZS50b2tlbiA9IGZ1bmN0aW9uKHNyYywgdG9wKSB7XG4gIHNyYyA9IHNyYy5yZXBsYWNlKC9eICskL2dtLCAnJyk7XG4gIHZhciBuZXh0LFxuICAgICAgbG9vc2UsXG4gICAgICBjYXAsXG4gICAgICBidWxsLFxuICAgICAgYixcbiAgICAgIGl0ZW0sXG4gICAgICBzcGFjZSxcbiAgICAgIGksXG4gICAgICB0YWcsXG4gICAgICBsLFxuICAgICAgaXNvcmRlcmVkO1xuXG4gIHdoaWxlIChzcmMpIHtcbiAgICAvLyBuZXdsaW5lXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMubmV3bGluZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBpZiAoY2FwWzBdLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ3NwYWNlJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb2RlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuY29kZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBjYXAgPSBjYXBbMF0ucmVwbGFjZSgvXiB7NH0vZ20sICcnKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgIHRleHQ6ICF0aGlzLm9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgICA/IGNhcC5yZXBsYWNlKC9cXG4rJC8sICcnKVxuICAgICAgICAgIDogY2FwXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGZlbmNlcyAoZ2ZtKVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmZlbmNlcy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICBsYW5nOiBjYXBbMl0sXG4gICAgICAgIHRleHQ6IGNhcFszXSB8fCAnJ1xuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBoZWFkaW5nXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuaGVhZGluZy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICBkZXB0aDogY2FwWzFdLmxlbmd0aCxcbiAgICAgICAgdGV4dDogY2FwWzJdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRhYmxlIG5vIGxlYWRpbmcgcGlwZSAoZ2ZtKVxuICAgIGlmICh0b3AgJiYgKGNhcCA9IHRoaXMucnVsZXMubnB0YWJsZS5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuXG4gICAgICBpdGVtID0ge1xuICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICBoZWFkZXI6IGNhcFsxXS5yZXBsYWNlKC9eICp8ICpcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgIGFsaWduOiBjYXBbMl0ucmVwbGFjZSgvXiAqfFxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgY2VsbHM6IGNhcFszXS5yZXBsYWNlKC9cXG4kLywgJycpLnNwbGl0KCdcXG4nKVxuICAgICAgfTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uYWxpZ24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKC9eICotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5jZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtLmNlbGxzW2ldID0gaXRlbS5jZWxsc1tpXS5zcGxpdCgvICpcXHwgKi8pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKGl0ZW0pO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBoclxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmhyLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnaHInXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGJsb2NrcXVvdGVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5ibG9ja3F1b3RlLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcblxuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdibG9ja3F1b3RlX3N0YXJ0J1xuICAgICAgfSk7XG5cbiAgICAgIGNhcCA9IGNhcFswXS5yZXBsYWNlKC9eICo+ID8vZ20sICcnKTtcblxuICAgICAgLy8gUGFzcyBgdG9wYCB0byBrZWVwIHRoZSBjdXJyZW50XG4gICAgICAvLyBcInRvcGxldmVsXCIgc3RhdGUuIFRoaXMgaXMgZXhhY3RseVxuICAgICAgLy8gaG93IG1hcmtkb3duLnBsIHdvcmtzLlxuICAgICAgdGhpcy50b2tlbihjYXAsIHRvcCk7XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnYmxvY2txdW90ZV9lbmQnXG4gICAgICB9KTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbGlzdFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmxpc3QuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgYnVsbCA9IGNhcFsyXTtcbiAgICAgIGlzb3JkZXJlZCA9IGJ1bGwubGVuZ3RoID4gMTtcblxuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdsaXN0X3N0YXJ0JyxcbiAgICAgICAgb3JkZXJlZDogaXNvcmRlcmVkLFxuICAgICAgICBzdGFydDogaXNvcmRlcmVkID8gK2J1bGwgOiAnJ1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEdldCBlYWNoIHRvcC1sZXZlbCBpdGVtLlxuICAgICAgY2FwID0gY2FwWzBdLm1hdGNoKHRoaXMucnVsZXMuaXRlbSk7XG5cbiAgICAgIG5leHQgPSBmYWxzZTtcbiAgICAgIGwgPSBjYXAubGVuZ3RoO1xuICAgICAgaSA9IDA7XG5cbiAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBjYXBbaV07XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBsaXN0IGl0ZW0ncyBidWxsZXRcbiAgICAgICAgLy8gc28gaXQgaXMgc2VlbiBhcyB0aGUgbmV4dCB0b2tlbi5cbiAgICAgICAgc3BhY2UgPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgaXRlbSA9IGl0ZW0ucmVwbGFjZSgvXiAqKFsqKy1dfFxcZCtcXC4pICsvLCAnJyk7XG5cbiAgICAgICAgLy8gT3V0ZGVudCB3aGF0ZXZlciB0aGVcbiAgICAgICAgLy8gbGlzdCBpdGVtIGNvbnRhaW5zLiBIYWNreS5cbiAgICAgICAgaWYgKH5pdGVtLmluZGV4T2YoJ1xcbiAnKSkge1xuICAgICAgICAgIHNwYWNlIC09IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgIGl0ZW0gPSAhdGhpcy5vcHRpb25zLnBlZGFudGljXG4gICAgICAgICAgICA/IGl0ZW0ucmVwbGFjZShuZXcgUmVnRXhwKCdeIHsxLCcgKyBzcGFjZSArICd9JywgJ2dtJyksICcnKVxuICAgICAgICAgICAgOiBpdGVtLnJlcGxhY2UoL14gezEsNH0vZ20sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIHRoZSBuZXh0IGxpc3QgaXRlbSBiZWxvbmdzIGhlcmUuXG4gICAgICAgIC8vIEJhY2twZWRhbCBpZiBpdCBkb2VzIG5vdCBiZWxvbmcgaW4gdGhpcyBsaXN0LlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNtYXJ0TGlzdHMgJiYgaSAhPT0gbCAtIDEpIHtcbiAgICAgICAgICBiID0gYmxvY2suYnVsbGV0LmV4ZWMoY2FwW2kgKyAxXSlbMF07XG4gICAgICAgICAgaWYgKGJ1bGwgIT09IGIgJiYgIShidWxsLmxlbmd0aCA+IDEgJiYgYi5sZW5ndGggPiAxKSkge1xuICAgICAgICAgICAgc3JjID0gY2FwLnNsaWNlKGkgKyAxKS5qb2luKCdcXG4nKSArIHNyYztcbiAgICAgICAgICAgIGkgPSBsIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciBpdGVtIGlzIGxvb3NlIG9yIG5vdC5cbiAgICAgICAgLy8gVXNlOiAvKF58XFxuKSg/ISApW15cXG5dK1xcblxcbig/IVxccyokKS9cbiAgICAgICAgLy8gZm9yIGRpc2NvdW50IGJlaGF2aW9yLlxuICAgICAgICBsb29zZSA9IG5leHQgfHwgL1xcblxcbig/IVxccyokKS8udGVzdChpdGVtKTtcbiAgICAgICAgaWYgKGkgIT09IGwgLSAxKSB7XG4gICAgICAgICAgbmV4dCA9IGl0ZW0uY2hhckF0KGl0ZW0ubGVuZ3RoIC0gMSkgPT09ICdcXG4nO1xuICAgICAgICAgIGlmICghbG9vc2UpIGxvb3NlID0gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IGxvb3NlXG4gICAgICAgICAgICA/ICdsb29zZV9pdGVtX3N0YXJ0J1xuICAgICAgICAgICAgOiAnbGlzdF9pdGVtX3N0YXJ0J1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZWN1cnNlLlxuICAgICAgICB0aGlzLnRva2VuKGl0ZW0sIGZhbHNlKTtcblxuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnbGlzdF9pdGVtX2VuZCdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnbGlzdF9lbmQnXG4gICAgICB9KTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaHRtbFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmh0bWwuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6IHRoaXMub3B0aW9ucy5zYW5pdGl6ZVxuICAgICAgICAgID8gJ3BhcmFncmFwaCdcbiAgICAgICAgICA6ICdodG1sJyxcbiAgICAgICAgcHJlOiAhdGhpcy5vcHRpb25zLnNhbml0aXplclxuICAgICAgICAgICYmIChjYXBbMV0gPT09ICdwcmUnIHx8IGNhcFsxXSA9PT0gJ3NjcmlwdCcgfHwgY2FwWzFdID09PSAnc3R5bGUnKSxcbiAgICAgICAgdGV4dDogY2FwWzBdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGRlZlxuICAgIGlmICh0b3AgJiYgKGNhcCA9IHRoaXMucnVsZXMuZGVmLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBpZiAoY2FwWzNdKSBjYXBbM10gPSBjYXBbM10uc3Vic3RyaW5nKDEsIGNhcFszXS5sZW5ndGggLSAxKTtcbiAgICAgIHRhZyA9IGNhcFsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKCF0aGlzLnRva2Vucy5saW5rc1t0YWddKSB7XG4gICAgICAgIHRoaXMudG9rZW5zLmxpbmtzW3RhZ10gPSB7XG4gICAgICAgICAgaHJlZjogY2FwWzJdLFxuICAgICAgICAgIHRpdGxlOiBjYXBbM11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRhYmxlIChnZm0pXG4gICAgaWYgKHRvcCAmJiAoY2FwID0gdGhpcy5ydWxlcy50YWJsZS5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuXG4gICAgICBpdGVtID0ge1xuICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICBoZWFkZXI6IGNhcFsxXS5yZXBsYWNlKC9eICp8ICpcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgIGFsaWduOiBjYXBbMl0ucmVwbGFjZSgvXiAqfFxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgY2VsbHM6IGNhcFszXS5yZXBsYWNlKC8oPzogKlxcfCAqKT9cXG4kLywgJycpLnNwbGl0KCdcXG4nKVxuICAgICAgfTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uYWxpZ24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKC9eICotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5jZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtLmNlbGxzW2ldID0gaXRlbS5jZWxsc1tpXVxuICAgICAgICAgIC5yZXBsYWNlKC9eICpcXHwgKnwgKlxcfCAqJC9nLCAnJylcbiAgICAgICAgICAuc3BsaXQoLyAqXFx8ICovKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b2tlbnMucHVzaChpdGVtKTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbGhlYWRpbmdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5saGVhZGluZy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICBkZXB0aDogY2FwWzJdID09PSAnPScgPyAxIDogMixcbiAgICAgICAgdGV4dDogY2FwWzFdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRvcC1sZXZlbCBwYXJhZ3JhcGhcbiAgICBpZiAodG9wICYmIChjYXAgPSB0aGlzLnJ1bGVzLnBhcmFncmFwaC5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgICAgICB0ZXh0OiBjYXBbMV0uY2hhckF0KGNhcFsxXS5sZW5ndGggLSAxKSA9PT0gJ1xcbidcbiAgICAgICAgICA/IGNhcFsxXS5zbGljZSgwLCAtMSlcbiAgICAgICAgICA6IGNhcFsxXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0ZXh0XG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMudGV4dC5leGVjKHNyYykpIHtcbiAgICAgIC8vIFRvcC1sZXZlbCBzaG91bGQgbmV2ZXIgcmVhY2ggaGVyZS5cbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICB0ZXh0OiBjYXBbMF1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHNyYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXMudG9rZW5zO1xufTtcblxuLyoqXG4gKiBJbmxpbmUtTGV2ZWwgR3JhbW1hclxuICovXG5cbnZhciBpbmxpbmUgPSB7XG4gIGVzY2FwZTogL15cXFxcKFtcXFxcYCp7fVxcW1xcXSgpIytcXC0uIV8+XSkvLFxuICBhdXRvbGluazogL148KHNjaGVtZTpbXlxcc1xceDAwLVxceDFmPD5dKnxlbWFpbCk+LyxcbiAgdXJsOiBub29wLFxuICB0YWc6IC9ePCEtLVtcXHNcXFNdKj8tLT58XjxcXC8/W2EtekEtWjAtOVxcLV0rKD86XCJbXlwiXSpcInwnW14nXSonfFxcc1tePCdcIj5cXC9cXHNdKikqP1xcLz8+LyxcbiAgbGluazogL14hP1xcWyhpbnNpZGUpXFxdXFwoaHJlZlxcKS8sXG4gIHJlZmxpbms6IC9eIT9cXFsoaW5zaWRlKVxcXVxccypcXFsoW15cXF1dKilcXF0vLFxuICBub2xpbms6IC9eIT9cXFsoKD86XFxbW15cXFtcXF1dKlxcXXxcXFxcW1xcW1xcXV18W15cXFtcXF1dKSopXFxdLyxcbiAgc3Ryb25nOiAvXl9fKFtcXHNcXFNdKz8pX18oPyFfKXxeXFwqXFwqKFtcXHNcXFNdKz8pXFwqXFwqKD8hXFwqKS8sXG4gIGVtOiAvXl8oW15cXHNfXSg/OlteX118X18pKz9bXlxcc19dKV9cXGJ8XlxcKigoPzpcXCpcXCp8W14qXSkrPylcXCooPyFcXCopLyxcbiAgY29kZTogL14oYCspXFxzKihbXFxzXFxTXSo/W15gXT8pXFxzKlxcMSg/IWApLyxcbiAgYnI6IC9eIHsyLH1cXG4oPyFcXHMqJCkvLFxuICBkZWw6IG5vb3AsXG4gIHRleHQ6IC9eW1xcc1xcU10rPyg/PVtcXFxcPCFcXFtgKl18XFxiX3wgezIsfVxcbnwkKS9cbn07XG5cbmlubGluZS5fc2NoZW1lID0gL1thLXpBLVpdW2EtekEtWjAtOSsuLV17MSwzMX0vO1xuaW5saW5lLl9lbWFpbCA9IC9bYS16QS1aMC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dKyhAKVthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykrKD8hWy1fXSkvO1xuXG5pbmxpbmUuYXV0b2xpbmsgPSBlZGl0KGlubGluZS5hdXRvbGluaylcbiAgLnJlcGxhY2UoJ3NjaGVtZScsIGlubGluZS5fc2NoZW1lKVxuICAucmVwbGFjZSgnZW1haWwnLCBpbmxpbmUuX2VtYWlsKVxuICAuZ2V0UmVnZXgoKVxuXG5pbmxpbmUuX2luc2lkZSA9IC8oPzpcXFtbXlxcW1xcXV0qXFxdfFxcXFxbXFxbXFxdXXxbXlxcW1xcXV18XFxdKD89W15cXFtdKlxcXSkpKi87XG5pbmxpbmUuX2hyZWYgPSAvXFxzKjw/KFtcXHNcXFNdKj8pPj8oPzpcXHMrWydcIl0oW1xcc1xcU10qPylbJ1wiXSk/XFxzKi87XG5cbmlubGluZS5saW5rID0gZWRpdChpbmxpbmUubGluaylcbiAgLnJlcGxhY2UoJ2luc2lkZScsIGlubGluZS5faW5zaWRlKVxuICAucmVwbGFjZSgnaHJlZicsIGlubGluZS5faHJlZilcbiAgLmdldFJlZ2V4KCk7XG5cbmlubGluZS5yZWZsaW5rID0gZWRpdChpbmxpbmUucmVmbGluaylcbiAgLnJlcGxhY2UoJ2luc2lkZScsIGlubGluZS5faW5zaWRlKVxuICAuZ2V0UmVnZXgoKTtcblxuLyoqXG4gKiBOb3JtYWwgSW5saW5lIEdyYW1tYXJcbiAqL1xuXG5pbmxpbmUubm9ybWFsID0gbWVyZ2Uoe30sIGlubGluZSk7XG5cbi8qKlxuICogUGVkYW50aWMgSW5saW5lIEdyYW1tYXJcbiAqL1xuXG5pbmxpbmUucGVkYW50aWMgPSBtZXJnZSh7fSwgaW5saW5lLm5vcm1hbCwge1xuICBzdHJvbmc6IC9eX18oPz1cXFMpKFtcXHNcXFNdKj9cXFMpX18oPyFfKXxeXFwqXFwqKD89XFxTKShbXFxzXFxTXSo/XFxTKVxcKlxcKig/IVxcKikvLFxuICBlbTogL15fKD89XFxTKShbXFxzXFxTXSo/XFxTKV8oPyFfKXxeXFwqKD89XFxTKShbXFxzXFxTXSo/XFxTKVxcKig/IVxcKikvXG59KTtcblxuLyoqXG4gKiBHRk0gSW5saW5lIEdyYW1tYXJcbiAqL1xuXG5pbmxpbmUuZ2ZtID0gbWVyZ2Uoe30sIGlubGluZS5ub3JtYWwsIHtcbiAgZXNjYXBlOiBlZGl0KGlubGluZS5lc2NhcGUpLnJlcGxhY2UoJ10pJywgJ358XSknKS5nZXRSZWdleCgpLFxuICB1cmw6IGVkaXQoL14oKD86ZnRwfGh0dHBzPyk6XFwvXFwvfHd3d1xcLikoPzpbYS16QS1aMC05XFwtXStcXC4/KStbXlxcczxdKnxeZW1haWwvKVxuICAgIC5yZXBsYWNlKCdlbWFpbCcsIGlubGluZS5fZW1haWwpXG4gICAgLmdldFJlZ2V4KCksXG4gIF9iYWNrcGVkYWw6IC8oPzpbXj8hLiw6OypffigpJl0rfFxcKFteKV0qXFwpfCYoPyFbYS16QS1aMC05XSs7JCl8Wz8hLiw6OypffildKyg/ISQpKSsvLFxuICBkZWw6IC9efn4oPz1cXFMpKFtcXHNcXFNdKj9cXFMpfn4vLFxuICB0ZXh0OiBlZGl0KGlubGluZS50ZXh0KVxuICAgIC5yZXBsYWNlKCddfCcsICd+XXwnKVxuICAgIC5yZXBsYWNlKCd8JywgJ3xodHRwcz86Ly98ZnRwOi8vfHd3d1xcXFwufFthLXpBLVowLTkuISMkJSZcXCcqKy89P15fYHtcXFxcfH1+LV0rQHwnKVxuICAgIC5nZXRSZWdleCgpXG59KTtcblxuLyoqXG4gKiBHRk0gKyBMaW5lIEJyZWFrcyBJbmxpbmUgR3JhbW1hclxuICovXG5cbmlubGluZS5icmVha3MgPSBtZXJnZSh7fSwgaW5saW5lLmdmbSwge1xuICBicjogZWRpdChpbmxpbmUuYnIpLnJlcGxhY2UoJ3syLH0nLCAnKicpLmdldFJlZ2V4KCksXG4gIHRleHQ6IGVkaXQoaW5saW5lLmdmbS50ZXh0KS5yZXBsYWNlKCd7Mix9JywgJyonKS5nZXRSZWdleCgpXG59KTtcblxuLyoqXG4gKiBJbmxpbmUgTGV4ZXIgJiBDb21waWxlclxuICovXG5cbmZ1bmN0aW9uIElubGluZUxleGVyKGxpbmtzLCBvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgbWFya2VkLmRlZmF1bHRzO1xuICB0aGlzLmxpbmtzID0gbGlua3M7XG4gIHRoaXMucnVsZXMgPSBpbmxpbmUubm9ybWFsO1xuICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IG5ldyBSZW5kZXJlcigpO1xuICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgaWYgKCF0aGlzLmxpbmtzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUb2tlbnMgYXJyYXkgcmVxdWlyZXMgYSBgbGlua3NgIHByb3BlcnR5LicpO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmJyZWFrcykge1xuICAgICAgdGhpcy5ydWxlcyA9IGlubGluZS5icmVha3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucnVsZXMgPSBpbmxpbmUuZ2ZtO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICB0aGlzLnJ1bGVzID0gaW5saW5lLnBlZGFudGljO1xuICB9XG59XG5cbi8qKlxuICogRXhwb3NlIElubGluZSBSdWxlc1xuICovXG5cbklubGluZUxleGVyLnJ1bGVzID0gaW5saW5lO1xuXG4vKipcbiAqIFN0YXRpYyBMZXhpbmcvQ29tcGlsaW5nIE1ldGhvZFxuICovXG5cbklubGluZUxleGVyLm91dHB1dCA9IGZ1bmN0aW9uKHNyYywgbGlua3MsIG9wdGlvbnMpIHtcbiAgdmFyIGlubGluZSA9IG5ldyBJbmxpbmVMZXhlcihsaW5rcywgb3B0aW9ucyk7XG4gIHJldHVybiBpbmxpbmUub3V0cHV0KHNyYyk7XG59O1xuXG4vKipcbiAqIExleGluZy9Db21waWxpbmdcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUub3V0cHV0ID0gZnVuY3Rpb24oc3JjKSB7XG4gIHZhciBvdXQgPSAnJyxcbiAgICAgIGxpbmssXG4gICAgICB0ZXh0LFxuICAgICAgaHJlZixcbiAgICAgIGNhcDtcblxuICB3aGlsZSAoc3JjKSB7XG4gICAgLy8gZXNjYXBlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZXNjYXBlLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSBjYXBbMV07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBhdXRvbGlua1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmF1dG9saW5rLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIGlmIChjYXBbMl0gPT09ICdAJykge1xuICAgICAgICB0ZXh0ID0gZXNjYXBlKHRoaXMubWFuZ2xlKGNhcFsxXSkpO1xuICAgICAgICBocmVmID0gJ21haWx0bzonICsgdGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBlc2NhcGUoY2FwWzFdKTtcbiAgICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICB9XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5saW5rKGhyZWYsIG51bGwsIHRleHQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdXJsIChnZm0pXG4gICAgaWYgKCF0aGlzLmluTGluayAmJiAoY2FwID0gdGhpcy5ydWxlcy51cmwuZXhlYyhzcmMpKSkge1xuICAgICAgY2FwWzBdID0gdGhpcy5ydWxlcy5fYmFja3BlZGFsLmV4ZWMoY2FwWzBdKVswXTtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMF0pO1xuICAgICAgICBocmVmID0gJ21haWx0bzonICsgdGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBlc2NhcGUoY2FwWzBdKTtcbiAgICAgICAgaWYgKGNhcFsxXSA9PT0gJ3d3dy4nKSB7XG4gICAgICAgICAgaHJlZiA9ICdodHRwOi8vJyArIHRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmxpbmsoaHJlZiwgbnVsbCwgdGV4dCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0YWdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy50YWcuZXhlYyhzcmMpKSB7XG4gICAgICBpZiAoIXRoaXMuaW5MaW5rICYmIC9ePGEgL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMuaW5MaW5rID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pbkxpbmsgJiYgL148XFwvYT4vaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgdGhpcy5pbkxpbmsgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5vcHRpb25zLnNhbml0aXplXG4gICAgICAgID8gdGhpcy5vcHRpb25zLnNhbml0aXplclxuICAgICAgICAgID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pXG4gICAgICAgICAgOiBlc2NhcGUoY2FwWzBdKVxuICAgICAgICA6IGNhcFswXVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbGlua1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmxpbmsuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy5pbkxpbmsgPSB0cnVlO1xuICAgICAgb3V0ICs9IHRoaXMub3V0cHV0TGluayhjYXAsIHtcbiAgICAgICAgaHJlZjogY2FwWzJdLFxuICAgICAgICB0aXRsZTogY2FwWzNdXG4gICAgICB9KTtcbiAgICAgIHRoaXMuaW5MaW5rID0gZmFsc2U7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyByZWZsaW5rLCBub2xpbmtcbiAgICBpZiAoKGNhcCA9IHRoaXMucnVsZXMucmVmbGluay5leGVjKHNyYykpXG4gICAgICAgIHx8IChjYXAgPSB0aGlzLnJ1bGVzLm5vbGluay5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgbGluayA9IChjYXBbMl0gfHwgY2FwWzFdKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgICBsaW5rID0gdGhpcy5saW5rc1tsaW5rLnRvTG93ZXJDYXNlKCldO1xuICAgICAgaWYgKCFsaW5rIHx8ICFsaW5rLmhyZWYpIHtcbiAgICAgICAgb3V0ICs9IGNhcFswXS5jaGFyQXQoMCk7XG4gICAgICAgIHNyYyA9IGNhcFswXS5zdWJzdHJpbmcoMSkgKyBzcmM7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5pbkxpbmsgPSB0cnVlO1xuICAgICAgb3V0ICs9IHRoaXMub3V0cHV0TGluayhjYXAsIGxpbmspO1xuICAgICAgdGhpcy5pbkxpbmsgPSBmYWxzZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHN0cm9uZ1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnN0cm9uZy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5zdHJvbmcodGhpcy5vdXRwdXQoY2FwWzJdIHx8IGNhcFsxXSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZW1cbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5lbS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5lbSh0aGlzLm91dHB1dChjYXBbMl0gfHwgY2FwWzFdKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBjb2RlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuY29kZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5jb2Rlc3Bhbihlc2NhcGUoY2FwWzJdLnRyaW0oKSwgdHJ1ZSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gYnJcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5ici5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5icigpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZGVsIChnZm0pXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuZGVsLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmRlbCh0aGlzLm91dHB1dChjYXBbMV0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRleHRcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy50ZXh0LmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnRleHQoZXNjYXBlKHRoaXMuc21hcnR5cGFudHMoY2FwWzBdKSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHNyYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29tcGlsZSBMaW5rXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLm91dHB1dExpbmsgPSBmdW5jdGlvbihjYXAsIGxpbmspIHtcbiAgdmFyIGhyZWYgPSBlc2NhcGUobGluay5ocmVmKSxcbiAgICAgIHRpdGxlID0gbGluay50aXRsZSA/IGVzY2FwZShsaW5rLnRpdGxlKSA6IG51bGw7XG5cbiAgcmV0dXJuIGNhcFswXS5jaGFyQXQoMCkgIT09ICchJ1xuICAgID8gdGhpcy5yZW5kZXJlci5saW5rKGhyZWYsIHRpdGxlLCB0aGlzLm91dHB1dChjYXBbMV0pKVxuICAgIDogdGhpcy5yZW5kZXJlci5pbWFnZShocmVmLCB0aXRsZSwgZXNjYXBlKGNhcFsxXSkpO1xufTtcblxuLyoqXG4gKiBTbWFydHlwYW50cyBUcmFuc2Zvcm1hdGlvbnNcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUuc21hcnR5cGFudHMgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIGlmICghdGhpcy5vcHRpb25zLnNtYXJ0eXBhbnRzKSByZXR1cm4gdGV4dDtcbiAgcmV0dXJuIHRleHRcbiAgICAvLyBlbS1kYXNoZXNcbiAgICAucmVwbGFjZSgvLS0tL2csICdcXHUyMDE0JylcbiAgICAvLyBlbi1kYXNoZXNcbiAgICAucmVwbGFjZSgvLS0vZywgJ1xcdTIwMTMnKVxuICAgIC8vIG9wZW5pbmcgc2luZ2xlc1xuICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcIlxcc10pJy9nLCAnJDFcXHUyMDE4JylcbiAgICAvLyBjbG9zaW5nIHNpbmdsZXMgJiBhcG9zdHJvcGhlc1xuICAgIC5yZXBsYWNlKC8nL2csICdcXHUyMDE5JylcbiAgICAvLyBvcGVuaW5nIGRvdWJsZXNcbiAgICAucmVwbGFjZSgvKF58Wy1cXHUyMDE0LyhcXFt7XFx1MjAxOFxcc10pXCIvZywgJyQxXFx1MjAxYycpXG4gICAgLy8gY2xvc2luZyBkb3VibGVzXG4gICAgLnJlcGxhY2UoL1wiL2csICdcXHUyMDFkJylcbiAgICAvLyBlbGxpcHNlc1xuICAgIC5yZXBsYWNlKC9cXC57M30vZywgJ1xcdTIwMjYnKTtcbn07XG5cbi8qKlxuICogTWFuZ2xlIExpbmtzXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLm1hbmdsZSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgaWYgKCF0aGlzLm9wdGlvbnMubWFuZ2xlKSByZXR1cm4gdGV4dDtcbiAgdmFyIG91dCA9ICcnLFxuICAgICAgbCA9IHRleHQubGVuZ3RoLFxuICAgICAgaSA9IDAsXG4gICAgICBjaDtcblxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGNoID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICBjaCA9ICd4JyArIGNoLnRvU3RyaW5nKDE2KTtcbiAgICB9XG4gICAgb3V0ICs9ICcmIycgKyBjaCArICc7JztcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJlbmRlcmVyXG4gKi9cblxuZnVuY3Rpb24gUmVuZGVyZXIob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xufVxuXG5SZW5kZXJlci5wcm90b3R5cGUuY29kZSA9IGZ1bmN0aW9uKGNvZGUsIGxhbmcsIGVzY2FwZWQpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICB2YXIgb3V0ID0gdGhpcy5vcHRpb25zLmhpZ2hsaWdodChjb2RlLCBsYW5nKTtcbiAgICBpZiAob3V0ICE9IG51bGwgJiYgb3V0ICE9PSBjb2RlKSB7XG4gICAgICBlc2NhcGVkID0gdHJ1ZTtcbiAgICAgIGNvZGUgPSBvdXQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFsYW5nKSB7XG4gICAgcmV0dXJuICc8cHJlPjxjb2RlPidcbiAgICAgICsgKGVzY2FwZWQgPyBjb2RlIDogZXNjYXBlKGNvZGUsIHRydWUpKVxuICAgICAgKyAnXFxuPC9jb2RlPjwvcHJlPic7XG4gIH1cblxuICByZXR1cm4gJzxwcmU+PGNvZGUgY2xhc3M9XCInXG4gICAgKyB0aGlzLm9wdGlvbnMubGFuZ1ByZWZpeFxuICAgICsgZXNjYXBlKGxhbmcsIHRydWUpXG4gICAgKyAnXCI+J1xuICAgICsgKGVzY2FwZWQgPyBjb2RlIDogZXNjYXBlKGNvZGUsIHRydWUpKVxuICAgICsgJ1xcbjwvY29kZT48L3ByZT5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmJsb2NrcXVvdGUgPSBmdW5jdGlvbihxdW90ZSkge1xuICByZXR1cm4gJzxibG9ja3F1b3RlPlxcbicgKyBxdW90ZSArICc8L2Jsb2NrcXVvdGU+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5odG1sID0gZnVuY3Rpb24oaHRtbCkge1xuICByZXR1cm4gaHRtbDtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5oZWFkaW5nID0gZnVuY3Rpb24odGV4dCwgbGV2ZWwsIHJhdykge1xuICByZXR1cm4gJzxoJ1xuICAgICsgbGV2ZWxcbiAgICArICcgaWQ9XCInXG4gICAgKyB0aGlzLm9wdGlvbnMuaGVhZGVyUHJlZml4XG4gICAgKyByYXcudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bXlxcd10rL2csICctJylcbiAgICArICdcIj4nXG4gICAgKyB0ZXh0XG4gICAgKyAnPC9oJ1xuICAgICsgbGV2ZWxcbiAgICArICc+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5ociA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5vcHRpb25zLnhodG1sID8gJzxoci8+XFxuJyA6ICc8aHI+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24oYm9keSwgb3JkZXJlZCwgc3RhcnQpIHtcbiAgdmFyIHR5cGUgPSBvcmRlcmVkID8gJ29sJyA6ICd1bCcsXG4gICAgICBzdGFydGF0dCA9IChvcmRlcmVkICYmIHN0YXJ0ICE9PSAxKSA/ICgnIHN0YXJ0PVwiJyArIHN0YXJ0ICsgJ1wiJykgOiAnJztcbiAgcmV0dXJuICc8JyArIHR5cGUgKyBzdGFydGF0dCArICc+XFxuJyArIGJvZHkgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5saXN0aXRlbSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8bGk+JyArIHRleHQgKyAnPC9saT5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnBhcmFncmFwaCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8cD4nICsgdGV4dCArICc8L3A+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50YWJsZSA9IGZ1bmN0aW9uKGhlYWRlciwgYm9keSkge1xuICByZXR1cm4gJzx0YWJsZT5cXG4nXG4gICAgKyAnPHRoZWFkPlxcbidcbiAgICArIGhlYWRlclxuICAgICsgJzwvdGhlYWQ+XFxuJ1xuICAgICsgJzx0Ym9keT5cXG4nXG4gICAgKyBib2R5XG4gICAgKyAnPC90Ym9keT5cXG4nXG4gICAgKyAnPC90YWJsZT5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRhYmxlcm93ID0gZnVuY3Rpb24oY29udGVudCkge1xuICByZXR1cm4gJzx0cj5cXG4nICsgY29udGVudCArICc8L3RyPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUudGFibGVjZWxsID0gZnVuY3Rpb24oY29udGVudCwgZmxhZ3MpIHtcbiAgdmFyIHR5cGUgPSBmbGFncy5oZWFkZXIgPyAndGgnIDogJ3RkJztcbiAgdmFyIHRhZyA9IGZsYWdzLmFsaWduXG4gICAgPyAnPCcgKyB0eXBlICsgJyBzdHlsZT1cInRleHQtYWxpZ246JyArIGZsYWdzLmFsaWduICsgJ1wiPidcbiAgICA6ICc8JyArIHR5cGUgKyAnPic7XG4gIHJldHVybiB0YWcgKyBjb250ZW50ICsgJzwvJyArIHR5cGUgKyAnPlxcbic7XG59O1xuXG4vLyBzcGFuIGxldmVsIHJlbmRlcmVyXG5SZW5kZXJlci5wcm90b3R5cGUuc3Ryb25nID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxzdHJvbmc+JyArIHRleHQgKyAnPC9zdHJvbmc+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5lbSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8ZW0+JyArIHRleHQgKyAnPC9lbT4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmNvZGVzcGFuID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxjb2RlPicgKyB0ZXh0ICsgJzwvY29kZT4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmJyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm9wdGlvbnMueGh0bWwgPyAnPGJyLz4nIDogJzxicj4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuICc8ZGVsPicgKyB0ZXh0ICsgJzwvZGVsPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUubGluayA9IGZ1bmN0aW9uKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuc2FuaXRpemUpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHByb3QgPSBkZWNvZGVVUklDb21wb25lbnQodW5lc2NhcGUoaHJlZikpXG4gICAgICAgIC5yZXBsYWNlKC9bXlxcdzpdL2csICcnKVxuICAgICAgICAudG9Mb3dlckNhc2UoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgaWYgKHByb3QuaW5kZXhPZignamF2YXNjcmlwdDonKSA9PT0gMCB8fCBwcm90LmluZGV4T2YoJ3Zic2NyaXB0OicpID09PSAwIHx8IHByb3QuaW5kZXhPZignZGF0YTonKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMuYmFzZVVybCAmJiAhb3JpZ2luSW5kZXBlbmRlbnRVcmwudGVzdChocmVmKSkge1xuICAgIGhyZWYgPSByZXNvbHZlVXJsKHRoaXMub3B0aW9ucy5iYXNlVXJsLCBocmVmKTtcbiAgfVxuICB2YXIgb3V0ID0gJzxhIGhyZWY9XCInICsgaHJlZiArICdcIic7XG4gIGlmICh0aXRsZSkge1xuICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgfVxuICBvdXQgKz0gJz4nICsgdGV4dCArICc8L2E+JztcbiAgcmV0dXJuIG91dDtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5pbWFnZSA9IGZ1bmN0aW9uKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuYmFzZVVybCAmJiAhb3JpZ2luSW5kZXBlbmRlbnRVcmwudGVzdChocmVmKSkge1xuICAgIGhyZWYgPSByZXNvbHZlVXJsKHRoaXMub3B0aW9ucy5iYXNlVXJsLCBocmVmKTtcbiAgfVxuICB2YXIgb3V0ID0gJzxpbWcgc3JjPVwiJyArIGhyZWYgKyAnXCIgYWx0PVwiJyArIHRleHQgKyAnXCInO1xuICBpZiAodGl0bGUpIHtcbiAgICBvdXQgKz0gJyB0aXRsZT1cIicgKyB0aXRsZSArICdcIic7XG4gIH1cbiAgb3V0ICs9IHRoaXMub3B0aW9ucy54aHRtbCA/ICcvPicgOiAnPic7XG4gIHJldHVybiBvdXQ7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuIHRleHQ7XG59O1xuXG4vKipcbiAqIFRleHRSZW5kZXJlclxuICogcmV0dXJucyBvbmx5IHRoZSB0ZXh0dWFsIHBhcnQgb2YgdGhlIHRva2VuXG4gKi9cblxuZnVuY3Rpb24gVGV4dFJlbmRlcmVyKCkge31cblxuLy8gbm8gbmVlZCBmb3IgYmxvY2sgbGV2ZWwgcmVuZGVyZXJzXG5cblRleHRSZW5kZXJlci5wcm90b3R5cGUuc3Ryb25nID1cblRleHRSZW5kZXJlci5wcm90b3R5cGUuZW0gPVxuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5jb2Rlc3BhbiA9XG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLmRlbCA9XG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICByZXR1cm4gdGV4dDtcbn1cblxuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5saW5rID1cblRleHRSZW5kZXJlci5wcm90b3R5cGUuaW1hZ2UgPSBmdW5jdGlvbihocmVmLCB0aXRsZSwgdGV4dCkge1xuICByZXR1cm4gJycgKyB0ZXh0O1xufVxuXG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLmJyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBQYXJzaW5nICYgQ29tcGlsaW5nXG4gKi9cblxuZnVuY3Rpb24gUGFyc2VyKG9wdGlvbnMpIHtcbiAgdGhpcy50b2tlbnMgPSBbXTtcbiAgdGhpcy50b2tlbiA9IG51bGw7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgbWFya2VkLmRlZmF1bHRzO1xuICB0aGlzLm9wdGlvbnMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgbmV3IFJlbmRlcmVyKCk7XG4gIHRoaXMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXI7XG4gIHRoaXMucmVuZGVyZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbn1cblxuLyoqXG4gKiBTdGF0aWMgUGFyc2UgTWV0aG9kXG4gKi9cblxuUGFyc2VyLnBhcnNlID0gZnVuY3Rpb24oc3JjLCBvcHRpb25zKSB7XG4gIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICByZXR1cm4gcGFyc2VyLnBhcnNlKHNyYyk7XG59O1xuXG4vKipcbiAqIFBhcnNlIExvb3BcbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oc3JjKSB7XG4gIHRoaXMuaW5saW5lID0gbmV3IElubGluZUxleGVyKHNyYy5saW5rcywgdGhpcy5vcHRpb25zKTtcbiAgLy8gdXNlIGFuIElubGluZUxleGVyIHdpdGggYSBUZXh0UmVuZGVyZXIgdG8gZXh0cmFjdCBwdXJlIHRleHRcbiAgdGhpcy5pbmxpbmVUZXh0ID0gbmV3IElubGluZUxleGVyKFxuICAgIHNyYy5saW5rcyxcbiAgICBtZXJnZSh7fSwgdGhpcy5vcHRpb25zLCB7cmVuZGVyZXI6IG5ldyBUZXh0UmVuZGVyZXIoKX0pXG4gICk7XG4gIHRoaXMudG9rZW5zID0gc3JjLnJldmVyc2UoKTtcblxuICB2YXIgb3V0ID0gJyc7XG4gIHdoaWxlICh0aGlzLm5leHQoKSkge1xuICAgIG91dCArPSB0aGlzLnRvaygpO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTmV4dCBUb2tlblxuICovXG5cblBhcnNlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b2tlbiA9IHRoaXMudG9rZW5zLnBvcCgpO1xufTtcblxuLyoqXG4gKiBQcmV2aWV3IE5leHQgVG9rZW5cbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMudG9rZW5zLmxlbmd0aCAtIDFdIHx8IDA7XG59O1xuXG4vKipcbiAqIFBhcnNlIFRleHQgVG9rZW5zXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRleHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJvZHkgPSB0aGlzLnRva2VuLnRleHQ7XG5cbiAgd2hpbGUgKHRoaXMucGVlaygpLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIGJvZHkgKz0gJ1xcbicgKyB0aGlzLm5leHQoKS50ZXh0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuaW5saW5lLm91dHB1dChib2R5KTtcbn07XG5cbi8qKlxuICogUGFyc2UgQ3VycmVudCBUb2tlblxuICovXG5cblBhcnNlci5wcm90b3R5cGUudG9rID0gZnVuY3Rpb24oKSB7XG4gIHN3aXRjaCAodGhpcy50b2tlbi50eXBlKSB7XG4gICAgY2FzZSAnc3BhY2UnOiB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNhc2UgJ2hyJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuaHIoKTtcbiAgICB9XG4gICAgY2FzZSAnaGVhZGluZyc6IHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmhlYWRpbmcoXG4gICAgICAgIHRoaXMuaW5saW5lLm91dHB1dCh0aGlzLnRva2VuLnRleHQpLFxuICAgICAgICB0aGlzLnRva2VuLmRlcHRoLFxuICAgICAgICB1bmVzY2FwZSh0aGlzLmlubGluZVRleHQub3V0cHV0KHRoaXMudG9rZW4udGV4dCkpKTtcbiAgICB9XG4gICAgY2FzZSAnY29kZSc6IHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmNvZGUodGhpcy50b2tlbi50ZXh0LFxuICAgICAgICB0aGlzLnRva2VuLmxhbmcsXG4gICAgICAgIHRoaXMudG9rZW4uZXNjYXBlZCk7XG4gICAgfVxuICAgIGNhc2UgJ3RhYmxlJzoge1xuICAgICAgdmFyIGhlYWRlciA9ICcnLFxuICAgICAgICAgIGJvZHkgPSAnJyxcbiAgICAgICAgICBpLFxuICAgICAgICAgIHJvdyxcbiAgICAgICAgICBjZWxsLFxuICAgICAgICAgIGo7XG5cbiAgICAgIC8vIGhlYWRlclxuICAgICAgY2VsbCA9ICcnO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMudG9rZW4uaGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwoXG4gICAgICAgICAgdGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4uaGVhZGVyW2ldKSxcbiAgICAgICAgICB7IGhlYWRlcjogdHJ1ZSwgYWxpZ246IHRoaXMudG9rZW4uYWxpZ25baV0gfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaGVhZGVyICs9IHRoaXMucmVuZGVyZXIudGFibGVyb3coY2VsbCk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnRva2VuLmNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJvdyA9IHRoaXMudG9rZW4uY2VsbHNbaV07XG5cbiAgICAgICAgY2VsbCA9ICcnO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgcm93Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY2VsbCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlY2VsbChcbiAgICAgICAgICAgIHRoaXMuaW5saW5lLm91dHB1dChyb3dbal0pLFxuICAgICAgICAgICAgeyBoZWFkZXI6IGZhbHNlLCBhbGlnbjogdGhpcy50b2tlbi5hbGlnbltqXSB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnRhYmxlKGhlYWRlciwgYm9keSk7XG4gICAgfVxuICAgIGNhc2UgJ2Jsb2NrcXVvdGVfc3RhcnQnOiB7XG4gICAgICBib2R5ID0gJyc7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnYmxvY2txdW90ZV9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuYmxvY2txdW90ZShib2R5KTtcbiAgICB9XG4gICAgY2FzZSAnbGlzdF9zdGFydCc6IHtcbiAgICAgIGJvZHkgPSAnJztcbiAgICAgIHZhciBvcmRlcmVkID0gdGhpcy50b2tlbi5vcmRlcmVkLFxuICAgICAgICAgIHN0YXJ0ID0gdGhpcy50b2tlbi5zdGFydDtcblxuICAgICAgd2hpbGUgKHRoaXMubmV4dCgpLnR5cGUgIT09ICdsaXN0X2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0aGlzLnRvaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5saXN0KGJvZHksIG9yZGVyZWQsIHN0YXJ0KTtcbiAgICB9XG4gICAgY2FzZSAnbGlzdF9pdGVtX3N0YXJ0Jzoge1xuICAgICAgYm9keSA9ICcnO1xuXG4gICAgICB3aGlsZSAodGhpcy5uZXh0KCkudHlwZSAhPT0gJ2xpc3RfaXRlbV9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2tlbi50eXBlID09PSAndGV4dCdcbiAgICAgICAgICA/IHRoaXMucGFyc2VUZXh0KClcbiAgICAgICAgICA6IHRoaXMudG9rKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmxpc3RpdGVtKGJvZHkpO1xuICAgIH1cbiAgICBjYXNlICdsb29zZV9pdGVtX3N0YXJ0Jzoge1xuICAgICAgYm9keSA9ICcnO1xuXG4gICAgICB3aGlsZSAodGhpcy5uZXh0KCkudHlwZSAhPT0gJ2xpc3RfaXRlbV9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdGl0ZW0oYm9keSk7XG4gICAgfVxuICAgIGNhc2UgJ2h0bWwnOiB7XG4gICAgICB2YXIgaHRtbCA9ICF0aGlzLnRva2VuLnByZSAmJiAhdGhpcy5vcHRpb25zLnBlZGFudGljXG4gICAgICAgID8gdGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4udGV4dClcbiAgICAgICAgOiB0aGlzLnRva2VuLnRleHQ7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5odG1sKGh0bWwpO1xuICAgIH1cbiAgICBjYXNlICdwYXJhZ3JhcGgnOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgodGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4udGV4dCkpO1xuICAgIH1cbiAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHRoaXMucGFyc2VUZXh0KCkpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIZWxwZXJzXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGh0bWwsIGVuY29kZSkge1xuICByZXR1cm4gaHRtbFxuICAgIC5yZXBsYWNlKCFlbmNvZGUgPyAvJig/ISM/XFx3KzspL2cgOiAvJi9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgIC5yZXBsYWNlKC8nL2csICcmIzM5OycpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZShodG1sKSB7XG4gIC8vIGV4cGxpY2l0bHkgbWF0Y2ggZGVjaW1hbCwgaGV4LCBhbmQgbmFtZWQgSFRNTCBlbnRpdGllc1xuICByZXR1cm4gaHRtbC5yZXBsYWNlKC8mKCMoPzpcXGQrKXwoPzojeFswLTlBLUZhLWZdKyl8KD86XFx3KykpOz8vaWcsIGZ1bmN0aW9uKF8sIG4pIHtcbiAgICBuID0gbi50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChuID09PSAnY29sb24nKSByZXR1cm4gJzonO1xuICAgIGlmIChuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICByZXR1cm4gbi5jaGFyQXQoMSkgPT09ICd4J1xuICAgICAgICA/IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQobi5zdWJzdHJpbmcoMiksIDE2KSlcbiAgICAgICAgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKCtuLnN1YnN0cmluZygxKSk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVkaXQocmVnZXgsIG9wdCkge1xuICByZWdleCA9IHJlZ2V4LnNvdXJjZTtcbiAgb3B0ID0gb3B0IHx8ICcnO1xuICByZXR1cm4ge1xuICAgIHJlcGxhY2U6IGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuICAgICAgdmFsID0gdmFsLnNvdXJjZSB8fCB2YWw7XG4gICAgICB2YWwgPSB2YWwucmVwbGFjZSgvKF58W15cXFtdKVxcXi9nLCAnJDEnKTtcbiAgICAgIHJlZ2V4ID0gcmVnZXgucmVwbGFjZShuYW1lLCB2YWwpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXRSZWdleDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleCwgb3B0KTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVVcmwoYmFzZSwgaHJlZikge1xuICBpZiAoIWJhc2VVcmxzWycgJyArIGJhc2VdKSB7XG4gICAgLy8gd2UgY2FuIGlnbm9yZSBldmVyeXRoaW5nIGluIGJhc2UgYWZ0ZXIgdGhlIGxhc3Qgc2xhc2ggb2YgaXRzIHBhdGggY29tcG9uZW50LFxuICAgIC8vIGJ1dCB3ZSBtaWdodCBuZWVkIHRvIGFkZCBfdGhhdF9cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTNcbiAgICBpZiAoL15bXjpdKzpcXC8qW14vXSokLy50ZXN0KGJhc2UpKSB7XG4gICAgICBiYXNlVXJsc1snICcgKyBiYXNlXSA9IGJhc2UgKyAnLyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2VVcmxzWycgJyArIGJhc2VdID0gYmFzZS5yZXBsYWNlKC9bXi9dKiQvLCAnJyk7XG4gICAgfVxuICB9XG4gIGJhc2UgPSBiYXNlVXJsc1snICcgKyBiYXNlXTtcblxuICBpZiAoaHJlZi5zbGljZSgwLCAyKSA9PT0gJy8vJykge1xuICAgIHJldHVybiBiYXNlLnJlcGxhY2UoLzpbXFxzXFxTXSovLCAnOicpICsgaHJlZjtcbiAgfSBlbHNlIGlmIChocmVmLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgcmV0dXJuIGJhc2UucmVwbGFjZSgvKDpcXC8qW14vXSopW1xcc1xcU10qLywgJyQxJykgKyBocmVmO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlICsgaHJlZjtcbiAgfVxufVxudmFyIGJhc2VVcmxzID0ge307XG52YXIgb3JpZ2luSW5kZXBlbmRlbnRVcmwgPSAvXiR8XlthLXpdW2EtejAtOSsuLV0qOnxeWz8jXS9pO1xuXG5mdW5jdGlvbiBub29wKCkge31cbm5vb3AuZXhlYyA9IG5vb3A7XG5cbmZ1bmN0aW9uIG1lcmdlKG9iaikge1xuICB2YXIgaSA9IDEsXG4gICAgICB0YXJnZXQsXG4gICAgICBrZXk7XG5cbiAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXQgPSBhcmd1bWVudHNbaV07XG4gICAgZm9yIChrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSkge1xuICAgICAgICBvYmpba2V5XSA9IHRhcmdldFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogTWFya2VkXG4gKi9cblxuZnVuY3Rpb24gbWFya2VkKHNyYywgb3B0LCBjYWxsYmFjaykge1xuICAvLyB0aHJvdyBlcnJvciBpbiBjYXNlIG9mIG5vbiBzdHJpbmcgaW5wdXRcbiAgaWYgKHR5cGVvZiBzcmMgPT09ICd1bmRlZmluZWQnIHx8IHNyYyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWFya2VkKCk6IGlucHV0IHBhcmFtZXRlciBpcyB1bmRlZmluZWQgb3IgbnVsbCcpO1xuICB9XG4gIGlmICh0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignbWFya2VkKCk6IGlucHV0IHBhcmFtZXRlciBpcyBvZiB0eXBlICdcbiAgICAgICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNyYykgKyAnLCBzdHJpbmcgZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChjYWxsYmFjayB8fCB0eXBlb2Ygb3B0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2sgPSBvcHQ7XG4gICAgICBvcHQgPSBudWxsO1xuICAgIH1cblxuICAgIG9wdCA9IG1lcmdlKHt9LCBtYXJrZWQuZGVmYXVsdHMsIG9wdCB8fCB7fSk7XG5cbiAgICB2YXIgaGlnaGxpZ2h0ID0gb3B0LmhpZ2hsaWdodCxcbiAgICAgICAgdG9rZW5zLFxuICAgICAgICBwZW5kaW5nLFxuICAgICAgICBpID0gMDtcblxuICAgIHRyeSB7XG4gICAgICB0b2tlbnMgPSBMZXhlci5sZXgoc3JjLCBvcHQpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgIH1cblxuICAgIHBlbmRpbmcgPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgdmFyIGRvbmUgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgb3B0LmhpZ2hsaWdodCA9IGhpZ2hsaWdodDtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG91dCA9IFBhcnNlci5wYXJzZSh0b2tlbnMsIG9wdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVyciA9IGU7XG4gICAgICB9XG5cbiAgICAgIG9wdC5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG5cbiAgICAgIHJldHVybiBlcnJcbiAgICAgICAgPyBjYWxsYmFjayhlcnIpXG4gICAgICAgIDogY2FsbGJhY2sobnVsbCwgb3V0KTtcbiAgICB9O1xuXG4gICAgaWYgKCFoaWdobGlnaHQgfHwgaGlnaGxpZ2h0Lmxlbmd0aCA8IDMpIHtcbiAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIG9wdC5oaWdobGlnaHQ7XG5cbiAgICBpZiAoIXBlbmRpbmcpIHJldHVybiBkb25lKCk7XG5cbiAgICBmb3IgKDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgKGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSAnY29kZScpIHtcbiAgICAgICAgICByZXR1cm4gLS1wZW5kaW5nIHx8IGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaGxpZ2h0KHRva2VuLnRleHQsIHRva2VuLmxhbmcsIGZ1bmN0aW9uKGVyciwgY29kZSkge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBkb25lKGVycik7XG4gICAgICAgICAgaWYgKGNvZGUgPT0gbnVsbCB8fCBjb2RlID09PSB0b2tlbi50ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gLS1wZW5kaW5nIHx8IGRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9rZW4udGV4dCA9IGNvZGU7XG4gICAgICAgICAgdG9rZW4uZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgLS1wZW5kaW5nIHx8IGRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSh0b2tlbnNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuICB0cnkge1xuICAgIGlmIChvcHQpIG9wdCA9IG1lcmdlKHt9LCBtYXJrZWQuZGVmYXVsdHMsIG9wdCk7XG4gICAgcmV0dXJuIFBhcnNlci5wYXJzZShMZXhlci5sZXgoc3JjLCBvcHQpLCBvcHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZS5tZXNzYWdlICs9ICdcXG5QbGVhc2UgcmVwb3J0IHRoaXMgdG8gaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZC4nO1xuICAgIGlmICgob3B0IHx8IG1hcmtlZC5kZWZhdWx0cykuc2lsZW50KSB7XG4gICAgICByZXR1cm4gJzxwPkFuIGVycm9yIG9jY3VycmVkOjwvcD48cHJlPidcbiAgICAgICAgKyBlc2NhcGUoZS5tZXNzYWdlICsgJycsIHRydWUpXG4gICAgICAgICsgJzwvcHJlPic7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbn1cblxuLyoqXG4gKiBPcHRpb25zXG4gKi9cblxubWFya2VkLm9wdGlvbnMgPVxubWFya2VkLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHQpIHtcbiAgbWVyZ2UobWFya2VkLmRlZmF1bHRzLCBvcHQpO1xuICByZXR1cm4gbWFya2VkO1xufTtcblxubWFya2VkLmRlZmF1bHRzID0ge1xuICBnZm06IHRydWUsXG4gIHRhYmxlczogdHJ1ZSxcbiAgYnJlYWtzOiBmYWxzZSxcbiAgcGVkYW50aWM6IGZhbHNlLFxuICBzYW5pdGl6ZTogZmFsc2UsXG4gIHNhbml0aXplcjogbnVsbCxcbiAgbWFuZ2xlOiB0cnVlLFxuICBzbWFydExpc3RzOiBmYWxzZSxcbiAgc2lsZW50OiBmYWxzZSxcbiAgaGlnaGxpZ2h0OiBudWxsLFxuICBsYW5nUHJlZml4OiAnbGFuZy0nLFxuICBzbWFydHlwYW50czogZmFsc2UsXG4gIGhlYWRlclByZWZpeDogJycsXG4gIHJlbmRlcmVyOiBuZXcgUmVuZGVyZXIoKSxcbiAgeGh0bWw6IGZhbHNlLFxuICBiYXNlVXJsOiBudWxsXG59O1xuXG4vKipcbiAqIEV4cG9zZVxuICovXG5cbm1hcmtlZC5QYXJzZXIgPSBQYXJzZXI7XG5tYXJrZWQucGFyc2VyID0gUGFyc2VyLnBhcnNlO1xuXG5tYXJrZWQuUmVuZGVyZXIgPSBSZW5kZXJlcjtcbm1hcmtlZC5UZXh0UmVuZGVyZXIgPSBUZXh0UmVuZGVyZXI7XG5cbm1hcmtlZC5MZXhlciA9IExleGVyO1xubWFya2VkLmxleGVyID0gTGV4ZXIubGV4O1xuXG5tYXJrZWQuSW5saW5lTGV4ZXIgPSBJbmxpbmVMZXhlcjtcbm1hcmtlZC5pbmxpbmVMZXhlciA9IElubGluZUxleGVyLm91dHB1dDtcblxubWFya2VkLnBhcnNlID0gbWFya2VkO1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gbWFya2VkO1xufSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gbWFya2VkOyB9KTtcbn0gZWxzZSB7XG4gIHJvb3QubWFya2VkID0gbWFya2VkO1xufVxufSkodGhpcyB8fCAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpKTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJyk7XG4iLCIvLyBMb2FkIG1vZHVsZXNcblxudmFyIFN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vc3RyaW5naWZ5Jyk7XG52YXIgUGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJyk7XG5cblxuLy8gRGVjbGFyZSBpbnRlcm5hbHNcblxudmFyIGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHN0cmluZ2lmeTogU3RyaW5naWZ5LFxuICAgIHBhcnNlOiBQYXJzZVxufTtcbiIsIi8vIExvYWQgbW9kdWxlc1xuXG52YXIgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cblxuLy8gRGVjbGFyZSBpbnRlcm5hbHNcblxudmFyIGludGVybmFscyA9IHtcbiAgICBkZWxpbWl0ZXI6ICcmJyxcbiAgICBkZXB0aDogNSxcbiAgICBhcnJheUxpbWl0OiAyMCxcbiAgICBwYXJhbWV0ZXJMaW1pdDogMTAwMFxufTtcblxuXG5pbnRlcm5hbHMucGFyc2VWYWx1ZXMgPSBmdW5jdGlvbiAoc3RyLCBvcHRpb25zKSB7XG5cbiAgICB2YXIgb2JqID0ge307XG4gICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KG9wdGlvbnMuZGVsaW1pdGVyLCBvcHRpb25zLnBhcmFtZXRlckxpbWl0ID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IG9wdGlvbnMucGFyYW1ldGVyTGltaXQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gcGFydHMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICB2YXIgcG9zID0gcGFydC5pbmRleE9mKCddPScpID09PSAtMSA/IHBhcnQuaW5kZXhPZignPScpIDogcGFydC5pbmRleE9mKCddPScpICsgMTtcblxuICAgICAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgICAgICAgb2JqW1V0aWxzLmRlY29kZShwYXJ0KV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBVdGlscy5kZWNvZGUocGFydC5zbGljZSgwLCBwb3MpKTtcbiAgICAgICAgICAgIHZhciB2YWwgPSBVdGlscy5kZWNvZGUocGFydC5zbGljZShwb3MgKyAxKSk7XG5cbiAgICAgICAgICAgIGlmICghb2JqW2tleV0pIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0gW10uY29uY2F0KG9ialtrZXldKS5jb25jYXQodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG5cbmludGVybmFscy5wYXJzZU9iamVjdCA9IGZ1bmN0aW9uIChjaGFpbiwgdmFsLCBvcHRpb25zKSB7XG5cbiAgICBpZiAoIWNoYWluLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIHZhciByb290ID0gY2hhaW4uc2hpZnQoKTtcblxuICAgIHZhciBvYmogPSB7fTtcbiAgICBpZiAocm9vdCA9PT0gJ1tdJykge1xuICAgICAgICBvYmogPSBbXTtcbiAgICAgICAgb2JqID0gb2JqLmNvbmNhdChpbnRlcm5hbHMucGFyc2VPYmplY3QoY2hhaW4sIHZhbCwgb3B0aW9ucykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGNsZWFuUm9vdCA9IHJvb3RbMF0gPT09ICdbJyAmJiByb290W3Jvb3QubGVuZ3RoIC0gMV0gPT09ICddJyA/IHJvb3Quc2xpY2UoMSwgcm9vdC5sZW5ndGggLSAxKSA6IHJvb3Q7XG4gICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KGNsZWFuUm9vdCwgMTApO1xuICAgICAgICBpZiAoIWlzTmFOKGluZGV4KSAmJlxuICAgICAgICAgICAgcm9vdCAhPT0gY2xlYW5Sb290ICYmXG4gICAgICAgICAgICBpbmRleCA8PSBvcHRpb25zLmFycmF5TGltaXQpIHtcblxuICAgICAgICAgICAgb2JqID0gW107XG4gICAgICAgICAgICBvYmpbaW5kZXhdID0gaW50ZXJuYWxzLnBhcnNlT2JqZWN0KGNoYWluLCB2YWwsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqW2NsZWFuUm9vdF0gPSBpbnRlcm5hbHMucGFyc2VPYmplY3QoY2hhaW4sIHZhbCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxuXG5pbnRlcm5hbHMucGFyc2VLZXlzID0gZnVuY3Rpb24gKGtleSwgdmFsLCBvcHRpb25zKSB7XG5cbiAgICBpZiAoIWtleSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhlIHJlZ2V4IGNodW5rc1xuXG4gICAgdmFyIHBhcmVudCA9IC9eKFteXFxbXFxdXSopLztcbiAgICB2YXIgY2hpbGQgPSAvKFxcW1teXFxbXFxdXSpcXF0pL2c7XG5cbiAgICAvLyBHZXQgdGhlIHBhcmVudFxuXG4gICAgdmFyIHNlZ21lbnQgPSBwYXJlbnQuZXhlYyhrZXkpO1xuXG4gICAgLy8gRG9uJ3QgYWxsb3cgdGhlbSB0byBvdmVyd3JpdGUgb2JqZWN0IHByb3RvdHlwZSBwcm9wZXJ0aWVzXG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShzZWdtZW50WzFdKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU3Rhc2ggdGhlIHBhcmVudCBpZiBpdCBleGlzdHNcblxuICAgIHZhciBrZXlzID0gW107XG4gICAgaWYgKHNlZ21lbnRbMV0pIHtcbiAgICAgICAga2V5cy5wdXNoKHNlZ21lbnRbMV0pO1xuICAgIH1cblxuICAgIC8vIExvb3AgdGhyb3VnaCBjaGlsZHJlbiBhcHBlbmRpbmcgdG8gdGhlIGFycmF5IHVudGlsIHdlIGhpdCBkZXB0aFxuXG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlICgoc2VnbWVudCA9IGNoaWxkLmV4ZWMoa2V5KSkgIT09IG51bGwgJiYgaSA8IG9wdGlvbnMuZGVwdGgpIHtcblxuICAgICAgICArK2k7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShzZWdtZW50WzFdLnJlcGxhY2UoL1xcW3xcXF0vZywgJycpKSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKHNlZ21lbnRbMV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUncyBhIHJlbWFpbmRlciwganVzdCBhZGQgd2hhdGV2ZXIgaXMgbGVmdFxuXG4gICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAga2V5cy5wdXNoKCdbJyArIGtleS5zbGljZShzZWdtZW50LmluZGV4KSArICddJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFscy5wYXJzZU9iamVjdChrZXlzLCB2YWwsIG9wdGlvbnMpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIsIG9wdGlvbnMpIHtcblxuICAgIGlmIChzdHIgPT09ICcnIHx8XG4gICAgICAgIHN0ciA9PT0gbnVsbCB8fFxuICAgICAgICB0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmRlbGltaXRlciA9IHR5cGVvZiBvcHRpb25zLmRlbGltaXRlciA9PT0gJ3N0cmluZycgfHwgVXRpbHMuaXNSZWdFeHAob3B0aW9ucy5kZWxpbWl0ZXIpID8gb3B0aW9ucy5kZWxpbWl0ZXIgOiBpbnRlcm5hbHMuZGVsaW1pdGVyO1xuICAgIG9wdGlvbnMuZGVwdGggPSB0eXBlb2Ygb3B0aW9ucy5kZXB0aCA9PT0gJ251bWJlcicgPyBvcHRpb25zLmRlcHRoIDogaW50ZXJuYWxzLmRlcHRoO1xuICAgIG9wdGlvbnMuYXJyYXlMaW1pdCA9IHR5cGVvZiBvcHRpb25zLmFycmF5TGltaXQgPT09ICdudW1iZXInID8gb3B0aW9ucy5hcnJheUxpbWl0IDogaW50ZXJuYWxzLmFycmF5TGltaXQ7XG4gICAgb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCA9IHR5cGVvZiBvcHRpb25zLnBhcmFtZXRlckxpbWl0ID09PSAnbnVtYmVyJyA/IG9wdGlvbnMucGFyYW1ldGVyTGltaXQgOiBpbnRlcm5hbHMucGFyYW1ldGVyTGltaXQ7XG5cbiAgICB2YXIgdGVtcE9iaiA9IHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gaW50ZXJuYWxzLnBhcnNlVmFsdWVzKHN0ciwgb3B0aW9ucykgOiBzdHI7XG4gICAgdmFyIG9iaiA9IHt9O1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBrZXlzIGFuZCBzZXR1cCB0aGUgbmV3IG9iamVjdFxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0ZW1wT2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBrZXlzLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciBuZXdPYmogPSBpbnRlcm5hbHMucGFyc2VLZXlzKGtleSwgdGVtcE9ialtrZXldLCBvcHRpb25zKTtcbiAgICAgICAgb2JqID0gVXRpbHMubWVyZ2Uob2JqLCBuZXdPYmopO1xuICAgIH1cblxuICAgIHJldHVybiBVdGlscy5jb21wYWN0KG9iaik7XG59O1xuIiwiLy8gTG9hZCBtb2R1bGVzXG5cbnZhciBVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuXG4vLyBEZWNsYXJlIGludGVybmFsc1xuXG52YXIgaW50ZXJuYWxzID0ge1xuICAgIGRlbGltaXRlcjogJyYnXG59O1xuXG5cbmludGVybmFscy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAob2JqLCBwcmVmaXgpIHtcblxuICAgIGlmIChVdGlscy5pc0J1ZmZlcihvYmopKSB7XG4gICAgICAgIG9iaiA9IG9iai50b1N0cmluZygpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIG9iaiA9IG9iai50b0lTT1N0cmluZygpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgb2JqID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIHR5cGVvZiBvYmogPT09ICdudW1iZXInIHx8XG4gICAgICAgIHR5cGVvZiBvYmogPT09ICdib29sZWFuJykge1xuXG4gICAgICAgIHJldHVybiBbZW5jb2RlVVJJQ29tcG9uZW50KHByZWZpeCkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqKV07XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQoaW50ZXJuYWxzLnN0cmluZ2lmeShvYmpba2V5XSwgcHJlZml4ICsgJ1snICsga2V5ICsgJ10nKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIG9wdGlvbnMpIHtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBkZWxpbWl0ZXIgPSB0eXBlb2Ygb3B0aW9ucy5kZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gaW50ZXJuYWxzLmRlbGltaXRlciA6IG9wdGlvbnMuZGVsaW1pdGVyO1xuXG4gICAgdmFyIGtleXMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoaW50ZXJuYWxzLnN0cmluZ2lmeShvYmpba2V5XSwga2V5KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ga2V5cy5qb2luKGRlbGltaXRlcik7XG59O1xuIiwiLy8gTG9hZCBtb2R1bGVzXG5cblxuLy8gRGVjbGFyZSBpbnRlcm5hbHNcblxudmFyIGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuYXJyYXlUb09iamVjdCA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcblxuICAgIHZhciBvYmogPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBzb3VyY2UubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcblxuICAgICAgICAgICAgb2JqW2ldID0gc291cmNlW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cblxuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHNvdXJjZS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldFtpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2ldID0gZXhwb3J0cy5tZXJnZSh0YXJnZXRbaV0sIHNvdXJjZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSBzb3VyY2VbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goc291cmNlKTtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBleHBvcnRzLmFycmF5VG9PYmplY3QodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICBmb3IgKHZhciBrID0gMCwga2wgPSBrZXlzLmxlbmd0aDsgayA8IGtsOyArK2spIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNba107XG4gICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXG4gICAgICAgICAgICBpZiAoIXRhcmdldFtrZXldKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gZXhwb3J0cy5tZXJnZSh0YXJnZXRba2V5XSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIucmVwbGFjZSgvXFwrL2csICcgJykpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuY29tcGFjdCA9IGZ1bmN0aW9uIChvYmosIHJlZnMpIHtcblxuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICBvYmogPT09IG51bGwpIHtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHJlZnMgPSByZWZzIHx8IFtdO1xuICAgIHZhciBsb29rdXAgPSByZWZzLmluZGV4T2Yob2JqKTtcbiAgICBpZiAobG9va3VwICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gcmVmc1tsb29rdXBdO1xuICAgIH1cblxuICAgIHJlZnMucHVzaChvYmopO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICB2YXIgY29tcGFjdGVkID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9ialtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb21wYWN0ZWQucHVzaChvYmpbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBhY3RlZDtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0ga2V5cy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBvYmpba2V5XSA9IGV4cG9ydHMuY29tcGFjdChvYmpba2V5XSwgcmVmcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cblxuZXhwb3J0cy5pc1JlZ0V4cCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufTtcblxuXG5leHBvcnRzLmlzQnVmZmVyID0gZnVuY3Rpb24gKG9iaikge1xuXG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuIiwiLyoqXG4gKiBBY3Rpb25zIHRoYXQgbW9kaWZ5IHRoZSBVUkwuXG4gKi9cbnZhciBMb2NhdGlvbkFjdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBhIG5ldyBsb2NhdGlvbiBpcyBiZWluZyBwdXNoZWQgdG8gdGhlIGhpc3Rvcnkgc3RhY2suXG4gICAqL1xuICBQVVNIOiAncHVzaCcsXG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGUgY3VycmVudCBsb2NhdGlvbiBzaG91bGQgYmUgcmVwbGFjZWQuXG4gICAqL1xuICBSRVBMQUNFOiAncmVwbGFjZScsXG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGUgbW9zdCByZWNlbnQgZW50cnkgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSB0aGUgaGlzdG9yeSBzdGFjay5cbiAgICovXG4gIFBPUDogJ3BvcCdcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMb2NhdGlvbkFjdGlvbnM7XG4iLCJ2YXIgTG9jYXRpb25BY3Rpb25zID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9Mb2NhdGlvbkFjdGlvbnMnKTtcblxuLyoqXG4gKiBBIHNjcm9sbCBiZWhhdmlvciB0aGF0IGF0dGVtcHRzIHRvIGltaXRhdGUgdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAqIG9mIG1vZGVybiBicm93c2Vycy5cbiAqL1xudmFyIEltaXRhdGVCcm93c2VyQmVoYXZpb3IgPSB7XG5cbiAgdXBkYXRlU2Nyb2xsUG9zaXRpb246IGZ1bmN0aW9uIChwb3NpdGlvbiwgYWN0aW9uVHlwZSkge1xuICAgIHN3aXRjaCAoYWN0aW9uVHlwZSkge1xuICAgICAgY2FzZSBMb2NhdGlvbkFjdGlvbnMuUFVTSDpcbiAgICAgIGNhc2UgTG9jYXRpb25BY3Rpb25zLlJFUExBQ0U6XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExvY2F0aW9uQWN0aW9ucy5QT1A6XG4gICAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW1pdGF0ZUJyb3dzZXJCZWhhdmlvcjtcbiIsIi8qKlxuICogQSBzY3JvbGwgYmVoYXZpb3IgdGhhdCBhbHdheXMgc2Nyb2xscyB0byB0aGUgdG9wIG9mIHRoZSBwYWdlXG4gKiBhZnRlciBhIHRyYW5zaXRpb24uXG4gKi9cbnZhciBTY3JvbGxUb1RvcEJlaGF2aW9yID0ge1xuXG4gIHVwZGF0ZVNjcm9sbFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2Nyb2xsVG9Ub3BCZWhhdmlvcjtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgRmFrZU5vZGUgPSByZXF1aXJlKCcuLi9taXhpbnMvRmFrZU5vZGUnKTtcbnZhciBQcm9wVHlwZXMgPSByZXF1aXJlKCcuLi91dGlscy9Qcm9wVHlwZXMnKTtcblxuLyoqXG4gKiBBIDxEZWZhdWx0Um91dGU+IGNvbXBvbmVudCBpcyBhIHNwZWNpYWwga2luZCBvZiA8Um91dGU+IHRoYXRcbiAqIHJlbmRlcnMgd2hlbiBpdHMgcGFyZW50IG1hdGNoZXMgYnV0IG5vbmUgb2YgaXRzIHNpYmxpbmdzIGRvLlxuICogT25seSBvbmUgc3VjaCByb3V0ZSBtYXkgYmUgdXNlZCBhdCBhbnkgZ2l2ZW4gbGV2ZWwgaW4gdGhlXG4gKiByb3V0ZSBoaWVyYXJjaHkuXG4gKi9cbnZhciBEZWZhdWx0Um91dGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgZGlzcGxheU5hbWU6ICdEZWZhdWx0Um91dGUnLFxuXG4gIG1peGluczogWyBGYWtlTm9kZSBdLFxuXG4gIHByb3BUeXBlczoge1xuICAgIG5hbWU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgcGF0aDogUHJvcFR5cGVzLmZhbHN5LFxuICAgIGhhbmRsZXI6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWZhdWx0Um91dGU7XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGNsYXNzU2V0ID0gcmVxdWlyZSgncmVhY3QvbGliL2N4Jyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgncmVhY3QvbGliL09iamVjdC5hc3NpZ24nKTtcbnZhciBOYXZpZ2F0aW9uID0gcmVxdWlyZSgnLi4vbWl4aW5zL05hdmlnYXRpb24nKTtcbnZhciBTdGF0ZSA9IHJlcXVpcmUoJy4uL21peGlucy9TdGF0ZScpO1xuXG5mdW5jdGlvbiBpc0xlZnRDbGlja0V2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5idXR0b24gPT09IDA7XG59XG5cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59XG5cbi8qKlxuICogPExpbms+IGNvbXBvbmVudHMgYXJlIHVzZWQgdG8gY3JlYXRlIGFuIDxhPiBlbGVtZW50IHRoYXQgbGlua3MgdG8gYSByb3V0ZS5cbiAqIFdoZW4gdGhhdCByb3V0ZSBpcyBhY3RpdmUsIHRoZSBsaW5rIGdldHMgYW4gXCJhY3RpdmVcIiBjbGFzcyBuYW1lIChvciB0aGVcbiAqIHZhbHVlIG9mIGl0cyBgYWN0aXZlQ2xhc3NOYW1lYCBwcm9wKS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgYXNzdW1pbmcgeW91IGhhdmUgdGhlIGZvbGxvd2luZyByb3V0ZTpcbiAqXG4gKiAgIDxSb3V0ZSBuYW1lPVwic2hvd1Bvc3RcIiBwYXRoPVwiL3Bvc3RzLzpwb3N0SURcIiBoYW5kbGVyPXtQb3N0fS8+XG4gKlxuICogWW91IGNvdWxkIHVzZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudCB0byBsaW5rIHRvIHRoYXQgcm91dGU6XG4gKlxuICogICA8TGluayB0bz1cInNob3dQb3N0XCIgcGFyYW1zPXt7IHBvc3RJRDogXCIxMjNcIiB9fSAvPlxuICpcbiAqIEluIGFkZGl0aW9uIHRvIHBhcmFtcywgbGlua3MgbWF5IHBhc3MgYWxvbmcgcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnNcbiAqIHVzaW5nIHRoZSBgcXVlcnlgIHByb3AuXG4gKlxuICogICA8TGluayB0bz1cInNob3dQb3N0XCIgcGFyYW1zPXt7IHBvc3RJRDogXCIxMjNcIiB9fSBxdWVyeT17eyBzaG93OnRydWUgfX0vPlxuICovXG52YXIgTGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICBkaXNwbGF5TmFtZTogJ0xpbmsnLFxuXG4gIG1peGluczogWyBOYXZpZ2F0aW9uLCBTdGF0ZSBdLFxuXG4gIHByb3BUeXBlczoge1xuICAgIGFjdGl2ZUNsYXNzTmFtZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIHRvOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgcGFyYW1zOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHF1ZXJ5OiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIG9uQ2xpY2s6IFJlYWN0LlByb3BUeXBlcy5mdW5jXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGl2ZUNsYXNzTmFtZTogJ2FjdGl2ZSdcbiAgICB9O1xuICB9LFxuXG4gIGhhbmRsZUNsaWNrOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgYWxsb3dUcmFuc2l0aW9uID0gdHJ1ZTtcbiAgICB2YXIgY2xpY2tSZXN1bHQ7XG5cbiAgICBpZiAodGhpcy5wcm9wcy5vbkNsaWNrKVxuICAgICAgY2xpY2tSZXN1bHQgPSB0aGlzLnByb3BzLm9uQ2xpY2soZXZlbnQpO1xuXG4gICAgaWYgKGlzTW9kaWZpZWRFdmVudChldmVudCkgfHwgIWlzTGVmdENsaWNrRXZlbnQoZXZlbnQpKVxuICAgICAgcmV0dXJuO1xuXG4gICAgaWYgKGNsaWNrUmVzdWx0ID09PSBmYWxzZSB8fCBldmVudC5kZWZhdWx0UHJldmVudGVkID09PSB0cnVlKVxuICAgICAgYWxsb3dUcmFuc2l0aW9uID0gZmFsc2U7XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYgKGFsbG93VHJhbnNpdGlvbilcbiAgICAgIHRoaXMudHJhbnNpdGlvblRvKHRoaXMucHJvcHMudG8sIHRoaXMucHJvcHMucGFyYW1zLCB0aGlzLnByb3BzLnF1ZXJ5KTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIFwiaHJlZlwiIGF0dHJpYnV0ZSB0byB1c2Ugb24gdGhlIERPTSBlbGVtZW50LlxuICAgKi9cbiAgZ2V0SHJlZjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1ha2VIcmVmKHRoaXMucHJvcHMudG8sIHRoaXMucHJvcHMucGFyYW1zLCB0aGlzLnByb3BzLnF1ZXJ5KTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIFwiY2xhc3NcIiBhdHRyaWJ1dGUgdG8gdXNlIG9uIHRoZSBET00gZWxlbWVudCwgd2hpY2ggY29udGFpbnNcbiAgICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmVDbGFzc05hbWUgcHJvcGVydHkgd2hlbiB0aGlzIDxMaW5rPiBpcyBhY3RpdmUuXG4gICAqL1xuICBnZXRDbGFzc05hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2xhc3NOYW1lcyA9IHt9O1xuXG4gICAgaWYgKHRoaXMucHJvcHMuY2xhc3NOYW1lKVxuICAgICAgY2xhc3NOYW1lc1t0aGlzLnByb3BzLmNsYXNzTmFtZV0gPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuaXNBY3RpdmUodGhpcy5wcm9wcy50bywgdGhpcy5wcm9wcy5wYXJhbXMsIHRoaXMucHJvcHMucXVlcnkpKVxuICAgICAgY2xhc3NOYW1lc1t0aGlzLnByb3BzLmFjdGl2ZUNsYXNzTmFtZV0gPSB0cnVlO1xuXG4gICAgcmV0dXJuIGNsYXNzU2V0KGNsYXNzTmFtZXMpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wcyA9IGFzc2lnbih7fSwgdGhpcy5wcm9wcywge1xuICAgICAgaHJlZjogdGhpcy5nZXRIcmVmKCksXG4gICAgICBjbGFzc05hbWU6IHRoaXMuZ2V0Q2xhc3NOYW1lKCksXG4gICAgICBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrXG4gICAgfSk7XG5cbiAgICByZXR1cm4gUmVhY3QuRE9NLmEocHJvcHMsIHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbms7XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIEZha2VOb2RlID0gcmVxdWlyZSgnLi4vbWl4aW5zL0Zha2VOb2RlJyk7XG52YXIgUHJvcFR5cGVzID0gcmVxdWlyZSgnLi4vdXRpbHMvUHJvcFR5cGVzJyk7XG5cbi8qKlxuICogQSA8Tm90Rm91bmRSb3V0ZT4gaXMgYSBzcGVjaWFsIGtpbmQgb2YgPFJvdXRlPiB0aGF0XG4gKiByZW5kZXJzIHdoZW4gdGhlIGJlZ2lubmluZyBvZiBpdHMgcGFyZW50J3MgcGF0aCBtYXRjaGVzXG4gKiBidXQgbm9uZSBvZiBpdHMgc2libGluZ3MgZG8sIGluY2x1ZGluZyBhbnkgPERlZmF1bHRSb3V0ZT4uXG4gKiBPbmx5IG9uZSBzdWNoIHJvdXRlIG1heSBiZSB1c2VkIGF0IGFueSBnaXZlbiBsZXZlbCBpbiB0aGVcbiAqIHJvdXRlIGhpZXJhcmNoeS5cbiAqL1xudmFyIE5vdEZvdW5kUm91dGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgZGlzcGxheU5hbWU6ICdOb3RGb3VuZFJvdXRlJyxcblxuICBtaXhpbnM6IFsgRmFrZU5vZGUgXSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBuYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHBhdGg6IFByb3BUeXBlcy5mYWxzeSxcbiAgICBoYW5kbGVyOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTm90Rm91bmRSb3V0ZTtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgRmFrZU5vZGUgPSByZXF1aXJlKCcuLi9taXhpbnMvRmFrZU5vZGUnKTtcbnZhciBQcm9wVHlwZXMgPSByZXF1aXJlKCcuLi91dGlscy9Qcm9wVHlwZXMnKTtcblxuLyoqXG4gKiBBIDxSZWRpcmVjdD4gY29tcG9uZW50IGlzIGEgc3BlY2lhbCBraW5kIG9mIDxSb3V0ZT4gdGhhdCBhbHdheXNcbiAqIHJlZGlyZWN0cyB0byBhbm90aGVyIHJvdXRlIHdoZW4gaXQgbWF0Y2hlcy5cbiAqL1xudmFyIFJlZGlyZWN0ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gIGRpc3BsYXlOYW1lOiAnUmVkaXJlY3QnLFxuXG4gIG1peGluczogWyBGYWtlTm9kZSBdLFxuXG4gIHByb3BUeXBlczoge1xuICAgIHBhdGg6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgZnJvbTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZywgLy8gQWxpYXMgZm9yIHBhdGguXG4gICAgdG86IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgaGFuZGxlcjogUHJvcFR5cGVzLmZhbHN5XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVkaXJlY3Q7XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIEZha2VOb2RlID0gcmVxdWlyZSgnLi4vbWl4aW5zL0Zha2VOb2RlJyk7XG5cbi8qKlxuICogPFJvdXRlPiBjb21wb25lbnRzIHNwZWNpZnkgY29tcG9uZW50cyB0aGF0IGFyZSByZW5kZXJlZCB0byB0aGUgcGFnZSB3aGVuIHRoZVxuICogVVJMIG1hdGNoZXMgYSBnaXZlbiBwYXR0ZXJuLlxuICpcbiAqIFJvdXRlcyBhcmUgYXJyYW5nZWQgaW4gYSBuZXN0ZWQgdHJlZSBzdHJ1Y3R1cmUuIFdoZW4gYSBuZXcgVVJMIGlzIHJlcXVlc3RlZCxcbiAqIHRoZSB0cmVlIGlzIHNlYXJjaGVkIGRlcHRoLWZpcnN0IHRvIGZpbmQgYSByb3V0ZSB3aG9zZSBwYXRoIG1hdGNoZXMgdGhlIFVSTC5cbiAqIFdoZW4gb25lIGlzIGZvdW5kLCBhbGwgcm91dGVzIGluIHRoZSB0cmVlIHRoYXQgbGVhZCB0byBpdCBhcmUgY29uc2lkZXJlZFxuICogXCJhY3RpdmVcIiBhbmQgdGhlaXIgY29tcG9uZW50cyBhcmUgcmVuZGVyZWQgaW50byB0aGUgRE9NLCBuZXN0ZWQgaW4gdGhlIHNhbWVcbiAqIG9yZGVyIGFzIHRoZXkgYXJlIGluIHRoZSB0cmVlLlxuICpcbiAqIFRoZSBwcmVmZXJyZWQgd2F5IHRvIGNvbmZpZ3VyZSBhIHJvdXRlciBpcyB1c2luZyBKU1guIFRoZSBYTUwtbGlrZSBzeW50YXggaXNcbiAqIGEgZ3JlYXQgd2F5IHRvIHZpc3VhbGl6ZSBob3cgcm91dGVzIGFyZSBsYWlkIG91dCBpbiBhbiBhcHBsaWNhdGlvbi5cbiAqXG4gKiAgIHZhciByb3V0ZXMgPSBbXG4gKiAgICAgPFJvdXRlIGhhbmRsZXI9e0FwcH0+XG4gKiAgICAgICA8Um91dGUgbmFtZT1cImxvZ2luXCIgaGFuZGxlcj17TG9naW59Lz5cbiAqICAgICAgIDxSb3V0ZSBuYW1lPVwibG9nb3V0XCIgaGFuZGxlcj17TG9nb3V0fS8+XG4gKiAgICAgICA8Um91dGUgbmFtZT1cImFib3V0XCIgaGFuZGxlcj17QWJvdXR9Lz5cbiAqICAgICA8L1JvdXRlPlxuICogICBdO1xuICogICBcbiAqICAgUm91dGVyLnJ1bihyb3V0ZXMsIGZ1bmN0aW9uIChIYW5kbGVyKSB7XG4gKiAgICAgUmVhY3QucmVuZGVyKDxIYW5kbGVyLz4sIGRvY3VtZW50LmJvZHkpO1xuICogICB9KTtcbiAqXG4gKiBIYW5kbGVycyBmb3IgUm91dGUgY29tcG9uZW50cyB0aGF0IGNvbnRhaW4gY2hpbGRyZW4gY2FuIHJlbmRlciB0aGVpciBhY3RpdmVcbiAqIGNoaWxkIHJvdXRlIHVzaW5nIGEgPFJvdXRlSGFuZGxlcj4gZWxlbWVudC5cbiAqXG4gKiAgIHZhciBBcHAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICByZXR1cm4gKFxuICogICAgICAgICA8ZGl2IGNsYXNzPVwiYXBwbGljYXRpb25cIj5cbiAqICAgICAgICAgICA8Um91dGVIYW5kbGVyLz5cbiAqICAgICAgICAgPC9kaXY+XG4gKiAgICAgICApO1xuICogICAgIH1cbiAqICAgfSk7XG4gKi9cbnZhciBSb3V0ZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICBkaXNwbGF5TmFtZTogJ1JvdXRlJyxcblxuICBtaXhpbnM6IFsgRmFrZU5vZGUgXSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBuYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHBhdGg6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgaGFuZGxlcjogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBpZ25vcmVTY3JvbGxCZWhhdmlvcjogUmVhY3QuUHJvcFR5cGVzLmJvb2xcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3V0ZTtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUm91dGVIYW5kbGVyTWl4aW4gPSByZXF1aXJlKCcuLi9taXhpbnMvUm91dGVIYW5kbGVyJyk7XG5cbi8qKlxuICogQSA8Um91dGVIYW5kbGVyPiBjb21wb25lbnQgcmVuZGVycyB0aGUgYWN0aXZlIGNoaWxkIHJvdXRlIGhhbmRsZXJcbiAqIHdoZW4gcm91dGVzIGFyZSBuZXN0ZWQuXG4gKi9cbnZhciBSb3V0ZUhhbmRsZXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgZGlzcGxheU5hbWU6ICdSb3V0ZUhhbmRsZXInLFxuXG4gIG1peGluczogW1JvdXRlSGFuZGxlck1peGluXSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVmOiAnX19yb3V0ZUhhbmRsZXJfXydcbiAgICB9O1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldFJvdXRlSGFuZGxlcigpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdXRlSGFuZGxlcjtcbiIsImV4cG9ydHMuRGVmYXVsdFJvdXRlID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL0RlZmF1bHRSb3V0ZScpO1xuZXhwb3J0cy5MaW5rID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL0xpbmsnKTtcbmV4cG9ydHMuTm90Rm91bmRSb3V0ZSA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9Ob3RGb3VuZFJvdXRlJyk7XG5leHBvcnRzLlJlZGlyZWN0ID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL1JlZGlyZWN0Jyk7XG5leHBvcnRzLlJvdXRlID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL1JvdXRlJyk7XG5leHBvcnRzLlJvdXRlSGFuZGxlciA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9Sb3V0ZUhhbmRsZXInKTtcblxuZXhwb3J0cy5IYXNoTG9jYXRpb24gPSByZXF1aXJlKCcuL2xvY2F0aW9ucy9IYXNoTG9jYXRpb24nKTtcbmV4cG9ydHMuSGlzdG9yeUxvY2F0aW9uID0gcmVxdWlyZSgnLi9sb2NhdGlvbnMvSGlzdG9yeUxvY2F0aW9uJyk7XG5leHBvcnRzLlJlZnJlc2hMb2NhdGlvbiA9IHJlcXVpcmUoJy4vbG9jYXRpb25zL1JlZnJlc2hMb2NhdGlvbicpO1xuXG5leHBvcnRzLkltaXRhdGVCcm93c2VyQmVoYXZpb3IgPSByZXF1aXJlKCcuL2JlaGF2aW9ycy9JbWl0YXRlQnJvd3NlckJlaGF2aW9yJyk7XG5leHBvcnRzLlNjcm9sbFRvVG9wQmVoYXZpb3IgPSByZXF1aXJlKCcuL2JlaGF2aW9ycy9TY3JvbGxUb1RvcEJlaGF2aW9yJyk7XG5cbmV4cG9ydHMuTmF2aWdhdGlvbiA9IHJlcXVpcmUoJy4vbWl4aW5zL05hdmlnYXRpb24nKTtcbmV4cG9ydHMuU3RhdGUgPSByZXF1aXJlKCcuL21peGlucy9TdGF0ZScpO1xuXG5leHBvcnRzLmNyZWF0ZSA9IHJlcXVpcmUoJy4vdXRpbHMvY3JlYXRlUm91dGVyJyk7XG5leHBvcnRzLnJ1biA9IHJlcXVpcmUoJy4vdXRpbHMvcnVuUm91dGVyJyk7XG5cbmV4cG9ydHMuSGlzdG9yeSA9IHJlcXVpcmUoJy4vdXRpbHMvSGlzdG9yeScpO1xuIiwidmFyIExvY2F0aW9uQWN0aW9ucyA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvTG9jYXRpb25BY3Rpb25zJyk7XG52YXIgSGlzdG9yeSA9IHJlcXVpcmUoJy4uL3V0aWxzL0hpc3RvcnknKTtcbnZhciBQYXRoID0gcmVxdWlyZSgnLi4vdXRpbHMvUGF0aCcpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgVVJMIHBhdGggZnJvbSB0aGUgYGhhc2hgIHBvcnRpb24gb2YgdGhlIFVSTCwgaW5jbHVkaW5nXG4gKiBxdWVyeSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGdldEhhc2hQYXRoKCkge1xuICByZXR1cm4gUGF0aC5kZWNvZGUoXG4gICAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAgIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYuc3BsaXQoJyMnKVsxXSB8fCAnJ1xuICApO1xufVxuXG52YXIgX2FjdGlvblR5cGU7XG5cbmZ1bmN0aW9uIGVuc3VyZVNsYXNoKCkge1xuICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG5cbiAgaWYgKHBhdGguY2hhckF0KDApID09PSAnLycpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgSGFzaExvY2F0aW9uLnJlcGxhY2UoJy8nICsgcGF0aCk7XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgX2NoYW5nZUxpc3RlbmVycyA9IFtdO1xuXG5mdW5jdGlvbiBub3RpZnlDaGFuZ2UodHlwZSkge1xuICBpZiAodHlwZSA9PT0gTG9jYXRpb25BY3Rpb25zLlBVU0gpXG4gICAgSGlzdG9yeS5sZW5ndGggKz0gMTtcblxuICB2YXIgY2hhbmdlID0ge1xuICAgIHBhdGg6IGdldEhhc2hQYXRoKCksXG4gICAgdHlwZTogdHlwZVxuICB9O1xuXG4gIF9jaGFuZ2VMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICBsaXN0ZW5lcihjaGFuZ2UpO1xuICB9KTtcbn1cblxudmFyIF9pc0xpc3RlbmluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBvbkhhc2hDaGFuZ2UoKSB7XG4gIGlmIChlbnN1cmVTbGFzaCgpKSB7XG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbiBfYWN0aW9uVHlwZSB0aGVuIGFsbCB3ZSBrbm93IGlzIHRoZSBoYXNoXG4gICAgLy8gY2hhbmdlZC4gSXQgd2FzIHByb2JhYmx5IGNhdXNlZCBieSB0aGUgdXNlciBjbGlja2luZyB0aGUgQmFja1xuICAgIC8vIGJ1dHRvbiwgYnV0IG1heSBoYXZlIGFsc28gYmVlbiB0aGUgRm9yd2FyZCBidXR0b24gb3IgbWFudWFsXG4gICAgLy8gbWFuaXB1bGF0aW9uLiBTbyBqdXN0IGd1ZXNzICdwb3AnLlxuICAgIG5vdGlmeUNoYW5nZShfYWN0aW9uVHlwZSB8fCBMb2NhdGlvbkFjdGlvbnMuUE9QKTtcbiAgICBfYWN0aW9uVHlwZSA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBBIExvY2F0aW9uIHRoYXQgdXNlcyBgd2luZG93LmxvY2F0aW9uLmhhc2hgLlxuICovXG52YXIgSGFzaExvY2F0aW9uID0ge1xuXG4gIGFkZENoYW5nZUxpc3RlbmVyOiBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICBfY2hhbmdlTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgLy8gRG8gdGhpcyBCRUZPUkUgbGlzdGVuaW5nIGZvciBoYXNoY2hhbmdlLlxuICAgIGVuc3VyZVNsYXNoKCk7XG5cbiAgICBpZiAoX2lzTGlzdGVuaW5nKVxuICAgICAgcmV0dXJuO1xuXG4gICAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIG9uSGFzaENoYW5nZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuYXR0YWNoRXZlbnQoJ29uaGFzaGNoYW5nZScsIG9uSGFzaENoYW5nZSk7XG4gICAgfVxuXG4gICAgX2lzTGlzdGVuaW5nID0gdHJ1ZTtcbiAgfSxcblxuICByZW1vdmVDaGFuZ2VMaXN0ZW5lcjogZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IF9jaGFuZ2VMaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbDsgaSArKykge1xuICAgICAgaWYgKF9jaGFuZ2VMaXN0ZW5lcnNbaV0gPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIF9jaGFuZ2VMaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgb25IYXNoQ2hhbmdlLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudCgnb25oYXNoY2hhbmdlJywgb25IYXNoQ2hhbmdlKTtcbiAgICB9XG5cbiAgICBpZiAoX2NoYW5nZUxpc3RlbmVycy5sZW5ndGggPT09IDApXG4gICAgICBfaXNMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgfSxcblxuXG5cbiAgcHVzaDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBfYWN0aW9uVHlwZSA9IExvY2F0aW9uQWN0aW9ucy5QVVNIO1xuICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gUGF0aC5lbmNvZGUocGF0aCk7XG4gIH0sXG5cbiAgcmVwbGFjZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBfYWN0aW9uVHlwZSA9IExvY2F0aW9uQWN0aW9ucy5SRVBMQUNFO1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArICcjJyArIFBhdGguZW5jb2RlKHBhdGgpKTtcbiAgfSxcblxuICBwb3A6IGZ1bmN0aW9uICgpIHtcbiAgICBfYWN0aW9uVHlwZSA9IExvY2F0aW9uQWN0aW9ucy5QT1A7XG4gICAgSGlzdG9yeS5iYWNrKCk7XG4gIH0sXG5cbiAgZ2V0Q3VycmVudFBhdGg6IGdldEhhc2hQYXRoLFxuXG4gIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICc8SGFzaExvY2F0aW9uPic7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoTG9jYXRpb247XG4iLCJ2YXIgTG9jYXRpb25BY3Rpb25zID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9Mb2NhdGlvbkFjdGlvbnMnKTtcbnZhciBIaXN0b3J5ID0gcmVxdWlyZSgnLi4vdXRpbHMvSGlzdG9yeScpO1xudmFyIFBhdGggPSByZXF1aXJlKCcuLi91dGlscy9QYXRoJyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBVUkwgcGF0aCBmcm9tIGB3aW5kb3cubG9jYXRpb25gLCBpbmNsdWRpbmcgcXVlcnkgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3dQYXRoKCkge1xuICByZXR1cm4gUGF0aC5kZWNvZGUoXG4gICAgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaFxuICApO1xufVxuXG52YXIgX2NoYW5nZUxpc3RlbmVycyA9IFtdO1xuXG5mdW5jdGlvbiBub3RpZnlDaGFuZ2UodHlwZSkge1xuICB2YXIgY2hhbmdlID0ge1xuICAgIHBhdGg6IGdldFdpbmRvd1BhdGgoKSxcbiAgICB0eXBlOiB0eXBlXG4gIH07XG5cbiAgX2NoYW5nZUxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgIGxpc3RlbmVyKGNoYW5nZSk7XG4gIH0pO1xufVxuXG52YXIgX2lzTGlzdGVuaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIG9uUG9wU3RhdGUoKSB7XG4gIG5vdGlmeUNoYW5nZShMb2NhdGlvbkFjdGlvbnMuUE9QKTtcbn1cblxuLyoqXG4gKiBBIExvY2F0aW9uIHRoYXQgdXNlcyBIVE1MNSBoaXN0b3J5LlxuICovXG52YXIgSGlzdG9yeUxvY2F0aW9uID0ge1xuXG4gIGFkZENoYW5nZUxpc3RlbmVyOiBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICBfY2hhbmdlTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgaWYgKF9pc0xpc3RlbmluZylcbiAgICAgIHJldHVybjtcblxuICAgIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgb25Qb3BTdGF0ZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuYXR0YWNoRXZlbnQoJ3BvcHN0YXRlJywgb25Qb3BTdGF0ZSk7XG4gICAgfVxuXG4gICAgX2lzTGlzdGVuaW5nID0gdHJ1ZTtcbiAgfSxcblxuICByZW1vdmVDaGFuZ2VMaXN0ZW5lcjogZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IF9jaGFuZ2VMaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbDsgaSArKykge1xuICAgICAgaWYgKF9jaGFuZ2VMaXN0ZW5lcnNbaV0gPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIF9jaGFuZ2VMaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIG9uUG9wU3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnQoJ3BvcHN0YXRlJywgb25Qb3BTdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKF9jaGFuZ2VMaXN0ZW5lcnMubGVuZ3RoID09PSAwKVxuICAgICAgX2lzTGlzdGVuaW5nID0gZmFsc2U7XG4gIH0sXG5cblxuXG4gIHB1c2g6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHsgcGF0aDogcGF0aCB9LCAnJywgUGF0aC5lbmNvZGUocGF0aCkpO1xuICAgIEhpc3RvcnkubGVuZ3RoICs9IDE7XG4gICAgbm90aWZ5Q2hhbmdlKExvY2F0aW9uQWN0aW9ucy5QVVNIKTtcbiAgfSxcblxuICByZXBsYWNlOiBmdW5jdGlvbiAocGF0aCkge1xuICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IHBhdGg6IHBhdGggfSwgJycsIFBhdGguZW5jb2RlKHBhdGgpKTtcbiAgICBub3RpZnlDaGFuZ2UoTG9jYXRpb25BY3Rpb25zLlJFUExBQ0UpO1xuICB9LFxuXG4gIHBvcDogSGlzdG9yeS5iYWNrLFxuXG4gIGdldEN1cnJlbnRQYXRoOiBnZXRXaW5kb3dQYXRoLFxuXG4gIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICc8SGlzdG9yeUxvY2F0aW9uPic7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIaXN0b3J5TG9jYXRpb247XG4iLCJ2YXIgSGlzdG9yeUxvY2F0aW9uID0gcmVxdWlyZSgnLi9IaXN0b3J5TG9jYXRpb24nKTtcbnZhciBIaXN0b3J5ID0gcmVxdWlyZSgnLi4vdXRpbHMvSGlzdG9yeScpO1xudmFyIFBhdGggPSByZXF1aXJlKCcuLi91dGlscy9QYXRoJyk7XG5cbi8qKlxuICogQSBMb2NhdGlvbiB0aGF0IHVzZXMgZnVsbCBwYWdlIHJlZnJlc2hlcy4gVGhpcyBpcyB1c2VkIGFzXG4gKiB0aGUgZmFsbGJhY2sgZm9yIEhpc3RvcnlMb2NhdGlvbiBpbiBicm93c2VycyB0aGF0IGRvIG5vdFxuICogc3VwcG9ydCB0aGUgSFRNTDUgaGlzdG9yeSBBUEkuXG4gKi9cbnZhciBSZWZyZXNoTG9jYXRpb24gPSB7XG5cbiAgcHVzaDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB3aW5kb3cubG9jYXRpb24gPSBQYXRoLmVuY29kZShwYXRoKTtcbiAgfSxcblxuICByZXBsYWNlOiBmdW5jdGlvbiAocGF0aCkge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKFBhdGguZW5jb2RlKHBhdGgpKTtcbiAgfSxcblxuICBwb3A6IEhpc3RvcnkuYmFjayxcblxuICBnZXRDdXJyZW50UGF0aDogSGlzdG9yeUxvY2F0aW9uLmdldEN1cnJlbnRQYXRoLFxuXG4gIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICc8UmVmcmVzaExvY2F0aW9uPic7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWZyZXNoTG9jYXRpb247XG4iLCJ2YXIgaW52YXJpYW50ID0gcmVxdWlyZSgncmVhY3QvbGliL2ludmFyaWFudCcpO1xuXG52YXIgRmFrZU5vZGUgPSB7XG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgZmFsc2UsXG4gICAgICAnJXMgZWxlbWVudHMgc2hvdWxkIG5vdCBiZSByZW5kZXJlZCcsXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lXG4gICAgKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZha2VOb2RlO1xuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBBIG1peGluIGZvciBjb21wb25lbnRzIHRoYXQgbW9kaWZ5IHRoZSBVUkwuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgbWl4aW5zOiBbIFJvdXRlci5OYXZpZ2F0aW9uIF0sXG4gKiAgICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uIChldmVudCkge1xuICogICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAqICAgICAgIHRoaXMudHJhbnNpdGlvblRvKCdhUm91dGUnLCB7IHRoZTogJ3BhcmFtcycgfSwgeyB0aGU6ICdxdWVyeScgfSk7XG4gKiAgICAgfSxcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAqICAgICAgIHJldHVybiAoXG4gKiAgICAgICAgIDxhIG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xpY2t9PkNsaWNrIG1lITwvYT5cbiAqICAgICAgICk7XG4gKiAgICAgfVxuICogICB9KTtcbiAqL1xudmFyIE5hdmlnYXRpb24gPSB7XG5cbiAgY29udGV4dFR5cGVzOiB7XG4gICAgbWFrZVBhdGg6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgbWFrZUhyZWY6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgdHJhbnNpdGlvblRvOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIHJlcGxhY2VXaXRoOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIGdvQmFjazogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFic29sdXRlIFVSTCBwYXRoIGNyZWF0ZWQgZnJvbSB0aGUgZ2l2ZW4gcm91dGVcbiAgICogbmFtZSwgVVJMIHBhcmFtZXRlcnMsIGFuZCBxdWVyeSB2YWx1ZXMuXG4gICAqL1xuICBtYWtlUGF0aDogZnVuY3Rpb24gKHRvLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5tYWtlUGF0aCh0bywgcGFyYW1zLCBxdWVyeSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgdGhhdCBtYXkgc2FmZWx5IGJlIHVzZWQgYXMgdGhlIGhyZWYgb2YgYVxuICAgKiBsaW5rIHRvIHRoZSByb3V0ZSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAgKi9cbiAgbWFrZUhyZWY6IGZ1bmN0aW9uICh0bywgcGFyYW1zLCBxdWVyeSkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQubWFrZUhyZWYodG8sIHBhcmFtcywgcXVlcnkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFuc2l0aW9ucyB0byB0aGUgVVJMIHNwZWNpZmllZCBpbiB0aGUgYXJndW1lbnRzIGJ5IHB1c2hpbmdcbiAgICogYSBuZXcgVVJMIG9udG8gdGhlIGhpc3Rvcnkgc3RhY2suXG4gICAqL1xuICB0cmFuc2l0aW9uVG86IGZ1bmN0aW9uICh0bywgcGFyYW1zLCBxdWVyeSkge1xuICAgIHRoaXMuY29udGV4dC50cmFuc2l0aW9uVG8odG8sIHBhcmFtcywgcXVlcnkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFuc2l0aW9ucyB0byB0aGUgVVJMIHNwZWNpZmllZCBpbiB0aGUgYXJndW1lbnRzIGJ5IHJlcGxhY2luZ1xuICAgKiB0aGUgY3VycmVudCBVUkwgaW4gdGhlIGhpc3Rvcnkgc3RhY2suXG4gICAqL1xuICByZXBsYWNlV2l0aDogZnVuY3Rpb24gKHRvLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgdGhpcy5jb250ZXh0LnJlcGxhY2VXaXRoKHRvLCBwYXJhbXMsIHF1ZXJ5KTtcbiAgfSxcblxuICAvKipcbiAgICogVHJhbnNpdGlvbnMgdG8gdGhlIHByZXZpb3VzIFVSTC5cbiAgICovXG4gIGdvQmFjazogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29udGV4dC5nb0JhY2soKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5hdmlnYXRpb247XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vKipcbiAqIFByb3ZpZGVzIHRoZSByb3V0ZXIgd2l0aCBjb250ZXh0IGZvciBSb3V0ZXIuTmF2aWdhdGlvbi5cbiAqL1xudmFyIE5hdmlnYXRpb25Db250ZXh0ID0ge1xuXG4gIGNoaWxkQ29udGV4dFR5cGVzOiB7XG4gICAgbWFrZVBhdGg6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgbWFrZUhyZWY6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgdHJhbnNpdGlvblRvOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIHJlcGxhY2VXaXRoOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIGdvQmFjazogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICB9LFxuXG4gIGdldENoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYWtlUGF0aDogdGhpcy5jb25zdHJ1Y3Rvci5tYWtlUGF0aCxcbiAgICAgIG1ha2VIcmVmOiB0aGlzLmNvbnN0cnVjdG9yLm1ha2VIcmVmLFxuICAgICAgdHJhbnNpdGlvblRvOiB0aGlzLmNvbnN0cnVjdG9yLnRyYW5zaXRpb25UbyxcbiAgICAgIHJlcGxhY2VXaXRoOiB0aGlzLmNvbnN0cnVjdG9yLnJlcGxhY2VXaXRoLFxuICAgICAgZ29CYWNrOiB0aGlzLmNvbnN0cnVjdG9yLmdvQmFja1xuICAgIH07XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOYXZpZ2F0aW9uQ29udGV4dDtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb250ZXh0VHlwZXM6IHtcbiAgICBnZXRSb3V0ZUF0RGVwdGg6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgZ2V0Um91dGVDb21wb25lbnRzOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIHJvdXRlSGFuZGxlcnM6IFJlYWN0LlByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgY2hpbGRDb250ZXh0VHlwZXM6IHtcbiAgICByb3V0ZUhhbmRsZXJzOiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZFxuICB9LFxuXG4gIGdldENoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3V0ZUhhbmRsZXJzOiB0aGlzLmNvbnRleHQucm91dGVIYW5kbGVycy5jb25jYXQoWyB0aGlzIF0pXG4gICAgfTtcbiAgfSxcblxuICBnZXRSb3V0ZURlcHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5yb3V0ZUhhbmRsZXJzLmxlbmd0aCAtIDE7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl91cGRhdGVSb3V0ZUNvbXBvbmVudCgpO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3VwZGF0ZVJvdXRlQ29tcG9uZW50KCk7XG4gIH0sXG5cbiAgX3VwZGF0ZVJvdXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlcHRoID0gdGhpcy5nZXRSb3V0ZURlcHRoKCk7XG4gICAgdmFyIGNvbXBvbmVudHMgPSB0aGlzLmNvbnRleHQuZ2V0Um91dGVDb21wb25lbnRzKCk7XG4gICAgY29tcG9uZW50c1tkZXB0aF0gPSB0aGlzLnJlZnNbdGhpcy5wcm9wcy5yZWYgfHwgJ19fcm91dGVIYW5kbGVyX18nXTtcbiAgfSxcblxuICBnZXRSb3V0ZUhhbmRsZXI6IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciByb3V0ZSA9IHRoaXMuY29udGV4dC5nZXRSb3V0ZUF0RGVwdGgodGhpcy5nZXRSb3V0ZURlcHRoKCkpO1xuICAgIHJldHVybiByb3V0ZSA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQocm91dGUuaGFuZGxlciwgcHJvcHMgfHwgdGhpcy5wcm9wcykgOiBudWxsO1xuICB9XG59OyIsInZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdyZWFjdC9saWIvaW52YXJpYW50Jyk7XG52YXIgY2FuVXNlRE9NID0gcmVxdWlyZSgncmVhY3QvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50JykuY2FuVXNlRE9NO1xudmFyIGdldFdpbmRvd1Njcm9sbFBvc2l0aW9uID0gcmVxdWlyZSgnLi4vdXRpbHMvZ2V0V2luZG93U2Nyb2xsUG9zaXRpb24nKTtcblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlU2Nyb2xsKHN0YXRlLCBwcmV2U3RhdGUpIHtcbiAgaWYgKCFwcmV2U3RhdGUpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgLy8gRG9uJ3QgdXBkYXRlIHNjcm9sbCBwb3NpdGlvbiB3aGVuIG9ubHkgdGhlIHF1ZXJ5IGhhcyBjaGFuZ2VkLlxuICBpZiAoc3RhdGUucGF0aG5hbWUgPT09IHByZXZTdGF0ZS5wYXRobmFtZSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIHJvdXRlcyA9IHN0YXRlLnJvdXRlcztcbiAgdmFyIHByZXZSb3V0ZXMgPSBwcmV2U3RhdGUucm91dGVzO1xuXG4gIHZhciBzaGFyZWRBbmNlc3RvclJvdXRlcyA9IHJvdXRlcy5maWx0ZXIoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgcmV0dXJuIHByZXZSb3V0ZXMuaW5kZXhPZihyb3V0ZSkgIT09IC0xO1xuICB9KTtcblxuICByZXR1cm4gIXNoYXJlZEFuY2VzdG9yUm91dGVzLnNvbWUoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgcmV0dXJuIHJvdXRlLmlnbm9yZVNjcm9sbEJlaGF2aW9yO1xuICB9KTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyB0aGUgcm91dGVyIHdpdGggdGhlIGFiaWxpdHkgdG8gbWFuYWdlIHdpbmRvdyBzY3JvbGwgcG9zaXRpb25cbiAqIGFjY29yZGluZyB0byBpdHMgc2Nyb2xsIGJlaGF2aW9yLlxuICovXG52YXIgU2Nyb2xsaW5nID0ge1xuXG4gIHN0YXRpY3M6IHtcbiAgICAvKipcbiAgICAgKiBSZWNvcmRzIGN1cmVudCBzY3JvbGwgcG9zaXRpb24gYXMgdGhlIGxhc3Qga25vd24gcG9zaXRpb24gZm9yIHRoZSBnaXZlbiBVUkwgcGF0aC5cbiAgICAgKi9cbiAgICByZWNvcmRTY3JvbGxQb3NpdGlvbjogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIGlmICghdGhpcy5zY3JvbGxIaXN0b3J5KVxuICAgICAgICB0aGlzLnNjcm9sbEhpc3RvcnkgPSB7fTtcblxuICAgICAgdGhpcy5zY3JvbGxIaXN0b3J5W3BhdGhdID0gZ2V0V2luZG93U2Nyb2xsUG9zaXRpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGFzdCBrbm93biBzY3JvbGwgcG9zaXRpb24gZm9yIHRoZSBnaXZlbiBVUkwgcGF0aC5cbiAgICAgKi9cbiAgICBnZXRTY3JvbGxQb3NpdGlvbjogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIGlmICghdGhpcy5zY3JvbGxIaXN0b3J5KVxuICAgICAgICB0aGlzLnNjcm9sbEhpc3RvcnkgPSB7fTtcblxuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsSGlzdG9yeVtwYXRoXSB8fCBudWxsO1xuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICB0aGlzLmdldFNjcm9sbEJlaGF2aW9yKCkgPT0gbnVsbCB8fCBjYW5Vc2VET00sXG4gICAgICAnQ2Fubm90IHVzZSBzY3JvbGwgYmVoYXZpb3Igd2l0aG91dCBhIERPTSdcbiAgICApO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdXBkYXRlU2Nyb2xsKCk7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiAocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICB0aGlzLl91cGRhdGVTY3JvbGwocHJldlN0YXRlKTtcbiAgfSxcblxuICBfdXBkYXRlU2Nyb2xsOiBmdW5jdGlvbiAocHJldlN0YXRlKSB7XG4gICAgaWYgKCFzaG91bGRVcGRhdGVTY3JvbGwodGhpcy5zdGF0ZSwgcHJldlN0YXRlKSlcbiAgICAgIHJldHVybjtcblxuICAgIHZhciBzY3JvbGxCZWhhdmlvciA9IHRoaXMuZ2V0U2Nyb2xsQmVoYXZpb3IoKTtcblxuICAgIGlmIChzY3JvbGxCZWhhdmlvcilcbiAgICAgIHNjcm9sbEJlaGF2aW9yLnVwZGF0ZVNjcm9sbFBvc2l0aW9uKFxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmdldFNjcm9sbFBvc2l0aW9uKHRoaXMuc3RhdGUucGF0aCksXG4gICAgICAgIHRoaXMuc3RhdGUuYWN0aW9uXG4gICAgICApO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2Nyb2xsaW5nO1xuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBBIG1peGluIGZvciBjb21wb25lbnRzIHRoYXQgbmVlZCB0byBrbm93IHRoZSBwYXRoLCByb3V0ZXMsIFVSTFxuICogcGFyYW1zIGFuZCBxdWVyeSB0aGF0IGFyZSBjdXJyZW50bHkgYWN0aXZlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICB2YXIgQWJvdXRMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIG1peGluczogWyBSb3V0ZXIuU3RhdGUgXSxcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAqICAgICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLnByb3BzLmNsYXNzTmFtZTtcbiAqICAgXG4gKiAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSgnYWJvdXQnKSlcbiAqICAgICAgICAgY2xhc3NOYW1lICs9ICcgaXMtYWN0aXZlJztcbiAqICAgXG4gKiAgICAgICByZXR1cm4gUmVhY3QuRE9NLmEoeyBjbGFzc05hbWU6IGNsYXNzTmFtZSB9LCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICovXG52YXIgU3RhdGUgPSB7XG5cbiAgY29udGV4dFR5cGVzOiB7XG4gICAgZ2V0Q3VycmVudFBhdGg6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgZ2V0Q3VycmVudFJvdXRlczogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBnZXRDdXJyZW50UGF0aG5hbWU6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgZ2V0Q3VycmVudFBhcmFtczogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBnZXRDdXJyZW50UXVlcnk6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgaXNBY3RpdmU6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBVUkwgcGF0aC5cbiAgICovXG4gIGdldFBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LmdldEN1cnJlbnRQYXRoKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJvdXRlcyB0aGF0IGFyZSBjdXJyZW50bHkgYWN0aXZlLlxuICAgKi9cbiAgZ2V0Um91dGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRDdXJyZW50Um91dGVzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgVVJMIHBhdGggd2l0aG91dCB0aGUgcXVlcnkgc3RyaW5nLlxuICAgKi9cbiAgZ2V0UGF0aG5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LmdldEN1cnJlbnRQYXRobmFtZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCBvZiB0aGUgVVJMIHBhcmFtcyB0aGF0IGFyZSBjdXJyZW50bHkgYWN0aXZlLlxuICAgKi9cbiAgZ2V0UGFyYW1zOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRDdXJyZW50UGFyYW1zKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IG9mIHRoZSBxdWVyeSBwYXJhbXMgdGhhdCBhcmUgY3VycmVudGx5IGFjdGl2ZS5cbiAgICovXG4gIGdldFF1ZXJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRDdXJyZW50UXVlcnkoKTtcbiAgfSxcblxuICAvKipcbiAgICogQSBoZWxwZXIgbWV0aG9kIHRvIGRldGVybWluZSBpZiBhIGdpdmVuIHJvdXRlLCBwYXJhbXMsIGFuZCBxdWVyeVxuICAgKiBhcmUgYWN0aXZlLlxuICAgKi9cbiAgaXNBY3RpdmU6IGZ1bmN0aW9uICh0bywgcGFyYW1zLCBxdWVyeSkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuaXNBY3RpdmUodG8sIHBhcmFtcywgcXVlcnkpO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGU7XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9PYmplY3QuYXNzaWduJyk7XG52YXIgUGF0aCA9IHJlcXVpcmUoJy4uL3V0aWxzL1BhdGgnKTtcblxuZnVuY3Rpb24gcm91dGVJc0FjdGl2ZShhY3RpdmVSb3V0ZXMsIHJvdXRlTmFtZSkge1xuICByZXR1cm4gYWN0aXZlUm91dGVzLnNvbWUoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgcmV0dXJuIHJvdXRlLm5hbWUgPT09IHJvdXRlTmFtZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhcmFtc0FyZUFjdGl2ZShhY3RpdmVQYXJhbXMsIHBhcmFtcykge1xuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBwYXJhbXMpXG4gICAgaWYgKFN0cmluZyhhY3RpdmVQYXJhbXNbcHJvcGVydHldKSAhPT0gU3RyaW5nKHBhcmFtc1twcm9wZXJ0eV0pKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBxdWVyeUlzQWN0aXZlKGFjdGl2ZVF1ZXJ5LCBxdWVyeSkge1xuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBxdWVyeSlcbiAgICBpZiAoU3RyaW5nKGFjdGl2ZVF1ZXJ5W3Byb3BlcnR5XSkgIT09IFN0cmluZyhxdWVyeVtwcm9wZXJ0eV0pKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIHRoZSByb3V0ZXIgd2l0aCBjb250ZXh0IGZvciBSb3V0ZXIuU3RhdGUuXG4gKi9cbnZhciBTdGF0ZUNvbnRleHQgPSB7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgVVJMIHBhdGggKyBxdWVyeSBzdHJpbmcuXG4gICAqL1xuICBnZXRDdXJyZW50UGF0aDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnBhdGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSByZWFkLW9ubHkgYXJyYXkgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgcm91dGVzLlxuICAgKi9cbiAgZ2V0Q3VycmVudFJvdXRlczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnJvdXRlcy5zbGljZSgwKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBVUkwgcGF0aCB3aXRob3V0IHRoZSBxdWVyeSBzdHJpbmcuXG4gICAqL1xuICBnZXRDdXJyZW50UGF0aG5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5wYXRobmFtZTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHJlYWQtb25seSBvYmplY3Qgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgVVJMIHBhcmFtZXRlcnMuXG4gICAqL1xuICBnZXRDdXJyZW50UGFyYW1zOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFzc2lnbih7fSwgdGhpcy5zdGF0ZS5wYXJhbXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcmVhZC1vbmx5IG9iamVjdCBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBxdWVyeSBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgZ2V0Q3VycmVudFF1ZXJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFzc2lnbih7fSwgdGhpcy5zdGF0ZS5xdWVyeSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcm91dGUsIHBhcmFtcywgYW5kIHF1ZXJ5IGFyZSBhY3RpdmUuXG4gICAqL1xuICBpc0FjdGl2ZTogZnVuY3Rpb24gKHRvLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgaWYgKFBhdGguaXNBYnNvbHV0ZSh0bykpXG4gICAgICByZXR1cm4gdG8gPT09IHRoaXMuc3RhdGUucGF0aDtcblxuICAgIHJldHVybiByb3V0ZUlzQWN0aXZlKHRoaXMuc3RhdGUucm91dGVzLCB0bykgJiZcbiAgICAgIHBhcmFtc0FyZUFjdGl2ZSh0aGlzLnN0YXRlLnBhcmFtcywgcGFyYW1zKSAmJlxuICAgICAgKHF1ZXJ5ID09IG51bGwgfHwgcXVlcnlJc0FjdGl2ZSh0aGlzLnN0YXRlLnF1ZXJ5LCBxdWVyeSkpO1xuICB9LFxuXG4gIGNoaWxkQ29udGV4dFR5cGVzOiB7XG4gICAgZ2V0Q3VycmVudFBhdGg6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgZ2V0Q3VycmVudFJvdXRlczogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBnZXRDdXJyZW50UGF0aG5hbWU6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgZ2V0Q3VycmVudFBhcmFtczogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBnZXRDdXJyZW50UXVlcnk6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgaXNBY3RpdmU6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgfSxcblxuICBnZXRDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0Q3VycmVudFBhdGg6IHRoaXMuZ2V0Q3VycmVudFBhdGgsXG4gICAgICBnZXRDdXJyZW50Um91dGVzOiB0aGlzLmdldEN1cnJlbnRSb3V0ZXMsXG4gICAgICBnZXRDdXJyZW50UGF0aG5hbWU6IHRoaXMuZ2V0Q3VycmVudFBhdGhuYW1lLFxuICAgICAgZ2V0Q3VycmVudFBhcmFtczogdGhpcy5nZXRDdXJyZW50UGFyYW1zLFxuICAgICAgZ2V0Q3VycmVudFF1ZXJ5OiB0aGlzLmdldEN1cnJlbnRRdWVyeSxcbiAgICAgIGlzQWN0aXZlOiB0aGlzLmlzQWN0aXZlXG4gICAgfTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlQ29udGV4dDtcbiIsIi8qKlxuICogUmVwcmVzZW50cyBhIGNhbmNlbGxhdGlvbiBjYXVzZWQgYnkgbmF2aWdhdGluZyBhd2F5XG4gKiBiZWZvcmUgdGhlIHByZXZpb3VzIHRyYW5zaXRpb24gaGFzIGZ1bGx5IHJlc29sdmVkLlxuICovXG5mdW5jdGlvbiBDYW5jZWxsYXRpb24oKSB7IH1cblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxsYXRpb247XG4iLCJ2YXIgaW52YXJpYW50ID0gcmVxdWlyZSgncmVhY3QvbGliL2ludmFyaWFudCcpO1xudmFyIGNhblVzZURPTSA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpLmNhblVzZURPTTtcblxudmFyIEhpc3RvcnkgPSB7XG5cbiAgLyoqXG4gICAqIFNlbmRzIHRoZSBicm93c2VyIGJhY2sgb25lIGVudHJ5IGluIHRoZSBoaXN0b3J5LlxuICAgKi9cbiAgYmFjazogZnVuY3Rpb24gKCkge1xuICAgIGludmFyaWFudChcbiAgICAgIGNhblVzZURPTSxcbiAgICAgICdDYW5ub3QgdXNlIEhpc3RvcnkuYmFjayB3aXRob3V0IGEgRE9NJ1xuICAgICk7XG5cbiAgICAvLyBEbyB0aGlzIGZpcnN0IHNvIHRoYXQgSGlzdG9yeS5sZW5ndGggd2lsbFxuICAgIC8vIGJlIGFjY3VyYXRlIGluIGxvY2F0aW9uIGNoYW5nZSBsaXN0ZW5lcnMuXG4gICAgSGlzdG9yeS5sZW5ndGggLT0gMTtcblxuICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKTtcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIGhpc3RvcnkuXG4gICAqL1xuICBsZW5ndGg6IDFcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIaXN0b3J5O1xuIiwidmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9pbnZhcmlhbnQnKTtcbnZhciBtZXJnZSA9IHJlcXVpcmUoJ3FzL2xpYi91dGlscycpLm1lcmdlO1xudmFyIHFzID0gcmVxdWlyZSgncXMnKTtcblxudmFyIHBhcmFtQ29tcGlsZU1hdGNoZXIgPSAvOihbYS16QS1aXyRdW2EtekEtWjAtOV8kXSopfFsqLigpXFxbXFxdXFxcXCt8e31eJF0vZztcbnZhciBwYXJhbUluamVjdE1hdGNoZXIgPSAvOihbYS16QS1aXyRdW2EtekEtWjAtOV8kP10qWz9dPyl8WypdL2c7XG52YXIgcGFyYW1JbmplY3RUcmFpbGluZ1NsYXNoTWF0Y2hlciA9IC9cXC9cXC9cXD98XFwvXFw/L2c7XG52YXIgcXVlcnlNYXRjaGVyID0gL1xcPyguKykvO1xuXG52YXIgX2NvbXBpbGVkUGF0dGVybnMgPSB7fTtcblxuZnVuY3Rpb24gY29tcGlsZVBhdHRlcm4ocGF0dGVybikge1xuICBpZiAoIShwYXR0ZXJuIGluIF9jb21waWxlZFBhdHRlcm5zKSkge1xuICAgIHZhciBwYXJhbU5hbWVzID0gW107XG4gICAgdmFyIHNvdXJjZSA9IHBhdHRlcm4ucmVwbGFjZShwYXJhbUNvbXBpbGVNYXRjaGVyLCBmdW5jdGlvbiAobWF0Y2gsIHBhcmFtTmFtZSkge1xuICAgICAgaWYgKHBhcmFtTmFtZSkge1xuICAgICAgICBwYXJhbU5hbWVzLnB1c2gocGFyYW1OYW1lKTtcbiAgICAgICAgcmV0dXJuICcoW14vPyNdKyknO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaCA9PT0gJyonKSB7XG4gICAgICAgIHBhcmFtTmFtZXMucHVzaCgnc3BsYXQnKTtcbiAgICAgICAgcmV0dXJuICcoLio/KSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ1xcXFwnICsgbWF0Y2g7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfY29tcGlsZWRQYXR0ZXJuc1twYXR0ZXJuXSA9IHtcbiAgICAgIG1hdGNoZXI6IG5ldyBSZWdFeHAoJ14nICsgc291cmNlICsgJyQnLCAnaScpLFxuICAgICAgcGFyYW1OYW1lczogcGFyYW1OYW1lc1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2NvbXBpbGVkUGF0dGVybnNbcGF0dGVybl07XG59XG5cbnZhciBQYXRoID0ge1xuXG4gIC8qKlxuICAgKiBTYWZlbHkgZGVjb2RlcyBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIFVSTCBwYXRoLlxuICAgKi9cbiAgZGVjb2RlOiBmdW5jdGlvbiAocGF0aCkge1xuICAgIHJldHVybiBkZWNvZGVVUkkocGF0aC5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhZmVseSBlbmNvZGVzIHNwZWNpYWwgY2hhcmFjdGVycyBpbiB0aGUgZ2l2ZW4gVVJMIHBhdGguXG4gICAqL1xuICBlbmNvZGU6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSShwYXRoKS5yZXBsYWNlKC8lMjAvZywgJysnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgbmFtZXMgb2YgYWxsIHBhcmFtZXRlcnMgaW4gdGhlIGdpdmVuIHBhdHRlcm4uXG4gICAqL1xuICBleHRyYWN0UGFyYW1OYW1lczogZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gY29tcGlsZVBhdHRlcm4ocGF0dGVybikucGFyYW1OYW1lcztcbiAgfSxcblxuICAvKipcbiAgICogRXh0cmFjdHMgdGhlIHBvcnRpb25zIG9mIHRoZSBnaXZlbiBVUkwgcGF0aCB0aGF0IG1hdGNoIHRoZSBnaXZlbiBwYXR0ZXJuXG4gICAqIGFuZCByZXR1cm5zIGFuIG9iamVjdCBvZiBwYXJhbSBuYW1lID0+IHZhbHVlIHBhaXJzLiBSZXR1cm5zIG51bGwgaWYgdGhlXG4gICAqIHBhdHRlcm4gZG9lcyBub3QgbWF0Y2ggdGhlIGdpdmVuIHBhdGguXG4gICAqL1xuICBleHRyYWN0UGFyYW1zOiBmdW5jdGlvbiAocGF0dGVybiwgcGF0aCkge1xuICAgIHZhciBvYmplY3QgPSBjb21waWxlUGF0dGVybihwYXR0ZXJuKTtcbiAgICB2YXIgbWF0Y2ggPSBwYXRoLm1hdGNoKG9iamVjdC5tYXRjaGVyKTtcblxuICAgIGlmICghbWF0Y2gpXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIHZhciBwYXJhbXMgPSB7fTtcblxuICAgIG9iamVjdC5wYXJhbU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtTmFtZSwgaW5kZXgpIHtcbiAgICAgIHBhcmFtc1twYXJhbU5hbWVdID0gbWF0Y2hbaW5kZXggKyAxXTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2ZXJzaW9uIG9mIHRoZSBnaXZlbiByb3V0ZSBwYXRoIHdpdGggcGFyYW1zIGludGVycG9sYXRlZC4gVGhyb3dzXG4gICAqIGlmIHRoZXJlIGlzIGEgZHluYW1pYyBzZWdtZW50IG9mIHRoZSByb3V0ZSBwYXRoIGZvciB3aGljaCB0aGVyZSBpcyBubyBwYXJhbS5cbiAgICovXG4gIGluamVjdFBhcmFtczogZnVuY3Rpb24gKHBhdHRlcm4sIHBhcmFtcykge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICAgIHZhciBzcGxhdEluZGV4ID0gMDtcblxuICAgIHJldHVybiBwYXR0ZXJuLnJlcGxhY2UocGFyYW1JbmplY3RNYXRjaGVyLCBmdW5jdGlvbiAobWF0Y2gsIHBhcmFtTmFtZSkge1xuICAgICAgcGFyYW1OYW1lID0gcGFyYW1OYW1lIHx8ICdzcGxhdCc7XG5cbiAgICAgIC8vIElmIHBhcmFtIGlzIG9wdGlvbmFsIGRvbid0IGNoZWNrIGZvciBleGlzdGVuY2VcbiAgICAgIGlmIChwYXJhbU5hbWUuc2xpY2UoLTEpICE9PSAnPycpIHtcbiAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgIHBhcmFtc1twYXJhbU5hbWVdICE9IG51bGwsXG4gICAgICAgICAgJ01pc3NpbmcgXCInICsgcGFyYW1OYW1lICsgJ1wiIHBhcmFtZXRlciBmb3IgcGF0aCBcIicgKyBwYXR0ZXJuICsgJ1wiJ1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1OYW1lID0gcGFyYW1OYW1lLnNsaWNlKDAsIC0xKTtcblxuICAgICAgICBpZiAocGFyYW1zW3BhcmFtTmFtZV0gPT0gbnVsbClcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWdtZW50O1xuICAgICAgaWYgKHBhcmFtTmFtZSA9PT0gJ3NwbGF0JyAmJiBBcnJheS5pc0FycmF5KHBhcmFtc1twYXJhbU5hbWVdKSkge1xuICAgICAgICBzZWdtZW50ID0gcGFyYW1zW3BhcmFtTmFtZV1bc3BsYXRJbmRleCsrXTtcblxuICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgc2VnbWVudCAhPSBudWxsLFxuICAgICAgICAgICdNaXNzaW5nIHNwbGF0ICMgJyArIHNwbGF0SW5kZXggKyAnIGZvciBwYXRoIFwiJyArIHBhdHRlcm4gKyAnXCInXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWdtZW50ID0gcGFyYW1zW3BhcmFtTmFtZV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWdtZW50O1xuICAgIH0pLnJlcGxhY2UocGFyYW1JbmplY3RUcmFpbGluZ1NsYXNoTWF0Y2hlciwgJy8nKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBpcyB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgYW55IHF1ZXJ5IHN0cmluZyBjb250YWluZWRcbiAgICogaW4gdGhlIGdpdmVuIHBhdGgsIG51bGwgaWYgdGhlIHBhdGggY29udGFpbnMgbm8gcXVlcnkgc3RyaW5nLlxuICAgKi9cbiAgZXh0cmFjdFF1ZXJ5OiBmdW5jdGlvbiAocGF0aCkge1xuICAgIHZhciBtYXRjaCA9IHBhdGgubWF0Y2gocXVlcnlNYXRjaGVyKTtcbiAgICByZXR1cm4gbWF0Y2ggJiYgcXMucGFyc2UobWF0Y2hbMV0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gcGF0aCB3aXRob3V0IHRoZSBxdWVyeSBzdHJpbmcuXG4gICAqL1xuICB3aXRob3V0UXVlcnk6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZShxdWVyeU1hdGNoZXIsICcnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZlcnNpb24gb2YgdGhlIGdpdmVuIHBhdGggd2l0aCB0aGUgcGFyYW1ldGVycyBpbiB0aGUgZ2l2ZW5cbiAgICogcXVlcnkgbWVyZ2VkIGludG8gdGhlIHF1ZXJ5IHN0cmluZy5cbiAgICovXG4gIHdpdGhRdWVyeTogZnVuY3Rpb24gKHBhdGgsIHF1ZXJ5KSB7XG4gICAgdmFyIGV4aXN0aW5nUXVlcnkgPSBQYXRoLmV4dHJhY3RRdWVyeShwYXRoKTtcblxuICAgIGlmIChleGlzdGluZ1F1ZXJ5KVxuICAgICAgcXVlcnkgPSBxdWVyeSA/IG1lcmdlKGV4aXN0aW5nUXVlcnksIHF1ZXJ5KSA6IGV4aXN0aW5nUXVlcnk7XG5cbiAgICB2YXIgcXVlcnlTdHJpbmcgPSBxdWVyeSAmJiBxcy5zdHJpbmdpZnkocXVlcnkpO1xuXG4gICAgaWYgKHF1ZXJ5U3RyaW5nKVxuICAgICAgcmV0dXJuIFBhdGgud2l0aG91dFF1ZXJ5KHBhdGgpICsgJz8nICsgcXVlcnlTdHJpbmc7XG5cbiAgICByZXR1cm4gcGF0aDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwYXRoIGlzIGFic29sdXRlLlxuICAgKi9cbiAgaXNBYnNvbHV0ZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gcGF0aC5cbiAgICovXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gKHBhdGgsIHBhcmVudFJvdXRlKSB7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXlxcLyovLCAnLycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBKb2lucyB0d28gVVJMIHBhdGhzIHRvZ2V0aGVyLlxuICAgKi9cbiAgam9pbjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS5yZXBsYWNlKC9cXC8qJC8sICcvJykgKyBiO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGF0aDtcbiIsInZhciBQcm9taXNlID0gcmVxdWlyZSgnd2hlbi9saWIvUHJvbWlzZScpO1xuXG4vLyBUT0RPOiBVc2UgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgY2hlY2sgKyBlbnZpZnkgdG8gZW5hYmxlXG4vLyB3aGVuJ3MgcHJvbWlzZSBtb25pdG9yIGhlcmUgd2hlbiBpbiBkZXYuXG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbiIsInZhciBQcm9wVHlwZXMgPSB7XG5cbiAgLyoqXG4gICAqIFJlcXVpcmVzIHRoYXQgdGhlIHZhbHVlIG9mIGEgcHJvcCBiZSBmYWxzeS5cbiAgICovXG4gIGZhbHN5OiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSlcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJzwnICsgY29tcG9uZW50TmFtZSArICc+IG1heSBub3QgaGF2ZSBhIFwiJyArIHByb3BOYW1lICsgJ1wiIHByb3AnKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb3BUeXBlcztcbiIsIi8qKlxuICogRW5jYXBzdWxhdGVzIGEgcmVkaXJlY3QgdG8gdGhlIGdpdmVuIHJvdXRlLlxuICovXG5mdW5jdGlvbiBSZWRpcmVjdCh0bywgcGFyYW1zLCBxdWVyeSkge1xuICB0aGlzLnRvID0gdG87XG4gIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVkaXJlY3Q7XG4iLCJ2YXIgYXNzaWduID0gcmVxdWlyZSgncmVhY3QvbGliL09iamVjdC5hc3NpZ24nKTtcbnZhciByZXZlcnNlZEFycmF5ID0gcmVxdWlyZSgnLi9yZXZlcnNlZEFycmF5Jyk7XG52YXIgUmVkaXJlY3QgPSByZXF1aXJlKCcuL1JlZGlyZWN0Jyk7XG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vUHJvbWlzZScpO1xuXG4vKipcbiAqIFJ1bnMgYWxsIGhvb2sgZnVuY3Rpb25zIHNlcmlhbGx5IGFuZCBjYWxscyBjYWxsYmFjayhlcnJvcikgd2hlbiBmaW5pc2hlZC5cbiAqIEEgaG9vayBtYXkgcmV0dXJuIGEgcHJvbWlzZSBpZiBpdCBuZWVkcyB0byBleGVjdXRlIGFzeW5jaHJvbm91c2x5LlxuICovXG5mdW5jdGlvbiBydW5Ib29rcyhob29rcywgY2FsbGJhY2spIHtcbiAgdmFyIHByb21pc2U7XG4gIHRyeSB7XG4gICAgcHJvbWlzZSA9IGhvb2tzLnJlZHVjZShmdW5jdGlvbiAocHJvbWlzZSwgaG9vaykge1xuICAgICAgLy8gVGhlIGZpcnN0IGhvb2sgdG8gdXNlIHRyYW5zaXRpb24ud2FpdCBtYWtlcyB0aGUgcmVzdFxuICAgICAgLy8gb2YgdGhlIHRyYW5zaXRpb24gYXN5bmMgZnJvbSB0aGF0IHBvaW50IGZvcndhcmQuXG4gICAgICByZXR1cm4gcHJvbWlzZSA/IHByb21pc2UudGhlbihob29rKSA6IGhvb2soKTtcbiAgICB9LCBudWxsKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IpOyAvLyBTeW5jIGVycm9yLlxuICB9XG5cbiAgaWYgKHByb21pc2UpIHtcbiAgICAvLyBVc2Ugc2V0VGltZW91dCB0byBicmVhayB0aGUgcHJvbWlzZSBjaGFpbi5cbiAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChjYWxsYmFjayk7XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuXG4vKipcbiAqIENhbGxzIHRoZSB3aWxsVHJhbnNpdGlvbkZyb20gaG9vayBvZiBhbGwgaGFuZGxlcnMgaW4gdGhlIGdpdmVuIG1hdGNoZXNcbiAqIHNlcmlhbGx5IGluIHJldmVyc2Ugd2l0aCB0aGUgdHJhbnNpdGlvbiBvYmplY3QgYW5kIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mXG4gKiB0aGUgcm91dGUncyBoYW5kbGVyLCBzbyB0aGF0IHRoZSBkZWVwZXN0IG5lc3RlZCBoYW5kbGVycyBhcmUgY2FsbGVkIGZpcnN0LlxuICogQ2FsbHMgY2FsbGJhY2soZXJyb3IpIHdoZW4gZmluaXNoZWQuXG4gKi9cbmZ1bmN0aW9uIHJ1blRyYW5zaXRpb25Gcm9tSG9va3ModHJhbnNpdGlvbiwgcm91dGVzLCBjb21wb25lbnRzLCBjYWxsYmFjaykge1xuICBjb21wb25lbnRzID0gcmV2ZXJzZWRBcnJheShjb21wb25lbnRzKTtcblxuICB2YXIgaG9va3MgPSByZXZlcnNlZEFycmF5KHJvdXRlcykubWFwKGZ1bmN0aW9uIChyb3V0ZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGhhbmRsZXIgPSByb3V0ZS5oYW5kbGVyO1xuXG4gICAgICBpZiAoIXRyYW5zaXRpb24uaXNBYm9ydGVkICYmIGhhbmRsZXIud2lsbFRyYW5zaXRpb25Gcm9tKVxuICAgICAgICByZXR1cm4gaGFuZGxlci53aWxsVHJhbnNpdGlvbkZyb20odHJhbnNpdGlvbiwgY29tcG9uZW50c1tpbmRleF0pO1xuXG4gICAgICB2YXIgcHJvbWlzZSA9IHRyYW5zaXRpb24uX3Byb21pc2U7XG4gICAgICB0cmFuc2l0aW9uLl9wcm9taXNlID0gbnVsbDtcblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcbiAgfSk7XG5cbiAgcnVuSG9va3MoaG9va3MsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBDYWxscyB0aGUgd2lsbFRyYW5zaXRpb25UbyBob29rIG9mIGFsbCBoYW5kbGVycyBpbiB0aGUgZ2l2ZW4gbWF0Y2hlc1xuICogc2VyaWFsbHkgd2l0aCB0aGUgdHJhbnNpdGlvbiBvYmplY3QgYW5kIGFueSBwYXJhbXMgdGhhdCBhcHBseSB0byB0aGF0XG4gKiBoYW5kbGVyLiBDYWxscyBjYWxsYmFjayhlcnJvcikgd2hlbiBmaW5pc2hlZC5cbiAqL1xuZnVuY3Rpb24gcnVuVHJhbnNpdGlvblRvSG9va3ModHJhbnNpdGlvbiwgcm91dGVzLCBwYXJhbXMsIHF1ZXJ5LCBjYWxsYmFjaykge1xuICB2YXIgaG9va3MgPSByb3V0ZXMubWFwKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IHJvdXRlLmhhbmRsZXI7XG5cbiAgICAgIGlmICghdHJhbnNpdGlvbi5pc0Fib3J0ZWQgJiYgaGFuZGxlci53aWxsVHJhbnNpdGlvblRvKVxuICAgICAgICBoYW5kbGVyLndpbGxUcmFuc2l0aW9uVG8odHJhbnNpdGlvbiwgcGFyYW1zLCBxdWVyeSk7XG5cbiAgICAgIHZhciBwcm9taXNlID0gdHJhbnNpdGlvbi5fcHJvbWlzZTtcbiAgICAgIHRyYW5zaXRpb24uX3Byb21pc2UgPSBudWxsO1xuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuICB9KTtcblxuICBydW5Ib29rcyhob29rcywgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIEVuY2Fwc3VsYXRlcyBhIHRyYW5zaXRpb24gdG8gYSBnaXZlbiBwYXRoLlxuICpcbiAqIFRoZSB3aWxsVHJhbnNpdGlvblRvIGFuZCB3aWxsVHJhbnNpdGlvbkZyb20gaGFuZGxlcnMgcmVjZWl2ZVxuICogYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBhcyB0aGVpciBmaXJzdCBhcmd1bWVudC5cbiAqL1xuZnVuY3Rpb24gVHJhbnNpdGlvbihwYXRoLCByZXRyeSkge1xuICB0aGlzLnBhdGggPSBwYXRoO1xuICB0aGlzLmFib3J0UmVhc29uID0gbnVsbDtcbiAgdGhpcy5pc0Fib3J0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZXRyeSA9IHJldHJ5LmJpbmQodGhpcyk7XG4gIHRoaXMuX3Byb21pc2UgPSBudWxsO1xufVxuXG5hc3NpZ24oVHJhbnNpdGlvbi5wcm90b3R5cGUsIHtcblxuICBhYm9ydDogZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIGlmICh0aGlzLmlzQWJvcnRlZCkge1xuICAgICAgLy8gRmlyc3QgYWJvcnQgd2lucy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmFib3J0UmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMuaXNBYm9ydGVkID0gdHJ1ZTtcbiAgfSxcblxuICByZWRpcmVjdDogZnVuY3Rpb24gKHRvLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgdGhpcy5hYm9ydChuZXcgUmVkaXJlY3QodG8sIHBhcmFtcywgcXVlcnkpKTtcbiAgfSxcblxuICB3YWl0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLl9wcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcbiAgfSxcblxuICBmcm9tOiBmdW5jdGlvbiAocm91dGVzLCBjb21wb25lbnRzLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBydW5UcmFuc2l0aW9uRnJvbUhvb2tzKHRoaXMsIHJvdXRlcywgY29tcG9uZW50cywgY2FsbGJhY2spO1xuICB9LFxuXG4gIHRvOiBmdW5jdGlvbiAocm91dGVzLCBwYXJhbXMsIHF1ZXJ5LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBydW5UcmFuc2l0aW9uVG9Ib29rcyh0aGlzLCByb3V0ZXMsIHBhcmFtcywgcXVlcnksIGNhbGxiYWNrKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2l0aW9uO1xuIiwiLyoganNoaW50IC1XMDU4ICovXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdyZWFjdC9saWIvd2FybmluZycpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9pbnZhcmlhbnQnKTtcbnZhciBjYW5Vc2VET00gPSByZXF1aXJlKCdyZWFjdC9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKS5jYW5Vc2VET007XG52YXIgSW1pdGF0ZUJyb3dzZXJCZWhhdmlvciA9IHJlcXVpcmUoJy4uL2JlaGF2aW9ycy9JbWl0YXRlQnJvd3NlckJlaGF2aW9yJyk7XG52YXIgUm91dGVIYW5kbGVyID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9Sb3V0ZUhhbmRsZXInKTtcbnZhciBMb2NhdGlvbkFjdGlvbnMgPSByZXF1aXJlKCcuLi9hY3Rpb25zL0xvY2F0aW9uQWN0aW9ucycpO1xudmFyIEhhc2hMb2NhdGlvbiA9IHJlcXVpcmUoJy4uL2xvY2F0aW9ucy9IYXNoTG9jYXRpb24nKTtcbnZhciBIaXN0b3J5TG9jYXRpb24gPSByZXF1aXJlKCcuLi9sb2NhdGlvbnMvSGlzdG9yeUxvY2F0aW9uJyk7XG52YXIgUmVmcmVzaExvY2F0aW9uID0gcmVxdWlyZSgnLi4vbG9jYXRpb25zL1JlZnJlc2hMb2NhdGlvbicpO1xudmFyIE5hdmlnYXRpb25Db250ZXh0ID0gcmVxdWlyZSgnLi4vbWl4aW5zL05hdmlnYXRpb25Db250ZXh0Jyk7XG52YXIgU3RhdGVDb250ZXh0ID0gcmVxdWlyZSgnLi4vbWl4aW5zL1N0YXRlQ29udGV4dCcpO1xudmFyIFNjcm9sbGluZyA9IHJlcXVpcmUoJy4uL21peGlucy9TY3JvbGxpbmcnKTtcbnZhciBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4gPSByZXF1aXJlKCcuL2NyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbicpO1xudmFyIHN1cHBvcnRzSGlzdG9yeSA9IHJlcXVpcmUoJy4vc3VwcG9ydHNIaXN0b3J5Jyk7XG52YXIgVHJhbnNpdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNpdGlvbicpO1xudmFyIFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vUHJvcFR5cGVzJyk7XG52YXIgUmVkaXJlY3QgPSByZXF1aXJlKCcuL1JlZGlyZWN0Jyk7XG52YXIgSGlzdG9yeSA9IHJlcXVpcmUoJy4vSGlzdG9yeScpO1xudmFyIENhbmNlbGxhdGlvbiA9IHJlcXVpcmUoJy4vQ2FuY2VsbGF0aW9uJyk7XG52YXIgUGF0aCA9IHJlcXVpcmUoJy4vUGF0aCcpO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGxvY2F0aW9uIGZvciBuZXcgcm91dGVycy5cbiAqL1xudmFyIERFRkFVTFRfTE9DQVRJT04gPSBjYW5Vc2VET00gPyBIYXNoTG9jYXRpb24gOiAnLyc7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgc2Nyb2xsIGJlaGF2aW9yIGZvciBuZXcgcm91dGVycy5cbiAqL1xudmFyIERFRkFVTFRfU0NST0xMX0JFSEFWSU9SID0gY2FuVXNlRE9NID8gSW1pdGF0ZUJyb3dzZXJCZWhhdmlvciA6IG51bGw7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgZXJyb3IgaGFuZGxlciBmb3IgbmV3IHJvdXRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRFcnJvckhhbmRsZXIoZXJyb3IpIHtcbiAgLy8gVGhyb3cgc28gd2UgZG9uJ3Qgc2lsZW50bHkgc3dhbGxvdyBhc3luYyBlcnJvcnMuXG4gIHRocm93IGVycm9yOyAvLyBUaGlzIGVycm9yIHByb2JhYmx5IG9yaWdpbmF0ZWQgaW4gYSB0cmFuc2l0aW9uIGhvb2suXG59XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgYWJvcnRlZCB0cmFuc2l0aW9uIGhhbmRsZXIgZm9yIG5ldyByb3V0ZXJzLlxuICovXG5mdW5jdGlvbiBkZWZhdWx0QWJvcnRIYW5kbGVyKGFib3J0UmVhc29uLCBsb2NhdGlvbikge1xuICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBhYm9ydGVkIHRyYW5zaXRpb24hIFJlYXNvbjogJyArIGFib3J0UmVhc29uKTtcblxuICBpZiAoYWJvcnRSZWFzb24gaW5zdGFuY2VvZiBDYW5jZWxsYXRpb24pIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoYWJvcnRSZWFzb24gaW5zdGFuY2VvZiBSZWRpcmVjdCkge1xuICAgIGxvY2F0aW9uLnJlcGxhY2UodGhpcy5tYWtlUGF0aChhYm9ydFJlYXNvbi50bywgYWJvcnRSZWFzb24ucGFyYW1zLCBhYm9ydFJlYXNvbi5xdWVyeSkpO1xuICB9IGVsc2Uge1xuICAgIGxvY2F0aW9uLnBvcCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRNYXRjaChwYXRobmFtZSwgcm91dGVzLCBkZWZhdWx0Um91dGUsIG5vdEZvdW5kUm91dGUpIHtcbiAgdmFyIG1hdGNoLCByb3V0ZSwgcGFyYW1zO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSByb3V0ZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICByb3V0ZSA9IHJvdXRlc1tpXTtcblxuICAgIC8vIENoZWNrIHRoZSBzdWJ0cmVlIGZpcnN0IHRvIGZpbmQgdGhlIG1vc3QgZGVlcGx5LW5lc3RlZCBtYXRjaC5cbiAgICBtYXRjaCA9IGZpbmRNYXRjaChwYXRobmFtZSwgcm91dGUuY2hpbGRSb3V0ZXMsIHJvdXRlLmRlZmF1bHRSb3V0ZSwgcm91dGUubm90Rm91bmRSb3V0ZSk7XG5cbiAgICBpZiAobWF0Y2ggIT0gbnVsbCkge1xuICAgICAgbWF0Y2gucm91dGVzLnVuc2hpZnQocm91dGUpO1xuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cblxuICAgIC8vIE5vIHJvdXRlcyBpbiB0aGUgc3VidHJlZSBtYXRjaGVkLCBzbyBjaGVjayB0aGlzIHJvdXRlLlxuICAgIHBhcmFtcyA9IFBhdGguZXh0cmFjdFBhcmFtcyhyb3V0ZS5wYXRoLCBwYXRobmFtZSk7XG5cbiAgICBpZiAocGFyYW1zKVxuICAgICAgcmV0dXJuIGNyZWF0ZU1hdGNoKHJvdXRlLCBwYXJhbXMpO1xuICB9XG5cbiAgLy8gTm8gcm91dGVzIG1hdGNoZWQsIHNvIHRyeSB0aGUgZGVmYXVsdCByb3V0ZSBpZiB0aGVyZSBpcyBvbmUuXG4gIGlmIChkZWZhdWx0Um91dGUgJiYgKHBhcmFtcyA9IFBhdGguZXh0cmFjdFBhcmFtcyhkZWZhdWx0Um91dGUucGF0aCwgcGF0aG5hbWUpKSlcbiAgICByZXR1cm4gY3JlYXRlTWF0Y2goZGVmYXVsdFJvdXRlLCBwYXJhbXMpO1xuXG4gIC8vIExhc3QgYXR0ZW1wdDogZG9lcyB0aGUgXCJub3QgZm91bmRcIiByb3V0ZSBtYXRjaD9cbiAgaWYgKG5vdEZvdW5kUm91dGUgJiYgKHBhcmFtcyA9IFBhdGguZXh0cmFjdFBhcmFtcyhub3RGb3VuZFJvdXRlLnBhdGgsIHBhdGhuYW1lKSkpXG4gICAgcmV0dXJuIGNyZWF0ZU1hdGNoKG5vdEZvdW5kUm91dGUsIHBhcmFtcyk7XG5cbiAgcmV0dXJuIG1hdGNoO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNYXRjaChyb3V0ZSwgcGFyYW1zKSB7XG4gIHJldHVybiB7IHJvdXRlczogWyByb3V0ZSBdLCBwYXJhbXM6IHBhcmFtcyB9O1xufVxuXG5mdW5jdGlvbiBoYXNQcm9wZXJ0aWVzKG9iamVjdCwgcHJvcGVydGllcykge1xuICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gcHJvcGVydGllcylcbiAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpICYmIG9iamVjdFtwcm9wZXJ0eU5hbWVdICE9PSBwcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGhhc01hdGNoKHJvdXRlcywgcm91dGUsIHByZXZQYXJhbXMsIG5leHRQYXJhbXMsIHByZXZRdWVyeSwgbmV4dFF1ZXJ5KSB7XG4gIHJldHVybiByb3V0ZXMuc29tZShmdW5jdGlvbiAocikge1xuICAgIGlmIChyICE9PSByb3V0ZSlcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBwYXJhbU5hbWVzID0gcm91dGUucGFyYW1OYW1lcztcbiAgICB2YXIgcGFyYW1OYW1lO1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgYWxsIHBhcmFtcyB0aGUgcm91dGUgY2FyZXMgYWJvdXQgZGlkIG5vdCBjaGFuZ2UuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcmFtTmFtZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHBhcmFtTmFtZSA9IHBhcmFtTmFtZXNbaV07XG5cbiAgICAgIGlmIChuZXh0UGFyYW1zW3BhcmFtTmFtZV0gIT09IHByZXZQYXJhbXNbcGFyYW1OYW1lXSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGUgcXVlcnkgaGFzbid0IGNoYW5nZWQuXG4gICAgcmV0dXJuIGhhc1Byb3BlcnRpZXMocHJldlF1ZXJ5LCBuZXh0UXVlcnkpICYmIGhhc1Byb3BlcnRpZXMobmV4dFF1ZXJ5LCBwcmV2UXVlcnkpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3IHJvdXRlciB1c2luZyB0aGUgZ2l2ZW4gb3B0aW9ucy4gQSByb3V0ZXJcbiAqIGlzIGEgUmVhY3RDb21wb25lbnQgY2xhc3MgdGhhdCBrbm93cyBob3cgdG8gcmVhY3QgdG8gY2hhbmdlcyBpbiB0aGVcbiAqIFVSTCBhbmQga2VlcCB0aGUgY29udGVudHMgb2YgdGhlIHBhZ2UgaW4gc3luYy5cbiAqXG4gKiBPcHRpb25zIG1heSBiZSBhbnkgb2YgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAtIHJvdXRlcyAgICAgICAgICAgKHJlcXVpcmVkKSBUaGUgcm91dGUgY29uZmlnXG4gKiAtIGxvY2F0aW9uICAgICAgICAgVGhlIGxvY2F0aW9uIHRvIHVzZS4gRGVmYXVsdHMgdG8gSGFzaExvY2F0aW9uIHdoZW5cbiAqICAgICAgICAgICAgICAgICAgICB0aGUgRE9NIGlzIGF2YWlsYWJsZSwgXCIvXCIgb3RoZXJ3aXNlXG4gKiAtIHNjcm9sbEJlaGF2aW9yICAgVGhlIHNjcm9sbCBiZWhhdmlvciB0byB1c2UuIERlZmF1bHRzIHRvIEltaXRhdGVCcm93c2VyQmVoYXZpb3JcbiAqICAgICAgICAgICAgICAgICAgICB3aGVuIHRoZSBET00gaXMgYXZhaWxhYmxlLCBudWxsIG90aGVyd2lzZVxuICogLSBvbkVycm9yICAgICAgICAgIEEgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGhhbmRsZSBlcnJvcnNcbiAqIC0gb25BYm9ydCAgICAgICAgICBBIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBoYW5kbGUgYWJvcnRlZCB0cmFuc2l0aW9uc1xuICpcbiAqIFdoZW4gcmVuZGVyaW5nIGluIGEgc2VydmVyLXNpZGUgZW52aXJvbm1lbnQsIHRoZSBsb2NhdGlvbiBzaG91bGQgc2ltcGx5XG4gKiBiZSB0aGUgVVJMIHBhdGggdGhhdCB3YXMgdXNlZCBpbiB0aGUgcmVxdWVzdCwgaW5jbHVkaW5nIHRoZSBxdWVyeSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlcihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMgPSB7IHJvdXRlczogb3B0aW9ucyB9OyAvLyBSb3V0ZXIuY3JlYXRlKDxSb3V0ZT4pXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgIG9wdGlvbnMgPSB7IHJvdXRlczogb3B0aW9ucyB9OyAvLyBSb3V0ZXIuY3JlYXRlKFsgPFJvdXRlPiwgPFJvdXRlPiBdKVxuICB9XG5cbiAgdmFyIHJvdXRlcyA9IFtdO1xuICB2YXIgbmFtZWRSb3V0ZXMgPSB7fTtcbiAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgdmFyIGxvY2F0aW9uID0gb3B0aW9ucy5sb2NhdGlvbiB8fCBERUZBVUxUX0xPQ0FUSU9OO1xuICB2YXIgc2Nyb2xsQmVoYXZpb3IgPSBvcHRpb25zLnNjcm9sbEJlaGF2aW9yIHx8IERFRkFVTFRfU0NST0xMX0JFSEFWSU9SO1xuICB2YXIgb25FcnJvciA9IG9wdGlvbnMub25FcnJvciB8fCBkZWZhdWx0RXJyb3JIYW5kbGVyO1xuICB2YXIgb25BYm9ydCA9IG9wdGlvbnMub25BYm9ydCB8fCBkZWZhdWx0QWJvcnRIYW5kbGVyO1xuICB2YXIgc3RhdGUgPSB7fTtcbiAgdmFyIG5leHRTdGF0ZSA9IHt9O1xuICB2YXIgcGVuZGluZ1RyYW5zaXRpb24gPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKCkge1xuICAgIHN0YXRlID0gbmV4dFN0YXRlO1xuICAgIG5leHRTdGF0ZSA9IHt9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgIWNhblVzZURPTSB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnLFxuICAgICAgJ1lvdSBzaG91bGQgbm90IHVzZSBhIHN0YXRpYyBsb2NhdGlvbiBpbiBhIERPTSBlbnZpcm9ubWVudCBiZWNhdXNlICcgK1xuICAgICAgJ3RoZSByb3V0ZXIgd2lsbCBub3QgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIGN1cnJlbnQgVVJMJ1xuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgY2FuVXNlRE9NLFxuICAgICAgJ1lvdSBjYW5ub3QgdXNlICVzIHdpdGhvdXQgYSBET00nLFxuICAgICAgbG9jYXRpb25cbiAgICApO1xuICB9XG5cbiAgLy8gQXV0b21hdGljYWxseSBmYWxsIGJhY2sgdG8gZnVsbCBwYWdlIHJlZnJlc2hlcyBpblxuICAvLyBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdGhlIEhUTUwgaGlzdG9yeSBBUEkuXG4gIGlmIChsb2NhdGlvbiA9PT0gSGlzdG9yeUxvY2F0aW9uICYmICFzdXBwb3J0c0hpc3RvcnkoKSlcbiAgICBsb2NhdGlvbiA9IFJlZnJlc2hMb2NhdGlvbjtcblxuICB2YXIgcm91dGVyID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gICAgZGlzcGxheU5hbWU6ICdSb3V0ZXInLFxuXG4gICAgbWl4aW5zOiBbIE5hdmlnYXRpb25Db250ZXh0LCBTdGF0ZUNvbnRleHQsIFNjcm9sbGluZyBdLFxuXG4gICAgc3RhdGljczoge1xuXG4gICAgICBkZWZhdWx0Um91dGU6IG51bGwsXG4gICAgICBub3RGb3VuZFJvdXRlOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgcm91dGVzIHRvIHRoaXMgcm91dGVyIGZyb20gdGhlIGdpdmVuIGNoaWxkcmVuIG9iamVjdCAoc2VlIFJlYWN0Q2hpbGRyZW4pLlxuICAgICAgICovXG4gICAgICBhZGRSb3V0ZXM6IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgICAgICByb3V0ZXMucHVzaC5hcHBseShyb3V0ZXMsIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihjaGlsZHJlbiwgdGhpcywgbmFtZWRSb3V0ZXMpKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhbiBhYnNvbHV0ZSBVUkwgcGF0aCBjcmVhdGVkIGZyb20gdGhlIGdpdmVuIHJvdXRlXG4gICAgICAgKiBuYW1lLCBVUkwgcGFyYW1ldGVycywgYW5kIHF1ZXJ5LlxuICAgICAgICovXG4gICAgICBtYWtlUGF0aDogZnVuY3Rpb24gKHRvLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgICAgIHZhciBwYXRoO1xuICAgICAgICBpZiAoUGF0aC5pc0Fic29sdXRlKHRvKSkge1xuICAgICAgICAgIHBhdGggPSBQYXRoLm5vcm1hbGl6ZSh0byk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJvdXRlID0gbmFtZWRSb3V0ZXNbdG9dO1xuXG4gICAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICAnVW5hYmxlIHRvIGZpbmQgPFJvdXRlIG5hbWU9XCIlc1wiPicsXG4gICAgICAgICAgICB0b1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBwYXRoID0gcm91dGUucGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQYXRoLndpdGhRdWVyeShQYXRoLmluamVjdFBhcmFtcyhwYXRoLCBwYXJhbXMpLCBxdWVyeSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgdGhhdCBtYXkgc2FmZWx5IGJlIHVzZWQgYXMgdGhlIGhyZWYgb2YgYSBsaW5rXG4gICAgICAgKiB0byB0aGUgcm91dGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZSwgVVJMIHBhcmFtZXRlcnMsIGFuZCBxdWVyeS5cbiAgICAgICAqL1xuICAgICAgbWFrZUhyZWY6IGZ1bmN0aW9uICh0bywgcGFyYW1zLCBxdWVyeSkge1xuICAgICAgICB2YXIgcGF0aCA9IHRoaXMubWFrZVBhdGgodG8sIHBhcmFtcywgcXVlcnkpO1xuICAgICAgICByZXR1cm4gKGxvY2F0aW9uID09PSBIYXNoTG9jYXRpb24pID8gJyMnICsgcGF0aCA6IHBhdGg7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zaXRpb25zIHRvIHRoZSBVUkwgc3BlY2lmaWVkIGluIHRoZSBhcmd1bWVudHMgYnkgcHVzaGluZ1xuICAgICAgICogYSBuZXcgVVJMIG9udG8gdGhlIGhpc3Rvcnkgc3RhY2suXG4gICAgICAgKi9cbiAgICAgIHRyYW5zaXRpb25UbzogZnVuY3Rpb24gKHRvLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgICAgIGludmFyaWFudChcbiAgICAgICAgICB0eXBlb2YgbG9jYXRpb24gIT09ICdzdHJpbmcnLFxuICAgICAgICAgICdZb3UgY2Fubm90IHVzZSB0cmFuc2l0aW9uVG8gd2l0aCBhIHN0YXRpYyBsb2NhdGlvbidcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMubWFrZVBhdGgodG8sIHBhcmFtcywgcXVlcnkpO1xuXG4gICAgICAgIGlmIChwZW5kaW5nVHJhbnNpdGlvbikge1xuICAgICAgICAgIC8vIFJlcGxhY2Ugc28gcGVuZGluZyBsb2NhdGlvbiBkb2VzIG5vdCBzdGF5IGluIGhpc3RvcnkuXG4gICAgICAgICAgbG9jYXRpb24ucmVwbGFjZShwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2NhdGlvbi5wdXNoKHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zaXRpb25zIHRvIHRoZSBVUkwgc3BlY2lmaWVkIGluIHRoZSBhcmd1bWVudHMgYnkgcmVwbGFjaW5nXG4gICAgICAgKiB0aGUgY3VycmVudCBVUkwgaW4gdGhlIGhpc3Rvcnkgc3RhY2suXG4gICAgICAgKi9cbiAgICAgIHJlcGxhY2VXaXRoOiBmdW5jdGlvbiAodG8sIHBhcmFtcywgcXVlcnkpIHtcbiAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgIHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3N0cmluZycsXG4gICAgICAgICAgJ1lvdSBjYW5ub3QgdXNlIHJlcGxhY2VXaXRoIHdpdGggYSBzdGF0aWMgbG9jYXRpb24nXG4gICAgICAgICk7XG5cbiAgICAgICAgbG9jYXRpb24ucmVwbGFjZSh0aGlzLm1ha2VQYXRoKHRvLCBwYXJhbXMsIHF1ZXJ5KSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zaXRpb25zIHRvIHRoZSBwcmV2aW91cyBVUkwgaWYgb25lIGlzIGF2YWlsYWJsZS4gUmV0dXJucyB0cnVlIGlmIHRoZVxuICAgICAgICogcm91dGVyIHdhcyBhYmxlIHRvIGdvIGJhY2ssIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlOiBUaGUgcm91dGVyIG9ubHkgdHJhY2tzIGhpc3RvcnkgZW50cmllcyBpbiB5b3VyIGFwcGxpY2F0aW9uLCBub3QgdGhlXG4gICAgICAgKiBjdXJyZW50IGJyb3dzZXIgc2Vzc2lvbiwgc28geW91IGNhbiBzYWZlbHkgY2FsbCB0aGlzIGZ1bmN0aW9uIHdpdGhvdXQgZ3VhcmRpbmdcbiAgICAgICAqIGFnYWluc3Qgc2VuZGluZyB0aGUgdXNlciBiYWNrIHRvIHNvbWUgb3RoZXIgc2l0ZS4gSG93ZXZlciwgd2hlbiB1c2luZ1xuICAgICAgICogUmVmcmVzaExvY2F0aW9uICh3aGljaCBpcyB0aGUgZmFsbGJhY2sgZm9yIEhpc3RvcnlMb2NhdGlvbiBpbiBicm93c2VycyB0aGF0XG4gICAgICAgKiBkb24ndCBzdXBwb3J0IEhUTUw1IGhpc3RvcnkpIHRoaXMgbWV0aG9kIHdpbGwgKmFsd2F5cyogc2VuZCB0aGUgY2xpZW50IGJhY2tcbiAgICAgICAqIGJlY2F1c2Ugd2UgY2Fubm90IHJlbGlhYmx5IHRyYWNrIGhpc3RvcnkgbGVuZ3RoLlxuICAgICAgICovXG4gICAgICBnb0JhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgIHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3N0cmluZycsXG4gICAgICAgICAgJ1lvdSBjYW5ub3QgdXNlIGdvQmFjayB3aXRoIGEgc3RhdGljIGxvY2F0aW9uJ1xuICAgICAgICApO1xuXG4gICAgICAgIGlmIChIaXN0b3J5Lmxlbmd0aCA+IDEgfHwgbG9jYXRpb24gPT09IFJlZnJlc2hMb2NhdGlvbikge1xuICAgICAgICAgIGxvY2F0aW9uLnBvcCgpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ2dvQmFjaygpIHdhcyBpZ25vcmVkIGJlY2F1c2UgdGhlcmUgaXMgbm8gcm91dGVyIGhpc3RvcnknKTtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFBlcmZvcm1zIGEgbWF0Y2ggb2YgdGhlIGdpdmVuIHBhdGhuYW1lIGFnYWluc3QgdGhpcyByb3V0ZXIgYW5kIHJldHVybnMgYW4gb2JqZWN0XG4gICAgICAgKiB3aXRoIHRoZSB7IHJvdXRlcywgcGFyYW1zIH0gdGhhdCBtYXRjaC4gUmV0dXJucyBudWxsIGlmIG5vIG1hdGNoIGNhbiBiZSBtYWRlLlxuICAgICAgICovXG4gICAgICBtYXRjaDogZnVuY3Rpb24gKHBhdGhuYW1lKSB7XG4gICAgICAgIHJldHVybiBmaW5kTWF0Y2gocGF0aG5hbWUsIHJvdXRlcywgdGhpcy5kZWZhdWx0Um91dGUsIHRoaXMubm90Rm91bmRSb3V0ZSkgfHwgbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUGVyZm9ybXMgYSB0cmFuc2l0aW9uIHRvIHRoZSBnaXZlbiBwYXRoIGFuZCBjYWxscyBjYWxsYmFjayhlcnJvciwgYWJvcnRSZWFzb24pXG4gICAgICAgKiB3aGVuIHRoZSB0cmFuc2l0aW9uIGlzIGZpbmlzaGVkLiBJZiBib3RoIGFyZ3VtZW50cyBhcmUgbnVsbCB0aGUgcm91dGVyJ3Mgc3RhdGVcbiAgICAgICAqIHdhcyB1cGRhdGVkLiBPdGhlcndpc2UgdGhlIHRyYW5zaXRpb24gZGlkIG5vdCBjb21wbGV0ZS5cbiAgICAgICAqXG4gICAgICAgKiBJbiBhIHRyYW5zaXRpb24sIGEgcm91dGVyIGZpcnN0IGRldGVybWluZXMgd2hpY2ggcm91dGVzIGFyZSBpbnZvbHZlZCBieSBiZWdpbm5pbmdcbiAgICAgICAqIHdpdGggdGhlIGN1cnJlbnQgcm91dGUsIHVwIHRoZSByb3V0ZSB0cmVlIHRvIHRoZSBmaXJzdCBwYXJlbnQgcm91dGUgdGhhdCBpcyBzaGFyZWRcbiAgICAgICAqIHdpdGggdGhlIGRlc3RpbmF0aW9uIHJvdXRlLCBhbmQgYmFjayBkb3duIHRoZSB0cmVlIHRvIHRoZSBkZXN0aW5hdGlvbiByb3V0ZS4gVGhlXG4gICAgICAgKiB3aWxsVHJhbnNpdGlvbkZyb20gaG9vayBpcyBpbnZva2VkIG9uIGFsbCByb3V0ZSBoYW5kbGVycyB3ZSdyZSB0cmFuc2l0aW9uaW5nIGF3YXlcbiAgICAgICAqIGZyb20sIGluIHJldmVyc2UgbmVzdGluZyBvcmRlci4gTGlrZXdpc2UsIHRoZSB3aWxsVHJhbnNpdGlvblRvIGhvb2sgaXMgaW52b2tlZCBvblxuICAgICAgICogYWxsIHJvdXRlIGhhbmRsZXJzIHdlJ3JlIHRyYW5zaXRpb25pbmcgdG8uXG4gICAgICAgKlxuICAgICAgICogQm90aCB3aWxsVHJhbnNpdGlvbkZyb20gYW5kIHdpbGxUcmFuc2l0aW9uVG8gaG9va3MgbWF5IGVpdGhlciBhYm9ydCBvciByZWRpcmVjdCB0aGVcbiAgICAgICAqIHRyYW5zaXRpb24uIFRvIHJlc29sdmUgYXN5bmNocm9ub3VzbHksIHRoZXkgbWF5IHVzZSB0cmFuc2l0aW9uLndhaXQocHJvbWlzZSkuIElmIG5vXG4gICAgICAgKiBob29rcyB3YWl0LCB0aGUgdHJhbnNpdGlvbiBpcyBmdWxseSBzeW5jaHJvbm91cy5cbiAgICAgICAqL1xuICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIChwYXRoLCBhY3Rpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChwZW5kaW5nVHJhbnNpdGlvbikge1xuICAgICAgICAgIHBlbmRpbmdUcmFuc2l0aW9uLmFib3J0KG5ldyBDYW5jZWxsYXRpb24pO1xuICAgICAgICAgIHBlbmRpbmdUcmFuc2l0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmV2UGF0aCA9IHN0YXRlLnBhdGg7XG4gICAgICAgIGlmIChwcmV2UGF0aCA9PT0gcGF0aClcbiAgICAgICAgICByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG8hXG5cbiAgICAgICAgLy8gUmVjb3JkIHRoZSBzY3JvbGwgcG9zaXRpb24gYXMgZWFybHkgYXMgcG9zc2libGUgdG9cbiAgICAgICAgLy8gZ2V0IGl0IGJlZm9yZSBicm93c2VycyB0cnkgdXBkYXRlIGl0IGF1dG9tYXRpY2FsbHkuXG4gICAgICAgIGlmIChwcmV2UGF0aCAmJiBhY3Rpb24gIT09IExvY2F0aW9uQWN0aW9ucy5SRVBMQUNFKVxuICAgICAgICAgIHRoaXMucmVjb3JkU2Nyb2xsUG9zaXRpb24ocHJldlBhdGgpO1xuXG4gICAgICAgIHZhciBwYXRobmFtZSA9IFBhdGgud2l0aG91dFF1ZXJ5KHBhdGgpO1xuICAgICAgICB2YXIgbWF0Y2ggPSB0aGlzLm1hdGNoKHBhdGhuYW1lKTtcblxuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIG1hdGNoICE9IG51bGwsXG4gICAgICAgICAgJ05vIHJvdXRlIG1hdGNoZXMgcGF0aCBcIiVzXCIuIE1ha2Ugc3VyZSB5b3UgaGF2ZSA8Um91dGUgcGF0aD1cIiVzXCI+IHNvbWV3aGVyZSBpbiB5b3VyIHJvdXRlcycsXG4gICAgICAgICAgcGF0aCwgcGF0aFxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChtYXRjaCA9PSBudWxsKVxuICAgICAgICAgIG1hdGNoID0ge307XG5cbiAgICAgICAgdmFyIHByZXZSb3V0ZXMgPSBzdGF0ZS5yb3V0ZXMgfHwgW107XG4gICAgICAgIHZhciBwcmV2UGFyYW1zID0gc3RhdGUucGFyYW1zIHx8IHt9O1xuICAgICAgICB2YXIgcHJldlF1ZXJ5ID0gc3RhdGUucXVlcnkgfHwge307XG5cbiAgICAgICAgdmFyIG5leHRSb3V0ZXMgPSBtYXRjaC5yb3V0ZXMgfHwgW107XG4gICAgICAgIHZhciBuZXh0UGFyYW1zID0gbWF0Y2gucGFyYW1zIHx8IHt9O1xuICAgICAgICB2YXIgbmV4dFF1ZXJ5ID0gUGF0aC5leHRyYWN0UXVlcnkocGF0aCkgfHwge307XG5cbiAgICAgICAgdmFyIGZyb21Sb3V0ZXMsIHRvUm91dGVzO1xuICAgICAgICBpZiAocHJldlJvdXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICBmcm9tUm91dGVzID0gcHJldlJvdXRlcy5maWx0ZXIoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gIWhhc01hdGNoKG5leHRSb3V0ZXMsIHJvdXRlLCBwcmV2UGFyYW1zLCBuZXh0UGFyYW1zLCBwcmV2UXVlcnksIG5leHRRdWVyeSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0b1JvdXRlcyA9IG5leHRSb3V0ZXMuZmlsdGVyKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICAgICAgcmV0dXJuICFoYXNNYXRjaChwcmV2Um91dGVzLCByb3V0ZSwgcHJldlBhcmFtcywgbmV4dFBhcmFtcywgcHJldlF1ZXJ5LCBuZXh0UXVlcnkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyb21Sb3V0ZXMgPSBbXTtcbiAgICAgICAgICB0b1JvdXRlcyA9IG5leHRSb3V0ZXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IG5ldyBUcmFuc2l0aW9uKHBhdGgsIHRoaXMucmVwbGFjZVdpdGguYmluZCh0aGlzLCBwYXRoKSk7XG4gICAgICAgIHBlbmRpbmdUcmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcblxuICAgICAgICB0cmFuc2l0aW9uLmZyb20oZnJvbVJvdXRlcywgY29tcG9uZW50cywgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgaWYgKGVycm9yIHx8IHRyYW5zaXRpb24uaXNBYm9ydGVkKVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwocm91dGVyLCBlcnJvciwgdHJhbnNpdGlvbik7XG5cbiAgICAgICAgICB0cmFuc2l0aW9uLnRvKHRvUm91dGVzLCBuZXh0UGFyYW1zLCBuZXh0UXVlcnksIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIHx8IHRyYW5zaXRpb24uaXNBYm9ydGVkKVxuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChyb3V0ZXIsIGVycm9yLCB0cmFuc2l0aW9uKTtcblxuICAgICAgICAgICAgbmV4dFN0YXRlLnBhdGggPSBwYXRoO1xuICAgICAgICAgICAgbmV4dFN0YXRlLmFjdGlvbiA9IGFjdGlvbjtcbiAgICAgICAgICAgIG5leHRTdGF0ZS5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgbmV4dFN0YXRlLnJvdXRlcyA9IG5leHRSb3V0ZXM7XG4gICAgICAgICAgICBuZXh0U3RhdGUucGFyYW1zID0gbmV4dFBhcmFtcztcbiAgICAgICAgICAgIG5leHRTdGF0ZS5xdWVyeSA9IG5leHRRdWVyeTtcblxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChyb3V0ZXIsIG51bGwsIHRyYW5zaXRpb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogU3RhcnRzIHRoaXMgcm91dGVyIGFuZCBjYWxscyBjYWxsYmFjayhyb3V0ZXIsIHN0YXRlKSB3aGVuIHRoZSByb3V0ZSBjaGFuZ2VzLlxuICAgICAgICpcbiAgICAgICAqIElmIHRoZSByb3V0ZXIncyBsb2NhdGlvbiBpcyBzdGF0aWMgKGkuZS4gYSBVUkwgcGF0aCBpbiBhIHNlcnZlciBlbnZpcm9ubWVudClcbiAgICAgICAqIHRoZSBjYWxsYmFjayBpcyBjYWxsZWQgb25seSBvbmNlLiBPdGhlcndpc2UsIHRoZSBsb2NhdGlvbiBzaG91bGQgYmUgb25lIG9mIHRoZVxuICAgICAgICogUm91dGVyLipMb2NhdGlvbiBvYmplY3RzIChlLmcuIFJvdXRlci5IYXNoTG9jYXRpb24gb3IgUm91dGVyLkhpc3RvcnlMb2NhdGlvbikuXG4gICAgICAgKi9cbiAgICAgIHJ1bjogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkaXNwYXRjaEhhbmRsZXIgPSBmdW5jdGlvbiAoZXJyb3IsIHRyYW5zaXRpb24pIHtcbiAgICAgICAgICBwZW5kaW5nVHJhbnNpdGlvbiA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIG9uRXJyb3IuY2FsbChyb3V0ZXIsIGVycm9yKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRyYW5zaXRpb24uaXNBYm9ydGVkKSB7XG4gICAgICAgICAgICBvbkFib3J0LmNhbGwocm91dGVyLCB0cmFuc2l0aW9uLmFib3J0UmVhc29uLCBsb2NhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwocm91dGVyLCByb3V0ZXIsIG5leHRTdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcm91dGVyLmRpc3BhdGNoKGxvY2F0aW9uLCBudWxsLCBkaXNwYXRjaEhhbmRsZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIExpc3RlbiBmb3IgY2hhbmdlcyB0byB0aGUgbG9jYXRpb24uXG4gICAgICAgICAgdmFyIGNoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgcm91dGVyLmRpc3BhdGNoKGNoYW5nZS5wYXRoLCBjaGFuZ2UudHlwZSwgZGlzcGF0Y2hIYW5kbGVyKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGxvY2F0aW9uLmFkZENoYW5nZUxpc3RlbmVyKVxuICAgICAgICAgICAgbG9jYXRpb24uYWRkQ2hhbmdlTGlzdGVuZXIoY2hhbmdlTGlzdGVuZXIpO1xuXG4gICAgICAgICAgLy8gQm9vdHN0cmFwIHVzaW5nIHRoZSBjdXJyZW50IHBhdGguXG4gICAgICAgICAgcm91dGVyLmRpc3BhdGNoKGxvY2F0aW9uLmdldEN1cnJlbnRQYXRoKCksIG51bGwsIGRpc3BhdGNoSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHRlYXJkb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbG9jYXRpb24ucmVtb3ZlQ2hhbmdlTGlzdGVuZXIodGhpcy5jaGFuZ2VMaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgcHJvcFR5cGVzOiB7XG4gICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLmZhbHN5XG4gICAgfSxcblxuICAgIGdldExvY2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgfSxcblxuICAgIGdldFNjcm9sbEJlaGF2aW9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc2Nyb2xsQmVoYXZpb3I7XG4gICAgfSxcblxuICAgIGdldFJvdXRlQXREZXB0aDogZnVuY3Rpb24gKGRlcHRoKSB7XG4gICAgICB2YXIgcm91dGVzID0gdGhpcy5zdGF0ZS5yb3V0ZXM7XG4gICAgICByZXR1cm4gcm91dGVzICYmIHJvdXRlc1tkZXB0aF07XG4gICAgfSxcblxuICAgIGdldFJvdXRlQ29tcG9uZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfSxcblxuICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdXBkYXRlU3RhdGUoKTtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gKCkge1xuICAgICAgdXBkYXRlU3RhdGUoKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICByb3V0ZXIudGVhcmRvd24oKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSb3V0ZUF0RGVwdGgoMCkgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlSGFuZGxlciwgdGhpcy5wcm9wcykgOiBudWxsO1xuICAgIH0sXG5cbiAgICBjaGlsZENvbnRleHRUeXBlczoge1xuICAgICAgZ2V0Um91dGVBdERlcHRoOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgZ2V0Um91dGVDb21wb25lbnRzOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgcm91dGVIYW5kbGVyczogUmVhY3QuUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWRcbiAgICB9LFxuXG4gICAgZ2V0Q2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXRSb3V0ZUNvbXBvbmVudHM6IHRoaXMuZ2V0Um91dGVDb21wb25lbnRzLFxuICAgICAgICBnZXRSb3V0ZUF0RGVwdGg6IHRoaXMuZ2V0Um91dGVBdERlcHRoLFxuICAgICAgICByb3V0ZUhhbmRsZXJzOiBbIHRoaXMgXVxuICAgICAgfTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgaWYgKG9wdGlvbnMucm91dGVzKVxuICAgIHJvdXRlci5hZGRSb3V0ZXMob3B0aW9ucy5yb3V0ZXMpO1xuXG4gIHJldHVybiByb3V0ZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUm91dGVyO1xuIiwiLyoganNoaW50IC1XMDg0ICovXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdyZWFjdC9saWIvd2FybmluZycpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9pbnZhcmlhbnQnKTtcbnZhciBEZWZhdWx0Um91dGUgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0RlZmF1bHRSb3V0ZScpO1xudmFyIE5vdEZvdW5kUm91dGUgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL05vdEZvdW5kUm91dGUnKTtcbnZhciBSZWRpcmVjdCA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvUmVkaXJlY3QnKTtcbnZhciBSb3V0ZSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvUm91dGUnKTtcbnZhciBQYXRoID0gcmVxdWlyZSgnLi9QYXRoJyk7XG5cbnZhciBDT05GSUdfRUxFTUVOVF9UWVBFUyA9IFtcbiAgRGVmYXVsdFJvdXRlLnR5cGUsXG4gIE5vdEZvdW5kUm91dGUudHlwZSxcbiAgUmVkaXJlY3QudHlwZSxcbiAgUm91dGUudHlwZVxuXTtcblxuZnVuY3Rpb24gY3JlYXRlUmVkaXJlY3RIYW5kbGVyKHRvLCBfcGFyYW1zLCBfcXVlcnkpIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICBzdGF0aWNzOiB7XG4gICAgICB3aWxsVHJhbnNpdGlvblRvOiBmdW5jdGlvbiAodHJhbnNpdGlvbiwgcGFyYW1zLCBxdWVyeSkge1xuICAgICAgICB0cmFuc2l0aW9uLnJlZGlyZWN0KHRvLCBfcGFyYW1zIHx8IHBhcmFtcywgX3F1ZXJ5IHx8IHF1ZXJ5KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyhjb21wb25lbnROYW1lLCBwcm9wVHlwZXMsIHByb3BzKSB7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICB2YXIgZXJyb3IgPSBwcm9wVHlwZXNbcHJvcE5hbWVdKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKVxuICAgICAgICB3YXJuaW5nKGZhbHNlLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUm91dGUoZWxlbWVudCwgcGFyZW50Um91dGUsIG5hbWVkUm91dGVzKSB7XG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICB2YXIgcHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICB2YXIgY29tcG9uZW50TmFtZSA9ICh0eXBlICYmIHR5cGUuZGlzcGxheU5hbWUpIHx8ICdVbmtub3duQ29tcG9uZW50JztcblxuICBpbnZhcmlhbnQoXG4gICAgQ09ORklHX0VMRU1FTlRfVFlQRVMuaW5kZXhPZih0eXBlKSAhPT0gLTEsXG4gICAgJ1VucmVjb2duaXplZCByb3V0ZSBjb25maWd1cmF0aW9uIGVsZW1lbnQgXCI8JXM+XCInLFxuICAgIGNvbXBvbmVudE5hbWVcbiAgKTtcblxuICBpZiAodHlwZS5wcm9wVHlwZXMpXG4gICAgY2hlY2tQcm9wVHlwZXMoY29tcG9uZW50TmFtZSwgdHlwZS5wcm9wVHlwZXMsIHByb3BzKTtcblxuICB2YXIgcm91dGUgPSB7IG5hbWU6IHByb3BzLm5hbWUgfTtcblxuICBpZiAocHJvcHMuaWdub3JlU2Nyb2xsQmVoYXZpb3IpIHtcbiAgICByb3V0ZS5pZ25vcmVTY3JvbGxCZWhhdmlvciA9IHRydWU7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gUmVkaXJlY3QudHlwZSkge1xuICAgIHJvdXRlLmhhbmRsZXIgPSBjcmVhdGVSZWRpcmVjdEhhbmRsZXIocHJvcHMudG8sIHByb3BzLnBhcmFtcywgcHJvcHMucXVlcnkpO1xuICAgIHByb3BzLnBhdGggPSBwcm9wcy5wYXRoIHx8IHByb3BzLmZyb20gfHwgJyonO1xuICB9IGVsc2Uge1xuICAgIHJvdXRlLmhhbmRsZXIgPSBwcm9wcy5oYW5kbGVyO1xuICB9XG5cbiAgdmFyIHBhcmVudFBhdGggPSAocGFyZW50Um91dGUgJiYgcGFyZW50Um91dGUucGF0aCkgfHwgJy8nO1xuXG4gIGlmICgocHJvcHMucGF0aCB8fCBwcm9wcy5uYW1lKSAmJiB0eXBlICE9PSBEZWZhdWx0Um91dGUudHlwZSAmJiB0eXBlICE9PSBOb3RGb3VuZFJvdXRlLnR5cGUpIHtcbiAgICB2YXIgcGF0aCA9IHByb3BzLnBhdGggfHwgcHJvcHMubmFtZTtcblxuICAgIC8vIFJlbGF0aXZlIHBhdGhzIGV4dGVuZCB0aGVpciBwYXJlbnQuXG4gICAgaWYgKCFQYXRoLmlzQWJzb2x1dGUocGF0aCkpXG4gICAgICBwYXRoID0gUGF0aC5qb2luKHBhcmVudFBhdGgsIHBhdGgpO1xuXG4gICAgcm91dGUucGF0aCA9IFBhdGgubm9ybWFsaXplKHBhdGgpO1xuICB9IGVsc2Uge1xuICAgIHJvdXRlLnBhdGggPSBwYXJlbnRQYXRoO1xuXG4gICAgaWYgKHR5cGUgPT09IE5vdEZvdW5kUm91dGUudHlwZSlcbiAgICAgIHJvdXRlLnBhdGggKz0gJyonO1xuICB9XG5cbiAgcm91dGUucGFyYW1OYW1lcyA9IFBhdGguZXh0cmFjdFBhcmFtTmFtZXMocm91dGUucGF0aCk7XG5cbiAgLy8gTWFrZSBzdXJlIHRoZSByb3V0ZSdzIHBhdGggaGFzIGFsbCBwYXJhbXMgaXRzIHBhcmVudCBuZWVkcy5cbiAgaWYgKHBhcmVudFJvdXRlICYmIEFycmF5LmlzQXJyYXkocGFyZW50Um91dGUucGFyYW1OYW1lcykpIHtcbiAgICBwYXJlbnRSb3V0ZS5wYXJhbU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtTmFtZSkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICByb3V0ZS5wYXJhbU5hbWVzLmluZGV4T2YocGFyYW1OYW1lKSAhPT0gLTEsXG4gICAgICAgICdUaGUgbmVzdGVkIHJvdXRlIHBhdGggXCIlc1wiIGlzIG1pc3NpbmcgdGhlIFwiJXNcIiBwYXJhbWV0ZXIgb2YgaXRzIHBhcmVudCBwYXRoIFwiJXNcIicsXG4gICAgICAgIHJvdXRlLnBhdGgsIHBhcmFtTmFtZSwgcGFyZW50Um91dGUucGF0aFxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB0aGUgcm91dGUgY2FuIGJlIGxvb2tlZCB1cCBieSA8TGluaz5zLlxuICBpZiAocHJvcHMubmFtZSkge1xuICAgIGludmFyaWFudChcbiAgICAgIG5hbWVkUm91dGVzW3Byb3BzLm5hbWVdID09IG51bGwsXG4gICAgICAnWW91IGNhbm5vdCB1c2UgdGhlIG5hbWUgXCIlc1wiIGZvciBtb3JlIHRoYW4gb25lIHJvdXRlJyxcbiAgICAgIHByb3BzLm5hbWVcbiAgICApO1xuXG4gICAgbmFtZWRSb3V0ZXNbcHJvcHMubmFtZV0gPSByb3V0ZTtcbiAgfVxuXG4gIC8vIEhhbmRsZSA8Tm90Rm91bmRSb3V0ZT4uXG4gIGlmICh0eXBlID09PSBOb3RGb3VuZFJvdXRlLnR5cGUpIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBwYXJlbnRSb3V0ZSxcbiAgICAgICc8Tm90Rm91bmRSb3V0ZT4gbXVzdCBoYXZlIGEgcGFyZW50IDxSb3V0ZT4nXG4gICAgKTtcblxuICAgIGludmFyaWFudChcbiAgICAgIHBhcmVudFJvdXRlLm5vdEZvdW5kUm91dGUgPT0gbnVsbCxcbiAgICAgICdZb3UgbWF5IG5vdCBoYXZlIG1vcmUgdGhhbiBvbmUgPE5vdEZvdW5kUm91dGU+IHBlciA8Um91dGU+J1xuICAgICk7XG5cbiAgICBwYXJlbnRSb3V0ZS5ub3RGb3VuZFJvdXRlID0gcm91dGU7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEhhbmRsZSA8RGVmYXVsdFJvdXRlPi5cbiAgaWYgKHR5cGUgPT09IERlZmF1bHRSb3V0ZS50eXBlKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgcGFyZW50Um91dGUsXG4gICAgICAnPERlZmF1bHRSb3V0ZT4gbXVzdCBoYXZlIGEgcGFyZW50IDxSb3V0ZT4nXG4gICAgKTtcblxuICAgIGludmFyaWFudChcbiAgICAgIHBhcmVudFJvdXRlLmRlZmF1bHRSb3V0ZSA9PSBudWxsLFxuICAgICAgJ1lvdSBtYXkgbm90IGhhdmUgbW9yZSB0aGFuIG9uZSA8RGVmYXVsdFJvdXRlPiBwZXIgPFJvdXRlPidcbiAgICApO1xuXG4gICAgcGFyZW50Um91dGUuZGVmYXVsdFJvdXRlID0gcm91dGU7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJvdXRlLmNoaWxkUm91dGVzID0gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKHByb3BzLmNoaWxkcmVuLCByb3V0ZSwgbmFtZWRSb3V0ZXMpO1xuXG4gIHJldHVybiByb3V0ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHJvdXRlIG9iamVjdHMgZnJvbSB0aGUgZ2l2ZW4gUmVhY3RDaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGNoaWxkcmVuLCBwYXJlbnRSb3V0ZSwgbmFtZWRSb3V0ZXMpIHtcbiAgdmFyIHJvdXRlcyA9IFtdO1xuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIC8vIEV4Y2x1ZGUgPERlZmF1bHRSb3V0ZT5zIGFuZCA8Tm90Rm91bmRSb3V0ZT5zLlxuICAgIGlmIChjaGlsZCA9IGNyZWF0ZVJvdXRlKGNoaWxkLCBwYXJlbnRSb3V0ZSwgbmFtZWRSb3V0ZXMpKVxuICAgICAgcm91dGVzLnB1c2goY2hpbGQpO1xuICB9KTtcblxuICByZXR1cm4gcm91dGVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbjtcbiIsInZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdyZWFjdC9saWIvaW52YXJpYW50Jyk7XG52YXIgY2FuVXNlRE9NID0gcmVxdWlyZSgncmVhY3QvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50JykuY2FuVXNlRE9NO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSB3aW5kb3cgYXMgeyB4LCB5IH0uXG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbFBvc2l0aW9uKCkge1xuICBpbnZhcmlhbnQoXG4gICAgY2FuVXNlRE9NLFxuICAgICdDYW5ub3QgZ2V0IGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIHdpdGhvdXQgYSBET00nXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG4gICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRXaW5kb3dTY3JvbGxQb3NpdGlvbjtcbiIsImZ1bmN0aW9uIHJldmVyc2VkQXJyYXkoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5LnNsaWNlKDApLnJldmVyc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXZlcnNlZEFycmF5O1xuIiwidmFyIGNyZWF0ZVJvdXRlciA9IHJlcXVpcmUoJy4vY3JlYXRlUm91dGVyJyk7XG5cbi8qKlxuICogQSBoaWdoLWxldmVsIGNvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGNyZWF0ZXMsIGNvbmZpZ3VyZXMsIGFuZFxuICogcnVucyBhIHJvdXRlciBpbiBvbmUgc2hvdC4gVGhlIG1ldGhvZCBzaWduYXR1cmUgaXM6XG4gKlxuICogICBSb3V0ZXIucnVuKHJvdXRlc1ssIGxvY2F0aW9uIF0sIGNhbGxiYWNrKTtcbiAqXG4gKiBVc2luZyBgd2luZG93LmxvY2F0aW9uLmhhc2hgIHRvIG1hbmFnZSB0aGUgVVJMLCB5b3UgY291bGQgZG86XG4gKlxuICogICBSb3V0ZXIucnVuKHJvdXRlcywgZnVuY3Rpb24gKEhhbmRsZXIpIHtcbiAqICAgICBSZWFjdC5yZW5kZXIoPEhhbmRsZXIvPiwgZG9jdW1lbnQuYm9keSk7XG4gKiAgIH0pO1xuICogXG4gKiBVc2luZyBIVE1MNSBoaXN0b3J5IGFuZCBhIGN1c3RvbSBcImN1cnNvclwiIHByb3A6XG4gKiBcbiAqICAgUm91dGVyLnJ1bihyb3V0ZXMsIFJvdXRlci5IaXN0b3J5TG9jYXRpb24sIGZ1bmN0aW9uIChIYW5kbGVyKSB7XG4gKiAgICAgUmVhY3QucmVuZGVyKDxIYW5kbGVyIGN1cnNvcj17Y3Vyc29yfS8+LCBkb2N1bWVudC5ib2R5KTtcbiAqICAgfSk7XG4gKlxuICogUmV0dXJucyB0aGUgbmV3bHkgY3JlYXRlZCByb3V0ZXIuXG4gKlxuICogTm90ZTogSWYgeW91IG5lZWQgdG8gc3BlY2lmeSBmdXJ0aGVyIG9wdGlvbnMgZm9yIHlvdXIgcm91dGVyIHN1Y2hcbiAqIGFzIGVycm9yL2Fib3J0IGhhbmRsaW5nIG9yIGN1c3RvbSBzY3JvbGwgYmVoYXZpb3IsIHVzZSBSb3V0ZXIuY3JlYXRlXG4gKiBpbnN0ZWFkLlxuICpcbiAqICAgdmFyIHJvdXRlciA9IFJvdXRlci5jcmVhdGUob3B0aW9ucyk7XG4gKiAgIHJvdXRlci5ydW4oZnVuY3Rpb24gKEhhbmRsZXIpIHtcbiAqICAgICAvLyAuLi5cbiAqICAgfSk7XG4gKi9cbmZ1bmN0aW9uIHJ1blJvdXRlcihyb3V0ZXMsIGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBsb2NhdGlvbjtcbiAgICBsb2NhdGlvbiA9IG51bGw7XG4gIH1cblxuICB2YXIgcm91dGVyID0gY3JlYXRlUm91dGVyKHtcbiAgICByb3V0ZXM6IHJvdXRlcyxcbiAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgfSk7XG5cbiAgcm91dGVyLnJ1bihjYWxsYmFjayk7XG5cbiAgcmV0dXJuIHJvdXRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBydW5Sb3V0ZXI7XG4iLCJmdW5jdGlvbiBzdXBwb3J0c0hpc3RvcnkoKSB7XG4gIC8qISB0YWtlbiBmcm9tIG1vZGVybml6clxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9MSUNFTlNFXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL2ZlYXR1cmUtZGV0ZWN0cy9oaXN0b3J5LmpzXG4gICAqIGNoYW5nZWQgdG8gYXZvaWQgZmFsc2UgbmVnYXRpdmVzIGZvciBXaW5kb3dzIFBob25lczogaHR0cHM6Ly9naXRodWIuY29tL3JhY2t0L3JlYWN0LXJvdXRlci9pc3N1ZXMvNTg2XG4gICAqL1xuICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICBpZiAoKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHxcbiAgICAgICh1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkpICYmXG4gICAgICB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmXG4gICAgICB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiZcbiAgICAgIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuICh3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNIaXN0b3J5O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENTU0NvcmVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBUaGUgQ1NTQ29yZSBtb2R1bGUgc3BlY2lmaWVzIHRoZSBBUEkgKGFuZCBpbXBsZW1lbnRzIG1vc3Qgb2YgdGhlIG1ldGhvZHMpXG4gKiB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZW4gZGVhbGluZyB3aXRoIHRoZSBkaXNwbGF5IG9mIGVsZW1lbnRzICh2aWEgdGhlaXJcbiAqIENTUyBjbGFzc2VzIGFuZCB2aXNpYmlsaXR5IG9uIHNjcmVlbi4gSXQgaXMgYW4gQVBJIGZvY3VzZWQgb24gbXV0YXRpbmcgdGhlXG4gKiBkaXNwbGF5IGFuZCBub3QgcmVhZGluZyBpdCBhcyBubyBsb2dpY2FsIHN0YXRlIHNob3VsZCBiZSBlbmNvZGVkIGluIHRoZVxuICogZGlzcGxheSBvZiBlbGVtZW50cy5cbiAqL1xuXG52YXIgQ1NTQ29yZSA9IHtcblxuICAvKipcbiAgICogQWRkcyB0aGUgY2xhc3MgcGFzc2VkIGluIHRvIHRoZSBlbGVtZW50IGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBoYXZlIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIHRoZSBDU1MgY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IHRoZSBlbGVtZW50IHBhc3NlZCBpblxuICAgKi9cbiAgYWRkQ2xhc3M6IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAhL1xccy8udGVzdChjbGFzc05hbWUpLFxuICAgICAgJ0NTU0NvcmUuYWRkQ2xhc3MgdGFrZXMgb25seSBhIHNpbmdsZSBjbGFzcyBuYW1lLiBcIiVzXCIgY29udGFpbnMgJyArXG4gICAgICAnbXVsdGlwbGUgY2xhc3Nlcy4nLCBjbGFzc05hbWVcbiAgICApIDogaW52YXJpYW50KCEvXFxzLy50ZXN0KGNsYXNzTmFtZSkpKTtcblxuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoIUNTU0NvcmUuaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnICsgY2xhc3NOYW1lO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgY2xhc3MgcGFzc2VkIGluIGZyb20gdGhlIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIHNldCB0aGUgY2xhc3Mgb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSB0aGUgQ1NTIGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSB0aGUgZWxlbWVudCBwYXNzZWQgaW5cbiAgICovXG4gIHJlbW92ZUNsYXNzOiBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgIS9cXHMvLnRlc3QoY2xhc3NOYW1lKSxcbiAgICAgICdDU1NDb3JlLnJlbW92ZUNsYXNzIHRha2VzIG9ubHkgYSBzaW5nbGUgY2xhc3MgbmFtZS4gXCIlc1wiIGNvbnRhaW5zICcgK1xuICAgICAgJ211bHRpcGxlIGNsYXNzZXMuJywgY2xhc3NOYW1lXG4gICAgKSA6IGludmFyaWFudCghL1xccy8udGVzdChjbGFzc05hbWUpKSk7XG5cbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKENTU0NvcmUuaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lXG4gICAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIGNsYXNzTmFtZSArICcoPzpcXFxcc3wkKScsICdnJyksICckMScpXG4gICAgICAgICAgLnJlcGxhY2UoL1xccysvZywgJyAnKSAvLyBtdWx0aXBsZSBzcGFjZXMgdG8gb25lXG4gICAgICAgICAgLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKTsgLy8gdHJpbSB0aGUgZW5kc1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSxcblxuICAvKipcbiAgICogSGVscGVyIHRvIGFkZCBvciByZW1vdmUgYSBjbGFzcyBmcm9tIGFuIGVsZW1lbnQgYmFzZWQgb24gYSBjb25kaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgdGhlIENTUyBjbGFzc05hbWVcbiAgICogQHBhcmFtIHsqfSBib29sIGNvbmRpdGlvbiB0byB3aGV0aGVyIHRvIGFkZCBvciByZW1vdmUgdGhlIGNsYXNzXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IHRoZSBlbGVtZW50IHBhc3NlZCBpblxuICAgKi9cbiAgY29uZGl0aW9uQ2xhc3M6IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzTmFtZSwgYm9vbCkge1xuICAgIHJldHVybiAoYm9vbCA/IENTU0NvcmUuYWRkQ2xhc3MgOiBDU1NDb3JlLnJlbW92ZUNsYXNzKShlbGVtZW50LCBjbGFzc05hbWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUZXN0cyB3aGV0aGVyIHRoZSBlbGVtZW50IGhhcyB0aGUgY2xhc3Mgc3BlY2lmaWVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTU5vZGV8RE9NV2luZG93fSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIHNldCB0aGUgY2xhc3Mgb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSB0aGUgQ1NTIGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBlbGVtZW50IGhhcyB0aGUgY2xhc3MsIGZhbHNlIGlmIG5vdFxuICAgKi9cbiAgaGFzQ2xhc3M6IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAhL1xccy8udGVzdChjbGFzc05hbWUpLFxuICAgICAgJ0NTUy5oYXNDbGFzcyB0YWtlcyBvbmx5IGEgc2luZ2xlIGNsYXNzIG5hbWUuJ1xuICAgICkgOiBpbnZhcmlhbnQoIS9cXHMvLnRlc3QoY2xhc3NOYW1lKSkpO1xuICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgcmV0dXJuICEhY2xhc3NOYW1lICYmIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiAoJyAnICsgZWxlbWVudC5jbGFzc05hbWUgKyAnICcpLmluZGV4T2YoJyAnICsgY2xhc3NOYW1lICsgJyAnKSA+IC0xO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTQ29yZTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFeGVjdXRpb25FbnZpcm9ubWVudFxuICovXG5cbi8qanNsaW50IGV2aWw6IHRydWUgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjYW5Vc2VET00gPSAhIShcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgd2luZG93LmRvY3VtZW50ICYmXG4gIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50XG4pO1xuXG4vKipcbiAqIFNpbXBsZSwgbGlnaHR3ZWlnaHQgbW9kdWxlIGFzc2lzdGluZyB3aXRoIHRoZSBkZXRlY3Rpb24gYW5kIGNvbnRleHQgb2ZcbiAqIFdvcmtlci4gSGVscHMgYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGFuZCBhbGxvd3MgY29kZSB0byByZWFzb24gYWJvdXRcbiAqIHdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIGluIGEgV29ya2VyLCBldmVuIGlmIHRoZXkgbmV2ZXIgaW5jbHVkZSB0aGUgbWFpblxuICogYFJlYWN0V29ya2VyYCBkZXBlbmRlbmN5LlxuICovXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSB7XG5cbiAgY2FuVXNlRE9NOiBjYW5Vc2VET00sXG5cbiAgY2FuVXNlV29ya2VyczogdHlwZW9mIFdvcmtlciAhPT0gJ3VuZGVmaW5lZCcsXG5cbiAgY2FuVXNlRXZlbnRMaXN0ZW5lcnM6XG4gICAgY2FuVXNlRE9NICYmICEhKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIHx8IHdpbmRvdy5hdHRhY2hFdmVudCksXG5cbiAgY2FuVXNlVmlld3BvcnQ6IGNhblVzZURPTSAmJiAhIXdpbmRvdy5zY3JlZW4sXG5cbiAgaXNJbldvcmtlcjogIWNhblVzZURPTSAvLyBGb3Igbm93LCB0aGlzIGlzIHRydWUgLSBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgT2JqZWN0LmFzc2lnblxuICovXG5cbi8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1vYmplY3QuYXNzaWduXG5cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZXMpIHtcbiAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiB0YXJnZXQgY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gIH1cblxuICB2YXIgdG8gPSBPYmplY3QodGFyZ2V0KTtcbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IgKHZhciBuZXh0SW5kZXggPSAxOyBuZXh0SW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBuZXh0SW5kZXgrKykge1xuICAgIHZhciBuZXh0U291cmNlID0gYXJndW1lbnRzW25leHRJbmRleF07XG4gICAgaWYgKG5leHRTb3VyY2UgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGZyb20gPSBPYmplY3QobmV4dFNvdXJjZSk7XG5cbiAgICAvLyBXZSBkb24ndCBjdXJyZW50bHkgc3VwcG9ydCBhY2Nlc3NvcnMgbm9yIHByb3hpZXMuIFRoZXJlZm9yZSB0aGlzXG4gICAgLy8gY29weSBjYW5ub3QgdGhyb3cuIElmIHdlIGV2ZXIgc3VwcG9ydGVkIHRoaXMgdGhlbiB3ZSBtdXN0IGhhbmRsZVxuICAgIC8vIGV4Y2VwdGlvbnMgYW5kIHNpZGUtZWZmZWN0cy4gV2UgZG9uJ3Qgc3VwcG9ydCBzeW1ib2xzIHNvIHRoZXkgd29uJ3RcbiAgICAvLyBiZSB0cmFuc2ZlcnJlZC5cblxuICAgIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG4gICAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRvO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ247XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RUcmFuc2l0aW9uRXZlbnRzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xuXG4vKipcbiAqIEVWRU5UX05BTUVfTUFQIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGV2ZW50IGZpcmVkIHdoZW4gYVxuICogdHJhbnNpdGlvbi9hbmltYXRpb24gZW5kcywgYmFzZWQgb24gdGhlIHN0eWxlIHByb3BlcnR5IHVzZWQgdG9cbiAqIGRlZmluZSB0aGF0IGV2ZW50LlxuICovXG52YXIgRVZFTlRfTkFNRV9NQVAgPSB7XG4gIHRyYW5zaXRpb25lbmQ6IHtcbiAgICAndHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJyxcbiAgICAnV2Via2l0VHJhbnNpdGlvbic6ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAnTW96VHJhbnNpdGlvbic6ICdtb3pUcmFuc2l0aW9uRW5kJyxcbiAgICAnT1RyYW5zaXRpb24nOiAnb1RyYW5zaXRpb25FbmQnLFxuICAgICdtc1RyYW5zaXRpb24nOiAnTVNUcmFuc2l0aW9uRW5kJ1xuICB9LFxuXG4gIGFuaW1hdGlvbmVuZDoge1xuICAgICdhbmltYXRpb24nOiAnYW5pbWF0aW9uZW5kJyxcbiAgICAnV2Via2l0QW5pbWF0aW9uJzogJ3dlYmtpdEFuaW1hdGlvbkVuZCcsXG4gICAgJ01vekFuaW1hdGlvbic6ICdtb3pBbmltYXRpb25FbmQnLFxuICAgICdPQW5pbWF0aW9uJzogJ29BbmltYXRpb25FbmQnLFxuICAgICdtc0FuaW1hdGlvbic6ICdNU0FuaW1hdGlvbkVuZCdcbiAgfVxufTtcblxudmFyIGVuZEV2ZW50cyA9IFtdO1xuXG5mdW5jdGlvbiBkZXRlY3RFdmVudHMoKSB7XG4gIHZhciB0ZXN0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmFyIHN0eWxlID0gdGVzdEVsLnN0eWxlO1xuXG4gIC8vIE9uIHNvbWUgcGxhdGZvcm1zLCBpbiBwYXJ0aWN1bGFyIHNvbWUgcmVsZWFzZXMgb2YgQW5kcm9pZCA0LngsXG4gIC8vIHRoZSB1bi1wcmVmaXhlZCBcImFuaW1hdGlvblwiIGFuZCBcInRyYW5zaXRpb25cIiBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIG9uIHRoZVxuICAvLyBzdHlsZSBvYmplY3QgYnV0IHRoZSBldmVudHMgdGhhdCBmaXJlIHdpbGwgc3RpbGwgYmUgcHJlZml4ZWQsIHNvIHdlIG5lZWRcbiAgLy8gdG8gY2hlY2sgaWYgdGhlIHVuLXByZWZpeGVkIGV2ZW50cyBhcmUgdXNlYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbVxuICAvLyBmcm9tIHRoZSBtYXBcbiAgaWYgKCEoJ0FuaW1hdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIEVWRU5UX05BTUVfTUFQLmFuaW1hdGlvbmVuZC5hbmltYXRpb247XG4gIH1cblxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIEVWRU5UX05BTUVfTUFQLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxuXG4gIGZvciAodmFyIGJhc2VFdmVudE5hbWUgaW4gRVZFTlRfTkFNRV9NQVApIHtcbiAgICB2YXIgYmFzZUV2ZW50cyA9IEVWRU5UX05BTUVfTUFQW2Jhc2VFdmVudE5hbWVdO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBiYXNlRXZlbnRzKSB7XG4gICAgICBpZiAoc3R5bGVOYW1lIGluIHN0eWxlKSB7XG4gICAgICAgIGVuZEV2ZW50cy5wdXNoKGJhc2VFdmVudHNbc3R5bGVOYW1lXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIGRldGVjdEV2ZW50cygpO1xufVxuXG4vLyBXZSB1c2UgdGhlIHJhdyB7YWRkfHJlbW92ZX1FdmVudExpc3RlbmVyKCkgY2FsbCBiZWNhdXNlIEV2ZW50TGlzdGVuZXJcbi8vIGRvZXMgbm90IGtub3cgaG93IHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lcnMgYW5kIHdlIHJlYWxseSBzaG91bGRcbi8vIGNsZWFuIHVwLiBBbHNvLCB0aGVzZSBldmVudHMgYXJlIG5vdCB0cmlnZ2VyZWQgaW4gb2xkZXIgYnJvd3NlcnNcbi8vIHNvIHdlIHNob3VsZCBiZSBBLU9LIGhlcmUuXG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnROYW1lLCBldmVudExpc3RlbmVyKSB7XG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIpIHtcbiAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRMaXN0ZW5lciwgZmFsc2UpO1xufVxuXG52YXIgUmVhY3RUcmFuc2l0aW9uRXZlbnRzID0ge1xuICBhZGRFbmRFdmVudExpc3RlbmVyOiBmdW5jdGlvbihub2RlLCBldmVudExpc3RlbmVyKSB7XG4gICAgaWYgKGVuZEV2ZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIElmIENTUyB0cmFuc2l0aW9ucyBhcmUgbm90IHN1cHBvcnRlZCwgdHJpZ2dlciBhbiBcImVuZCBhbmltYXRpb25cIlxuICAgICAgLy8gZXZlbnQgaW1tZWRpYXRlbHkuXG4gICAgICB3aW5kb3cuc2V0VGltZW91dChldmVudExpc3RlbmVyLCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZW5kRXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZW5kRXZlbnQpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZW5kRXZlbnQsIGV2ZW50TGlzdGVuZXIpO1xuICAgIH0pO1xuICB9LFxuXG4gIHJlbW92ZUVuZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKG5vZGUsIGV2ZW50TGlzdGVuZXIpIHtcbiAgICBpZiAoZW5kRXZlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbmRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihlbmRFdmVudCkge1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBlbmRFdmVudCwgZXZlbnRMaXN0ZW5lcik7XG4gICAgfSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RUcmFuc2l0aW9uRXZlbnRzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGN4XG4gKi9cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gbWFyayBzdHJpbmcgbGl0ZXJhbHMgcmVwcmVzZW50aW5nIENTUyBjbGFzcyBuYW1lc1xuICogc28gdGhhdCB0aGV5IGNhbiBiZSB0cmFuc2Zvcm1lZCBzdGF0aWNhbGx5LiBUaGlzIGFsbG93cyBmb3IgbW9kdWxhcml6YXRpb25cbiAqIGFuZCBtaW5pZmljYXRpb24gb2YgQ1NTIGNsYXNzIG5hbWVzLlxuICpcbiAqIEluIHN0YXRpY191cHN0cmVhbSwgdGhpcyBmdW5jdGlvbiBpcyBhY3R1YWxseSBpbXBsZW1lbnRlZCwgYnV0IGl0IHNob3VsZFxuICogZXZlbnR1YWxseSBiZSByZXBsYWNlZCB3aXRoIHNvbWV0aGluZyBtb3JlIGRlc2NyaXB0aXZlLCBhbmQgdGhlIHRyYW5zZm9ybVxuICogdGhhdCBpcyB1c2VkIGluIHRoZSBtYWluIHN0YWNrIHNob3VsZCBiZSBwb3J0ZWQgZm9yIHVzZSBlbHNld2hlcmUuXG4gKlxuICogQHBhcmFtIHN0cmluZ3xvYmplY3QgY2xhc3NOYW1lIHRvIG1vZHVsYXJpemUsIG9yIGFuIG9iamVjdCBvZiBrZXkvdmFsdWVzLlxuICogICAgICAgICAgICAgICAgICAgICAgSW4gdGhlIG9iamVjdCBjYXNlLCB0aGUgdmFsdWVzIGFyZSBjb25kaXRpb25zIHRoYXRcbiAqICAgICAgICAgICAgICAgICAgICAgIGRldGVybWluZSBpZiB0aGUgY2xhc3NOYW1lIGtleXMgc2hvdWxkIGJlIGluY2x1ZGVkLlxuICogQHBhcmFtIFtzdHJpbmcgLi4uXSAgVmFyaWFibGUgbGlzdCBvZiBjbGFzc05hbWVzIGluIHRoZSBzdHJpbmcgY2FzZS5cbiAqIEByZXR1cm4gc3RyaW5nICAgICAgIFJlbmRlcmFibGUgc3BhY2Utc2VwYXJhdGVkIENTUyBjbGFzc05hbWUuXG4gKi9cbmZ1bmN0aW9uIGN4KGNsYXNzTmFtZXMpIHtcbiAgaWYgKHR5cGVvZiBjbGFzc05hbWVzID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGNsYXNzTmFtZXMpLmZpbHRlcihmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICAgIHJldHVybiBjbGFzc05hbWVzW2NsYXNzTmFtZV07XG4gICAgfSkuam9pbignICcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuam9pbi5jYWxsKGFyZ3VtZW50cywgJyAnKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGN4O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGVtcHR5RnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge31cblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uKGFyZykgeyByZXR1cm4gYXJnOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaW52YXJpYW50XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xuICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ0ludmFyaWFudCBWaW9sYXRpb246ICcgK1xuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSB3YXJuaW5nXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZShcIi4vZW1wdHlGdW5jdGlvblwiKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCApIHtmb3IgKHZhciBhcmdzPVtdLCRfXzA9MiwkX18xPWFyZ3VtZW50cy5sZW5ndGg7JF9fMDwkX18xOyRfXzArKykgYXJncy5wdXNoKGFyZ3VtZW50c1skX18wXSk7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICtcbiAgICAgICAgJ21lc3NhZ2UgYXJndW1lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgY29uc29sZS53YXJuKCdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgIHtyZXR1cm4gYXJnc1thcmdJbmRleCsrXTt9KSk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8vIFRoaXMgbWV0aG9kIG9mIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCBuZWVkcyB0byBiZVxuLy8ga2VwdCBpZGVudGljYWwgdG8gdGhlIHdheSBpdCBpcyBvYnRhaW5lZCBpbiBydW50aW1lLmpzXG52YXIgZyA9IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG5cbi8vIFVzZSBgZ2V0T3duUHJvcGVydHlOYW1lc2AgYmVjYXVzZSBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgY2FsbGluZ1xuLy8gYGhhc093blByb3BlcnR5YCBvbiB0aGUgZ2xvYmFsIGBzZWxmYCBvYmplY3QgaW4gYSB3b3JrZXIuIFNlZSAjMTgzLlxudmFyIGhhZFJ1bnRpbWUgPSBnLnJlZ2VuZXJhdG9yUnVudGltZSAmJlxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnKS5pbmRleE9mKFwicmVnZW5lcmF0b3JSdW50aW1lXCIpID49IDA7XG5cbi8vIFNhdmUgdGhlIG9sZCByZWdlbmVyYXRvclJ1bnRpbWUgaW4gY2FzZSBpdCBuZWVkcyB0byBiZSByZXN0b3JlZCBsYXRlci5cbnZhciBvbGRSdW50aW1lID0gaGFkUnVudGltZSAmJiBnLnJlZ2VuZXJhdG9yUnVudGltZTtcblxuLy8gRm9yY2UgcmVldmFsdXRhdGlvbiBvZiBydW50aW1lLmpzLlxuZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcnVudGltZVwiKTtcblxuaWYgKGhhZFJ1bnRpbWUpIHtcbiAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcnVudGltZS5cbiAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBvbGRSdW50aW1lO1xufSBlbHNlIHtcbiAgLy8gUmVtb3ZlIHRoZSBnbG9iYWwgcHJvcGVydHkgYWRkZWQgYnkgcnVudGltZS5qcy5cbiAgdHJ5IHtcbiAgICBkZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIGcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBJbiBzbG9wcHkgbW9kZSwgdW5ib3VuZCBgdGhpc2AgcmVmZXJzIHRvIHRoZSBnbG9iYWwgb2JqZWN0LCBmYWxsYmFjayB0b1xuICAvLyBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpZiB3ZSdyZSBpbiBnbG9iYWwgc3RyaWN0IG1vZGUuIFRoYXQgaXMgc2FkbHkgYSBmb3JtXG4gIC8vIG9mIGluZGlyZWN0IGV2YWwgd2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXG4gIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKClcbik7XG4iLCIvLyEgc3RhYmxlLmpzIDAuMS44LCBodHRwczovL2dpdGh1Yi5jb20vVHdvLVNjcmVlbi9zdGFibGVcbi8vISDCqSAyMDE4IEFuZ3J5IEJ5dGVzIGFuZCBjb250cmlidXRvcnMuIE1JVCBsaWNlbnNlZC5cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsLnN0YWJsZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAvLyBBIHN0YWJsZSBhcnJheSBzb3J0LCBiZWNhdXNlIGBBcnJheSNzb3J0KClgIGlzIG5vdCBndWFyYW50ZWVkIHN0YWJsZS5cbiAgLy8gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBtZXJnZSBzb3J0LCB3aXRob3V0IHJlY3Vyc2lvbi5cblxuICB2YXIgc3RhYmxlID0gZnVuY3Rpb24gKGFyciwgY29tcCkge1xuICAgIHJldHVybiBleGVjKGFyci5zbGljZSgpLCBjb21wKVxuICB9O1xuXG4gIHN0YWJsZS5pbnBsYWNlID0gZnVuY3Rpb24gKGFyciwgY29tcCkge1xuICAgIHZhciByZXN1bHQgPSBleGVjKGFyciwgY29tcCk7XG5cbiAgICAvLyBUaGlzIHNpbXBseSBjb3BpZXMgYmFjayBpZiB0aGUgcmVzdWx0IGlzbid0IGluIHRoZSBvcmlnaW5hbCBhcnJheSxcbiAgICAvLyB3aGljaCBoYXBwZW5zIG9uIGFuIG9kZCBudW1iZXIgb2YgcGFzc2VzLlxuICAgIGlmIChyZXN1bHQgIT09IGFycikge1xuICAgICAgcGFzcyhyZXN1bHQsIG51bGwsIGFyci5sZW5ndGgsIGFycik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyclxuICB9O1xuXG4gIC8vIEV4ZWN1dGUgdGhlIHNvcnQgdXNpbmcgdGhlIGlucHV0IGFycmF5IGFuZCBhIHNlY29uZCBidWZmZXIgYXMgd29yayBzcGFjZS5cbiAgLy8gUmV0dXJucyBvbmUgb2YgdGhvc2UgdHdvLCBjb250YWluaW5nIHRoZSBmaW5hbCByZXN1bHQuXG4gIGZ1bmN0aW9uIGV4ZWMoYXJyLCBjb21wKSB7XG4gICAgaWYgKHR5cGVvZihjb21wKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoYSkubG9jYWxlQ29tcGFyZShiKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBTaG9ydC1jaXJjdWl0IHdoZW4gdGhlcmUncyBub3RoaW5nIHRvIHNvcnQuXG4gICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgaWYgKGxlbiA8PSAxKSB7XG4gICAgICByZXR1cm4gYXJyXG4gICAgfVxuXG4gICAgLy8gUmF0aGVyIHRoYW4gZGl2aWRpbmcgaW5wdXQsIHNpbXBseSBpdGVyYXRlIGNodW5rcyBvZiAxLCAyLCA0LCA4LCBldGMuXG4gICAgLy8gQ2h1bmtzIGFyZSB0aGUgc2l6ZSBvZiB0aGUgbGVmdCBvciByaWdodCBoYW5kIGluIG1lcmdlIHNvcnQuXG4gICAgLy8gU3RvcCB3aGVuIHRoZSBsZWZ0LWhhbmQgY292ZXJzIGFsbCBvZiB0aGUgYXJyYXkuXG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGNoayA9IDE7IGNoayA8IGxlbjsgY2hrICo9IDIpIHtcbiAgICAgIHBhc3MoYXJyLCBjb21wLCBjaGssIGJ1ZmZlcik7XG5cbiAgICAgIHZhciB0bXAgPSBhcnI7XG4gICAgICBhcnIgPSBidWZmZXI7XG4gICAgICBidWZmZXIgPSB0bXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyclxuICB9XG5cbiAgLy8gUnVuIGEgc2luZ2xlIHBhc3Mgd2l0aCB0aGUgZ2l2ZW4gY2h1bmsgc2l6ZS5cbiAgdmFyIHBhc3MgPSBmdW5jdGlvbiAoYXJyLCBjb21wLCBjaGssIHJlc3VsdCkge1xuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICAvLyBTdGVwIHNpemUgLyBkb3VibGUgY2h1bmsgc2l6ZS5cbiAgICB2YXIgZGJsID0gY2hrICogMjtcbiAgICAvLyBCb3VuZHMgb2YgdGhlIGxlZnQgYW5kIHJpZ2h0IGNodW5rcy5cbiAgICB2YXIgbCwgciwgZTtcbiAgICAvLyBJdGVyYXRvcnMgb3ZlciB0aGUgbGVmdCBhbmQgcmlnaHQgY2h1bmsuXG4gICAgdmFyIGxpLCByaTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBwYWlycyBvZiBjaHVua3MuXG4gICAgZm9yIChsID0gMDsgbCA8IGxlbjsgbCArPSBkYmwpIHtcbiAgICAgIHIgPSBsICsgY2hrO1xuICAgICAgZSA9IHIgKyBjaGs7XG4gICAgICBpZiAociA+IGxlbikgciA9IGxlbjtcbiAgICAgIGlmIChlID4gbGVuKSBlID0gbGVuO1xuXG4gICAgICAvLyBJdGVyYXRlIGJvdGggY2h1bmtzIGluIHBhcmFsbGVsLlxuICAgICAgbGkgPSBsO1xuICAgICAgcmkgPSByO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgLy8gQ29tcGFyZSB0aGUgY2h1bmtzLlxuICAgICAgICBpZiAobGkgPCByICYmIHJpIDwgZSkge1xuICAgICAgICAgIC8vIFRoaXMgd29ya3MgZm9yIGEgcmVndWxhciBgc29ydCgpYCBjb21wYXRpYmxlIGNvbXBhcmF0b3IsXG4gICAgICAgICAgLy8gYnV0IGFsc28gZm9yIGEgc2ltcGxlIGNvbXBhcmF0b3IgbGlrZTogYGEgPiBiYFxuICAgICAgICAgIGlmIChjb21wKGFycltsaV0sIGFycltyaV0pIDw9IDApIHtcbiAgICAgICAgICAgIHJlc3VsdFtpKytdID0gYXJyW2xpKytdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFtpKytdID0gYXJyW3JpKytdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RoaW5nIHRvIGNvbXBhcmUsIGp1c3QgZmx1c2ggd2hhdCdzIGxlZnQuXG4gICAgICAgIGVsc2UgaWYgKGxpIDwgcikge1xuICAgICAgICAgIHJlc3VsdFtpKytdID0gYXJyW2xpKytdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJpIDwgZSkge1xuICAgICAgICAgIHJlc3VsdFtpKytdID0gYXJyW3JpKytdO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJvdGggaXRlcmF0b3JzIGFyZSBhdCB0aGUgY2h1bmsgZW5kcy5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc3RhYmxlO1xuXG59KSkpO1xuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbihmdW5jdGlvbihkZWZpbmUpIHsgJ3VzZSBzdHJpY3QnO1xuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cblx0dmFyIG1ha2VQcm9taXNlID0gcmVxdWlyZSgnLi9tYWtlUHJvbWlzZScpO1xuXHR2YXIgU2NoZWR1bGVyID0gcmVxdWlyZSgnLi9TY2hlZHVsZXInKTtcblx0dmFyIGFzeW5jID0gcmVxdWlyZSgnLi9hc3luYycpO1xuXG5cdHJldHVybiBtYWtlUHJvbWlzZSh7XG5cdFx0c2NoZWR1bGVyOiBuZXcgU2NoZWR1bGVyKGFzeW5jKVxuXHR9KTtcblxufSk7XG59KSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH0pO1xuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbihmdW5jdGlvbihkZWZpbmUpIHsgJ3VzZSBzdHJpY3QnO1xuZGVmaW5lKGZ1bmN0aW9uKCkge1xuXHQvKipcblx0ICogQ2lyY3VsYXIgcXVldWVcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNhcGFjaXR5UG93MiBwb3dlciBvZiAyIHRvIHdoaWNoIHRoaXMgcXVldWUncyBjYXBhY2l0eVxuXHQgKiAgd2lsbCBiZSBzZXQgaW5pdGlhbGx5LiBlZyB3aGVuIGNhcGFjaXR5UG93MiA9PSAzLCBxdWV1ZSBjYXBhY2l0eVxuXHQgKiAgd2lsbCBiZSA4LlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFF1ZXVlKGNhcGFjaXR5UG93Mikge1xuXHRcdHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IHRoaXMubGVuZ3RoID0gMDtcblx0XHR0aGlzLmJ1ZmZlciA9IG5ldyBBcnJheSgxIDw8IGNhcGFjaXR5UG93Mik7XG5cdH1cblxuXHRRdWV1ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKHgpIHtcblx0XHRpZih0aGlzLmxlbmd0aCA9PT0gdGhpcy5idWZmZXIubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLl9lbnN1cmVDYXBhY2l0eSh0aGlzLmxlbmd0aCAqIDIpO1xuXHRcdH1cblxuXHRcdHRoaXMuYnVmZmVyW3RoaXMudGFpbF0gPSB4O1xuXHRcdHRoaXMudGFpbCA9ICh0aGlzLnRhaWwgKyAxKSAmICh0aGlzLmJ1ZmZlci5sZW5ndGggLSAxKTtcblx0XHQrK3RoaXMubGVuZ3RoO1xuXHRcdHJldHVybiB0aGlzLmxlbmd0aDtcblx0fTtcblxuXHRRdWV1ZS5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgeCA9IHRoaXMuYnVmZmVyW3RoaXMuaGVhZF07XG5cdFx0dGhpcy5idWZmZXJbdGhpcy5oZWFkXSA9IHZvaWQgMDtcblx0XHR0aGlzLmhlYWQgPSAodGhpcy5oZWFkICsgMSkgJiAodGhpcy5idWZmZXIubGVuZ3RoIC0gMSk7XG5cdFx0LS10aGlzLmxlbmd0aDtcblx0XHRyZXR1cm4geDtcblx0fTtcblxuXHRRdWV1ZS5wcm90b3R5cGUuX2Vuc3VyZUNhcGFjaXR5ID0gZnVuY3Rpb24oY2FwYWNpdHkpIHtcblx0XHR2YXIgaGVhZCA9IHRoaXMuaGVhZDtcblx0XHR2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG5cdFx0dmFyIG5ld0J1ZmZlciA9IG5ldyBBcnJheShjYXBhY2l0eSk7XG5cdFx0dmFyIGkgPSAwO1xuXHRcdHZhciBsZW47XG5cblx0XHRpZihoZWFkID09PSAwKSB7XG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aDtcblx0XHRcdGZvcig7IGk8bGVuOyArK2kpIHtcblx0XHRcdFx0bmV3QnVmZmVyW2ldID0gYnVmZmVyW2ldO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYXBhY2l0eSA9IGJ1ZmZlci5sZW5ndGg7XG5cdFx0XHRsZW4gPSB0aGlzLnRhaWw7XG5cdFx0XHRmb3IoOyBoZWFkPGNhcGFjaXR5OyArK2ksICsraGVhZCkge1xuXHRcdFx0XHRuZXdCdWZmZXJbaV0gPSBidWZmZXJbaGVhZF07XG5cdFx0XHR9XG5cblx0XHRcdGZvcihoZWFkPTA7IGhlYWQ8bGVuOyArK2ksICsraGVhZCkge1xuXHRcdFx0XHRuZXdCdWZmZXJbaV0gPSBidWZmZXJbaGVhZF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5idWZmZXIgPSBuZXdCdWZmZXI7XG5cdFx0dGhpcy5oZWFkID0gMDtcblx0XHR0aGlzLnRhaWwgPSB0aGlzLmxlbmd0aDtcblx0fTtcblxuXHRyZXR1cm4gUXVldWU7XG5cbn0pO1xufSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbihmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpOyB9KSk7XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSkge1xuXG5cdHZhciBRdWV1ZSA9IHJlcXVpcmUoJy4vUXVldWUnKTtcblxuXHQvLyBDcmVkaXQgdG8gVHdpc29sIChodHRwczovL2dpdGh1Yi5jb20vVHdpc29sKSBmb3Igc3VnZ2VzdGluZ1xuXHQvLyB0aGlzIHR5cGUgb2YgZXh0ZW5zaWJsZSBxdWV1ZSArIHRyYW1wb2xpbmUgYXBwcm9hY2ggZm9yIG5leHQtdGljayBjb25mbGF0aW9uLlxuXG5cdC8qKlxuXHQgKiBBc3luYyB0YXNrIHNjaGVkdWxlclxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBhc3luYyBmdW5jdGlvbiB0byBzY2hlZHVsZSBhIHNpbmdsZSBhc3luYyBmdW5jdGlvblxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFNjaGVkdWxlcihhc3luYykge1xuXHRcdHRoaXMuX2FzeW5jID0gYXN5bmM7XG5cdFx0dGhpcy5fcXVldWUgPSBuZXcgUXVldWUoMTUpO1xuXHRcdHRoaXMuX2FmdGVyUXVldWUgPSBuZXcgUXVldWUoNSk7XG5cdFx0dGhpcy5fcnVubmluZyA9IGZhbHNlO1xuXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHRoaXMuZHJhaW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdHNlbGYuX2RyYWluKCk7XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbnF1ZXVlIGEgdGFza1xuXHQgKiBAcGFyYW0ge3sgcnVuOmZ1bmN0aW9uIH19IHRhc2tcblx0ICovXG5cdFNjaGVkdWxlci5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uKHRhc2spIHtcblx0XHR0aGlzLl9hZGQodGhpcy5fcXVldWUsIHRhc2spO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbnF1ZXVlIGEgdGFzayB0byBydW4gYWZ0ZXIgdGhlIG1haW4gdGFzayBxdWV1ZVxuXHQgKiBAcGFyYW0ge3sgcnVuOmZ1bmN0aW9uIH19IHRhc2tcblx0ICovXG5cdFNjaGVkdWxlci5wcm90b3R5cGUuYWZ0ZXJRdWV1ZSA9IGZ1bmN0aW9uKHRhc2spIHtcblx0XHR0aGlzLl9hZGQodGhpcy5fYWZ0ZXJRdWV1ZSwgdGFzayk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYWluIHRoZSBoYW5kbGVyIHF1ZXVlIGVudGlyZWx5LCBhbmQgdGhlbiB0aGUgYWZ0ZXIgcXVldWVcblx0ICovXG5cdFNjaGVkdWxlci5wcm90b3R5cGUuX2RyYWluID0gZnVuY3Rpb24oKSB7XG5cdFx0cnVuUXVldWUodGhpcy5fcXVldWUpO1xuXHRcdHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcblx0XHRydW5RdWV1ZSh0aGlzLl9hZnRlclF1ZXVlKTtcblx0fTtcblxuXHQvKipcblx0ICogQWRkIGEgdGFzayB0byB0aGUgcSwgYW5kIHNjaGVkdWxlIGRyYWluIGlmIG5vdCBhbHJlYWR5IHNjaGVkdWxlZFxuXHQgKiBAcGFyYW0ge1F1ZXVlfSBxdWV1ZVxuXHQgKiBAcGFyYW0ge3tydW46ZnVuY3Rpb259fSB0YXNrXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRTY2hlZHVsZXIucHJvdG90eXBlLl9hZGQgPSBmdW5jdGlvbihxdWV1ZSwgdGFzaykge1xuXHRcdHF1ZXVlLnB1c2godGFzayk7XG5cdFx0aWYoIXRoaXMuX3J1bm5pbmcpIHtcblx0XHRcdHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuXHRcdFx0dGhpcy5fYXN5bmModGhpcy5kcmFpbik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSdW4gYWxsIHRoZSB0YXNrcyBpbiB0aGUgcVxuXHQgKiBAcGFyYW0gcXVldWVcblx0ICovXG5cdGZ1bmN0aW9uIHJ1blF1ZXVlKHF1ZXVlKSB7XG5cdFx0d2hpbGUocXVldWUubGVuZ3RoID4gMCkge1xuXHRcdFx0cXVldWUuc2hpZnQoKS5ydW4oKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gU2NoZWR1bGVyO1xuXG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH0pKTtcbiIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuXG4oZnVuY3Rpb24oZGVmaW5lKSB7ICd1c2Ugc3RyaWN0JztcbmRlZmluZShmdW5jdGlvbihyZXF1aXJlKSB7XG5cblx0Ly8gU25pZmYgXCJiZXN0XCIgYXN5bmMgc2NoZWR1bGluZyBvcHRpb25cblx0Ly8gUHJlZmVyIHByb2Nlc3MubmV4dFRpY2sgb3IgTXV0YXRpb25PYnNlcnZlciwgdGhlbiBjaGVjayBmb3Jcblx0Ly8gdmVydHggYW5kIGZpbmFsbHkgZmFsbCBiYWNrIHRvIHNldFRpbWVvdXRcblxuXHQvKmpzaGludCBtYXhjb21wbGV4aXR5OjYqL1xuXHQvKmdsb2JhbCBwcm9jZXNzLGRvY3VtZW50LHNldFRpbWVvdXQsTXV0YXRpb25PYnNlcnZlcixXZWJLaXRNdXRhdGlvbk9ic2VydmVyKi9cblx0dmFyIG5leHRUaWNrLCBNdXRhdGlvbk9icztcblxuXHRpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MgIT09IG51bGwgJiZcblx0XHR0eXBlb2YgcHJvY2Vzcy5uZXh0VGljayA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdG5leHRUaWNrID0gZnVuY3Rpb24oZikge1xuXHRcdFx0cHJvY2Vzcy5uZXh0VGljayhmKTtcblx0XHR9O1xuXG5cdH0gZWxzZSBpZiAoTXV0YXRpb25PYnMgPVxuXHRcdCh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBNdXRhdGlvbk9ic2VydmVyKSB8fFxuXHRcdCh0eXBlb2YgV2ViS2l0TXV0YXRpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBXZWJLaXRNdXRhdGlvbk9ic2VydmVyKSkge1xuXHRcdG5leHRUaWNrID0gKGZ1bmN0aW9uIChkb2N1bWVudCwgTXV0YXRpb25PYnNlcnZlcikge1xuXHRcdFx0dmFyIHNjaGVkdWxlZDtcblx0XHRcdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0dmFyIG8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcihydW4pO1xuXHRcdFx0by5vYnNlcnZlKGVsLCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG5cblx0XHRcdGZ1bmN0aW9uIHJ1bigpIHtcblx0XHRcdFx0dmFyIGYgPSBzY2hlZHVsZWQ7XG5cdFx0XHRcdHNjaGVkdWxlZCA9IHZvaWQgMDtcblx0XHRcdFx0ZigpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGYpIHtcblx0XHRcdFx0c2NoZWR1bGVkID0gZjtcblx0XHRcdFx0ZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsICd4Jyk7XG5cdFx0XHR9O1xuXHRcdH0oZG9jdW1lbnQsIE11dGF0aW9uT2JzKSk7XG5cblx0fSBlbHNlIHtcblx0XHRuZXh0VGljayA9IChmdW5jdGlvbihjanNSZXF1aXJlKSB7XG5cdFx0XHR2YXIgdmVydHg7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyB2ZXJ0LnggMS54IHx8IDIueFxuXHRcdFx0XHR2ZXJ0eCA9IGNqc1JlcXVpcmUoJ3ZlcnR4Jyk7XG5cdFx0XHR9IGNhdGNoIChpZ25vcmUpIHt9XG5cblx0XHRcdGlmICh2ZXJ0eCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIHZlcnR4LnJ1bk9uTG9vcCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdHJldHVybiB2ZXJ0eC5ydW5Pbkxvb3A7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR5cGVvZiB2ZXJ0eC5ydW5PbkNvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRyZXR1cm4gdmVydHgucnVuT25Db250ZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNhcHR1cmUgc2V0VGltZW91dCB0byBhdm9pZCBiZWluZyBjYXVnaHQgYnkgZmFrZSB0aW1lcnNcblx0XHRcdC8vIHVzZWQgaW4gdGltZSBiYXNlZCB0ZXN0c1xuXHRcdFx0dmFyIGNhcHR1cmVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKHQpIHtcblx0XHRcdFx0Y2FwdHVyZWRTZXRUaW1lb3V0KHQsIDApO1xuXHRcdFx0fTtcblx0XHR9KHJlcXVpcmUpKTtcblx0fVxuXG5cdHJldHVybiBuZXh0VGljaztcbn0pO1xufSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbihmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfSkpO1xuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbihmdW5jdGlvbihkZWZpbmUpIHsgJ3VzZSBzdHJpY3QnO1xuZGVmaW5lKGZ1bmN0aW9uKCkge1xuXG5cdHJldHVybiBmdW5jdGlvbiBtYWtlUHJvbWlzZShlbnZpcm9ubWVudCkge1xuXG5cdFx0dmFyIHRhc2tzID0gZW52aXJvbm1lbnQuc2NoZWR1bGVyO1xuXG5cdFx0dmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHxcblx0XHRcdGZ1bmN0aW9uKHByb3RvKSB7XG5cdFx0XHRcdGZ1bmN0aW9uIENoaWxkKCkge31cblx0XHRcdFx0Q2hpbGQucHJvdG90eXBlID0gcHJvdG87XG5cdFx0XHRcdHJldHVybiBuZXcgQ2hpbGQoKTtcblx0XHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGUgYSBwcm9taXNlIHdob3NlIGZhdGUgaXMgZGV0ZXJtaW5lZCBieSByZXNvbHZlclxuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlXG5cdFx0ICogQG5hbWUgUHJvbWlzZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIsIGhhbmRsZXIpIHtcblx0XHRcdHRoaXMuX2hhbmRsZXIgPSByZXNvbHZlciA9PT0gSGFuZGxlciA/IGhhbmRsZXIgOiBpbml0KHJlc29sdmVyKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBSdW4gdGhlIHN1cHBsaWVkIHJlc29sdmVyXG5cdFx0ICogQHBhcmFtIHJlc29sdmVyXG5cdFx0ICogQHJldHVybnMge1BlbmRpbmd9XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gaW5pdChyZXNvbHZlcikge1xuXHRcdFx0dmFyIGhhbmRsZXIgPSBuZXcgUGVuZGluZygpO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXNvbHZlcihwcm9taXNlUmVzb2x2ZSwgcHJvbWlzZVJlamVjdCwgcHJvbWlzZU5vdGlmeSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHByb21pc2VSZWplY3QoZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBoYW5kbGVyO1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRyYW5zaXRpb24gZnJvbSBwcmUtcmVzb2x1dGlvbiBzdGF0ZSB0byBwb3N0LXJlc29sdXRpb24gc3RhdGUsIG5vdGlmeWluZ1xuXHRcdFx0ICogYWxsIGxpc3RlbmVycyBvZiB0aGUgdWx0aW1hdGUgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uXG5cdFx0XHQgKiBAcGFyYW0geyp9IHggcmVzb2x1dGlvbiB2YWx1ZVxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBwcm9taXNlUmVzb2x2ZSAoeCkge1xuXHRcdFx0XHRoYW5kbGVyLnJlc29sdmUoeCk7XG5cdFx0XHR9XG5cdFx0XHQvKipcblx0XHRcdCAqIFJlamVjdCB0aGlzIHByb21pc2Ugd2l0aCByZWFzb24sIHdoaWNoIHdpbGwgYmUgdXNlZCB2ZXJiYXRpbVxuXHRcdFx0ICogQHBhcmFtIHtFcnJvcnwqfSByZWFzb24gcmVqZWN0aW9uIHJlYXNvbiwgc3Ryb25nbHkgc3VnZ2VzdGVkXG5cdFx0XHQgKiAgIHRvIGJlIGFuIEVycm9yIHR5cGVcblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gcHJvbWlzZVJlamVjdCAocmVhc29uKSB7XG5cdFx0XHRcdGhhbmRsZXIucmVqZWN0KHJlYXNvbik7XG5cdFx0XHR9XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogSXNzdWUgYSBwcm9ncmVzcyBldmVudCwgbm90aWZ5aW5nIGFsbCBwcm9ncmVzcyBsaXN0ZW5lcnNcblx0XHRcdCAqIEBwYXJhbSB7Kn0geCBwcm9ncmVzcyBldmVudCBwYXlsb2FkIHRvIHBhc3MgdG8gYWxsIGxpc3RlbmVyc1xuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBwcm9taXNlTm90aWZ5ICh4KSB7XG5cdFx0XHRcdGhhbmRsZXIubm90aWZ5KHgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENyZWF0aW9uXG5cblx0XHRQcm9taXNlLnJlc29sdmUgPSByZXNvbHZlO1xuXHRcdFByb21pc2UucmVqZWN0ID0gcmVqZWN0O1xuXHRcdFByb21pc2UubmV2ZXIgPSBuZXZlcjtcblxuXHRcdFByb21pc2UuX2RlZmVyID0gZGVmZXI7XG5cdFx0UHJvbWlzZS5faGFuZGxlciA9IGdldEhhbmRsZXI7XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGEgdHJ1c3RlZCBwcm9taXNlLiBJZiB4IGlzIGFscmVhZHkgYSB0cnVzdGVkIHByb21pc2UsIGl0IGlzXG5cdFx0ICogcmV0dXJuZWQsIG90aGVyd2lzZSByZXR1cm5zIGEgbmV3IHRydXN0ZWQgUHJvbWlzZSB3aGljaCBmb2xsb3dzIHguXG5cdFx0ICogQHBhcmFtICB7Kn0geFxuXHRcdCAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Vcblx0XHQgKi9cblx0XHRmdW5jdGlvbiByZXNvbHZlKHgpIHtcblx0XHRcdHJldHVybiBpc1Byb21pc2UoeCkgPyB4XG5cdFx0XHRcdDogbmV3IFByb21pc2UoSGFuZGxlciwgbmV3IEFzeW5jKGdldEhhbmRsZXIoeCkpKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm4gYSByZWplY3QgcHJvbWlzZSB3aXRoIHggYXMgaXRzIHJlYXNvbiAoeCBpcyB1c2VkIHZlcmJhdGltKVxuXHRcdCAqIEBwYXJhbSB7Kn0geFxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSByZWplY3RlZCBwcm9taXNlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gcmVqZWN0KHgpIHtcblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShIYW5kbGVyLCBuZXcgQXN5bmMobmV3IFJlamVjdGVkKHgpKSk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGEgcHJvbWlzZSB0aGF0IHJlbWFpbnMgcGVuZGluZyBmb3JldmVyXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9IGZvcmV2ZXItcGVuZGluZyBwcm9taXNlLlxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIG5ldmVyKCkge1xuXHRcdFx0cmV0dXJuIGZvcmV2ZXJQZW5kaW5nUHJvbWlzZTsgLy8gU2hvdWxkIGJlIGZyb3plblxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgYW4gaW50ZXJuYWwge3Byb21pc2UsIHJlc29sdmVyfSBwYWlyXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBkZWZlcigpIHtcblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShIYW5kbGVyLCBuZXcgUGVuZGluZygpKTtcblx0XHR9XG5cblx0XHQvLyBUcmFuc2Zvcm1hdGlvbiBhbmQgZmxvdyBjb250cm9sXG5cblx0XHQvKipcblx0XHQgKiBUcmFuc2Zvcm0gdGhpcyBwcm9taXNlJ3MgZnVsZmlsbG1lbnQgdmFsdWUsIHJldHVybmluZyBhIG5ldyBQcm9taXNlXG5cdFx0ICogZm9yIHRoZSB0cmFuc2Zvcm1lZCByZXN1bHQuICBJZiB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLCBvblJlamVjdGVkXG5cdFx0ICogaXMgY2FsbGVkIHdpdGggdGhlIHJlYXNvbi4gIG9uUHJvZ3Jlc3MgKm1heSogYmUgY2FsbGVkIHdpdGggdXBkYXRlcyB0b3dhcmRcblx0XHQgKiB0aGlzIHByb21pc2UncyBmdWxmaWxsbWVudC5cblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gb25GdWxmaWxsZWQgZnVsZmlsbG1lbnQgaGFuZGxlclxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb249fSBvblJlamVjdGVkIHJlamVjdGlvbiBoYW5kbGVyXG5cdFx0ICogQGRlcHJlY2F0ZWQgQHBhcmFtIHtmdW5jdGlvbj19IG9uUHJvZ3Jlc3MgcHJvZ3Jlc3MgaGFuZGxlclxuXHRcdCAqIEByZXR1cm4ge1Byb21pc2V9IG5ldyBwcm9taXNlXG5cdFx0ICovXG5cdFx0UHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5faGFuZGxlcjtcblx0XHRcdHZhciBzdGF0ZSA9IHBhcmVudC5qb2luKCkuc3RhdGUoKTtcblxuXHRcdFx0aWYgKCh0eXBlb2Ygb25GdWxmaWxsZWQgIT09ICdmdW5jdGlvbicgJiYgc3RhdGUgPiAwKSB8fFxuXHRcdFx0XHQodHlwZW9mIG9uUmVqZWN0ZWQgIT09ICdmdW5jdGlvbicgJiYgc3RhdGUgPCAwKSkge1xuXHRcdFx0XHQvLyBTaG9ydCBjaXJjdWl0OiB2YWx1ZSB3aWxsIG5vdCBjaGFuZ2UsIHNpbXBseSBzaGFyZSBoYW5kbGVyXG5cdFx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihIYW5kbGVyLCBwYXJlbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcCA9IHRoaXMuX2JlZ2V0KCk7XG5cdFx0XHR2YXIgY2hpbGQgPSBwLl9oYW5kbGVyO1xuXG5cdFx0XHRwYXJlbnQuY2hhaW4oY2hpbGQsIHBhcmVudC5yZWNlaXZlciwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsXG5cdFx0XHRcdFx0YXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB2b2lkIDApO1xuXG5cdFx0XHRyZXR1cm4gcDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSWYgdGhpcyBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQgZHVlIHRvIGFuIGVycm9yLCBjYWxsIG9uUmVqZWN0ZWQgdG9cblx0XHQgKiBoYW5kbGUgdGhlIGVycm9yLiBTaG9ydGN1dCBmb3IgLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKVxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb24/fSBvblJlamVjdGVkXG5cdFx0ICogQHJldHVybiB7UHJvbWlzZX1cblx0XHQgKi9cblx0XHRQcm9taXNlLnByb3RvdHlwZVsnY2F0Y2gnXSA9IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpIHtcblx0XHRcdHJldHVybiB0aGlzLnRoZW4odm9pZCAwLCBvblJlamVjdGVkKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlcyBhIG5ldywgcGVuZGluZyBwcm9taXNlIG9mIHRoZSBzYW1lIHR5cGUgYXMgdGhpcyBwcm9taXNlXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX1cblx0XHQgKi9cblx0XHRQcm9taXNlLnByb3RvdHlwZS5fYmVnZXQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLl9oYW5kbGVyO1xuXHRcdFx0dmFyIGNoaWxkID0gbmV3IFBlbmRpbmcocGFyZW50LnJlY2VpdmVyLCBwYXJlbnQuam9pbigpLmNvbnRleHQpO1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKEhhbmRsZXIsIGNoaWxkKTtcblx0XHR9O1xuXG5cdFx0Ly8gQXJyYXkgY29tYmluYXRvcnNcblxuXHRcdFByb21pc2UuYWxsID0gYWxsO1xuXHRcdFByb21pc2UucmFjZSA9IHJhY2U7XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCBmdWxmaWxsIHdoZW4gYWxsIHByb21pc2VzIGluIHRoZVxuXHRcdCAqIGlucHV0IGFycmF5IGhhdmUgZnVsZmlsbGVkLCBvciB3aWxsIHJlamVjdCB3aGVuIG9uZSBvZiB0aGVcblx0XHQgKiBwcm9taXNlcyByZWplY3RzLlxuXHRcdCAqIEBwYXJhbSB7YXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2UgZm9yIGFycmF5IG9mIGZ1bGZpbGxtZW50IHZhbHVlc1xuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuXHRcdFx0Lypqc2hpbnQgbWF4Y29tcGxleGl0eTo4Ki9cblx0XHRcdHZhciByZXNvbHZlciA9IG5ldyBQZW5kaW5nKCk7XG5cdFx0XHR2YXIgcGVuZGluZyA9IHByb21pc2VzLmxlbmd0aCA+Pj4gMDtcblx0XHRcdHZhciByZXN1bHRzID0gbmV3IEFycmF5KHBlbmRpbmcpO1xuXG5cdFx0XHR2YXIgaSwgaCwgeCwgcztcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBwcm9taXNlcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR4ID0gcHJvbWlzZXNbaV07XG5cblx0XHRcdFx0aWYgKHggPT09IHZvaWQgMCAmJiAhKGkgaW4gcHJvbWlzZXMpKSB7XG5cdFx0XHRcdFx0LS1wZW5kaW5nO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG1heWJlVGhlbmFibGUoeCkpIHtcblx0XHRcdFx0XHRoID0gZ2V0SGFuZGxlck1heWJlVGhlbmFibGUoeCk7XG5cblx0XHRcdFx0XHRzID0gaC5zdGF0ZSgpO1xuXHRcdFx0XHRcdGlmIChzID09PSAwKSB7XG5cdFx0XHRcdFx0XHRoLmZvbGQoc2V0dGxlQXQsIGksIHJlc3VsdHMsIHJlc29sdmVyKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHMgPiAwKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzW2ldID0gaC52YWx1ZTtcblx0XHRcdFx0XHRcdC0tcGVuZGluZztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dW5yZXBvcnRSZW1haW5pbmcocHJvbWlzZXMsIGkrMSwgaCk7XG5cdFx0XHRcdFx0XHRyZXNvbHZlci5iZWNvbWUoaCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXN1bHRzW2ldID0geDtcblx0XHRcdFx0XHQtLXBlbmRpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYocGVuZGluZyA9PT0gMCkge1xuXHRcdFx0XHRyZXNvbHZlci5iZWNvbWUobmV3IEZ1bGZpbGxlZChyZXN1bHRzKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShIYW5kbGVyLCByZXNvbHZlcik7XG5cblx0XHRcdGZ1bmN0aW9uIHNldHRsZUF0KGksIHgsIHJlc29sdmVyKSB7XG5cdFx0XHRcdC8qanNoaW50IHZhbGlkdGhpczp0cnVlKi9cblx0XHRcdFx0dGhpc1tpXSA9IHg7XG5cdFx0XHRcdGlmKC0tcGVuZGluZyA9PT0gMCkge1xuXHRcdFx0XHRcdHJlc29sdmVyLmJlY29tZShuZXcgRnVsZmlsbGVkKHRoaXMpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVucmVwb3J0UmVtYWluaW5nKHByb21pc2VzLCBzdGFydCwgcmVqZWN0ZWRIYW5kbGVyKSB7XG5cdFx0XHR2YXIgaSwgaCwgeDtcblx0XHRcdGZvcihpPXN0YXJ0OyBpPHByb21pc2VzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHggPSBwcm9taXNlc1tpXTtcblx0XHRcdFx0aWYobWF5YmVUaGVuYWJsZSh4KSkge1xuXHRcdFx0XHRcdGggPSBnZXRIYW5kbGVyTWF5YmVUaGVuYWJsZSh4KTtcblxuXHRcdFx0XHRcdGlmKGggIT09IHJlamVjdGVkSGFuZGxlcikge1xuXHRcdFx0XHRcdFx0aC52aXNpdChoLCB2b2lkIDAsIGguX3VucmVwb3J0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBGdWxmaWxsLXJlamVjdCBjb21wZXRpdGl2ZSByYWNlLiBSZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCBzZXR0bGVcblx0XHQgKiB0byB0aGUgc2FtZSBzdGF0ZSBhcyB0aGUgZWFybGllc3QgaW5wdXQgcHJvbWlzZSB0byBzZXR0bGUuXG5cdFx0ICpcblx0XHQgKiBXQVJOSU5HOiBUaGUgRVM2IFByb21pc2Ugc3BlYyByZXF1aXJlcyB0aGF0IHJhY2UoKWluZyBhbiBlbXB0eSBhcnJheVxuXHRcdCAqIG11c3QgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IGlzIHBlbmRpbmcgZm9yZXZlci4gIFRoaXMgaW1wbGVtZW50YXRpb25cblx0XHQgKiByZXR1cm5zIGEgc2luZ2xldG9uIGZvcmV2ZXItcGVuZGluZyBwcm9taXNlLCB0aGUgc2FtZSBzaW5nbGV0b24gdGhhdCBpc1xuXHRcdCAqIHJldHVybmVkIGJ5IFByb21pc2UubmV2ZXIoKSwgdGh1cyBjYW4gYmUgY2hlY2tlZCB3aXRoID09PVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHthcnJheX0gcHJvbWlzZXMgYXJyYXkgb2YgcHJvbWlzZXMgdG8gcmFjZVxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBpZiBpbnB1dCBpcyBub24tZW1wdHksIGEgcHJvbWlzZSB0aGF0IHdpbGwgc2V0dGxlXG5cdFx0ICogdG8gdGhlIHNhbWUgb3V0Y29tZSBhcyB0aGUgZWFybGllc3QgaW5wdXQgcHJvbWlzZSB0byBzZXR0bGUuIGlmIGVtcHR5XG5cdFx0ICogaXMgZW1wdHksIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBuZXZlciBzZXR0bGUuXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gcmFjZShwcm9taXNlcykge1xuXHRcdFx0Ly8gU2lnaCwgcmFjZShbXSkgaXMgdW50ZXN0YWJsZSB1bmxlc3Mgd2UgcmV0dXJuICpzb21ldGhpbmcqXG5cdFx0XHQvLyB0aGF0IGlzIHJlY29nbml6YWJsZSB3aXRob3V0IGNhbGxpbmcgLnRoZW4oKSBvbiBpdC5cblx0XHRcdGlmKE9iamVjdChwcm9taXNlcykgPT09IHByb21pc2VzICYmIHByb21pc2VzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gbmV2ZXIoKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGggPSBuZXcgUGVuZGluZygpO1xuXHRcdFx0dmFyIGksIHg7XG5cdFx0XHRmb3IoaT0wOyBpPHByb21pc2VzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHggPSBwcm9taXNlc1tpXTtcblx0XHRcdFx0aWYgKHggIT09IHZvaWQgMCAmJiBpIGluIHByb21pc2VzKSB7XG5cdFx0XHRcdFx0Z2V0SGFuZGxlcih4KS52aXNpdChoLCBoLnJlc29sdmUsIGgucmVqZWN0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKEhhbmRsZXIsIGgpO1xuXHRcdH1cblxuXHRcdC8vIFByb21pc2UgaW50ZXJuYWxzXG5cdFx0Ly8gQmVsb3cgdGhpcywgZXZlcnl0aGluZyBpcyBAcHJpdmF0ZVxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IGFuIGFwcHJvcHJpYXRlIGhhbmRsZXIgZm9yIHgsIHdpdGhvdXQgY2hlY2tpbmcgZm9yIGN5Y2xlc1xuXHRcdCAqIEBwYXJhbSB7Kn0geFxuXHRcdCAqIEByZXR1cm5zIHtvYmplY3R9IGhhbmRsZXJcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBnZXRIYW5kbGVyKHgpIHtcblx0XHRcdGlmKGlzUHJvbWlzZSh4KSkge1xuXHRcdFx0XHRyZXR1cm4geC5faGFuZGxlci5qb2luKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF5YmVUaGVuYWJsZSh4KSA/IGdldEhhbmRsZXJVbnRydXN0ZWQoeCkgOiBuZXcgRnVsZmlsbGVkKHgpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEdldCBhIGhhbmRsZXIgZm9yIHRoZW5hYmxlIHguXG5cdFx0ICogTk9URTogWW91IG11c3Qgb25seSBjYWxsIHRoaXMgaWYgbWF5YmVUaGVuYWJsZSh4KSA9PSB0cnVlXG5cdFx0ICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb258UHJvbWlzZX0geFxuXHRcdCAqIEByZXR1cm5zIHtvYmplY3R9IGhhbmRsZXJcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBnZXRIYW5kbGVyTWF5YmVUaGVuYWJsZSh4KSB7XG5cdFx0XHRyZXR1cm4gaXNQcm9taXNlKHgpID8geC5faGFuZGxlci5qb2luKCkgOiBnZXRIYW5kbGVyVW50cnVzdGVkKHgpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEdldCBhIGhhbmRsZXIgZm9yIHBvdGVudGlhbGx5IHVudHJ1c3RlZCB0aGVuYWJsZSB4XG5cdFx0ICogQHBhcmFtIHsqfSB4XG5cdFx0ICogQHJldHVybnMge29iamVjdH0gaGFuZGxlclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGdldEhhbmRsZXJVbnRydXN0ZWQoeCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIHVudHJ1c3RlZFRoZW4gPSB4LnRoZW47XG5cdFx0XHRcdHJldHVybiB0eXBlb2YgdW50cnVzdGVkVGhlbiA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0XHRcdD8gbmV3IFRoZW5hYmxlKHVudHJ1c3RlZFRoZW4sIHgpXG5cdFx0XHRcdFx0OiBuZXcgRnVsZmlsbGVkKHgpO1xuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgUmVqZWN0ZWQoZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlciBmb3IgYSBwcm9taXNlIHRoYXQgaXMgcGVuZGluZyBmb3JldmVyXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gSGFuZGxlcigpIHt9XG5cblx0XHRIYW5kbGVyLnByb3RvdHlwZS53aGVuXG5cdFx0XHQ9IEhhbmRsZXIucHJvdG90eXBlLmJlY29tZVxuXHRcdFx0PSBIYW5kbGVyLnByb3RvdHlwZS5ub3RpZnlcblx0XHRcdD0gSGFuZGxlci5wcm90b3R5cGUuZmFpbFxuXHRcdFx0PSBIYW5kbGVyLnByb3RvdHlwZS5fdW5yZXBvcnRcblx0XHRcdD0gSGFuZGxlci5wcm90b3R5cGUuX3JlcG9ydFxuXHRcdFx0PSBub29wO1xuXG5cdFx0SGFuZGxlci5wcm90b3R5cGUuX3N0YXRlID0gMDtcblxuXHRcdEhhbmRsZXIucHJvdG90eXBlLnN0YXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc3RhdGU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFJlY3Vyc2l2ZWx5IGNvbGxhcHNlIGhhbmRsZXIgY2hhaW4gdG8gZmluZCB0aGUgaGFuZGxlclxuXHRcdCAqIG5lYXJlc3QgdG8gdGhlIGZ1bGx5IHJlc29sdmVkIHZhbHVlLlxuXHRcdCAqIEByZXR1cm5zIHtvYmplY3R9IGhhbmRsZXIgbmVhcmVzdCB0aGUgZnVsbHkgcmVzb2x2ZWQgdmFsdWVcblx0XHQgKi9cblx0XHRIYW5kbGVyLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaCA9IHRoaXM7XG5cdFx0XHR3aGlsZShoLmhhbmRsZXIgIT09IHZvaWQgMCkge1xuXHRcdFx0XHRoID0gaC5oYW5kbGVyO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGg7XG5cdFx0fTtcblxuXHRcdEhhbmRsZXIucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24odG8sIHJlY2VpdmVyLCBmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcykge1xuXHRcdFx0dGhpcy53aGVuKHtcblx0XHRcdFx0cmVzb2x2ZXI6IHRvLFxuXHRcdFx0XHRyZWNlaXZlcjogcmVjZWl2ZXIsXG5cdFx0XHRcdGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuXHRcdFx0XHRyZWplY3RlZDogcmVqZWN0ZWQsXG5cdFx0XHRcdHByb2dyZXNzOiBwcm9ncmVzc1xuXHRcdFx0fSk7XG5cdFx0fTtcblxuXHRcdEhhbmRsZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24ocmVjZWl2ZXIsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKSB7XG5cdFx0XHR0aGlzLmNoYWluKGZhaWxJZlJlamVjdGVkLCByZWNlaXZlciwgZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpO1xuXHRcdH07XG5cblx0XHRIYW5kbGVyLnByb3RvdHlwZS5mb2xkID0gZnVuY3Rpb24oZiwgeiwgYywgdG8pIHtcblx0XHRcdHRoaXMudmlzaXQodG8sIGZ1bmN0aW9uKHgpIHtcblx0XHRcdFx0Zi5jYWxsKGMsIHosIHgsIHRoaXMpO1xuXHRcdFx0fSwgdG8ucmVqZWN0LCB0by5ub3RpZnkpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGVyIHRoYXQgaW52b2tlcyBmYWlsKCkgb24gYW55IGhhbmRsZXIgaXQgYmVjb21lc1xuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIEZhaWxJZlJlamVjdGVkKCkge31cblxuXHRcdGluaGVyaXQoSGFuZGxlciwgRmFpbElmUmVqZWN0ZWQpO1xuXG5cdFx0RmFpbElmUmVqZWN0ZWQucHJvdG90eXBlLmJlY29tZSA9IGZ1bmN0aW9uKGgpIHtcblx0XHRcdGguZmFpbCgpO1xuXHRcdH07XG5cblx0XHR2YXIgZmFpbElmUmVqZWN0ZWQgPSBuZXcgRmFpbElmUmVqZWN0ZWQoKTtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgdGhhdCBtYW5hZ2VzIGEgcXVldWUgb2YgY29uc3VtZXJzIHdhaXRpbmcgb24gYSBwZW5kaW5nIHByb21pc2Vcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBQZW5kaW5nKHJlY2VpdmVyLCBpbmhlcml0ZWRDb250ZXh0KSB7XG5cdFx0XHRQcm9taXNlLmNyZWF0ZUNvbnRleHQodGhpcywgaW5oZXJpdGVkQ29udGV4dCk7XG5cblx0XHRcdHRoaXMuY29uc3VtZXJzID0gdm9pZCAwO1xuXHRcdFx0dGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuXHRcdFx0dGhpcy5oYW5kbGVyID0gdm9pZCAwO1xuXHRcdFx0dGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGluaGVyaXQoSGFuZGxlciwgUGVuZGluZyk7XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5fc3RhdGUgPSAwO1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdHRoaXMuYmVjb21lKGdldEhhbmRsZXIoeCkpO1xuXHRcdH07XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHRpZih0aGlzLnJlc29sdmVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5iZWNvbWUobmV3IFJlamVjdGVkKHgpKTtcblx0XHR9O1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCF0aGlzLnJlc29sdmVkKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaCA9IHRoaXM7XG5cblx0XHRcdHdoaWxlIChoLmhhbmRsZXIgIT09IHZvaWQgMCkge1xuXHRcdFx0XHRoID0gaC5oYW5kbGVyO1xuXHRcdFx0XHRpZiAoaCA9PT0gdGhpcykge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmhhbmRsZXIgPSBjeWNsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBoO1xuXHRcdH07XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBxID0gdGhpcy5jb25zdW1lcnM7XG5cdFx0XHR2YXIgaGFuZGxlciA9IHRoaXMuam9pbigpO1xuXHRcdFx0dGhpcy5jb25zdW1lcnMgPSB2b2lkIDA7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcS5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRoYW5kbGVyLndoZW4ocVtpXSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdFBlbmRpbmcucHJvdG90eXBlLmJlY29tZSA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcblx0XHRcdGlmKHRoaXMucmVzb2x2ZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnJlc29sdmVkID0gdHJ1ZTtcblx0XHRcdHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG5cdFx0XHRpZih0aGlzLmNvbnN1bWVycyAhPT0gdm9pZCAwKSB7XG5cdFx0XHRcdHRhc2tzLmVucXVldWUodGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKHRoaXMuY29udGV4dCAhPT0gdm9pZCAwKSB7XG5cdFx0XHRcdGhhbmRsZXIuX3JlcG9ydCh0aGlzLmNvbnRleHQpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS53aGVuID0gZnVuY3Rpb24oY29udGludWF0aW9uKSB7XG5cdFx0XHRpZih0aGlzLnJlc29sdmVkKSB7XG5cdFx0XHRcdHRhc2tzLmVucXVldWUobmV3IENvbnRpbnVhdGlvblRhc2soY29udGludWF0aW9uLCB0aGlzLmhhbmRsZXIpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmKHRoaXMuY29uc3VtZXJzID09PSB2b2lkIDApIHtcblx0XHRcdFx0XHR0aGlzLmNvbnN1bWVycyA9IFtjb250aW51YXRpb25dO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuY29uc3VtZXJzLnB1c2goY29udGludWF0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHRpZighdGhpcy5yZXNvbHZlZCkge1xuXHRcdFx0XHR0YXNrcy5lbnF1ZXVlKG5ldyBQcm9ncmVzc1Rhc2soeCwgdGhpcykpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdFx0dmFyIGMgPSB0eXBlb2YgY29udGV4dCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmNvbnRleHQgOiBjb250ZXh0O1xuXHRcdFx0dGhpcy5yZXNvbHZlZCAmJiB0aGlzLmhhbmRsZXIuam9pbigpLmZhaWwoYyk7XG5cdFx0fTtcblxuXHRcdFBlbmRpbmcucHJvdG90eXBlLl9yZXBvcnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cdFx0XHR0aGlzLnJlc29sdmVkICYmIHRoaXMuaGFuZGxlci5qb2luKCkuX3JlcG9ydChjb250ZXh0KTtcblx0XHR9O1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUuX3VucmVwb3J0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnJlc29sdmVkICYmIHRoaXMuaGFuZGxlci5qb2luKCkuX3VucmVwb3J0KCk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFdyYXAgYW5vdGhlciBoYW5kbGVyIGFuZCBmb3JjZSBpdCBpbnRvIGEgZnV0dXJlIHN0YWNrXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGhhbmRsZXJcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBBc3luYyhoYW5kbGVyKSB7XG5cdFx0XHR0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuXHRcdH1cblxuXHRcdGluaGVyaXQoSGFuZGxlciwgQXN5bmMpO1xuXG5cdFx0QXN5bmMucHJvdG90eXBlLndoZW4gPSBmdW5jdGlvbihjb250aW51YXRpb24pIHtcblx0XHRcdHRhc2tzLmVucXVldWUobmV3IENvbnRpbnVhdGlvblRhc2soY29udGludWF0aW9uLCB0aGlzKSk7XG5cdFx0fTtcblxuXHRcdEFzeW5jLnByb3RvdHlwZS5fcmVwb3J0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdFx0dGhpcy5qb2luKCkuX3JlcG9ydChjb250ZXh0KTtcblx0XHR9O1xuXG5cdFx0QXN5bmMucHJvdG90eXBlLl91bnJlcG9ydCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5qb2luKCkuX3VucmVwb3J0KCk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgdGhhdCB3cmFwcyBhbiB1bnRydXN0ZWQgdGhlbmFibGUgYW5kIGFzc2ltaWxhdGVzIGl0IGluIGEgZnV0dXJlIHN0YWNrXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gdGhlblxuXHRcdCAqIEBwYXJhbSB7e3RoZW46IGZ1bmN0aW9ufX0gdGhlbmFibGVcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBUaGVuYWJsZSh0aGVuLCB0aGVuYWJsZSkge1xuXHRcdFx0UGVuZGluZy5jYWxsKHRoaXMpO1xuXHRcdFx0dGFza3MuZW5xdWV1ZShuZXcgQXNzaW1pbGF0ZVRhc2sodGhlbiwgdGhlbmFibGUsIHRoaXMpKTtcblx0XHR9XG5cblx0XHRpbmhlcml0KFBlbmRpbmcsIFRoZW5hYmxlKTtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgZm9yIGEgZnVsZmlsbGVkIHByb21pc2Vcblx0XHQgKiBAcGFyYW0geyp9IHggZnVsZmlsbG1lbnQgdmFsdWVcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBGdWxmaWxsZWQoeCkge1xuXHRcdFx0UHJvbWlzZS5jcmVhdGVDb250ZXh0KHRoaXMpO1xuXHRcdFx0dGhpcy52YWx1ZSA9IHg7XG5cdFx0fVxuXG5cdFx0aW5oZXJpdChIYW5kbGVyLCBGdWxmaWxsZWQpO1xuXG5cdFx0RnVsZmlsbGVkLnByb3RvdHlwZS5fc3RhdGUgPSAxO1xuXG5cdFx0RnVsZmlsbGVkLnByb3RvdHlwZS5mb2xkID0gZnVuY3Rpb24oZiwgeiwgYywgdG8pIHtcblx0XHRcdHJ1bkNvbnRpbnVhdGlvbjMoZiwgeiwgdGhpcywgYywgdG8pO1xuXHRcdH07XG5cblx0XHRGdWxmaWxsZWQucHJvdG90eXBlLndoZW4gPSBmdW5jdGlvbihjb250KSB7XG5cdFx0XHRydW5Db250aW51YXRpb24xKGNvbnQuZnVsZmlsbGVkLCB0aGlzLCBjb250LnJlY2VpdmVyLCBjb250LnJlc29sdmVyKTtcblx0XHR9O1xuXG5cdFx0dmFyIGVycm9ySWQgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlciBmb3IgYSByZWplY3RlZCBwcm9taXNlXG5cdFx0ICogQHBhcmFtIHsqfSB4IHJlamVjdGlvbiByZWFzb25cblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBSZWplY3RlZCh4KSB7XG5cdFx0XHRQcm9taXNlLmNyZWF0ZUNvbnRleHQodGhpcyk7XG5cblx0XHRcdHRoaXMuaWQgPSArK2Vycm9ySWQ7XG5cdFx0XHR0aGlzLnZhbHVlID0geDtcblx0XHRcdHRoaXMuaGFuZGxlZCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5yZXBvcnRlZCA9IGZhbHNlO1xuXG5cdFx0XHR0aGlzLl9yZXBvcnQoKTtcblx0XHR9XG5cblx0XHRpbmhlcml0KEhhbmRsZXIsIFJlamVjdGVkKTtcblxuXHRcdFJlamVjdGVkLnByb3RvdHlwZS5fc3RhdGUgPSAtMTtcblxuXHRcdFJlamVjdGVkLnByb3RvdHlwZS5mb2xkID0gZnVuY3Rpb24oZiwgeiwgYywgdG8pIHtcblx0XHRcdHRvLmJlY29tZSh0aGlzKTtcblx0XHR9O1xuXG5cdFx0UmVqZWN0ZWQucHJvdG90eXBlLndoZW4gPSBmdW5jdGlvbihjb250KSB7XG5cdFx0XHRpZih0eXBlb2YgY29udC5yZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR0aGlzLl91bnJlcG9ydCgpO1xuXHRcdFx0fVxuXHRcdFx0cnVuQ29udGludWF0aW9uMShjb250LnJlamVjdGVkLCB0aGlzLCBjb250LnJlY2VpdmVyLCBjb250LnJlc29sdmVyKTtcblx0XHR9O1xuXG5cdFx0UmVqZWN0ZWQucHJvdG90eXBlLl9yZXBvcnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cdFx0XHR0YXNrcy5hZnRlclF1ZXVlKG5ldyBSZXBvcnRUYXNrKHRoaXMsIGNvbnRleHQpKTtcblx0XHR9O1xuXG5cdFx0UmVqZWN0ZWQucHJvdG90eXBlLl91bnJlcG9ydCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5oYW5kbGVkID0gdHJ1ZTtcblx0XHRcdHRhc2tzLmFmdGVyUXVldWUobmV3IFVucmVwb3J0VGFzayh0aGlzKSk7XG5cdFx0fTtcblxuXHRcdFJlamVjdGVkLnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdFx0UHJvbWlzZS5vbkZhdGFsUmVqZWN0aW9uKHRoaXMsIGNvbnRleHQgPT09IHZvaWQgMCA/IHRoaXMuY29udGV4dCA6IGNvbnRleHQpO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBSZXBvcnRUYXNrKHJlamVjdGlvbiwgY29udGV4dCkge1xuXHRcdFx0dGhpcy5yZWplY3Rpb24gPSByZWplY3Rpb247XG5cdFx0XHR0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuXHRcdH1cblxuXHRcdFJlcG9ydFRhc2sucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYoIXRoaXMucmVqZWN0aW9uLmhhbmRsZWQpIHtcblx0XHRcdFx0dGhpcy5yZWplY3Rpb24ucmVwb3J0ZWQgPSB0cnVlO1xuXHRcdFx0XHRQcm9taXNlLm9uUG90ZW50aWFsbHlVbmhhbmRsZWRSZWplY3Rpb24odGhpcy5yZWplY3Rpb24sIHRoaXMuY29udGV4dCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIFVucmVwb3J0VGFzayhyZWplY3Rpb24pIHtcblx0XHRcdHRoaXMucmVqZWN0aW9uID0gcmVqZWN0aW9uO1xuXHRcdH1cblxuXHRcdFVucmVwb3J0VGFzay5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZih0aGlzLnJlamVjdGlvbi5yZXBvcnRlZCkge1xuXHRcdFx0XHRQcm9taXNlLm9uUG90ZW50aWFsbHlVbmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkKHRoaXMucmVqZWN0aW9uKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gVW5oYW5kbGVkIHJlamVjdGlvbiBob29rc1xuXHRcdC8vIEJ5IGRlZmF1bHQsIGV2ZXJ5dGhpbmcgaXMgYSBub29wXG5cblx0XHQvLyBUT0RPOiBCZXR0ZXIgbmFtZXM6IFwiYW5ub3RhdGVcIj9cblx0XHRQcm9taXNlLmNyZWF0ZUNvbnRleHRcblx0XHRcdD0gUHJvbWlzZS5lbnRlckNvbnRleHRcblx0XHRcdD0gUHJvbWlzZS5leGl0Q29udGV4dFxuXHRcdFx0PSBQcm9taXNlLm9uUG90ZW50aWFsbHlVbmhhbmRsZWRSZWplY3Rpb25cblx0XHRcdD0gUHJvbWlzZS5vblBvdGVudGlhbGx5VW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZFxuXHRcdFx0PSBQcm9taXNlLm9uRmF0YWxSZWplY3Rpb25cblx0XHRcdD0gbm9vcDtcblxuXHRcdC8vIEVycm9ycyBhbmQgc2luZ2xldG9uc1xuXG5cdFx0dmFyIGZvcmV2ZXJQZW5kaW5nSGFuZGxlciA9IG5ldyBIYW5kbGVyKCk7XG5cdFx0dmFyIGZvcmV2ZXJQZW5kaW5nUHJvbWlzZSA9IG5ldyBQcm9taXNlKEhhbmRsZXIsIGZvcmV2ZXJQZW5kaW5nSGFuZGxlcik7XG5cblx0XHRmdW5jdGlvbiBjeWNsZSgpIHtcblx0XHRcdHJldHVybiBuZXcgUmVqZWN0ZWQobmV3IFR5cGVFcnJvcignUHJvbWlzZSBjeWNsZScpKTtcblx0XHR9XG5cblx0XHQvLyBUYXNrIHJ1bm5lcnNcblxuXHRcdC8qKlxuXHRcdCAqIFJ1biBhIHNpbmdsZSBjb25zdW1lclxuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIENvbnRpbnVhdGlvblRhc2soY29udGludWF0aW9uLCBoYW5kbGVyKSB7XG5cdFx0XHR0aGlzLmNvbnRpbnVhdGlvbiA9IGNvbnRpbnVhdGlvbjtcblx0XHRcdHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG5cdFx0fVxuXG5cdFx0Q29udGludWF0aW9uVGFzay5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmhhbmRsZXIuam9pbigpLndoZW4odGhpcy5jb250aW51YXRpb24pO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSdW4gYSBxdWV1ZSBvZiBwcm9ncmVzcyBoYW5kbGVyc1xuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIFByb2dyZXNzVGFzayh2YWx1ZSwgaGFuZGxlcikge1xuXHRcdFx0dGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcblx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRQcm9ncmVzc1Rhc2sucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHEgPSB0aGlzLmhhbmRsZXIuY29uc3VtZXJzO1xuXHRcdFx0aWYocSA9PT0gdm9pZCAwKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgYywgaSA9IDA7IGkgPCBxLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdGMgPSBxW2ldO1xuXHRcdFx0XHRydW5Ob3RpZnkoYy5wcm9ncmVzcywgdGhpcy52YWx1ZSwgdGhpcy5oYW5kbGVyLCBjLnJlY2VpdmVyLCBjLnJlc29sdmVyKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQXNzaW1pbGF0ZSBhIHRoZW5hYmxlLCBzZW5kaW5nIGl0J3MgdmFsdWUgdG8gcmVzb2x2ZXJcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0aGVuXG5cdFx0ICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHRoZW5hYmxlXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IHJlc29sdmVyXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gQXNzaW1pbGF0ZVRhc2sodGhlbiwgdGhlbmFibGUsIHJlc29sdmVyKSB7XG5cdFx0XHR0aGlzLl90aGVuID0gdGhlbjtcblx0XHRcdHRoaXMudGhlbmFibGUgPSB0aGVuYWJsZTtcblx0XHRcdHRoaXMucmVzb2x2ZXIgPSByZXNvbHZlcjtcblx0XHR9XG5cblx0XHRBc3NpbWlsYXRlVGFzay5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaCA9IHRoaXMucmVzb2x2ZXI7XG5cdFx0XHR0cnlBc3NpbWlsYXRlKHRoaXMuX3RoZW4sIHRoaXMudGhlbmFibGUsIF9yZXNvbHZlLCBfcmVqZWN0LCBfbm90aWZ5KTtcblxuXHRcdFx0ZnVuY3Rpb24gX3Jlc29sdmUoeCkgeyBoLnJlc29sdmUoeCk7IH1cblx0XHRcdGZ1bmN0aW9uIF9yZWplY3QoeCkgIHsgaC5yZWplY3QoeCk7IH1cblx0XHRcdGZ1bmN0aW9uIF9ub3RpZnkoeCkgIHsgaC5ub3RpZnkoeCk7IH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdHJ5QXNzaW1pbGF0ZSh0aGVuLCB0aGVuYWJsZSwgcmVzb2x2ZSwgcmVqZWN0LCBub3RpZnkpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoZW4uY2FsbCh0aGVuYWJsZSwgcmVzb2x2ZSwgcmVqZWN0LCBub3RpZnkpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZWplY3QoZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXIgaGVscGVyc1xuXG5cdFx0LyoqXG5cdFx0ICogQHBhcmFtIHsqfSB4XG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWZmIHggaXMgYSB0cnVzdGVkIFByb21pc2Vcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBpc1Byb21pc2UoeCkge1xuXHRcdFx0cmV0dXJuIHggaW5zdGFuY2VvZiBQcm9taXNlO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFRlc3QganVzdCBlbm91Z2ggdG8gcnVsZSBvdXQgcHJpbWl0aXZlcywgaW4gb3JkZXIgdG8gdGFrZSBmYXN0ZXJcblx0XHQgKiBwYXRocyBpbiBzb21lIGNvZGVcblx0XHQgKiBAcGFyYW0geyp9IHhcblx0XHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UgaWZmIHggaXMgZ3VhcmFudGVlZCAqbm90KiB0byBiZSBhIHRoZW5hYmxlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gbWF5YmVUaGVuYWJsZSh4KSB7XG5cdFx0XHRyZXR1cm4gKHR5cGVvZiB4ID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJykgJiYgeCAhPT0gbnVsbDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBydW5Db250aW51YXRpb24xKGYsIGgsIHJlY2VpdmVyLCBuZXh0KSB7XG5cdFx0XHRpZih0eXBlb2YgZiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRyZXR1cm4gbmV4dC5iZWNvbWUoaCk7XG5cdFx0XHR9XG5cblx0XHRcdFByb21pc2UuZW50ZXJDb250ZXh0KGgpO1xuXHRcdFx0dHJ5Q2F0Y2hSZWplY3QoZiwgaC52YWx1ZSwgcmVjZWl2ZXIsIG5leHQpO1xuXHRcdFx0UHJvbWlzZS5leGl0Q29udGV4dCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJ1bkNvbnRpbnVhdGlvbjMoZiwgeCwgaCwgcmVjZWl2ZXIsIG5leHQpIHtcblx0XHRcdGlmKHR5cGVvZiBmICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHJldHVybiBuZXh0LmJlY29tZShoKTtcblx0XHRcdH1cblxuXHRcdFx0UHJvbWlzZS5lbnRlckNvbnRleHQoaCk7XG5cdFx0XHR0cnlDYXRjaFJlamVjdDMoZiwgeCwgaC52YWx1ZSwgcmVjZWl2ZXIsIG5leHQpO1xuXHRcdFx0UHJvbWlzZS5leGl0Q29udGV4dCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJ1bk5vdGlmeShmLCB4LCBoLCByZWNlaXZlciwgbmV4dCkge1xuXHRcdFx0aWYodHlwZW9mIGYgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cmV0dXJuIG5leHQubm90aWZ5KHgpO1xuXHRcdFx0fVxuXG5cdFx0XHRQcm9taXNlLmVudGVyQ29udGV4dChoKTtcblx0XHRcdHRyeUNhdGNoUmV0dXJuKGYsIHgsIHJlY2VpdmVyLCBuZXh0KTtcblx0XHRcdFByb21pc2UuZXhpdENvbnRleHQoKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm4gZi5jYWxsKHRoaXNBcmcsIHgpLCBvciBpZiBpdCB0aHJvd3MgcmV0dXJuIGEgcmVqZWN0ZWQgcHJvbWlzZSBmb3Jcblx0XHQgKiB0aGUgdGhyb3duIGV4Y2VwdGlvblxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHRyeUNhdGNoUmVqZWN0KGYsIHgsIHRoaXNBcmcsIG5leHQpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdG5leHQuYmVjb21lKGdldEhhbmRsZXIoZi5jYWxsKHRoaXNBcmcsIHgpKSk7XG5cdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0bmV4dC5iZWNvbWUobmV3IFJlamVjdGVkKGUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBTYW1lIGFzIGFib3ZlLCBidXQgaW5jbHVkZXMgdGhlIGV4dHJhIGFyZ3VtZW50IHBhcmFtZXRlci5cblx0XHQgKi9cblx0XHRmdW5jdGlvbiB0cnlDYXRjaFJlamVjdDMoZiwgeCwgeSwgdGhpc0FyZywgbmV4dCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Zi5jYWxsKHRoaXNBcmcsIHgsIHksIG5leHQpO1xuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdG5leHQuYmVjb21lKG5ldyBSZWplY3RlZChlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGYuY2FsbCh0aGlzQXJnLCB4KSwgb3IgaWYgaXQgdGhyb3dzLCAqcmV0dXJuKiB0aGUgZXhjZXB0aW9uXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gdHJ5Q2F0Y2hSZXR1cm4oZiwgeCwgdGhpc0FyZywgbmV4dCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0bmV4dC5ub3RpZnkoZi5jYWxsKHRoaXNBcmcsIHgpKTtcblx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRuZXh0Lm5vdGlmeShlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpbmhlcml0KFBhcmVudCwgQ2hpbGQpIHtcblx0XHRcdENoaWxkLnByb3RvdHlwZSA9IG9iamVjdENyZWF0ZShQYXJlbnQucHJvdG90eXBlKTtcblx0XHRcdENoaWxkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENoaWxkO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5cdFx0cmV0dXJuIFByb21pc2U7XG5cdH07XG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTsgfSkpO1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJzZXF1aW5zXCIsXG4gIFwidmVyc2lvblwiOiBcIjAuOS4zXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJNdXRhYmxlIHNlcXVlbmNlcyBhbmQgbmF0aXZlIGRhdGEgc3RydWN0dXJlcyAoTWFwLCBTZXQsIExpc3QpIGZvbGxvd2luZyB0aGUgSW1tdXRhYmxlLmpzIEFQSVwiLFxuICBcImF1dGhvclwiOiBcImNvbnJhZEBidXJuaW5ncG90YXRvLmNvbVwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJmaWxlc1wiOiBbXG4gICAgXCJkaXN0LyoqXCJcbiAgXSxcbiAgXCJtYWluXCI6IFwiZGlzdC9fc2VxdWlucy5qc1wiLFxuICBcIm1vZHVsZVwiOiBcImRpc3Qvc2VxdWlucy5tanNcIixcbiAgXCJ0eXBpbmdzXCI6IFwiZGlzdC9zZXF1aW5zLmQudHNcIixcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImJ1aWxkXCI6IFwicnVuLXMgYnVpbGQ6KlwiLFxuICAgIFwiYnVpbGQ6ZGlzdFwiOiBcImJyb2Njb2xpIGJ1aWxkIGRpc3QgLS1vdmVyd3JpdGVcIixcbiAgICBcImJ1aWxkOnBhZ2VzXCI6IFwiZ3VscCAtLWd1bHBmaWxlIC4vcmVzb3VyY2VzL2d1bHBmaWxlLmpzIGRlZmF1bHRcIixcbiAgICBcImJ1aWxkOnR5cGUtdGVzdHNcIjogXCJub2RlIC4vcmVzb3VyY2VzL2J1aWxkLXR5cGUtdGVzdHMuanNcIixcbiAgICBcInN0YXJ0OnBhZ2VzXCI6IFwiZ3VscCAtLWd1bHBmaWxlIC4vcmVzb3VyY2VzL2d1bHBmaWxlLmpzIGRldlwiLFxuICAgIFwiZm9ybWF0XCI6IFwicHJldHRpZXIgLS13cml0ZSBcXFwie3NyYyxwYWdlcy9zcmMscGFnZXMvbGliLHJlc291cmNlc30vKiovKi5qc1xcXCJcIixcbiAgICBcInRlc3RcIjogXCJydW4tcCAtLWFnZ3JlZ2F0ZS1vdXRwdXQgdGVzdDpqcyB0ZXN0OnR5cGVzXCIsXG4gICAgXCJ0ZXN0Ol9faVwiOiBcInJ1bi1wIHRlc3Q6anMgdGVzdDp0eXBlczpfX2lcIixcbiAgICBcInRlc3Q6anNcIjogXCJqZXN0XCIsXG4gICAgXCJ0ZXN0OnR5cGVzXCI6IFwicnVuLXMgYnVpbGQ6ZGlzdCB0ZXN0OnR5cGVzOl9faVwiLFxuICAgIFwidGVzdDp0eXBlczpfX2lcIjogXCJydW4tcyBidWlsZDp0eXBlLXRlc3RzIHRlc3Q6dHlwZXM6KjpfX2lcIixcbiAgICBcInRlc3Q6dHlwZXM6dHNcIjogXCJydW4tcyBidWlsZDp0eXBlLXRlc3RzIHRlc3Q6dHlwZXM6dHM6X19pXCIsXG4gICAgXCJ0ZXN0OnR5cGVzOnRzOl9faVwiOiBcInRzY1wiLFxuICAgIFwidGVzdDpuby1jaGFuZ2VzXCI6IFwiLi9yZXNvdXJjZXMvY2hlY2stY2hhbmdlcy5zaFwiLFxuICAgIFwidmVyaWZ5XCI6IFwicnVuLXMgZm9ybWF0IHRlc3Q6bm8tY2hhbmdlcyBidWlsZCB0ZXN0Ol9faVwiXG4gIH0sXG4gIFwiZW5naW5lc1wiOiB7XG4gICAgXCJ5YXJuXCI6IFwiXjEuMTAuMVwiXG4gIH0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkBiYWJlbC9jb3JlXCI6IFwiXjcuMi4yXCIsXG4gICAgXCJAYmFiZWwvcGx1Z2luLXN5bnRheC10eXBlc2NyaXB0XCI6IFwiXjcuMi4wXCIsXG4gICAgXCJAYmFiZWwvcGx1Z2luLXRyYW5zZm9ybS1ydW50aW1lXCI6IFwiXjcuMi4wXCIsXG4gICAgXCJAYmFiZWwvcHJlc2V0LWVudlwiOiBcIjcuMi4zXCIsXG4gICAgXCJAYmFiZWwvcHJlc2V0LXR5cGVzY3JpcHRcIjogXCJeNy4xLjBcIixcbiAgICBcIkB0eXBlcy9qZXN0XCI6IFwiXjIzLjMuMTFcIixcbiAgICBcImJhYmVsLWNvcmVcIjogXCJeNy4wLjAtYnJpZGdlLjBcIixcbiAgICBcImJhYmVsLWplc3RcIjogXCJeMjMuNi4wXCIsXG4gICAgXCJiYWJlbC1wbHVnaW4tbWluaWZ5LWRlYWQtY29kZS1lbGltaW5hdGlvblwiOiBcIl4wLjUuMFwiLFxuICAgIFwiYnJvY2NvbGlcIjogXCJeMi4wLjAtYmV0YS40XCIsXG4gICAgXCJicm9jY29saS1iYWJlbC10cmFuc3BpbGVyXCI6IFwiXjcuMC4wXCIsXG4gICAgXCJicm9jY29saS1jbGlcIjogXCJeMS4wLjBcIixcbiAgICBcImJyb2Njb2xpLW1lcmdlLXRyZWVzXCI6IFwiXjMuMC4xXCIsXG4gICAgXCJicm9jY29saS1yb2xsdXBcIjogXCJeMi4xLjFcIixcbiAgICBcImJyb3dzZXItc3luY1wiOiBcIjIuMjQuNFwiLFxuICAgIFwiYnJvd3NlcmlmeVwiOiBcIjE2LjIuMlwiLFxuICAgIFwiZGVsXCI6IFwiMy4wLjBcIixcbiAgICBcImd1bHBcIjogXCIzLjkuMVwiLFxuICAgIFwiZ3VscC1jb25jYXRcIjogXCIyLjYuMVwiLFxuICAgIFwiZ3VscC1maWx0ZXJcIjogXCI1LjEuMFwiLFxuICAgIFwiZ3VscC1oZWFkZXJcIjogXCIyLjAuNVwiLFxuICAgIFwiZ3VscC1sZXNzXCI6IFwiMy41LjBcIixcbiAgICBcImd1bHAtc2l6ZVwiOiBcIjMuMC4wXCIsXG4gICAgXCJndWxwLXNvdXJjZW1hcHNcIjogXCIyLjYuNFwiLFxuICAgIFwiZ3VscC11Z2xpZnlcIjogXCIyLjEuMFwiLFxuICAgIFwiZ3VscC11dGlsXCI6IFwiMy4wLjhcIixcbiAgICBcImltbXV0YWJsZVwiOiBcIl40LjAuMC1yYy4xMFwiLFxuICAgIFwiamVzdFwiOiBcIl4yMy42LjBcIixcbiAgICBcIm1hcmtlZFwiOiBcIjAuMy4xOVwiLFxuICAgIFwibnBtLXJ1bi1hbGxcIjogXCJeNC4xLjVcIixcbiAgICBcInByZXR0aWVyXCI6IFwiXjEuMTUuM1wiLFxuICAgIFwicmVhY3RcIjogXCJeMC4xMi4wXCIsXG4gICAgXCJyZWFjdC1yb3V0ZXJcIjogXCJeMC4xMS4yXCIsXG4gICAgXCJyZWFjdC10b29sc1wiOiBcIjAuMTMuM1wiLFxuICAgIFwicmVjdXJzaXZlLXJlYWRkaXJcIjogXCJeMi4yLjJcIixcbiAgICBcInJvbGx1cC1wbHVnaW4tYmFiZWxcIjogXCJeNC4wLjJcIixcbiAgICBcInJvbGx1cC1wbHVnaW4tY29tbW9uanNcIjogXCJeOS4xLjZcIixcbiAgICBcInJvbGx1cC1wbHVnaW4tbm9kZS1yZXNvbHZlXCI6IFwiXjMuMy4wXCIsXG4gICAgXCJydW4tc2VxdWVuY2VcIjogXCIyLjIuMVwiLFxuICAgIFwidHlwZXNjcmlwdFwiOiBcIjMuMi4yXCIsXG4gICAgXCJ2aW55bC1idWZmZXJcIjogXCIxLjAuMVwiLFxuICAgIFwidmlueWwtc291cmNlLXN0cmVhbVwiOiBcIjIuMC4wXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQGJhYmVsL3J1bnRpbWVcIjogXCJeNy4wLjBcIixcbiAgICBcImludmFyaWFudFwiOiBcIl4yLjIuNFwiLFxuICAgIFwiaXRlci10b29sc1wiOiBcIl42LjEuOC1uZXh0LjNcIixcbiAgICBcInN0YWJsZVwiOiBcIl4wLjEuOFwiXG4gIH0sXG4gIFwicmVzb2x1dGlvbnNcIjoge1xuICAgIFwiYmFiZWwtY29yZVwiOiBcIjcuMC4wLWJyaWRnZS4wXCJcbiAgfSxcbiAgXCJqZXN0XCI6IHtcbiAgICBcIm1vZHVsZUZpbGVFeHRlbnNpb25zXCI6IFtcbiAgICAgIFwianNcIlxuICAgIF0sXG4gICAgXCJzZXR1cFRlc3RGcmFtZXdvcmtTY3JpcHRGaWxlXCI6IFwiPHJvb3REaXI+L3NyYy9fX3Rlc3RfXy9oZWxwZXJzL2ZyYW1ld29yay1zZXR1cC5qc1wiLFxuICAgIFwiY292ZXJhZ2VQYXRoSWdub3JlUGF0dGVybnNcIjogW1xuICAgICAgXCIvbm9kZV9tb2R1bGVzL1wiLFxuICAgICAgXCIvX190ZXN0X18vXCJcbiAgICBdXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL2NvbmFydGlzdDYvc2VxdWlucy5naXRcIlxuICB9LFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcIm11dGFibGVcIixcbiAgICBcImltbXV0YWJsZVwiLFxuICAgIFwibWFwXCIsXG4gICAgXCJzZXRcIixcbiAgICBcImxpc3RcIixcbiAgICBcInN0YWJsZVwiLFxuICAgIFwic29ydFwiLFxuICAgIFwic2VxdWVuY2VcIixcbiAgICBcInNlcVwiLFxuICAgIFwiaXRlci10b29sc1wiLFxuICAgIFwiZXM2XCIsXG4gICAgXCJlczIwMTVcIlxuICBdLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2NvbmFydGlzdDYvc2VxdWlucy9pc3N1ZXNcIlxuICB9LFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2NvbmFydGlzdDYvc2VxdWlucyNyZWFkbWVcIlxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1wiZ3JvdXBzXCI6W3tcInRpdGxlXCI6XCJDb25jcmV0ZVwiLFwibWVtYmVyc1wiOntcIkxpc3RcIjp7XCJjbGFzc1wiOntcImlzQ2xhc3NcIjp0cnVlLFwiY29uc3RydWN0b3JcIjp7XCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjI0fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjoxfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjB9XX0sXCJsaW5lXCI6MjV9LHtcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoyNn1dfSxcInN0YXRpY3NcIjp7XCJpc0xpc3RcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYSBMaXN0XCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnc2VxdWlucycpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuTGlzdC5pc0xpc3QoW10pOyAvLyBmYWxzZVxcbkxpc3QuaXNMaXN0KG5ldyBMaXN0KCkpOyAvLyB0cnVlXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlTGlzdFwiLFwidHlwZVwiOntcImtcIjowfX1dLFwidHlwZVwiOntcImtcIjozfSxcImxpbmVcIjozOX1dfSxcIm9mXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNyZWF0ZXMgYSBuZXcgU2VxdWlucyBMaXN0IGNvbnRhaW5pbmcgYHZhbHVlc2AuXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnc2VxdWlucycpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuTGlzdC5vZigxLCAyLCAzLCA0KVxcbi8vIExpc3QgWyAxLCAyLCAzLCA0IF1cXG5gYGBcXG5cXG5Ob3RlOiBWYWx1ZXMgYXJlIG5vdCBhbHRlcmVkIG9yIGNvbnZlcnRlZCBpbiBhbnkgd2F5LlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ3NlcXVpbnMnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbkxpc3Qub2Yoe3g6MX0sIDIsIFszXSwgNClcXG4vLyBMaXN0IFsgeyB4OiAxIH0sIDIsIFsgMyBdLCA0IF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZXNcIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6NjJ9XX19LFwibGluZVwiOjc5LFwiZG9jXCI6e1wic3lub3BzaXNcIjpcIkxpc3QgaXMgYSBkZW5zZSBgSW5kZXhlZGAgYENvbGxlY3Rpb25gIGJhY2tlZCBieSBhIEphdmFTY3JpcHQgYXJyYXkuXFxuTGlzdCBzaGFyZXMgaXRzIHBlZm9ybWFuY2UgY2hhcmFjdGVyc2l0aWNzIHdpdGggYXJyYXkgdG9vLiBgZ2V0YCwgYHNldGAsXFxuYHB1c2hgLCBhbmQgYHBvcGAgYXJlIGFsbCBPKDEpIG9uIGxpc3RzLiBgc2hpZnRgIGFuZCBgdW5zaGlmdGAgYXJlIE8obikuXCIsXCJkZXNjcmlwdGlvblwiOlwiVW5saWtlIGEgSmF2YVNjcmlwdCBBcnJheSwgdGhlcmUgaXMgbm8gZGlzdGluY3Rpb24gYmV0d2VlbiBhblxcblxcXCJ1bnNldFxcXCIgaW5kZXggYW5kIGFuIGluZGV4IHNldCB0byBgdW5kZWZpbmVkYC4gYExpc3QjZm9yRWFjaGAgdmlzaXRzIGFsbFxcbmluZGljZXMgZnJvbSAwIHRvIHNpemUsIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGV5IHdlcmUgZXhwbGljaXRseSBkZWZpbmVkLlwiLFwibm90ZXNcIjpbXX0sXCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcImV4dGVuZHNcIjpbe1wia1wiOjExLFwibmFtZVwiOlwiQ29uY3JldGVcIixcImFyZ3NcIjpbe1wia1wiOjR9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX1dLFwiaW1wbGVtZW50c1wiOlt7XCJrXCI6MTEsXCJuYW1lXCI6XCJJbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX1dLFwiZ3JvdXBzXCI6W3tcIm1lbWJlcnNcIjp7XCIjc2l6ZVwiOntcImxpbmVcIjo4M319fSx7XCJ0aXRsZVwiOlwiUGVyc2lzdGVudCBjaGFuZ2VzXCIsXCJtZW1iZXJzXCI6e1wiI3NldFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJTZXRzIGBpbmRleGAgdG8gYHZhbHVlYC5cIixcImRlc2NyaXB0aW9uXCI6XCJgaW5kZXhgIG1heSBiZSBhIG5lZ2F0aXZlIG51bWJlciwgd2hpY2ggaW5kZXhlcyBiYWNrIGZyb20gdGhlIGVuZCBvZiB0aGVcXG5MaXN0LiBgdi5zZXQoLTEsIFxcXCJ2YWx1ZVxcXCIpYCBzZXRzIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIExpc3QuXFxuXFxuSWYgYGluZGV4YCBsYXJnZXIgdGhhbiBgc2l6ZWAsIHRoZSByZXR1cm5lZCBMaXN0J3MgYHNpemVgIHdpbGwgYmUgbGFyZ2VcXG5lbm91Z2ggdG8gaW5jbHVkZSB0aGUgYGluZGV4YC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdzZXF1aW5zJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBvcmlnaW5hbExpc3QgPSBMaXN0KFsgMCBdKTtcXG4vLyBMaXN0IFsgMCBdXFxub3JpZ2luYWxMaXN0LnNldCgxLCAxKTtcXG4vLyBMaXN0IFsgMCwgMSBdXFxub3JpZ2luYWxMaXN0LnNldCgwLCAnb3ZlcndyaXR0ZW4nKTtcXG4vLyBMaXN0IFsgXFxcIm92ZXJ3cml0dGVuXFxcIiBdXFxub3JpZ2luYWxMaXN0LnNldCgyLCAyKTtcXG4vLyBMaXN0IFsgMCwgdW5kZWZpbmVkLCAyIF1cXG5cXG5uZXcgTGlzdCgpLnNldCg1MDAwMCwgJ3ZhbHVlJykuc2l6ZTtcXG4vLyA1MDAwMVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJpbmRleFwiLFwidHlwZVwiOntcImtcIjo0fX0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoxMTN9XX0sXCIjZGVsZXRlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJlbW92ZXMgdGhlIHZhbHVlIGF0IGBpbmRleGAgZnJvbSB0aGUgbGlzdC4gVmFsdWVzIGF0IGluZGljZXMgYWJvdmVcXG5gaW5kZXhgIGFyZSBzaGlmdGVkIGRvd24gYnkgMSB0byBmaWxsIHRoZSBwb3NpdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJUaGlzIGlzIHN5bm9ueW1vdXMgd2l0aCBgbGlzdC5zcGxpY2UoaW5kZXgsIDEpYC5cXG5cXG5gaW5kZXhgIG1heSBiZSBhIG5lZ2F0aXZlIG51bWJlciwgd2hpY2ggaW5kZXhlcyBiYWNrIGZyb20gdGhlIGVuZCBvZiB0aGVcXG5MaXN0LiBgdi5kZWxldGUoLTEpYCBkZWxldGVzIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIExpc3QuXFxuXFxuTm90ZTogYGRlbGV0ZWAgY2Fubm90IGJlIHNhZmVseSB1c2VkIGluIElFOFxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ3NlcXVpbnMnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbm5ldyBMaXN0KFsgMCwgMSwgMiwgMywgNCBdKS5kZWxldGUoMCk7XFxuLy8gTGlzdCBbIDEsIDIsIDMsIDQgXVxcbmBgYFxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcInJlbW92ZVwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6NH19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTM2fV19LFwiI2luc2VydFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJJbnNlcnRzIGB2YWx1ZWAgYXQgYGluZGV4YCBpbiB0aGUgbGlzdC4gVmFsdWVzIGF0IGluZGljZXMgYWJvdmVcXG5gaW5kZXhgIGFyZSBzaGlmdGVkIG92ZXIgYnkgMS5cIixcImRlc2NyaXB0aW9uXCI6XCJUaGlzIGlzIHN5bm9ueW1vdXMgd2l0aCBgbGlzdC5zcGxpY2UoaW5kZXgsIDAsIHZhbHVlKWAuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnc2VxdWlucycpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxubmV3IExpc3QoWyAwLCAxLCAyLCAzLCA0IF0pLmluc2VydCg2LCA1KVxcbi8vIExpc3QgWyAwLCAxLCAyLCAzLCA0LCA1IF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6NH19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTUzfV19LFwiI2NsZWFyXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJlbW92ZXMgYWxsIHZhbHVlcyBmcm9tIHRoZSBsaXN0LlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ3NlcXVpbnMnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbm5ldyBMaXN0KFsgMSwgMiwgMywgNCBdKS5jbGVhcigpXFxuLy8gTGlzdCBbXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTY2fV19LFwiI3B1c2hcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQXBwZW5kcyBgdmFsdWVzYCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ3NlcXVpbnMnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbm5ldyBMaXN0KFsgMSwgMiwgMywgNCBdKS5wdXNoKDUpXFxuLy8gTGlzdCBbIDEsIDIsIDMsIDQsIDUgXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZXNcIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTc5fV19LFwiI3BvcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZW1vdmVzIHRoZSBsYXN0IHZhbHVlIGZyb20gdGhlIGxpc3QgYW5kIHJldHVybnMgaXQuXCIsXCJkZXNjcmlwdGlvblwiOlwiYGBganNcXG5uZXcgTGlzdChbIDEsIDIsIDMsIDQgXSkucG9wKClcXG4vLyBMaXN0WyAxLCAyLCAzIF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjE4OX1dfSxcIiN1bnNoaWZ0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkluc2VydHMgYHZhbHVlc2AgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdC4gTm90ZSB0aGF0IHRoaXMgd2lsbFxcbnJlcXVpcmUgc2hpZnRpbmcgZXZlcnkgaXRlbSBpbiB0aGUgbGlzdCwgYW5kIHdpbGwgdGFrZSBPKG4pIHRpbWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnc2VxdWlucycpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxubmV3IExpc3QoWyAyLCAzLCA0XSkudW5zaGlmdCgxKTtcXG4vLyBMaXN0IFsgMSwgMiwgMywgNCBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlc1wiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoyMDN9XX0sXCIjc2hpZnRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmVtb3ZlcyB0aGUgZmlyc3QgdmFsdWUgZnJvbSB0aGUgbGlzdCBhbmQgcmV0dXJucyBpdC4gTm90ZSB0aGF0XFxudGhpcyB3aWxsIHJlcXVpcmUgc2hpZnRpbmcgZXZlcnkgaXRlbSBpbiB0aGUgbGlzdCwgYW5kIHdpbGwgdGFrZSBPKG4pXFxudGltZS5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdzZXF1aW5zJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5uZXcgTGlzdChbIDAsIDEsIDIsIDMsIDQgXSkuc2hpZnQoKTtcXG4vLyBMaXN0IFsgMSwgMiwgMywgNCBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoyMTh9XX0sXCIjc2V0U2l6ZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJTZXRzIGxpc3QncyBgc2l6ZWAuIElmIGBzaXplYCBpcyBsZXNzIHRoYW4gdGhlIGxpc3QncyBzaXplLCB2YWx1ZXMgYXRcXG5oaWdoZXIgaW5kaWNlcyB3aWxsIGJlIGV4Y2x1ZGVkLiBJZiBgc2l6ZWAgaXMgZ3JlYXRlciB0aGFuIHRoZSBsaXN0J3NcXG5zaXplLCBuZXdseSBjcmVhdGVkIGluZGljaWVzIHdpbGwgaGF2ZSB1bmRlZmluZWQgdmFsdWVzLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzaXplXCIsXCJ0eXBlXCI6e1wia1wiOjR9fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjIyNX1dfX19LHtcInRpdGxlXCI6XCJTZXF1ZW5jZSBhbGdvcml0aG1zXCIsXCJtZW1iZXJzXCI6e1wiI2NvbmNhdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IExpc3Qgd2l0aCBvdGhlciB2YWx1ZXMgb3IgY29sbGVjdGlvbnMgY29uY2F0ZW5hdGVkIHRvIHRoaXMgb25lLlxcblwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcIm1lcmdlXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlc09yQ29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6MTEsXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiQ1wifV19LHtcImtcIjoxMCxcInBhcmFtXCI6XCJDXCJ9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiQ1wifV19XX0sXCJsaW5lXCI6MjM0fV19LFwiI21hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IExpc3Qgd2l0aCB2YWx1ZXMgcGFzc2VkIHRocm91Z2ggYVxcbmBtYXBwZXJgIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ3NlcXVpbnMnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbm5ldyBMaXN0KFsgMSwgMiBdKS5tYXAoeCA9PiAxMCAqIHgpXFxuLy8gTGlzdCBbIDEwLCAyMCBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjR9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEyfX1dLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJNXCJ9fX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjoyNDl9XX0sXCIjZmxhdHRlblwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiQ29sbGVjdGlvbi5mbGF0dGVuXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJkZXB0aFwiLFwidHlwZVwiOntcImtcIjo0fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjB9XX0sXCJsaW5lXCI6MjU0fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic2hhbGxvd1wiLFwidHlwZVwiOntcImtcIjozfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjB9XX0sXCJsaW5lXCI6MjU1fV19LFwiI2ZsYXRNYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRmxhdC1tYXBzIHRoZSBMaXN0LCByZXR1cm5pbmcgYSBuZXcgTGlzdC5cIixcImRlc2NyaXB0aW9uXCI6XCJTaW1pbGFyIHRvIGBsaXN0Lm1hcCguLi4pLmZsYXR0ZW4odHJ1ZSlgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo5LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo0fX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMn19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiTVwifV19fX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjoyNjJ9XX0sXCIjZmlsdGVyXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTGlzdCB3aXRoIG9ubHkgdGhlIHZhbHVlcyBmb3Igd2hpY2ggdGhlIGBwcmVkaWNhdGVgXFxuZnVuY3Rpb24gcmV0dXJucyB0cnVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJGXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo5LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjR9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEyfX1dLFwidHlwZVwiOntcImtcIjozfX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJGXCJ9XX0sXCJsaW5lXCI6MjcwfSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6NH19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTJ9fV0sXCJ0eXBlXCI6e1wia1wiOjB9fX1dLFwidHlwZVwiOntcImtcIjoxMn0sXCJsaW5lXCI6MjczfV19LFwiI3ppcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgTGlzdCBcXFwiemlwcGVkXFxcIiB3aXRoIHRoZSBwcm92aWRlZCBjb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIkxpa2UgYHppcFdpdGhgLCBidXQgdXNpbmcgdGhlIGRlZmF1bHQgYHppcHBlcmA6IGNyZWF0aW5nIGFuIGBBcnJheWAuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnc2VxdWlucycpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuY29uc3QgYSA9IG5ldyBMaXN0KFsgMSwgMiwgMyBdKTtcXG5jb25zdCBiID0gbmV3IExpc3QoWyA0LCA1LCA2IF0pO1xcbmNvbnN0IGMgPSBhLnppcChiKTsgLy8gTGlzdCBbIFsgMSwgNCBdLCBbIDIsIDUgXSwgWyAzLCA2IF0gXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJVXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQ29sbGVjdGlvbkxpa2VcIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJVXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjoxNixcInR5cGVzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJVXCJ9XX1dfSxcImxpbmVcIjoyODl9LHtcInR5cGVQYXJhbXNcIjpbXCJVXCIsXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQ29sbGVjdGlvbkxpa2VcIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJVXCJ9XX19LHtcIm5hbWVcIjpcIm90aGVyMlwiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25MaWtlXCIsXCJhcmdzXCI6W3tcImtcIjowfSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6MTYsXCJ0eXBlc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVVwifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19XX0sXCJsaW5lXCI6MjkwfSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTEsXCJuYW1lXCI6XCJDb2xsZWN0aW9uTGlrZVwiLFwiYXJnc1wiOlt7XCJrXCI6MH0se1wia1wiOjB9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6MH1dfSxcImxpbmVcIjoyOTR9XX0sXCIjemlwQWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBMaXN0IFxcXCJ6aXBwZWRcXFwiIHdpdGggdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb25zLlwiLFwiZGVzY3JpcHRpb25cIjpcIlVubGlrZSBgemlwYCwgYHppcEFsbGAgY29udGludWVzIHppcHBpbmcgdW50aWwgdGhlIGxvbmdlc3QgY29sbGVjdGlvbiBpc1xcbmV4aGF1c3RlZC4gTWlzc2luZyB2YWx1ZXMgZnJvbSBzaG9ydGVyIGNvbGxlY3Rpb25zIGFyZSBmaWxsZWQgd2l0aCBgdW5kZWZpbmVkYC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdzZXF1aW5zJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBhID0gbmV3IExpc3QoWyAxLCAyIF0pO1xcbmNvbnN0IGIgPSBuZXcgTGlzdChbIDMsIDQsIDUgXSk7XFxuY29uc3QgYyA9IGEuemlwQWxsKGIpOyAvLyBMaXN0IFsgWyAxLCAzIF0sIFsgMiwgNCBdLCBbIHVuZGVmaW5lZCwgNSBdIF1cXG5gYGBcXG5cXG5Ob3RlOiBTaW5jZSB6aXBBbGwgd2lsbCByZXR1cm4gYSBjb2xsZWN0aW9uIGFzIGxhcmdlIGFzIHRoZSBsYXJnZXN0XFxuaW5wdXQsIHNvbWUgcmVzdWx0cyBtYXkgY29udGFpbiB1bmRlZmluZWQgdmFsdWVzLiBUeXBlU2NyaXB0IGNhbm5vdFxcbmFjY291bnQgZm9yIHRoZXNlIHdpdGhvdXQgY2FzZXMgKGFzIG9mIHYyLjUpLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJVXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQ29sbGVjdGlvbkxpa2VcIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJVXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjoxNixcInR5cGVzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJVXCJ9XX1dfSxcImxpbmVcIjozMTV9LHtcInR5cGVQYXJhbXNcIjpbXCJVXCIsXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQ29sbGVjdGlvbkxpa2VcIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJVXCJ9XX19LHtcIm5hbWVcIjpcIm90aGVyMlwiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25MaWtlXCIsXCJhcmdzXCI6W3tcImtcIjowfSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6MTYsXCJ0eXBlc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVVwifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19XX0sXCJsaW5lXCI6MzE2fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTEsXCJuYW1lXCI6XCJDb2xsZWN0aW9uTGlrZVwiLFwiYXJnc1wiOlt7XCJrXCI6MH0se1wia1wiOjB9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6MH1dfSxcImxpbmVcIjozMjB9XX0sXCIjemlwV2l0aFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgTGlzdCBcXFwiemlwcGVkXFxcIiB3aXRoIHRoZSBwcm92aWRlZCBjb2xsZWN0aW9ucyBieSB1c2luZyBhXFxuY3VzdG9tIGB6aXBwZXJgIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ3NlcXVpbnMnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmNvbnN0IGEgPSBuZXcgTGlzdChbIDEsIDIsIDMgXSk7XFxuY29uc3QgYiA9IG5ldyBMaXN0KFsgNCwgNSwgNiBdKTtcXG5jb25zdCBjID0gYS56aXBXaXRoKChhLCBiKSA9PiBhICsgYiwgYik7XFxuLy8gTGlzdCBbIDUsIDcsIDkgXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJVXCIsXCJaXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInppcHBlclwiLFwidHlwZVwiOntcImtcIjo5LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIm90aGVyVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVVwifX1dLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJaXCJ9fX0se1wibmFtZVwiOlwib3RoZXJDb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQ29sbGVjdGlvbkxpa2VcIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJVXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJaXCJ9XX0sXCJsaW5lXCI6MzM2fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiVlwiLFwiWlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ6aXBwZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJvdGhlclZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlVcIn19LHtcIm5hbWVcIjpcInRoaXJkVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJaXCJ9fX0se1wibmFtZVwiOlwib3RoZXJDb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQ29sbGVjdGlvbkxpa2VcIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJVXCJ9XX19LHtcIm5hbWVcIjpcInRoaXJkQ29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25MaWtlXCIsXCJhcmdzXCI6W3tcImtcIjowfSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiWlwifV19LFwibGluZVwiOjM0MH0se1widHlwZVBhcmFtc1wiOltcIlpcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiemlwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiYW55XCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjB9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJaXCJ9fX0se1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTEsXCJuYW1lXCI6XCJDb2xsZWN0aW9uTGlrZVwiLFwiYXJnc1wiOlt7XCJrXCI6MH0se1wia1wiOjB9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiWlwifV19LFwibGluZVwiOjM0NX1dfX19LHtcInRpdGxlXCI6XCJDb21iaW5hdGlvblwiLFwibWVtYmVyc1wiOntcIiNpbnRlcnBvc2VcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIExpc3Qgd2l0aCBgc2VwYXJhdG9yYCBiZXR3ZWVuIGVhY2ggaXRlbS5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdzZXF1aW5zJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5uZXcgTGlzdChbIDEsIDIsIDMgXSkuaW50ZXJwb3NlKG51bGwpO1xcbi8vIExpc3QgWyAxLCBudWxsLCAyLCBudWxsLCAzXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJTXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInNlcGFyYXRvclwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJTXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiU1wifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19XX0sXCJsaW5lXCI6MzYzfV19fX0se1widGl0bGVcIjpcIkNvbnZlcnNpb25zXCIsXCJtZW1iZXJzXCI6e1wiI3RvSlNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRGVlcGx5IGNvbnZlcnRzIGFsbCBuZXN0ZWQgc3RydWN0dXJlcyB0byBPYmplY3RzIGFuZCBBcnJheXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjowfV19LFwibGluZVwiOjM3MH1dfSxcIiN0b0pTT05cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhbiBBcnJheSBjb250YWluaW5nIHRoZSB2YWx1ZXMgZnJvbSB0aGUgTGlzdC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjozNzV9XX0sXCIjdG9Db25jcmV0ZVwiOntcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMn0sXCJsaW5lXCI6Mzc3fV19LFwiI3RvU2VxXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYW4gYEluZGV4ZWRTZXF1ZW5jZWAgb2YgdGhlIHZhbHVlcyBmcm9tIHRoZSBMaXN0LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJbmRleGVkU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjozODJ9XX19fV19fSxcIk1hcFwiOntcImNsYXNzXCI6e1wiaXNDbGFzc1wiOnRydWUsXCJjb25zdHJ1Y3RvclwiOntcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktcIixcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiZW50cmllc1wiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNixcInR5cGVzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX1dfX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIk1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjM5Nn0se1widHlwZVBhcmFtc1wiOltcIktcIixcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIk1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjM5N30se1widHlwZVBhcmFtc1wiOltcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib2JqXCIsXCJ0eXBlXCI6e1wia1wiOjYsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6NX19XSxcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifX1dfX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIk1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6NX0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjozOTh9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJlbnRyaWVzXCIsXCJ0eXBlXCI6e1wia1wiOjF9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTWFwXCIsXCJhcmdzXCI6W3tcImtcIjowfSx7XCJrXCI6MH1dfSxcImxpbmVcIjozOTl9LHtcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCJdLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIk1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjQwMH1dfSxcInN0YXRpY3NcIjp7XCJpc01hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBhIE1hcFwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnc2VxdWlucycpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuTWFwLmlzTWFwKHt9KSAvLyBmYWxzZVxcbk1hcC5pc01hcChuZXcgTWFwKCkpIC8vIHRydWVcXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVNYXBcIixcInR5cGVcIjp7XCJrXCI6MH19XSxcInR5cGVcIjp7XCJrXCI6M30sXCJsaW5lXCI6NDEzfV19fSxcImxpbmVcIjo0MzMsXCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiTWFwIGlzIGEgYEtleWVkYCBgQ29sbGVjdGlvbmAgb2YgYFtrZXksIHZhbHVlXWAgdHVwbGVzIHdpdGhcXG5PKDEpIGBnZXRgIGFuZCBgc2V0YC4gSXRzIEFQSSBpcyBmdWxseSBjb21wYXRpYmxlIHdpdGggdGhhdCBvZlxcbltKYXZhU2NyaXB0IE1hcF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwKSxcXG5idXQgdGhlIFNlcXVpbnMgTWFwIGNsYXNzIGRlbGVnYXRlcyB0byBhIG5hdGl2ZSBNYXAgZm9yIHN0b3JhZ2UgYXNcXG5vcHBvc2VkIHRvIGV4dGVuZGluZyB0aGUgbmF0aXZlIE1hcCBjbGFzcy5cIixcImRlc2NyaXB0aW9uXCI6XCJNYXAncyBrZXlzIGNhbiBiZSBvZiBhbnkgdHlwZS4gVGhpcyBhbGxvd3MgdGhlIHVzZSBvZiBhbnkgdmFsdWVcXG4oaW5jbHVkaW5nIE5hTikgYXMgYSBrZXkuIFN0cmljdCBpZGVudGl0eSBpcyB1c2VkIHRvIGV2YWx1YXRlIGtleVxcbmVxdWFsaXR5LiBUd28gc2ltaWxhciBsb29raW5nIG9iamVjdHMsIGZvciBleGFtcGxlLCB3aGVuIGJvdGggdXNlZCBhc1xcbmtleXMsIHdpbGwgc3RvcmUgdHdvIHNlcGFyYXRlIHZhbHVlcy5cIixcIm5vdGVzXCI6W119LFwidHlwZVBhcmFtc1wiOltcIktcIixcIlZcIl0sXCJleHRlbmRzXCI6W3tcImtcIjoxMSxcIm5hbWVcIjpcIkNvbmNyZXRlXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX1dLFwiaW1wbGVtZW50c1wiOlt7XCJrXCI6MTEsXCJuYW1lXCI6XCJLZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19XSxcImdyb3Vwc1wiOlt7XCJtZW1iZXJzXCI6e1wiI3NpemVcIjp7XCJsaW5lXCI6NDM3fX19LHtcInRpdGxlXCI6XCJQZXJzaXN0ZW50IGNoYW5nZXNcIixcIm1lbWJlcnNcIjp7XCIjc2V0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNldHMgYGtleWAgdG8gYHZhbHVlYC4gSWYgYW4gZXF1aXZhbGVudCB0aGUga2V5IGFscmVhZHkgZXhpc3RzIGluXFxudGhlIG1hcCwgaXQgd2lsbCBiZSByZXBsYWNlZC5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ3NlcXVpbnMnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmNvbnN0IG9yaWdpbmFsTWFwID0gTWFwKClcXG5jb25zdCBuZXdlck1hcCA9IG9yaWdpbmFsTWFwLnNldCgna2V5JywgJ3ZhbHVlJylcXG5jb25zdCBuZXdlc3RNYXAgPSBuZXdlck1hcC5zZXQoJ2tleScsICduZXdlciB2YWx1ZScpXFxuXFxub3JpZ2luYWxNYXBcXG4vLyBNYXAge31cXG5uZXdlck1hcFxcbi8vIE1hcCB7IFxcXCJrZXlcXFwiOiBcXFwidmFsdWVcXFwiIH1cXG5uZXdlc3RNYXBcXG4vLyBNYXAgeyBcXFwia2V5XFxcIjogXFxcIm5ld2VyIHZhbHVlXFxcIiB9XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjEyfSxcImxpbmVcIjo0NjF9XX0sXCIjZGVsZXRlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJlbW92ZXMgYGtleWAgYW5kIGl0cyBhc3NvY2lhdGVkIHZhbHVlIGZyb20gdGhlIG1hcC5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgZGVsZXRlYCBjYW5ub3QgYmUgc2FmZWx5IHVzZWQgaW4gSUU4LCBidXQgaXMgcHJvdmlkZWQgdG8gbWlycm9yXFxudGhlIEVTNiBjb2xsZWN0aW9uIEFQSS5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ3NlcXVpbnMnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmNvbnN0IG9yaWdpbmFsTWFwID0gTWFwKHtcXG4gIGtleTogJ3ZhbHVlJyxcXG4gIG90aGVyS2V5OiAnb3RoZXIgdmFsdWUnXFxufSlcXG4vLyBNYXAgeyBcXFwia2V5XFxcIjogXFxcInZhbHVlXFxcIiwgXFxcIm90aGVyS2V5XFxcIjogXFxcIm90aGVyIHZhbHVlXFxcIiB9XFxub3JpZ2luYWxNYXAuZGVsZXRlKCdvdGhlcktleScpXFxuLy8gTWFwIHsgXFxcImtleVxcXCI6IFxcXCJ2YWx1ZVxcXCIgfVxcbmBgYFxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcInJlbW92ZVwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn19XSxcInR5cGVcIjp7XCJrXCI6MTJ9LFwibGluZVwiOjQ4NH1dfSxcIiNjbGVhclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZW1vdmVzIGFsbCBrZXlzIGFuZCB2YWx1ZXMgZnJvbSB0aGUgbWFwLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnc2VxdWlucycpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxubmV3IE1hcCh7IGtleTogJ3ZhbHVlJyB9KS5jbGVhcigpXFxuLy8gTWFwIHt9XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMn0sXCJsaW5lXCI6NDk4fV19LFwiI21lcmdlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTWFwIHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgdGhlIHByb3ZpZGVkIENvbGxlY3Rpb25zXFxuKG9yIEpTIG9iamVjdHMpIGludG8gdGhpcyBNYXAuIEluIG90aGVyIHdvcmRzLCB0aGlzIHRha2VzIGVhY2ggZW50cnkgb2ZcXG5lYWNoIGNvbGxlY3Rpb24gYW5kIHNldHMgaXQgb24gdGhpcyBNYXAuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogVmFsdWVzIHByb3ZpZGVkIHRvIGBtZXJnZWAgYXJlIHNoYWxsb3dseSBjb252ZXJ0ZWQgYmVmb3JlIGJlaW5nXFxubWVyZ2VkLiBObyBuZXN0ZWQgdmFsdWVzIGFyZSBhbHRlcmVkLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnc2VxdWlucycpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuY29uc3Qgb25lID0gbmV3IE1hcCh7IGE6IDEwLCBiOiAyMCwgYzogMzAgfSlcXG5jb25zdCB0d28gPSBuZXcgTWFwKHsgYjogNDAsIGE6IDUwLCBkOiA2MCB9KVxcbm9uZS5tZXJnZSh0d28pIC8vIE1hcCB7IFxcXCJhXFxcIjogNTAsIFxcXCJiXFxcIjogNDAsIFxcXCJjXFxcIjogMzAsIFxcXCJkXFxcIjogNjAgfVxcbnR3by5tZXJnZShvbmUpIC8vIE1hcCB7IFxcXCJiXFxcIjogMjAsIFxcXCJhXFxcIjogMTAsIFxcXCJkXFxcIjogNjAsIFxcXCJjXFxcIjogMzAgfVxcbmBgYFxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcImNvbmNhdFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS0NcIixcIlZDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjExLFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE2LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktDXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWQ1wifV19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTWFwXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJLQ1wifV19LHtcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWQ1wifV19XX0sXCJsaW5lXCI6NTIwfSx7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo2LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjV9fV0sXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIkNcIn19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTWFwXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo1fV19LHtcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJDXCJ9XX1dfSxcImxpbmVcIjo1MjF9XX19fSx7XCJ0aXRsZVwiOlwiU2VxdWVuY2UgYWxnb3JpdGhtc1wiLFwibWVtYmVyc1wiOntcIiNtYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBNYXAgd2l0aCB2YWx1ZXMgcGFzc2VkIHRocm91Z2ggYVxcbmBtYXBwZXJgIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIiAgICBuZXcgTWFwKHsgYTogMSwgYjogMiB9KS5tYXAoeCA9PiAxMCAqIHgpXFxuICAgIC8vIE1hcCB7IGE6IDEwLCBiOiAyMCB9XCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTJ9fV0sXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIk1cIn19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTWFwXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6NTM4fV19LFwiI21hcEtleXNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcIktleWVkLm1hcEtleXNcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTJ9fV0sXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIk1cIn19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTWFwXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJNXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6NTQzfV19LFwiI21hcEVudHJpZXNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcIktleWVkLm1hcEVudHJpZXNcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktNXCIsXCJWTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJlbnRyeVwiLFwidHlwZVwiOntcImtcIjoxNixcInR5cGVzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX19LHtcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjR9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEyfX1dLFwidHlwZVwiOntcImtcIjoxNixcInR5cGVzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJLTVwifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVk1cIn1dfX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJNYXBcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWTVwifV19LFwibGluZVwiOjU0OH1dfSxcIiNmbGF0dGVuXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJDb2xsZWN0aW9uLmZsYXR0ZW5cIn1dfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImRlcHRoXCIsXCJ0eXBlXCI6e1wia1wiOjR9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTWFwXCIsXCJhcmdzXCI6W3tcImtcIjowfSx7XCJrXCI6MH1dfSxcImxpbmVcIjo1NTV9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzaGFsbG93XCIsXCJ0eXBlXCI6e1wia1wiOjN9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTWFwXCIsXCJhcmdzXCI6W3tcImtcIjowfSx7XCJrXCI6MH1dfSxcImxpbmVcIjo1NTZ9XX0sXCIjZmxhdE1hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJGbGF0LW1hcHMgdGhlIE1hcCwgcmV0dXJuaW5nIGEgbmV3IE1hcC5cIixcImRlc2NyaXB0aW9uXCI6XCJTaW1pbGFyIHRvIGBkYXRhLm1hcCguLi4pLmZsYXR0ZW4odHJ1ZSlgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJLTVwiLFwiVk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTJ9fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE2LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWTVwifV19XX19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTWFwXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJLTVwifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVk1cIn1dfSxcImxpbmVcIjo1NjN9XX0sXCIjZmlsdGVyXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTWFwIHdpdGggb25seSB0aGUgZW50cmllcyBmb3Igd2hpY2ggdGhlIGBwcmVkaWNhdGVgXFxuZnVuY3Rpb24gcmV0dXJucyB0cnVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJGXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo5LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEyfX1dLFwidHlwZVwiOntcImtcIjozfX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJNYXBcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIkZcIn1dfSxcImxpbmVcIjo1NzF9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMn19XSxcInR5cGVcIjp7XCJrXCI6MH19fV0sXCJ0eXBlXCI6e1wia1wiOjEyfSxcImxpbmVcIjo1NzR9XX0sXCIjZmxpcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiS2V5ZWQuZmxpcFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTWFwXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9XX0sXCJsaW5lXCI6NTc5fV19fX0se1widGl0bGVcIjpcIkNvbnZlcnNpb25zXCIsXCJtZW1iZXJzXCI6e1wiI3RvSlNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRGVlcGx5IGNvbnZlcnRzIGFsbCBuZXN0ZWQgc3RydWN0dXJlcyB0byBPYmplY3RzIGFuZCBBcnJheXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo2LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjV9fV0sXCJ0eXBlXCI6e1wia1wiOjB9fV19LFwibGluZVwiOjU4Nn1dfSxcIiN0b0pTT05cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhbiBPYmplY3Qgd2l0aCB0aGUga2V5cyAoc3RyaW5naWZpZWQpIGFuZCB2YWx1ZXMgZnJvbSB0aGUgTWFwLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6NixcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo1fX1dLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9fV19LFwibGluZVwiOjU5MX1dfSxcIiN0b0NvbmNyZXRlXCI6e1wic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEyfSxcImxpbmVcIjo1OTN9XX0sXCIjdG9TZXFcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhbiBgS2V5ZWRTZXF1ZW5jZWAgb2YgdGhlIGVudHJpZXMgZnJvbSB0aGUgTGlzdC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiS2V5ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjU5OH1dfX19XX19LFwiU2V0XCI6e1wiY2xhc3NcIjp7XCJpc0NsYXNzXCI6dHJ1ZSxcImNvbnN0cnVjdG9yXCI6e1wic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjYwNH0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6MX0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJTZXRcIixcImFyZ3NcIjpbe1wia1wiOjB9XX0sXCJsaW5lXCI6NjA1fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJTZXRcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjo2MDZ9XX0sXCJzdGF0aWNzXCI6e1wiaXNTZXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYSBTZXRcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVTZXRcIixcInR5cGVcIjp7XCJrXCI6MH19XSxcInR5cGVcIjp7XCJrXCI6M30sXCJsaW5lXCI6NjExfV19LFwib2ZcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQ3JlYXRlcyBhIG5ldyBTZXQgY29udGFpbmluZyBgdmFsdWVzYC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZXNcIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJTZXRcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjo2MTZ9XX0sXCJmcm9tS2V5c1wiOntcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjB9XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJTZXRcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjo2MjJ9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvYmpcIixcInR5cGVcIjp7XCJrXCI6NixcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo1fX1dLFwidHlwZVwiOntcImtcIjowfX1dfX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6NX1dfSxcImxpbmVcIjo2MjN9LHtcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJTZXRcIixcImFyZ3NcIjpbe1wia1wiOjB9XX0sXCJsaW5lXCI6NjI0fV19LFwidW5pb25cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiYFNldC51bmlvbigpYCBjcmVhdGVzIGEgbmV3IFNldCB0aGF0IGluY2x1ZGVzIGFsbCBtZW1iZXJzIHByZXNlbnQgaW4gYW55XFxuaW5wdXQgU2V0LlwiLFwiZGVzY3JpcHRpb25cIjpcIklmIGFuIGlucHV0IGlzIGFuIGFzc29jaWF0aXZlIGl0ZXJhYmxlLCBpdHMgdmFsdWVzIGFyZSBjb25zaWRlcmVkIHRoZSBTZXQuXFxuXFxuYGBganNcXG5jb25zdCB7IFNldCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCB1bmlvbmVkID0gU2V0LnVuaW9uKFtcXG4gIFNldChbICdhJywgJ2InLCAnYycgXSlcXG4gIFNldChbICdjJywgJ2EnLCAndCcgXSlcXG5dKVxcbi8vIFNldCBbIFxcXCJhXFxcIiwgXFxcImJcXFwiLCBcXFwiY1xcXCIsIFxcXCJ0XFxcIlxcXCIgXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInNldHNcIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTEsXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjY0MX1dfSxcImludGVyc2VjdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJgU2V0LmludGVyc2VjdCgpYCBjcmVhdGVzIGEgbmV3IFNldCB0aGF0IGluY2x1ZGVzIG9ubHkgbWVtYmVycyB0aGF0IGFyZVxcbnByZXNlbnQgaW4gYWxsIGlucHV0IFNldHMuXCIsXCJkZXNjcmlwdGlvblwiOlwiSWYgYW4gaW5wdXQgaXMgYW4gYXNzb2NpYXRpdmUgaXRlcmFibGUsIGl0cyB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgdGhlIFNldC5cXG5cXG5gYGBqc1xcbmNvbnN0IHsgU2V0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IGludGVyc2VjdGVkID0gU2V0LmludGVyc2VjdChbXFxuICBTZXQoWyAnYScsICdiJywgJ2MnIF0pXFxuICBTZXQoWyAnYycsICdhJywgJ3QnIF0pXFxuXSlcXG4vLyBTZXQgWyBcXFwiYVxcXCIsIFxcXCJjXFxcIlxcXCIgXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInNldHNcIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTEsXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjY1OH1dfX0sXCJsaW5lXCI6Njc4LFwiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNldCBpcyBhIGBEdXBsaWNhdGVkYCBgQ29sbGVjdGlvbmAgb2YgdW5pcXVlIHZhbHVlcyB3aXRoIE8oMSkgYGFkZGAgYW5kIGBoYXNgLlxcbkl0cyBBUEkgaXMgZnVsbHkgY29tcGF0aWJsZSB3aXRoIHRoYXQgb2ZcXG5bSmF2YVNjcmlwdCBTZXRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1NldCksXFxuYnV0IHRoZSBTZXF1aW5zIFNldCBjbGFzcyBkZWxlZ2F0ZXMgdG8gYSBuYXRpdmUgU2V0IGZvciBzdG9yYWdlIGFzXFxub3Bwb3NlZCB0byBleHRlbmRpbmcgdGhlIG5hdGl2ZSBTZXQgY2xhc3MuXCIsXCJkZXNjcmlwdGlvblwiOlwiV2hlbiBpdGVyYXRpbmcgYSBTZXQsIHRoZSBlbnRyaWVzIHdpbGwgYmUgW3ZhbHVlLCB2YWx1ZV0gdHVwbGVzLlxcblxcblNldCB2YWx1ZXMsIGxpa2UgTWFwIGtleXMsIG1heSBiZSBvZiBhbnkgdHlwZSBpbmNsdWRpbmcgb3RoZXIgY29sbGVjdGlvbnNcXG5hbmQgTmFOLlwiLFwibm90ZXNcIjpbXX0sXCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcImV4dGVuZHNcIjpbe1wia1wiOjExLFwibmFtZVwiOlwiQ29uY3JldGVcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfV0sXCJpbXBsZW1lbnRzXCI6W3tcImtcIjoxMSxcIm5hbWVcIjpcIkR1cGxpY2F0ZWRcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfV0sXCJncm91cHNcIjpbe1wibWVtYmVyc1wiOntcIiNzaXplXCI6e1wibGluZVwiOjY4Mn19fSx7XCJ0aXRsZVwiOlwiUGVyc2lzdGVudCBjaGFuZ2VzXCIsXCJtZW1iZXJzXCI6e1wiI2FkZFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJBZGRzIHZhbHVlIHRvIHRoZSBzZXQuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn19XSxcInR5cGVcIjp7XCJrXCI6MTJ9LFwibGluZVwiOjY4OX1dfSxcIiNkZWxldGVcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmVtb3ZlcyB2YWx1ZSBmcm9tIHRoZSBzZXQuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYGRlbGV0ZWAgKipjYW5ub3QqKiBiZSBzYWZlbHkgdXNlZCBpbiBJRTgsIHVzZSBgcmVtb3ZlYCBpZlxcbnN1cHBvcnRpbmcgb2xkIGJyb3dzZXJzLlxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcInJlbW92ZVwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifX1dLFwidHlwZVwiOntcImtcIjoxMn0sXCJsaW5lXCI6Njk5fV19LFwiI2NsZWFyXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNsZWFycyBhbGwga2V5cyBhbmQgdmFsdWVzIGZyb20gdGhlIHNldFwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTJ9LFwibGluZVwiOjcwNX1dfSxcIiN1bmlvblwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgU2V0IGluY2x1ZGluZyBhbnkgdmFsdWUgZnJvbSBgY29sbGVjdGlvbnNgIHRoYXQgZG9lcyBub3QgYWxyZWFkeVxcbmV4aXN0IGluIHRoaXMgU2V0LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcIm1lcmdlXCJ9LHtcIm5hbWVcIjpcImFsaWFzXCIsXCJib2R5XCI6XCJjb25jYXRcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTEsXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiQ1wifV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiQ1wifV19XX0sXCJsaW5lXCI6NzEzfV19LFwiI2ludGVyc2VjdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgU2V0IHdoaWNoIGhhcyByZW1vdmVkIGFueSB2YWx1ZXMgbm90IGFsc28gY29udGFpbmVkXFxud2l0aGluIGBjb2xsZWN0aW9uc2AuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjExLFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTJ9LFwibGluZVwiOjcyMX1dfSxcIiNzdWJ0cmFjdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgU2V0IGV4Y2x1ZGluZyBhbnkgdmFsdWVzIGNvbnRhaW5lZCB3aXRoaW4gYGNvbGxlY3Rpb25zYC5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBTZXQgfSA9IHJlcXVpcmUoJ3NlcXVpbnMnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbm5ldyBTZXQoWyAxLCAyLCAzIF0pLnN1YnRyYWN0KFsxLCAzXSlcXG4vLyBTZXQgWzJdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjExLFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTJ9LFwibGluZVwiOjczNH1dfX19LHtcInRpdGxlXCI6XCJTZXF1ZW5jZSBhbGdvcml0aG1zXCIsXCJtZW1iZXJzXCI6e1wiI21hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFNldCB3aXRoIHZhbHVlcyBwYXNzZWQgdGhyb3VnaCBhXFxuYG1hcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiICAgIG5ldyBTZXQoWzEsMl0pLm1hcCh4ID0+IDEwICogeClcXG4gICAgLy8gU2V0IFsxMCwyMF1cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMn19XSxcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiTVwifX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJTZXRcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjo3NDV9XX0sXCIjZmxhdHRlblwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiQ29sbGVjdGlvbi5mbGF0dGVuXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJkZXB0aFwiLFwidHlwZVwiOntcImtcIjo0fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6MH1dfSxcImxpbmVcIjo3NTB9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzaGFsbG93XCIsXCJ0eXBlXCI6e1wia1wiOjN9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiU2V0XCIsXCJhcmdzXCI6W3tcImtcIjowfV19LFwibGluZVwiOjc1MX1dfSxcIiNmbGF0TWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkZsYXQtbWFwcyB0aGUgU2V0LCByZXR1cm5pbmcgYSBuZXcgU2V0LlwiLFwiZGVzY3JpcHRpb25cIjpcIlNpbWlsYXIgdG8gYHNldC5tYXAoLi4uKS5mbGF0dGVuKHRydWUpYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMn19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiTVwifV19fX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjc1OH1dfSxcIiNmaWx0ZXJcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBTZXQgd2l0aCBvbmx5IHRoZSB2YWx1ZXMgZm9yIHdoaWNoIHRoZSBgcHJlZGljYXRlYFxcbmZ1bmN0aW9uIHJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiRlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMn19XSxcInR5cGVcIjp7XCJrXCI6M319fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiU2V0XCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJGXCJ9XX0sXCJsaW5lXCI6NzY0fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTJ9fV0sXCJ0eXBlXCI6e1wia1wiOjB9fX1dLFwidHlwZVwiOntcImtcIjoxMn0sXCJsaW5lXCI6NzY3fV19fX0se1widGl0bGVcIjpcIkNvbnZlcnNpb25zXCIsXCJtZW1iZXJzXCI6e1wiI3RvSlNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRGVlcGx5IGNvbnZlcnRzIGFsbCBuZXN0ZWQgc3RydWN0dXJlcyB0byBPYmplY3RzIGFuZCBBcnJheXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjowfV19LFwibGluZVwiOjc3NH1dfSxcIiN0b0pTT05cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhbiBBcnJheSB3aXRoIHRoZSB2YWx1ZXMgZnJvbSB0aGUgU2V0LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjc3OX1dfSxcIiN0b0NvbmNyZXRlXCI6e1wic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEyfSxcImxpbmVcIjo3ODF9XX0sXCIjdG9TZXFcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIGBTZXRTZXF1ZW5jZWAgb2YgdGhlIHZhbHVlcyBmcm9tIHRoZSBTZXQuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIlNldFNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6Nzg2fV19fX1dfX19fSx7XCJ0aXRsZVwiOlwiU2VxdWVuY2VcIixcIm1lbWJlcnNcIjp7XCJJbmRleGVkU2VxdWVuY2VcIjp7XCJjbGFzc1wiOntcImlzQ2xhc3NcIjp0cnVlLFwiY29uc3RydWN0b3JcIjp7XCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiSW5kZXhlZFNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6Nzk0fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjoxfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkluZGV4ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MH1dfSxcImxpbmVcIjo3OTV9LHtcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkluZGV4ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjc5Nn1dfSxcInN0YXRpY3NcIjp7XCJvZlwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDcmVhdGVzIGEgbmV3IEluZGV4ZWRTZXF1ZW5jZSBjb250YWluaW5nIGB2YWx1ZXNgLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlc1wiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkluZGV4ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjgwMX1dfX0sXCJsaW5lXCI6ODE4LFwiZG9jXCI6e1wic3lub3BzaXNcIjpcIkFuIEluZGV4ZWRTZXF1ZW5jZSBpcyBxdWl0ZSBzaW1wbHkgYW4gYEluZGV4ZWRgIGBTZXF1ZW5jZWAuIEl0IHJlcHJlc2VudHNcXG5zZXF1ZW50aWFsIHRyYW5zZm9ybWF0aW9ucyBhZ2FpbnN0IEFycmF5IG9yIExpc3QtbGlrZSBkYXRhIGFzIGEgc2VyaWVzIG9mXFxuY2hhaW5lZCBmdW5jdGlvbiBjYWxscy4gVGhlIGNoYWluIG9mIGNhbGxzIHdpbGwgdXN1YWxseSBiZSB0ZXJtaW5hdGVkIHdpdGhcXG5gdG9MaXN0YC5cIixcImRlc2NyaXB0aW9uXCI6XCJXaGVuIGNvbnN0cnVjdGluZyBhbiBJbmRleGVkU2VxdWVuY2UgZnJvbSBhbm90aGVyIGRhdGEgdHlwZSwga2V5cyB3aWxsIGJlXFxuZGlzY2FyZGVkLlwiLFwibm90ZXNcIjpbXX0sXCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcImV4dGVuZHNcIjpbe1wia1wiOjExLFwibmFtZVwiOlwiU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjR9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX1dLFwiaW1wbGVtZW50c1wiOlt7XCJrXCI6MTEsXCJuYW1lXCI6XCJJbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX1dLFwiZ3JvdXBzXCI6W3tcInRpdGxlXCI6XCJDb21iaW5hdGlvblwiLFwibWVtYmVyc1wiOntcIiNjb25jYXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBJbmRleGVkU2VxdWVuY2Ugd2l0aCBvdGhlciBjb2xsZWN0aW9ucyBjb25jYXRlbmF0ZWQgdG8gdGhpc1xcbm9uZS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZXNPckNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjExLFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIkNcIn1dfSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiQ1wifV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkluZGV4ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiQ1wifV19XX0sXCJsaW5lXCI6ODI1fV19LFwiI2ludGVycG9zZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGFuIEluZGV4ZWRTZXF1ZW5jZSB3aXRoIGBzZXBhcmF0b3JgIGJldHdlZW4gZWFjaCBpdGVtLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ3NlcXVpbnMnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbm5ldyBJbmRleGVkU2VxdWVuY2UoWyAxLCAyLCAzIF0pLmludGVycG9zZShudWxsKTtcXG4vLyBJbmRleGVkU2VxdWVuY2UgWyAxLCBudWxsLCAyLCBudWxsLCAzXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJTXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInNlcGFyYXRvclwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJTXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiSW5kZXhlZFNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJTXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX1dfSxcImxpbmVcIjo4NDB9XX19fSx7XCJ0aXRsZVwiOlwiU2VxdWVuY2UgYWxnb3JpdGhtc1wiLFwibWVtYmVyc1wiOntcIiNtYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBJbmRleGVkU2VxdWVuY2Ugd2l0aCB2YWx1ZXMgcGFzc2VkIHRocm91Z2ggYVxcbmBtYXBwZXJgIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IFNlcSB9ID0gcmVxdWlyZSgnc2VxdWlucycpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuSW5kZXhlZFNlcXVlbmNlKFsgMSwgMiBdKS5tYXAoeCA9PiAxMCAqIHgpXFxuLy8gU2VxIFsgMTAsIDIwIF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6NH19XSxcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiTVwifX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJbmRleGVkU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjo4NTZ9XX0sXCIjdGFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkRvZXMgbm90IGFsdGVyIHRoZSBzZXF1ZW5jZSwgYnV0IGFsbG93cyB5b3UgdG8gaW5zcGVjdCB2YWx1ZXMgYXMgdGhleSBhcmVcXG5jb21wdHVlZC4gUmV0dXJucyB0aGUgc2VxdWVuY2UgZm9yIGNoYWluaW5nLiBVbmxpa2UgYGZvckVhY2hgLCB0YXAgZG9lcyBub3RcXG5ldmFsdWF0ZSB0aGUgc2VxdWVuY2UuXCIsXCJkZXNjcmlwdGlvblwiOlwiYGBganNcXG5jb25zdCBzZXEgPSBJbmRleGVkU2VxdWVuY2UoWyAxLCAyIF0pLnRhcCh4ID0+IGNvbnNvbGUubG9nKHgpKVxcbkFycmF5LmZyb20oc2VxKTsgLy8gbG9ncyAxLCAyXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImZuXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjR9fV0sXCJ0eXBlXCI6e1wia1wiOjB9fX1dLFwidHlwZVwiOntcImtcIjoxMn0sXCJsaW5lXCI6ODY4fV19LFwiI2ZsYXR0ZW5cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcIkNvbGxlY3Rpb24uZmxhdHRlblwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiZGVwdGhcIixcInR5cGVcIjp7XCJrXCI6NH0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJbmRleGVkU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjB9XX0sXCJsaW5lXCI6ODczfSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic2hhbGxvd1wiLFwidHlwZVwiOntcImtcIjozfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkluZGV4ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MH1dfSxcImxpbmVcIjo4NzR9XX0sXCIjZmxhdE1hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJGbGF0LW1hcHMgdGhlIEluZGV4ZWRTZXF1ZW5jZSwgcmV0dXJuaW5nIGFuIEluZGV4ZWRTZXF1ZW5jZS5cIixcImRlc2NyaXB0aW9uXCI6XCJTaW1pbGFyIHRvIGBzZXEubWFwKC4uLikuZmxhdHRlbih0cnVlKWAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjR9fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIk1cIn1dfX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJbmRleGVkU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjo4ODF9XX0sXCIjZmlsdGVyXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgSW5kZXhlZFNlcXVlbmNlIHdpdGggb25seSB0aGUgdmFsdWVzIGZvciB3aGljaCB0aGVcXG5gcHJlZGljYXRlYCBmdW5jdGlvbiByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6NH19XSxcInR5cGVcIjp7XCJrXCI6M319fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiSW5kZXhlZFNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJGXCJ9XX0sXCJsaW5lXCI6ODg5fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6NH19XSxcInR5cGVcIjp7XCJrXCI6MH19fV0sXCJ0eXBlXCI6e1wia1wiOjEyfSxcImxpbmVcIjo4OTJ9XX0sXCIjemlwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgSW5kZXhlZFNlcXVlbmNlIFxcXCJ6aXBwZWRcXFwiIHdpdGggdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb25zLlwiLFwiZGVzY3JpcHRpb25cIjpcIkxpa2UgYHppcFdpdGhgLCBidXQgdXNpbmcgdGhlIGRlZmF1bHQgYHppcHBlcmA6IGNyZWF0aW5nIGFuIGBBcnJheWAuXFxuXFxuYGBganNcXG5jb25zdCBhID0gU2VxKFsgMSwgMiwgMyBdKTtcXG5jb25zdCBiID0gU2VxKFsgNCwgNSwgNiBdKTtcXG5jb25zdCBjID0gYS56aXAoYik7IC8vIFNlcSBbIFsgMSwgNCBdLCBbIDIsIDUgXSwgWyAzLCA2IF0gXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJVXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQ29sbGVjdGlvbkxpa2VcIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJVXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJbmRleGVkU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjE2LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlVcIn1dfV19LFwibGluZVwiOjkwNX0se1widHlwZVBhcmFtc1wiOltcIlVcIixcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib3RoZXJcIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJDb2xsZWN0aW9uTGlrZVwiLFwiYXJnc1wiOlt7XCJrXCI6MH0se1wia1wiOjEwLFwicGFyYW1cIjpcIlVcIn1dfX0se1wibmFtZVwiOlwib3RoZXIyXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQ29sbGVjdGlvbkxpa2VcIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJbmRleGVkU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjE2LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlVcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfV19LFwibGluZVwiOjkwNn0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjExLFwibmFtZVwiOlwiQ29sbGVjdGlvbkxpa2VcIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjowfV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkluZGV4ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MH1dfSxcImxpbmVcIjo5MTB9XX0sXCIjemlwQWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgSW5kZXhlZFNlcXVlbmNlIFxcXCJ6aXBwZWRcXFwiIHdpdGggdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb25zLlxcbkNvbnRpbnVlcyB1bnRpbCB0aGUgbG9uZ2VzdCBjb2xsZWN0aW9uIGlzIGV4aGF1c3RlZC5cIixcImRlc2NyaXB0aW9uXCI6XCJNaXNzaW5nIHZhbHVlcyBmcm9tIHNob3J0ZXIgY29sbGVjdGlvbnMgYXJlIGZpbGxlZCB3aXRoIGB1bmRlZmluZWRgLlxcblxcbmBgYGpzXFxuY29uc3QgYSA9IFNlcShbIDEsIDIgXSk7XFxuY29uc3QgYiA9IFNlcShbIDMsIDQsIDUgXSk7XFxuY29uc3QgYyA9IGEuemlwQWxsKGIpOyAvLyBTZXEgWyBbIDEsIDMgXSwgWyAyLCA0IF0sIFsgdW5kZWZpbmVkLCA1IF0gXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJVXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQ29sbGVjdGlvbkxpa2VcIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJVXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJbmRleGVkU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjE2LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlVcIn1dfV19LFwibGluZVwiOjkyNH0se1widHlwZVBhcmFtc1wiOltcIlVcIixcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib3RoZXJcIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJDb2xsZWN0aW9uTGlrZVwiLFwiYXJnc1wiOlt7XCJrXCI6MH0se1wia1wiOjEwLFwicGFyYW1cIjpcIlVcIn1dfX0se1wibmFtZVwiOlwib3RoZXIyXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQ29sbGVjdGlvbkxpa2VcIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJbmRleGVkU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjE2LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlVcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfV19LFwibGluZVwiOjkyNX0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjExLFwibmFtZVwiOlwiQ29sbGVjdGlvbkxpa2VcIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjowfV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkluZGV4ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MH1dfSxcImxpbmVcIjo5Mjl9XX0sXCIjemlwV2l0aFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IEluZGV4ZWRTZXF1ZW5jZSBcXFwiemlwcGVkXFxcIiB3aXRoIHRoZSBwcm92aWRlZCBjb2xsZWN0aW9ucyBieVxcbnVzaW5nIGEgY3VzdG9tIGB6aXBwZXJgIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcImBgYGpzXFxuY29uc3QgYSA9IFNlcShbIDEsIDIsIDMgXSk7XFxuY29uc3QgYiA9IFNlcShbIDQsIDUsIDYgXSk7XFxuY29uc3QgYyA9IGEuemlwV2l0aCgoYSwgYikgPT4gYSArIGIsIGIpO1xcbi8vIFNlcSBbIDUsIDcsIDkgXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJVXCIsXCJaXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInppcHBlclwiLFwidHlwZVwiOntcImtcIjo5LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIm90aGVyVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVVwifX1dLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJaXCJ9fX0se1wibmFtZVwiOlwib3RoZXJDb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQ29sbGVjdGlvbkxpa2VcIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJVXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJbmRleGVkU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlpcIn1dfSxcImxpbmVcIjo5NDJ9LHtcInR5cGVQYXJhbXNcIjpbXCJVXCIsXCJWXCIsXCJaXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInppcHBlclwiLFwidHlwZVwiOntcImtcIjo5LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIm90aGVyVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVVwifX0se1wibmFtZVwiOlwidGhpcmRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlpcIn19fSx7XCJuYW1lXCI6XCJvdGhlckNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJDb2xsZWN0aW9uTGlrZVwiLFwiYXJnc1wiOlt7XCJrXCI6MH0se1wia1wiOjEwLFwicGFyYW1cIjpcIlVcIn1dfX0se1wibmFtZVwiOlwidGhpcmRDb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQ29sbGVjdGlvbkxpa2VcIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJbmRleGVkU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlpcIn1dfSxcImxpbmVcIjo5NDZ9LHtcInR5cGVQYXJhbXNcIjpbXCJaXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInppcHBlclwiLFwidHlwZVwiOntcImtcIjo5LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImFueVwiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjowfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiWlwifX19LHtcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjExLFwibmFtZVwiOlwiQ29sbGVjdGlvbkxpa2VcIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjowfV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkluZGV4ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiWlwifV19LFwibGluZVwiOjk1MX1dfX19LHtcInRpdGxlXCI6XCJDb252ZXJzaW9uc1wiLFwibWVtYmVyc1wiOntcIiN0b0NvbmNyZXRlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBgTGlzdGAgb2YgdGhlIHNlcXVlbmNlJ3MgdmFsdWVzXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjo5NjF9XX0sXCIjdG9TZXFcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBpdHNlbGZcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEyfSxcImxpbmVcIjo5NjZ9XX0sXCIjdG9KU1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJEZWVwbHkgY29udmVydHMgdGhpcyBJbmRleGVkU2VxdWVuY2UgdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdFxcbkFycmF5LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MH1dfSxcImxpbmVcIjo5NzJ9XX0sXCIjdG9KU09OXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIEluZGV4ZWRTZXF1ZW5jZSB0byBlcXVpdmFsZW50IG5hdGl2ZSBKYXZhU2NyaXB0XFxuQXJyYXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6OTc4fV19fX1dfX0sXCJLZXllZFNlcXVlbmNlXCI6e1wiY2xhc3NcIjp7XCJpc0NsYXNzXCI6dHJ1ZSxcImNvbnN0cnVjdG9yXCI6e1wic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJlbnRyaWVzXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE2LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfV19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiS2V5ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjk5Mn0se1widHlwZVBhcmFtc1wiOltcIktcIixcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIktleWVkU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjo5OTN9LHtcInR5cGVQYXJhbXNcIjpbXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9ialwiLFwidHlwZVwiOntcImtcIjo2LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjV9fV0sXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn19XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJLZXllZFNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjo1fSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjk5NH0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImVudHJpZXNcIixcInR5cGVcIjp7XCJrXCI6MX0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJLZXllZFNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjowfSx7XCJrXCI6MH1dfSxcImxpbmVcIjo5OTV9LHtcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCJdLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIktleWVkU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjo5OTZ9XX0sXCJsaW5lXCI6MTAxNCxcImRvY1wiOntcInN5bm9wc2lzXCI6XCJBIEtleWVkU2VxdWVuY2UgaXMsIGFzIGV4cGVjdGVkLCBhIGBLZXllZGAgYFNlcXVlbmNlYC4gSXQgcmVwcmVzZW50c1xcbnNlcXVlbnRpYWwgdHJhbnNmb3JtYXRpb25zIG9uIE9iamVjdCBvciBNYXAtbGlrZSBkYXRhIGFzIGEgc2VyaWVzIG9mXFxuY2hhaW5lZCBmdW5jdGlvbiBjYWxscy4gTm90ZSB0aGF0IGEgS2V5ZWRTZXF1ZW5jZSBsYWNrcyB0aGUga2V5LWNvYWxlc2NpbmdcXG5wcm9wZXJ0eSBvZiBhIGBNYXBgLiBEdXBsaWNhdGUga2V5cyB3aWxsIGJlIGVsaW1pbmF0ZWQgd2hlbiBjYWxsaW5nIGBhcyhNYXApYFxcbndoaWNoIHdpbGwgdXN1YWxseSBiZSB0aGUgbGFzdCBjYWxsIGluIHRoZSBjaGFpbi5cIixcImRlc2NyaXB0aW9uXCI6XCJXaGVuIGNvbnN0cnVjdGluZyBhIEtleWVkU2VxdWVuY2UgcGFzcyBlaXRoZXIga2V5ZWQgZGF0YSBvciBhbiBpdGVyYWJsZSBvZlxcbltLLCBWXSB0dXBsZXMuXCIsXCJub3Rlc1wiOltdfSxcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCJdLFwiZXh0ZW5kc1wiOlt7XCJrXCI6MTEsXCJuYW1lXCI6XCJTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19XSxcImltcGxlbWVudHNcIjpbe1wia1wiOjExLFwibmFtZVwiOlwiS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfV0sXCJncm91cHNcIjpbe1wibWVtYmVyc1wiOntcIiNjb25jYXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBLZXllZFNlcXVlbmNlIHdpdGggb3RoZXIgY29sbGVjdGlvbnMgY29uY2F0ZW5hdGVkIHRvIHRoaXMgb25lLlwiLFwiZGVzY3JpcHRpb25cIjpcIkFsbCBlbnRyaWVzIHdpbGwgYmUgcHJlc2VudCBpbiB0aGUgcmVzdWx0aW5nIEtleWVkU2VxdWVuY2UsIGV2ZW4gaWYgdGhleVxcbmhhdmUgdGhlIHNhbWUga2V5LlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJLQ1wiLFwiVkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTEsXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTYsXCJ0eXBlc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS0NcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZDXCJ9XX1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJLZXllZFNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJLQ1wifV19LHtcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWQ1wifV19XX0sXCJsaW5lXCI6MTAyMX0se1widHlwZVBhcmFtc1wiOltcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6NixcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo1fX1dLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJDXCJ9fV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIktleWVkU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn0se1wia1wiOjV9XX0se1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIkNcIn1dfV19LFwibGluZVwiOjEwMjR9XX0sXCIjbWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgS2V5ZWRTZXF1ZW5jZSB3aXRoIHZhbHVlcyBwYXNzZWQgdGhyb3VnaCBhXFxuYG1hcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgS2V5ZWRTZXF1ZW5jZSB9ID0gcmVxdWlyZSgnc2VxdWlucycpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuS2V5ZWRTZXF1ZW5jZSh7IGE6IDEsIGI6IDIgfSkubWFwKHggPT4gMTAgKiB4KVxcbi8vIFNlcSB7IFxcXCJhXFxcIjogMTAsIFxcXCJiXFxcIjogMjAgfVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo5LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIk1cIn19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiS2V5ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjEwNDB9XX0sXCIjbWFwS2V5c1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiS2V5ZWQubWFwS2V5c1wifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJNXCJ9fX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIktleWVkU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIk1cIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjoxMDQ1fV19LFwiI21hcEVudHJpZXNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcIktleWVkLm1hcEVudHJpZXNcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktNXCIsXCJWTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJlbnRyeVwiLFwidHlwZVwiOntcImtcIjoxNixcInR5cGVzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX19LHtcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjR9fV0sXCJ0eXBlXCI6e1wia1wiOjE2LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWTVwifV19fX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIktleWVkU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWTVwifV19LFwibGluZVwiOjEwNTB9XX0sXCIjdGFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkRvZXMgbm90IGFsdGVyIHRoZSBzZXF1ZW5jZSwgYnV0IGFsbG93cyB5b3UgdG8gaW5zcGVjdCBrZXlzIGFuZCB2YWx1ZXMgYXNcXG50aGV5IGFyZSBjb21wdHVlZC4gUmV0dXJucyB0aGUgc2VxdWVuY2UgZm9yIGNoYWluaW5nLiBVbmxpa2UgYGZvckVhY2hgLCB0YXBcXG5kb2VzIG5vdCBldmFsdWF0ZSB0aGUgc2VxdWVuY2UuXCIsXCJkZXNjcmlwdGlvblwiOlwiYGBganNcXG5jb25zdCBzZXEgPSBLZXllZFNlcXVlbmNlKFtbMSwgMV0sIFsyLCAyXV0pLnRhcCh4ID0+IGNvbnNvbGUubG9nKHgpKVxcbkFycmF5LmZyb20oc2VxKTsgLy8gbG9ncyAxLCAyXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImZuXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn19XSxcInR5cGVcIjp7XCJrXCI6MH19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiS2V5ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjEwNjR9XX0sXCIjZmxhdHRlblwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiQ29sbGVjdGlvbi5mbGF0dGVuXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJkZXB0aFwiLFwidHlwZVwiOntcImtcIjo0fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIktleWVkU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjowfV19LFwibGluZVwiOjEwNjl9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzaGFsbG93XCIsXCJ0eXBlXCI6e1wia1wiOjN9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiS2V5ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MH0se1wia1wiOjB9XX0sXCJsaW5lXCI6MTA3MH1dfSxcIiNmbGF0TWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkZsYXQtbWFwcyB0aGUgS2V5ZWRTZXF1ZW5jZSwgcmV0dXJuaW5nIGEgbmV3IEtleWVkU2VxdWVuY2UuXCIsXCJkZXNjcmlwdGlvblwiOlwiU2ltaWxhciB0byBgc2VxLm1hcCguLi4pLmZsYXR0ZW4odHJ1ZSlgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJLTVwiLFwiVk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTYsXCJ0eXBlc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS01cIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZNXCJ9XX1dfX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJLZXllZFNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJLTVwifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVk1cIn1dfSxcImxpbmVcIjoxMDc3fV19LFwiI2ZpbHRlclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IEtleWVkU2VxdWVuY2Ugd2l0aCBvbmx5IHRoZSBlbnRyaWVzIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWBcXG5mdW5jdGlvbiByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn19XSxcInR5cGVcIjp7XCJrXCI6M319fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiS2V5ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiRlwifV19LFwibGluZVwiOjEwODV9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifX1dLFwidHlwZVwiOntcImtcIjowfX19XSxcInR5cGVcIjp7XCJrXCI6MTJ9LFwibGluZVwiOjEwODh9XX0sXCIjZmxpcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiS2V5ZWQuZmxpcFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiS2V5ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifV19LFwibGluZVwiOjEwOTN9XX19fSx7XCJ0aXRsZVwiOlwiQ29udmVyc2lvbnNcIixcIm1lbWJlcnNcIjp7XCIjdG9KU1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJEZWVwbHkgY29udmVydHMgdGhpcyBLZXllZFNlcXVlbmNlIHRvIGVxdWl2YWxlbnQgbmF0aXZlIEphdmFTY3JpcHQgT2JqZWN0LlwiLFwiZGVzY3JpcHRpb25cIjpcIkNvbnZlcnRzIGtleXMgdG8gU3RyaW5ncy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiT2JqZWN0XCJ9LFwibGluZVwiOjExMDJ9XX0sXCIjdG9KU09OXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIEtleWVkU2VxdWVuY2UgdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdCBPYmplY3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiQ29udmVydHMga2V5cyB0byBTdHJpbmdzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6NixcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo1fX1dLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9fV19LFwibGluZVwiOjExMDl9XX0sXCIjdG9Db25jcmV0ZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgYE1hcGAgb2YgdGhlIGVudHJpZXMgZnJvbSB0aGlzIHNlcXVlbmNlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJNYXBcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjoxMTE0fV19LFwiI3RvU2VxXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgaXRzZWxmXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMn0sXCJsaW5lXCI6MTExOX1dfX19XX19LFwiU2V0U2VxdWVuY2VcIjp7XCJjbGFzc1wiOntcImlzQ2xhc3NcIjp0cnVlLFwiY29uc3RydWN0b3JcIjp7XCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiU2V0U2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoxMTI1fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjoxfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIlNldFNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjowfV19LFwibGluZVwiOjExMjZ9LHtcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIlNldFNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTEyN31dfSxcInN0YXRpY3NcIjp7XCJvZlwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDcmVhdGVzIGEgbmV3IFNldFNlcXVlbmNlIGNvbnRhaW5pbmcgYHZhbHVlc2AuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVzXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiU2V0U2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoxMTMyfV19fSxcImxpbmVcIjoxMTUxLFwiZG9jXCI6e1wic3lub3BzaXNcIjpcIkEgU2V0U2VxdWVuY2UgaXMgYSBgRHVwbGljYXRlZGAgYFNlcXVlbmNlYC4gSXQgcmVwcmVzZW50cyBzZXF1bnRpYWxcXG50cmFuc2Zvcm1hdGlvbnMgb24gU2V0LWxpa2UgZGF0YSBhcyBhIHNlcmllcyBvZiBjaGFpbmVkIGZ1bmN0aW9uIGNhbGxzLlxcbk5vdGUgdGhhdCBhIFNldFNlcXVlbmNlIGlzIGFsbG93ZWQgdG8gY29udGFpbiBkdXBsaWNhdGUgdmFsdWVzLiBTdWNoXFxuZHVwbGljYXRlcyB3aWxsIGJlIGVsaW1pbmF0ZWQgd2hlbiB1c2luZyBgYXMoU2V0KWAgb3IgYSBzaW1pbGFyIG1ldGhvZCB0b1xcbmNvbnZlcnQgYmFjayB0byBhIGNvbmNyZXRlIHR5cGUgYWZ0ZXIgdGhlIGRlc2lyZWQgdHJhbnNmb3JtYXRpb25zIGFyZVxcbm1hZGUuXCIsXCJkZXNjcmlwdGlvblwiOlwiV2hlbiBjb25zdHJ1Y3RpbmcgYSBTZXRTZXF1ZW5jZSBmcm9tIGFub3RoZXIgZGF0YSB0eXBlLCBhbnkgYXNzb2NpYXRlZFxcbmluZGljZXMgb3Iga2V5cyBhcmUgZGlzY2FyZWRlZC5cIixcIm5vdGVzXCI6W119LFwidHlwZVBhcmFtc1wiOltcIlRcIl0sXCJleHRlbmRzXCI6W3tcImtcIjoxMSxcIm5hbWVcIjpcIlNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX1dLFwiaW1wbGVtZW50c1wiOlt7XCJrXCI6MTEsXCJuYW1lXCI6XCJEdXBsaWNhdGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX1dLFwiZ3JvdXBzXCI6W3tcIm1lbWJlcnNcIjp7XCIjY29uY2F0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU2V0U2VxdWVuY2Ugd2l0aCBvdGhlciBjb2xsZWN0aW9ucyBjb25jYXRlbmF0ZWQgdG8gdGhpcyBvbmUuXCIsXCJkZXNjcmlwdGlvblwiOlwiQWxsIGVudHJpZXMgd2lsbCBiZSBwcmVzZW50IGluIHRoZSByZXN1bHRpbmcgU2V0U2VxdWVuY2UsIGV2ZW4gaWYgdGhleVxcbmFyZSBkdXBsaWNhdGVzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJVXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjExLFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlVcIn1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJTZXRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVVwifV19XX0sXCJsaW5lXCI6MTE1OH1dfSxcIiNtYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBTZXRTZXF1ZW5jZSB3aXRoIHZhbHVlcyBwYXNzZWQgdGhyb3VnaCBhXFxuYG1hcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiYGBganNcXG5TZXRTZXF1ZW5jZShbIDEsIDIgXSkubWFwKHggPT4gMTAgKiB4KVxcbi8vIFNlcSB7IDEwLCAyMCB9XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn19XSxcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiTVwifX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJTZXRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjExNjl9XX0sXCIjdGFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkRvZXMgbm90IGFsdGVyIHRoZSBzZXF1ZW5jZSwgYnV0IGFsbG93cyB5b3UgdG8gaW5zcGVjdCB2YWx1ZXMgYXMgdGhleSBhcmVcXG5jb21wdHVlZC4gUmV0dXJucyB0aGUgc2VxdWVuY2UgZm9yIGNoYWluaW5nLiBVbmxpa2UgYGZvckVhY2hgLCB0YXAgZG9lcyBub3RcXG5ldmFsdWF0ZSB0aGUgc2VxdWVuY2UuXCIsXCJkZXNjcmlwdGlvblwiOlwiYGBganNcXG5jb25zdCBzZXEgPSBTZXRTZXF1ZW5jZShbIDEsIDIgXSkudGFwKHggPT4gY29uc29sZS5sb2coeCkpXFxuQXJyYXkuZnJvbShzZXEpOyAvLyBsb2dzIDEsIDJcXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiZm5cIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifX1dLFwidHlwZVwiOntcImtcIjowfX19XSxcInR5cGVcIjp7XCJrXCI6MTJ9LFwibGluZVwiOjExODF9XX0sXCIjZmxhdHRlblwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiQ29sbGVjdGlvbi5mbGF0dGVuXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJkZXB0aFwiLFwidHlwZVwiOntcImtcIjo0fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIlNldFNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjowfV19LFwibGluZVwiOjExODZ9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzaGFsbG93XCIsXCJ0eXBlXCI6e1wia1wiOjN9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiU2V0U2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjB9XX0sXCJsaW5lXCI6MTE4N31dfSxcIiNmbGF0TWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkZsYXQtbWFwcyB0aGUgU2V0U2VxdWVuY2UsIHJldHVybmluZyBhIFNldFNlcXVlbmNlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlNpbWlsYXIgdG8gYHNlcS5tYXAoLi4uKS5mbGF0dGVuKHRydWUpYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJNXCJ9XX19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiU2V0U2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjoxMTk0fV19LFwiI2ZpbHRlclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFNldFNlcXVlbmNlIHdpdGggb25seSB0aGUgdmFsdWVzIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWBcXG5mdW5jdGlvbiByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn19XSxcInR5cGVcIjp7XCJrXCI6M319fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiU2V0U2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIkZcIn1dfSxcImxpbmVcIjoxMjAwfSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn19XSxcInR5cGVcIjp7XCJrXCI6MH19fV0sXCJ0eXBlXCI6e1wia1wiOjEyfSxcImxpbmVcIjoxMjAzfV19fX0se1widGl0bGVcIjpcIkNvbnZlcnNpb25cIixcIm1lbWJlcnNcIjp7XCIjdG9KU1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJEZWVwbHkgY29udmVydHMgdGhpcyBTZXRTZXF1ZW5jZSB0byBlcXVpdmFsZW50IG5hdGl2ZSBKYXZhU2NyaXB0IEFycmF5LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MH1dfSxcImxpbmVcIjoxMjA5fV19LFwiI3RvSlNPTlwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJTaGFsbG93bHkgY29udmVydHMgdGhpcyBTZXRTZXF1ZW5jZSB0byBlcXVpdmFsZW50IG5hdGl2ZSBKYXZhU2NyaXB0IEFycmF5LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjEyMTR9XX0sXCIjdG9Db25jcmV0ZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgYFNldGAgb2YgdGhlIHZhbHVlcyBmcm9tIHRoaXMgc2VxdWVuY2UuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjEyMTl9XX0sXCIjdG9TZXFcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBpdHNlbGZcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEyfSxcImxpbmVcIjoxMjI0fV19fX1dfX0sXCJTZXFcIjp7XCJjYWxsXCI6e1wic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiU1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzZXFcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiU1wifX1dLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJTXCJ9LFwibGluZVwiOjEyMjl9LHtcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJLZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiS2V5ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjEyMzB9LHtcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJbmRleGVkU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoxMjMxfSx7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiRHVwbGljYXRlZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiU2V0U2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoxMjMyfSx7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkluZGV4ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjEyMzN9LHtcInR5cGVQYXJhbXNcIjpbXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9ialwiLFwidHlwZVwiOntcImtcIjo2LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjV9fV0sXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn19XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJLZXllZFNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjo1fSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjEyMzR9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjF9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiSW5kZXhlZFNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjowfV19LFwibGluZVwiOjEyMzV9XX0sXCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiU2VxIGlzIGEgaGVscGVyIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBpbnN0YW5jZXMgb2YgYFNlcXVlbmNlYC4gR2l2ZW4gYW55IGFyZ3VtZW50LFxcblNlcSB3aWxsIG1ha2UgYSBiZXN0LWVmZm9ydCBndWVzcyBhcyB0byB0aGUgYXBwcm9wcmlhdGUgYFNlcXVlbmNlYCBzdWJ0eXBlLCBhbmRcXG53aWxsIHJldHVybiBhbiBpbnN0YW5jZSBvZiBpdC4gVGhlIGRlc2lyZWQgU2VxdWVuY2UgdHlwZSBjYW4gYmUgc2VsZWN0ZWQgYnkgdXNpbmdcXG5vbmUgb2YgdGhlIG5lc3RlZCBmdW5jdGlvbnM6IGBTZXEuSW5kZXhlZGAsIGBTZXEuS2V5ZWRgLCBvciBgU2VxLlNldGAuXCIsXCJkZXNjcmlwdGlvblwiOlwiU2VxJ3MgYmVzdC1lZmZvcnQgc2VsZWN0aW9uIG9mIHN1YnR5cGVzIHVzZXMgdGhlIGZvbGxvd2luZyBsb2dpYzpcXG5cXG4gICogSWYgYSBgQ29sbGVjdGlvbmAgYSBgU2VxdWVuY2VgIG9mIHRoZSBzYW1lIHN1YnR5cGUgYXMgdGhlIGNvbGxlY3Rpb25cXG4gICogSWYgYW4gQXJyYXktbGlrZSBvciBJdGVyYWJsZSwgYW4gYEluZGV4ZWRTZXF1ZW5jZWAuXFxuICAqIElmIGFuIE9iamVjdCwgYSBgS2V5ZWRTZXF1ZW5jZWAuXFxuXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJjb25zdHJ1Y3RzXCIsXCJib2R5XCI6XCJcIn1dfSxcIm1vZHVsZVwiOntcImlzU2VxXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGBtYXliZVNlcWAgaXMgYSBTZXF1ZW5jZSwgaXQgaXMgbm90IGJhY2tlZCBieSBhIGNvbmNyZXRlXFxuc3RydWN0dXJlIHN1Y2ggYXMgTWFwLCBMaXN0LCBvciBTZXQuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlU2VxXCIsXCJ0eXBlXCI6e1wia1wiOjB9fV0sXCJ0eXBlXCI6e1wia1wiOjN9LFwibGluZVwiOjEyNTZ9XX19LFwiS2V5ZWRcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkZhY3RvcnkgZnVuY3Rpb24gZm9yIGNvbnZlbmllbnQgY29uc3RydWN0aW9uIG9mIGBLZXllZFNlcXVlbmNlYCBpbnN0YW5jZXNcXG5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcImNvbnN0cnVjdHNcIixcImJvZHlcIjpcIlwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE2LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfV19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiS2V5ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjEyNjh9LHtcInR5cGVQYXJhbXNcIjpbXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9ialwiLFwidHlwZVwiOntcImtcIjo2LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjV9fV0sXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn19XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJLZXllZFNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjo1fSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjEyNzF9LHtcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCJdLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIktleWVkU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjoxMjcyfSx7XCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiS2V5ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MH0se1wia1wiOjB9XX0sXCJsaW5lXCI6MTI3M31dfX0sXCJJbmRleGVkXCI6e1wibW9kdWxlXCI6e1wib2ZcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlByb3ZpZGVzIGFuIEluZGV4ZWRTZXF1ZW5jZSBvZiB0aGUgdmFsdWVzIHByb3ZpZGVkLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlc1wiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkluZGV4ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjEyNzl9XX19fSxcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRmFjdG9yeSBmdW5jdGlvbiBmb3IgY29udmVuaWVudCBjb25zdHJ1Y3Rpb24gb2YgYEluZGV4ZWRTZXF1ZW5jZWAgaW5zdGFuY2VzXFxuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJjb25zdHJ1Y3RzXCIsXCJib2R5XCI6XCJcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkluZGV4ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MH1dfSxcImxpbmVcIjoxMjg3fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJbmRleGVkU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoxMjg4fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkluZGV4ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjEyODl9XX19LFwiU2V0XCI6e1wibW9kdWxlXCI6e1wib2ZcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBTZXRTZXF1ZW5jZSBvZiB0aGUgcHJvdmlkZWQgdmFsdWVzXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVzXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiU2V0U2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoxMjk1fV19fX0sXCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkZhY3RvcnkgZnVuY3Rpb24gZm9yIGNvbnZlbmllbnQgY29uc3RydWN0aW9uIG9mIGBTZXRTZXF1ZW5jZWAgaW5zdGFuY2VzXFxuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJjb25zdHJ1Y3RzXCIsXCJib2R5XCI6XCJcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIlNldFNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjowfV19LFwibGluZVwiOjEzMDN9LHtcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIlNldFNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTMwNH0se1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJTZXRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjEzMDV9XX19fX19fSx7XCJ0aXRsZVwiOlwiQWJzdHJhY3RcIixcIm1lbWJlcnNcIjp7XCJDb25jcmV0ZVwiOntcImludGVyZmFjZVwiOntcImxpbmVcIjoxMzIwLFwiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNvbmNyZXRlcyBhcmUgYSB0eXBlIG9mIGBDb2xsZWN0aW9uYCB3aGljaCBzdG9yZSB0aGVpciBvd24gZGF0YVxcbmFuZCBoYXZlIE8oMSkgcmFuZG9tIGFjY2Vzcy4gSXQgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGBMaXN0YCwgYE1hcGAsIGFuZFxcbmBTZXRgLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiXSxcImV4dGVuZHNcIjpbe1wia1wiOjExLFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19XSxcImdyb3Vwc1wiOlt7XCJ0aXRsZVwiOlwiUmVhZGluZyB2YWx1ZXNcIixcIm1lbWJlcnNcIjp7XCIjZ2V0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQga2V5LCBvciBub3RTZXRWYWx1ZSBpZlxcbnRoZSBDb2xsZWN0aW9uIGRvZXMgbm90IGNvbnRhaW4gdGhpcyBrZXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogaXQgaXMgcG9zc2libGUgYSBrZXkgbWF5IGJlIGFzc29jaWF0ZWQgd2l0aCBhbiBgdW5kZWZpbmVkYCB2YWx1ZSxcXG5zbyBpZiBgbm90U2V0VmFsdWVgIGlzIG5vdCBwcm92aWRlZCBhbmQgdGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYCxcXG50aGF0IGRvZXMgbm90IGd1YXJhbnRlZSB0aGUga2V5IHdhcyBub3QgZm91bmQuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk5TVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiTlNWXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIk5TVlwifV19LFwibGluZVwiOjEzMzF9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifX1dLFwidHlwZVwiOntcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjoxM31dfSxcImxpbmVcIjoxMzMyfV19LFwiI2hhc1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGEga2V5IGV4aXN0cyB3aXRoaW4gdGhpcyBgQ29sbGVjdGlvbmAuXFxudG8gZGV0ZXJtaW5lIGVxdWFsaXR5XCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjN9LFwibGluZVwiOjEzMzh9XX0sXCIjaW5jbHVkZXNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBhIHZhbHVlIGV4aXN0cyB3aXRoaW4gdGhpcyBgQ29sbGVjdGlvbmAuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJhbGlhc1wiLFwiYm9keVwiOlwiY29udGFpbnNcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6M30sXCJsaW5lXCI6MTM0NH1dfSxcIiNmaXJzdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJJbiBjYXNlIHRoZSBgQ29sbGVjdGlvbmAgaXMgbm90IGVtcHR5IHJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlXFxuYENvbGxlY3Rpb25gLlxcbkluIGNhc2UgdGhlIGBDb2xsZWN0aW9uYCBpcyBlbXB0eSByZXR1cm5zIHRoZSBvcHRpb25hbCBkZWZhdWx0XFxudmFsdWUgaWYgcHJvdmlkZWQsIGlmIG5vIGRlZmF1bHQgdmFsdWUgaXMgcHJvdmlkZWQgcmV0dXJucyB1bmRlZmluZWQuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk5TVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJOU1ZcIn0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiTlNWXCJ9XX0sXCJsaW5lXCI6MTM1M31dfX19LHtcInRpdGxlXCI6XCJSZWR1Y2luZyBhIHZhbHVlXCIsXCJtZW1iZXJzXCI6e1wiI2lzRW1wdHlcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyB0cnVlIGlmIHRoaXMgQ29sbGVjdGlvbiBpbmNsdWRlcyBubyB2YWx1ZXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiRm9yIHNvbWUgbGF6eSBgU2VxYCwgYGlzRW1wdHlgIG1pZ2h0IG5lZWQgdG8gaXRlcmF0ZSB0byBkZXRlcm1pbmVcXG5lbXB0aW5lc3MuIEF0IG1vc3Qgb25lIGl0ZXJhdGlvbiB3aWxsIG9jY3VyLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6M30sXCJsaW5lXCI6MTM2M31dfX19XX19LFwiU2VxdWVuY2VcIjp7XCJpbnRlcmZhY2VcIjp7XCJsaW5lXCI6MTQxNixcImRvY1wiOntcInN5bm9wc2lzXCI6XCJTZXF1ZW5jZSBpcyB0aGUgYWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgZGVzY3JpYmluZyBlZmZpY2llbnQsIGxhenlcXG50cmFuc2Zvcm1hdGlvbnMuIFNlcXVlbmNlcyBuZXZlciBzdG9yZSB0aGVpciBvd24gZGF0YSwgaW5zdGVhZCB0aGV5XFxuZGVzY3JpYmUgaG93IHRvIGNvbXB1dGUgdmFsdWVzIChvciBrZXlzKSB1c2luZyBhIHNlcmllcyBvZiB0cmFuc2Zvcm1zIGFnYWluc3RcXG5zb21lIHNvdXJjZSBkYXRhLiBTZXF1ZW5jZXMgYXJlIGltbXV0YWJsZSB3aXRoIHJlZ2FyZHMgdG8gd2hpY2ggdHJhbnNmb3Jtc1xcbnRoZXkgYXBwbHksIGJ1dCBhcyB0aGVpciBzb3VyY2UgZGF0YSBpcyBtdXRhYmxlIGFwcGx5aW5nIHRoZSBzZXF1ZW5jZVxcbnRyYW5zZm9ybWF0aW9ucyBtb3JlIHRoYW4gb25jZSBtYXkgeWllbGQgZGlmZmVyZW50IHJlc3VsdHMgaWYgdGhlIHNvdXJjZSBkYXRhXFxuaGFzIGNoYW5nZWQuIFNlcXVlbmNlIHN1YnR5cGVzIGFyZSBgSW5kZXhlZFNlcXVlbmNlYCwgYEtleWVkU2VxdWVuY2VgLFxcbmFuZCBgU2V0U2VxdWVuY2VgLlwiLFwiZGVzY3JpcHRpb25cIjpcIldoeSBhcmUgU2VxdWVuY2VzIGVmZmljaWVudD8gQm90aCBhIHNlcXVlbmNlIGFuZCBhIGNvbmNyZXRlXFxuc3RydWN0dXJlIG1heSBiZSB0cmFuc2Zvcm1lZCB0aHJvdWdoIGNoYW5pbmVkIG9wZXJhdGlvbnMgbGlrZVxcbmBudW1zLmZpbHRlcih4ID0+IHggPiAwKS5tYXAoeCA9PiB4ICsgMSlgLiBUaGUgZGlmZmVyZW5jZSBpcyBpbiBob3cgdGhleVxcbmV4ZWN1dGUuIEEgY29uY3JldGUgc3RydWN0dXJlIHdpbGwgZG8gYWxsIHRoZSBtYXBwaW5nIChhbmQgc3RvcmUgaXQpIGFuZFxcbnRoZW4gZG8gYWxsIHRoZSBmaWx0ZXJpbmcgb24gdGhlIG1hcHBlZCByZXN1bHRzLiBBIHNlcXVlbmNlIGV4ZWN1dGVzIHZhbHVlXFxuYnkgdmFsdWUgbm90IHRyYW5zZm9ybSBieSB0cmFuc2Zvcm0uIFRoZSBmaWx0ZXIgZnVuY3Rpb24gd2lsbCByZWFkIG51bWJlcnNcXG51bnRpbCBpdCBmaW5kcyBvbmUgZ3JlYXRlciB0aGFuIDAgdGhlbiB0aGUgbWFwcGVyIGZ1bmN0aW9uIHdpbGxcXG5hZGQgb25lIHRvIGl0LiBPbmx5IHRoZW4gd2lsbCBhIHNlY29uZCB2YWx1ZSBiZSByZWFkLlxcblxcblRoaXMgbWV0aG9kIG9mIHdvcmtpbmcgZ2l2ZXMgc2VxdWVuY2VzIHRoZWlyIGxhemluZXNzLCBiZWNhdXNlIFNlcXVlbmNlXFxudmFsdWVzIGFyZSBjb25zdW1lZCBhbmQgb3BlcmF0b3JzIGFwcGxpZWQgdG8gdGhlbSBvbmx5IG9uIGRlbWFuZC4gVmFsdWVzXFxuZ2VuZXJhdGVkIGJ5IGEgc2VxdWVuY2UgYXJlIG5vdCBpbXBsaWNpdGx5IGNhY2hlZCBvciBzdG9yZWQuIFRoaXMgbWVhbnNcXG50aGF0IFNlcXVlbmNlcyBjYW4gZXZlbiBoYXZlIGluZmludGVseSBtYW55IGl0ZW1zLiBUYWtlIGZvciBleGFtcGxlIHRoaXMgd2F5XFxub2YgZXhwcmVzc2luZyB0aGUgY29uY2VwdCBvZiBcXFwidGhlIGZpcnN0IG4gbmF0dXJhbCBudW1iZXJzOlxcXCJcXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBSYW5nZSB9ID0gcmVxdWlyZSgnc2VxdWlucycpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuZnVuY3Rpb24gbmF0dXJhbHMobikge1xcbiAgcmV0dXJuIFJhbmdlKDEsIEluZmluaXR5KS5zbGljZSgwLCBuKS5hcyhBcnJheSlcXG59XFxubmF0dXJhbHMoMyk7IC8vIFsxLCAyLCAzXVxcbmBgYFxcbldlIG1vdmUgc21vb3RobHkgcGFzdCBvdXIgaW5hYmlsaXR5IHRvIHN0b3JlIGEgbGlzdCBvZiBpbmZpbml0ZSBzaXplLFxcbmJlY2F1c2Ugc2xpY2Ugd2lsbCBvbmx5IGV2ZXIgcmVxdWVzdCB0aHJlZSB2YWx1ZXMgZnJvbSBSYW5nZS5cXG5cXG5CZWNhdXNlIHNldXFlbmNlcyBuZWVkIG5vdCBjYWNoZSBpbnRlcm1lZGlhdGUgc3RhdGVzLCB0aGV5IHNoaW5lIHdoZW5cXG53b3JraW5nIHdpdGggbXVsdGlwbGUgdHJhbnNmb3JtcyBvbiBsaXN0cyB3aGljaCBtYXkgbm90IGJlIGluZmluaXRlIGJ1dFxcbmFyZSBzaW1wbHkgdmVyeSBsYXJnZS4gSW4gcHJhY3RpY2FsIHRlcm1zIHRoZXkgYWxsb3cgdGhlIHByb2dyYW1tZXIgdG9cXG5yZWR1Y2UgbWVtb3J5IHVzYWdlIGF0IHRoZSBjb3N0IG9mIENQVSBjeWNsZXMuXFxuXFxuRmluYWxseSwgU2VxdWVuY2UgaXMgb2Z0ZW4gdXNlZCB0byBwcm92aWRlIGEgcmljaCBjb2xsZWN0aW9uIEFQSSB0byBKYXZhU2NyaXB0XFxuT2JqZWN0LlxcblxcbmBgYGpzXFxuU2VxKHsgeDogMCwgeTogMSwgejogMiB9KS5tYXAodiA9PiB2ICogMikuYXMoT2JqZWN0KTtcXG4vLyB7IHg6IDAsIHk6IDIsIHo6IDQgfVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiXSxcImV4dGVuZHNcIjpbe1wia1wiOjExLFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19XSxcImdyb3Vwc1wiOlt7XCJ0aXRsZVwiOlwiU2VxdWVuY2UgYWxnb3JpdGhtc1wiLFwibWVtYmVyc1wiOntcIiNtYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBTZXF1ZW5jZSB3aXRoIHZhbHVlcyBwYXNzZWQgdGhyb3VnaCBhXFxuYG1hcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgU2VxIH0gPSByZXF1aXJlKCdzZXF1aW5zJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5TZXEoWyAxLCAyIF0pLm1hcCh4ID0+IDEwICogeClcXG4vLyBTZXEgWyAxMCwgMjAgXVxcbmBgYFxcblxcbk5vdGU6IHVzZWQgb25seSBmb3Igc2V0cy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifX1dLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJNXCJ9fX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIlNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6MTQzMX0se1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn19XSxcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiTVwifX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiTVwifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjE0NDd9XX0sXCIjZmxhdE1hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJGbGF0LW1hcHMgdGhlIFNlcXVlbmNlLCByZXR1cm5pbmcgYSBTZXF1ZW5jZSBvZiB0aGUgc2FtZSB0eXBlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlNpbWlsYXIgdG8gYHNlcS5tYXAoLi4uKS5mbGF0dGVuKHRydWUpYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJNXCJ9XX19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjoxNDU0fSx7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJNXCJ9XX19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIk1cIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjoxNDU1fV19LFwiI2ZpbHRlclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFNlcXVlbmNlIHdpdGggb25seSB0aGUgdmFsdWVzIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWBcXG5mdW5jdGlvbiByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn19XSxcInR5cGVcIjp7XCJrXCI6M319fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIkZcIn1dfSxcImxpbmVcIjoxNDYxfSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn19XSxcInR5cGVcIjp7XCJrXCI6MH19fV0sXCJ0eXBlXCI6e1wia1wiOjEyfSxcImxpbmVcIjoxNDY0fV19fX1dfX0sXCJDb2xsZWN0aW9uXCI6e1wiaW50ZXJmYWNlXCI6e1wibGluZVwiOjE0NzcsXCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQ29sbGVjdGlvbiBpcyB0aGUgYmFzZSB0eXBlIGZvciBhbGwgU2VxdWlucyBzdHJ1Y3R1cmVzLiBUaGVyZSBhcmUgdHdvXFxuZnVuZGFtZW50YWwgQ29sbGVjdGlvbiB0eXBlczogQ29uY3JldGUgYW5kIFNlcXVlbmNlLiBUaGUgZGlzdGluY3Rpb24gaXMgdGhhdFxcbmEgYENvbmNyZXRlYCBzdG9yZXMgaXRzIGRhdGEsIHdoaWxlIGEgYFNlcXVlbmNlYCBjb21wdXRlcyBpdC5cXG5GdXJ0aGVybW9yZSwgYWxsIENvbGxlY3Rpb25zIGhhdmUga2V5cyBhbmQgdmFsdWVzIG9mIHNvbWUga2luZC4gVmFsdWVzIGFyZVxcbnNpbWlsYXIgZXZlcnl3aGVyZSwgYnV0IHRoZSBuYXR1cmUgb2Yga2V5cyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBDb2xsZWN0aW9uJ3NcXG5zdWJ0eXBlLiBLZXkgbWF5IGJlIGV4cGxpY2l0bHkgZGVjbGFyZWQgKCBgS2V5ZWRgIHN1YnR5cGUpLCB0aGUgaW5kZXggb2YgdGhlXFxuaXRlbSBpbiB0aGUgY29sbGVjdGlvbiAoIGBJbmRleGVkYCBzdWJ0eXBlKSwgb3IganVzdCB0aGUgdmFsdWUgYWdhaW4gYXMgYVxcbnBsYWNlaG9sZGVyICggYER1cGxpY2F0ZWRgIHN1YnR5cGUpLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiXSxcImdyb3Vwc1wiOlt7XCJ0aXRsZVwiOlwiU2VxdWVuY2UgYWxnb3JpdGhtc1wiLFwibWVtYmVyc1wiOntcIiNtYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgd2l0aCB2YWx1ZXMgcGFzc2VkIHRocm91Z2ggYVxcbmBtYXBwZXJgIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IENvbGxlY3Rpb24gfSA9IHJlcXVpcmUoJ3NlcXVpbnMnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbkNvbGxlY3Rpb24oeyBhOiAxLCBiOiAyIH0pLm1hcCh4ID0+IDEwICogeClcXG4vLyBTZXF1ZW5jZSB7IFxcXCJhXFxcIjogMTAsIFxcXCJiXFxcIjogMjAgfVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo5LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEyfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJNXCJ9fX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjoxNDkyfV19LFwiI2ZpbHRlclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZSB3aXRoIG9ubHkgdGhlIGVudHJpZXMgZm9yIHdoaWNoXFxudGhlIGBwcmVkaWNhdGVgIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ3NlcXVpbnMnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbm5ldyBNYXAoeyBhOiAxLCBiOiAyLCBjOiAzLCBkOiA0fSkuZmlsdGVyKHggPT4geCAlIDIgPT09IDApXFxuLy8gTWFwIHsgXFxcImJcXFwiOiAyLCBcXFwiZFxcXCI6IDQgfVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJGXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo5LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEyfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjozfX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJGXCJ9XX0sXCJsaW5lXCI6MTUxNH0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo5LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEyfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjowfX19XSxcInR5cGVcIjp7XCJrXCI6MTJ9LFwibGluZVwiOjE1MTd9XX0sXCIjZmlsdGVyTm90XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIHdpdGggb25seSB0aGUgZW50cmllcyBmb3Igd2hpY2hcXG50aGUgYHByZWRpY2F0ZWAgZnVuY3Rpb24gcmV0dXJucyBmYWxzZS5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ3NlcXVpbnMnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbm5ldyBNYXAoeyBhOiAxLCBiOiAyLCBjOiAzLCBkOiA0fSkuZmlsdGVyTm90KHggPT4geCAlIDIgPT09IDApXFxuLy8gTWFwIHsgXFxcImFcXFwiOiAxLCBcXFwiY1xcXCI6IDMgfVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMn0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6M319fV0sXCJ0eXBlXCI6e1wia1wiOjEyfSxcImxpbmVcIjoxNTMxfV19LFwiI3JldmVyc2VcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV2ZXJzZXMgdGhlIG9yZGVyIG9mIGVsZW1lbnRzIGluIHRoZSBjb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTJ9LFwibGluZVwiOjE1MzZ9XX0sXCIjc29ydFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJTdGFibHkgc29ydHMgdGhlIGVsZW1lbnRzIG9mIHRoZSBjb2xsZWN0aW9uIGJ5IHVzaW5nIGEgYGNvbXBhcmF0b3JgLlwiLFwiZGVzY3JpcHRpb25cIjpcIklmIGEgYGNvbXBhcmF0b3JgIGlzIG5vdCBwcm92aWRlZCwgYSBkZWZhdWx0IGNvbXBhcmF0b3IgdXNlcyBgPGAgYW5kIGA+YC5cXG5cXG5gY29tcGFyYXRvcih2YWx1ZUEsIHZhbHVlQilgOlxcblxcbiAgKiBSZXR1cm5zIGAwYCBpZiB0aGUgZWxlbWVudHMgc2hvdWxkIG5vdCBiZSBzd2FwcGVkLlxcbiAgKiBSZXR1cm5zIGAtMWAgKG9yIGFueSBuZWdhdGl2ZSBudW1iZXIpIGlmIGB2YWx1ZUFgIGNvbWVzIGJlZm9yZSBgdmFsdWVCYFxcbiAgKiBSZXR1cm5zIGAxYCAob3IgYW55IHBvc2l0aXZlIG51bWJlcikgaWYgYHZhbHVlQWAgY29tZXMgYWZ0ZXIgYHZhbHVlQmBcXG4gICogSXMgcHVyZSwgaS5lLiBpdCBtdXN0IGFsd2F5cyByZXR1cm4gdGhlIHNhbWUgdmFsdWUgZm9yIHRoZSBzYW1lIHBhaXJcXG4gICAgb2YgdmFsdWVzLlxcblxcbldoZW4gc29ydGluZyBjb2xsZWN0aW9ucyB3aGljaCBoYXZlIG5vIGRlZmluZWQgb3JkZXIsIHRoZWlyIG9yZGVyZWRcXG5lcXVpdmFsZW50cyB3aWxsIGJlIHJldHVybmVkLiBlLmcuIGBtYXAuc29ydCgpYCByZXR1cm5zIE9yZGVyZWRNYXAuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdzZXF1aW5zJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5uZXcgTWFwKHsgXFxcImNcXFwiOiAzLCBcXFwiYVxcXCI6IDEsIFxcXCJiXFxcIjogMiB9KS5zb3J0KChhLCBiKSA9PiB7XFxuICBpZiAoYSA8IGIpIHsgcmV0dXJuIC0xOyB9XFxuICBpZiAoYSA+IGIpIHsgcmV0dXJuIDE7IH1cXG4gIGlmIChhID09PSBiKSB7IHJldHVybiAwOyB9XFxufSk7XFxuLy8gTWFwIHsgXFxcImFcXFwiOiAxLCBcXFwiYlxcXCI6IDIsIFxcXCJjXFxcIjogMyB9XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbXBhcmF0b3JcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZUFcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwidmFsdWVCXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6NH19LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEyfSxcImxpbmVcIjoxNTY2fV19LFwiI3NvcnRCeVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJMaWtlIGBzb3J0YCwgYnV0IGFsc28gYWNjZXB0cyBhIGBjb21wYXJhdG9yVmFsdWVNYXBwZXJgIHdoaWNoIGFsbG93cyBmb3JcXG5zb3J0aW5nIGJ5IG1vcmUgc29waGlzdGljYXRlZCBtZWFuczpcIixcImRlc2NyaXB0aW9uXCI6XCIgICAgaGl0dGVycy5zb3J0QnkoaGl0dGVyID0+IGhpdHRlci5hdmdIaXRzKVwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbXBhcmF0b3JWYWx1ZU1hcHBlclwiLFwidHlwZVwiOntcImtcIjo5LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEyfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJDXCJ9fX0se1wibmFtZVwiOlwiY29tcGFyYXRvclwiLFwidHlwZVwiOntcImtcIjo5LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlQVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZUJcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiQ1wifX1dLFwidHlwZVwiOntcImtcIjo0fX0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTJ9LFwibGluZVwiOjE1NzR9XX0sXCIjZ3JvdXBCeVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgYEtleWVkYCBvZiBgS2V5ZWRzYCwgZ3JvdXBlZCBieSB0aGUgcmV0dXJuXFxudmFsdWUgb2YgdGhlIGBncm91cGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBMaXN0LCBNYXAgfSA9IHJlcXVpcmUoJ3NlcXVpbnMnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmNvbnN0IGxpc3RPZk1hcHMgPSBuZXcgTGlzdChbXFxuICBuZXcgTWFwKHsgdjogMCB9KSxcXG4gIG5ldyBNYXAoeyB2OiAxIH0pLFxcbiAgbmV3IE1hcCh7IHY6IDEgfSksXFxuICBuZXcgTWFwKHsgdjogMCB9KSxcXG4gIG5ldyBNYXAoeyB2OiAyIH0pXFxuXSlcXG5jb25zdCBncm91cHNPZk1hcHMgPSBsaXN0T2ZNYXBzLmdyb3VwQnkoeCA9PiB4LmdldCgndicpKVxcbi8vIE1hcCB7XFxuLy8gICAwOiBMaXN0IFsgbmV3IE1hcHsgXFxcInZcXFwiOiAwIH0sIG5ldyBNYXAgeyBcXFwidlxcXCI6IDAgfSBdLFxcbi8vICAgMTogTGlzdCBbIG5ldyBNYXB7IFxcXCJ2XFxcIjogMSB9LCBuZXcgTWFwIHsgXFxcInZcXFwiOiAxIH0gXSxcXG4vLyAgIDI6IExpc3QgWyBuZXcgTWFweyBcXFwidlxcXCI6IDIgfSBdLFxcbi8vIH1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiR1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJncm91cGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTJ9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIkdcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiS2V5ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiR1wifSx7XCJrXCI6MTEsXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX1dfSxcImxpbmVcIjoxNjAyfV19fX0se1widGl0bGVcIjpcIlNpZGUgZWZmZWN0c1wiLFwibWVtYmVyc1wiOntcIiNmb3JFYWNoXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRoZSBgc2lkZUVmZmVjdGAgaXMgZXhlY3V0ZWQgZm9yIGV2ZXJ5IGVudHJ5IGluIHRoZSBDb2xsZWN0aW9uLlxcbmBmb3JFYWNoYCBoYXMgbm8gcmV0dXJuIHZhbHVlIVwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzaWRlRWZmZWN0XCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTJ9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjB9fX1dLFwidHlwZVwiOntcImtcIjoyfSxcImxpbmVcIjoxNjEyfV19LFwiI2ZvclNvbWVcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVGhlIGBzaWRlRWZmZWN0YCBpcyBleGVjdXRlZCBmb3IgZW50cmllcyBpbiB0aGUgQ29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJJZiBhbnkgY2FsbCBvZiBgc2lkZUVmZmVjdGAgcmV0dXJuc1xcbmBmYWxzZWAsIHRoZSBpdGVyYXRpb24gd2lsbCBzdG9wLiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZW50cmllcyBpdGVyYXRlZFxcbihpbmNsdWRpbmcgdGhlIGxhc3QgaXRlcmF0aW9uIHdoaWNoIHJldHVybmVkIGZhbHNlKS5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic2lkZUVmZmVjdFwiLFwidHlwZVwiOntcImtcIjo5LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEyfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjowfX19XSxcInR5cGVcIjp7XCJrXCI6NH0sXCJsaW5lXCI6MTYyMX1dfX19LHtcInRpdGxlXCI6XCJDcmVhdGluZyBzdWJzZXRzXCIsXCJtZW1iZXJzXCI6e1wiI3NsaWNlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIHJlcHJlc2VudGluZyBhIHBvcnRpb24gb2YgdGhpc1xcbkNvbGxlY3Rpb24gZnJvbSBzdGFydCB1cCB0byBidXQgbm90IGluY2x1ZGluZyBlbmQuXCIsXCJkZXNjcmlwdGlvblwiOlwiSWYgYmVnaW4gaXMgbmVnYXRpdmUsIGl0IGlzIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIENvbGxlY3Rpb24uIGUuZy5cXG5gc2xpY2UoLTIpYCByZXR1cm5zIGEgQ29sbGVjdGlvbiBvZiB0aGUgbGFzdCB0d28gZW50cmllcy4gSWYgaXQgaXMgbm90XFxucHJvdmlkZWQgdGhlIG5ldyBDb2xsZWN0aW9uIHdpbGwgYmVnaW4gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGlzIENvbGxlY3Rpb24uXFxuXFxuSWYgZW5kIGlzIG5lZ2F0aXZlLCBpdCBpcyBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBDb2xsZWN0aW9uLiBlLmcuXFxuYHNsaWNlKDAsIC0xKWAgcmV0dXJucyBhIENvbGxlY3Rpb24gb2YgZXZlcnl0aGluZyBidXQgdGhlIGxhc3QgZW50cnkuIElmXFxuaXQgaXMgbm90IHByb3ZpZGVkLCB0aGUgbmV3IENvbGxlY3Rpb24gd2lsbCBjb250aW51ZSB0aHJvdWdoIHRoZSBlbmQgb2ZcXG50aGlzIENvbGxlY3Rpb24uXFxuXFxuSWYgdGhlIHJlcXVlc3RlZCBzbGljZSBpcyBlcXVpdmFsZW50IHRvIHRoZSBjdXJyZW50IENvbGxlY3Rpb24sIHRoZW4gaXRcXG53aWxsIHJldHVybiBpdHNlbGYuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImJlZ2luXCIsXCJ0eXBlXCI6e1wia1wiOjR9LFwib3B0aW9uYWxcIjp0cnVlfSx7XCJuYW1lXCI6XCJlbmRcIixcInR5cGVcIjp7XCJrXCI6NH0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTJ9LFwibGluZVwiOjE2NDF9XX19fSx7XCJ0aXRsZVwiOlwiQ29tYmluYXRpb25cIixcIm1lbWJlcnNcIjp7XCIjY29uY2F0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIHdpdGggb3RoZXIgdmFsdWVzIGFuZFxcbmNvbGxlY3Rpb24tbGlrZSBjb25jYXRlbmF0ZWQgdG8gdGhpcyBvbmUuXCIsXCJkZXNjcmlwdGlvblwiOlwiRm9yIFNlcXMsIGFsbCBlbnRyaWVzIHdpbGwgYmUgcHJlc2VudCBpbiB0aGUgcmVzdWx0aW5nIFNlcXVlbmNlLCBldmVuIGlmIHRoZXlcXG5oYXZlIHRoZSBzYW1lIGtleS5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVzT3JDb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjowfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjowfSx7XCJrXCI6MH1dfSxcImxpbmVcIjoxNjUyfV19LFwiI2ZsYXR0ZW5cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRmxhdHRlbnMgbmVzdGVkIENvbGxlY3Rpb25zLlwiLFwiZGVzY3JpcHRpb25cIjpcIldpbGwgZGVlcGx5IGZsYXR0ZW4gdGhlIENvbGxlY3Rpb24gYnkgZGVmYXVsdCwgcmV0dXJuaW5nIGEgQ29sbGVjdGlvbiBvZiB0aGVcXG5zYW1lIHR5cGUsIGJ1dCBhIGBkZXB0aGAgY2FuIGJlIHByb3ZpZGVkIGluIHRoZSBmb3JtIG9mIGEgbnVtYmVyIG9yXFxuYm9vbGVhbiAod2hlcmUgdHJ1ZSBtZWFucyB0byBzaGFsbG93bHkgZmxhdHRlbiBvbmUgbGV2ZWwpLiBBIGRlcHRoIG9mIDBcXG4ob3Igc2hhbGxvdzogZmFsc2UpIHdpbGwgZGVlcGx5IGZsYXR0ZW4uXFxuXFxuRmxhdHRlbnMgb25seSBvdGhlcnMgQ29sbGVjdGlvbiwgbm90IEFycmF5cyBvciBPYmplY3RzLlxcblxcbk5vdGU6IGBmbGF0dGVuKHRydWUpYCBvcGVyYXRlcyBvbiBDb2xsZWN0aW9uPGFueSwgQ29sbGVjdGlvbjxLLCBWPj4gYW5kXFxucmV0dXJucyBDb2xsZWN0aW9uPEssIFY+XCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImRlcHRoXCIsXCJ0eXBlXCI6e1wia1wiOjR9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MH0se1wia1wiOjB9XX0sXCJsaW5lXCI6MTY2N30se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInNoYWxsb3dcIixcInR5cGVcIjp7XCJrXCI6M30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjowfSx7XCJrXCI6MH1dfSxcImxpbmVcIjoxNjY4fV19LFwiI2ZsYXRNYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRmxhdC1tYXBzIHRoZSBDb2xsZWN0aW9uLCByZXR1cm5pbmcgYSBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUuXCIsXCJkZXNjcmlwdGlvblwiOlwiU2ltaWxhciB0byBgY29sbGVjdGlvbi5tYXAoLi4uKS5mbGF0dGVuKHRydWUpYC5cXG5Vc2VkIGZvciBEaWN0aW9uYXJpZXMgb25seS5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMn0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiTVwifV19fX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjoxNjc1fSx7XCJ0eXBlUGFyYW1zXCI6W1wiS01cIixcIlZNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo5LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEyfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNixcInR5cGVzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJLTVwifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVk1cIn1dfV19fX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWTVwifV19LFwibGluZVwiOjE2ODV9XX19fSx7XCJ0aXRsZVwiOlwiUmVkdWNpbmcgYSB2YWx1ZVwiLFwibWVtYmVyc1wiOntcIiNyZWR1Y2VcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmVkdWNlcyB0aGUgQ29sbGVjdGlvbiB0byBhIHZhbHVlIGJ5IGNhbGxpbmcgdGhlIGByZWR1Y2VyYCBmb3IgZXZlcnkgZW50cnlcXG5pbiB0aGUgQ29sbGVjdGlvbiBhbmQgcGFzc2luZyBhbG9uZyB0aGUgcmVkdWNlZCB2YWx1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJJZiBgaW5pdGlhbFJlZHVjdGlvbmAgaXMgbm90IHByb3ZpZGVkLCB0aGUgZmlyc3QgaXRlbSBpbiB0aGVcXG5Db2xsZWN0aW9uIHdpbGwgYmUgdXNlZC5cXG5cIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiYEFycmF5I3JlZHVjZWAuXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJSXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInJlZHVjZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJyZWR1Y3Rpb25cIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiUlwifX0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTJ9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlJcIn19fSx7XCJuYW1lXCI6XCJpbml0aWFsUmVkdWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlJcIn19XSxcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiUlwifSxcImxpbmVcIjoxNzAwfSx7XCJ0eXBlUGFyYW1zXCI6W1wiUlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJyZWR1Y2VyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicmVkdWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlJcIn1dfX0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTJ9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlJcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlJcIn0sXCJsaW5lXCI6MTcwNH1dfSxcIiNldmVyeVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1ZSBmb3IgYWxsIGVudHJpZXMgaW4gdGhlIENvbGxlY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo5LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEyfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjozfX19XSxcInR5cGVcIjp7XCJrXCI6M30sXCJsaW5lXCI6MTcwOX1dfSxcIiNzb21lXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnVlIGZvciBhbnkgZW50cnkgaW4gdGhlIENvbGxlY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo5LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEyfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjozfX19XSxcInR5cGVcIjp7XCJrXCI6M30sXCJsaW5lXCI6MTcxNH1dfSxcIiNjb3VudFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSBzaXplIG9mIHRoaXMgQ29sbGVjdGlvbiBieSBpdGVyYXRpbmcgdGhyb3VnaCBpdC5cIixcImRlc2NyaXB0aW9uXCI6XCJJZiBhIGBwcmVkaWNhdGVgIGlzIHByb3ZpZGVkLCByZXR1cm5zIHRoZSBjb3VudCBvZiBlbnRyaWVzIGluIHRoZVxcblNlcXVlbmNlIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnVlLlxcblxcbk5PVEU6IEZvciBjb25jcmV0ZSBjb2xsZWN0aW9ucywgdGhpcyByZXR1cm5zIHNpemUgd2hlbiBubyBhcmdzXFxuYXJlIHBhc3NlZC4gRm9yIHNlcXVlbmNlcyBpdCBtdXN0IGFsd2F5cyBpdGVyYXRlIG92ZXIgdGhlIHdob2xlXFxuY29sbGVjdGlvbi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjR9LFwibGluZVwiOjE3MjZ9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMn0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6M319fV0sXCJ0eXBlXCI6e1wia1wiOjR9LFwibGluZVwiOjE3Mjd9XX19fSx7XCJ0aXRsZVwiOlwiU2VhcmNoIGZvciB2YWx1ZVwiLFwibWVtYmVyc1wiOntcIiNmaW5kXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdGhlIGZpcnN0IHZhbHVlIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMn0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6M319fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjEzfV19LFwibGluZVwiOjE3MzR9XX19fSx7XCJ0aXRsZVwiOlwiQ29udmVyc2lvbnNcIixcIm1lbWJlcnNcIjp7XCIjdG9cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQ29udmVydHMgdGhpcyBjb2xsZWN0aW9uIGludG8gdGhlIHR5cGUgb2YgY29sbGVjdGlvbiBzcGVjaWZpZWQgYXMgdGhlXFxuYENvbGxlY3Rpb25Db25zdHJ1Y3RvcmAgcGFyYW1ldGVyLiBJZiBubyBjb252ZXJzaW9uIGlzIG5lY2Nlc3NhcnksIHJldHVybnNcXG4gdGhlIG9yaWdpbmFsIGluc3RhbmNlLiBUaGUgZWFzaWVzdCB3YXkgdG8gZGVzY3JpYmUgdGhlIGZ1bmN0aW9uIGlzIHRvIHNob3dcXG5zb21lIGV4YW1wbGUgdXNhZ2VzOlwiLFwiZGVzY3JpcHRpb25cIjpcImBgYGpzXFxuaW1wb3J0IHtMaXN0LCBNYXAsIFNldCwgSW5kZXhlZFNlcXVlbmNlLCBLZXllZFNlcXVlbmNlLCBTZXRTZXF1ZW5jZSwgTmF0aXZlTWFwLCBOYXRpdmVTZXR9IGZyb20gJ3NlcXVpbnMnO1xcbmNvbnN0IGxpc3QgPSBuZXcgTGlzdChbMSwgMiwgM10pO1xcbmxpc3QudG8oTWFwKSAvLyBNYXB7MCA9PiAxLCAxID0+IDIsIDIgPT4gM31cXG5saXN0LnRvKFNldCkgLy8gU2V0ezEsIDIsIDN9XFxubGlzdC50byhMaXN0KSAvLyBsaXN0XFxubGlzdC50byhJbmRleGVkU2VxdWVuY2UpIC8vIG5ldyBJbmRleGVkU2VxdWVuY2UobGlzdClcXG5saXN0LnRvKEtleWVkU2VxdWVuY2UpIC8vIG5ldyBLZXllZFNlcXVlbmNlKGxpc3QpXFxubGlzdC50byhTZXRTZXF1ZW5jZSkgLy8gbmV3IFNldFNlcXVlbmNlKGxpc3QpXFxubGlzdC50byhOYXRpdmVNYXApIC8vIE5hdGl2ZU1hcHswID0+IDEsIDEgPT4gMiwgMiA9PiAzfVxcbmxpc3QudG8oTmF0aXZlTWFwKSBpbnN0YW5jZW9mIGdsb2JhbC5NYXAgLy8gdHJ1ZVxcbmxpc3QudG8oTmF0aXZlU2V0KSAvLyBOYXRpdmVTZXR7MSwgMiwgM31cXG5saXN0LnRvKE5hdGl2ZVNldCkgaW5zdGFuY2VvZiBnbG9iYWwuU2V0IC8vIHRydWVcXG5saXN0LnRvKEFycmF5KSAvLyBbMSwgMiwgM11cXG5saXN0LnRvKE9iamVjdCkgLy8geycwJzogMSwgJzEnOiAyLCAnMic6IDN9XFxuYGBgXFxuXFxuXFxuV2hpbGUgeW91IGNhbiBmaW5kIGRlZmluaXRpdmUgaW5mb3JtYXRpb24gaW4gdGhlIGNvbnN0cnVjdG9yIHJlZmVyZW5jZXMsXFxudGhlIGJhc2ljcyBhcmUgdGhhdCBrZXlzIHdpbGwgYmUgZGlzY2FyZGVkIHdoZW4gY29udmVydGluZyBmcm9tIGEgYEtleWVkYFxcbnRvIGFueXRoaW5nIG90aGVyIHRoYW4gYSBgS2V5ZWRgLiBXaGVuIGNvbnZlcnRpbmcgYW4gYEluZGV4ZWRgIHRvIGFcXG5gS2V5ZWRgLCB0aGUgaW5kZXhlcyB3aWxsIGJlY29tZSB0aGUga2V5cy4gV2hlbiBjb252ZXJ0aW5nIGEgYER1cGxpY2F0ZWRgXFxudG8gYSBrZXllZCwgdGhlIGtleXMgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgdmFsdWVzLlxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwicHJhZ21hXCIsXCJib2R5XCI6XCJzaG93RXhhbXBsZUFib3ZlVHlwZVwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiVHlwZVwiLFwidHlwZVwiOntcImtcIjo2LFwibWVtYmVyc1wiOlt7XCJjb25zdHJ1Y3RcIjp0cnVlLFwibmFtZVwiOlwibmV3XCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiSW5kZXhlZFNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjowfV19fV19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiSW5kZXhlZFNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6MTc3NH0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIlR5cGVcIixcInR5cGVcIjp7XCJrXCI6NixcIm1lbWJlcnNcIjpbe1wiY29uc3RydWN0XCI6dHJ1ZSxcIm5hbWVcIjpcIm5ld1wiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIktleWVkU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjowfV19fV19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiS2V5ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjE3NzV9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJUeXBlXCIsXCJ0eXBlXCI6e1wia1wiOjYsXCJtZW1iZXJzXCI6W3tcImNvbnN0cnVjdFwiOnRydWUsXCJuYW1lXCI6XCJuZXdcIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJTZXRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MH1dfX1dfX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIlNldFNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6MTc3Nn0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIlR5cGVcIixcInR5cGVcIjp7XCJrXCI6NixcIm1lbWJlcnNcIjpbe1wiY29uc3RydWN0XCI6dHJ1ZSxcIm5hbWVcIjpcIm5ld1wiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjB9XX19XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6MTc3N30se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIlR5cGVcIixcInR5cGVcIjp7XCJrXCI6NixcIm1lbWJlcnNcIjpbe1wiY29uc3RydWN0XCI6dHJ1ZSxcIm5hbWVcIjpcIm5ld1wiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIk1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6MH0se1wia1wiOjB9XX19XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJNYXBcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjoxNzc4fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiVHlwZVwiLFwidHlwZVwiOntcImtcIjo2LFwibWVtYmVyc1wiOlt7XCJjb25zdHJ1Y3RcIjp0cnVlLFwibmFtZVwiOlwibmV3XCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiU2V0XCIsXCJhcmdzXCI6W3tcImtcIjowfV19fV19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiU2V0XCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6MTc3OX0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIlR5cGVcIixcInR5cGVcIjp7XCJrXCI6NixcIm1lbWJlcnNcIjpbe1wiY29uc3RydWN0XCI6dHJ1ZSxcIm5hbWVcIjpcIm5ld1wiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIk5hdGl2ZU1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6MH0se1wia1wiOjB9XX19XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJOYXRpdmVNYXBcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjoxNzgwfSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiVHlwZVwiLFwidHlwZVwiOntcImtcIjo2LFwibWVtYmVyc1wiOlt7XCJjb25zdHJ1Y3RcIjp0cnVlLFwibmFtZVwiOlwibmV3XCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTmF0aXZlU2V0XCIsXCJhcmdzXCI6W3tcImtcIjowfV19fV19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTmF0aXZlU2V0XCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6MTc4MX0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIlR5cGVcIixcInR5cGVcIjp7XCJrXCI6NixcIm1lbWJlcnNcIjpbe1wiY29uc3RydWN0XCI6dHJ1ZSxcIm5hbWVcIjpcIm5ld1wiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjowfV19fV19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjoxNzgyfSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiVHlwZVwiLFwidHlwZVwiOntcImtcIjo2LFwibWVtYmVyc1wiOlt7XCJuYW1lXCI6XCJwcm90b3R5cGVcIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJPYmplY3RcIn19XX19XSxcInR5cGVcIjp7XCJrXCI6NixcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo1fX1dLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9fV19LFwibGluZVwiOjE3ODN9XX0sXCIjdG9Db25jcmV0ZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDb252ZXJ0cyB0aGlzIGNvbGxlY3Rpb24gdG8gYE1hcGAgaWYgaXQgaXMgYEtleWVkYCwgYExpc3RgIGlmIGl0IGlzXFxuYEluZGV4ZWRgLCBvciBgU2V0YCBpZiBpdCBpcyBgRHVwbGljYXRlZGAuXFxub3JcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQ29uY3JldGVcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjoxNzkwfV19LFwiI3RvU2VxXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNvbnZlcnRzIHRoaXMgQ29sbGVjdGlvbiB0byBhIFNlcXVlbmNlIG9mIHRoZSBzYW1lIGtpbmQgKGBJbmRleGVkYCxcXG5gS2V5ZWRgLCBvciBgRHVwbGljYXRlZGApLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjE3OTZ9XX0sXCIjdG9KU1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJEZWVwbHkgY29udmVydHMgdGhpcyBDb2xsZWN0aW9uIHRvIGVxdWl2YWxlbnQgbmF0aXZlIEphdmFTY3JpcHQgQXJyYXkgb3IgT2JqZWN0LlwiLFwiZGVzY3JpcHRpb25cIjpcImBJbmRleGVkYCwgYW5kIGBEdXBsaWNhdGVkYCBiZWNvbWUgYEFycmF5YCwgd2hpbGVcXG5gS2V5ZWRgIGJlY29tZXMgYE9iamVjdGAsIGNvbnZlcnRpbmcga2V5cyB0byBTdHJpbmdzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6MTEsXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MH1dfSx7XCJrXCI6NixcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo1fX1dLFwidHlwZVwiOntcImtcIjowfX1dfV19LFwibGluZVwiOjE4MDR9XX0sXCIjdG9KU09OXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIENvbGxlY3Rpb24gdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdCBBcnJheSBvciBPYmplY3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiYEluZGV4ZWRgLCBhbmQgYER1cGxpY2F0ZWRgIGJlY29tZSBgQXJyYXlgLCB3aGlsZVxcbmBLZXllZGAgYmVjb21lcyBgT2JqZWN0YCwgY29udmVydGluZyBrZXlzIHRvIFN0cmluZ3MuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjoxMSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX0se1wia1wiOjYsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6NX19XSxcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifX1dfV19LFwibGluZVwiOjE4MTJ9XX19fSx7XCJ0aXRsZVwiOlwiSXRlcmFibGVzXCIsXCJtZW1iZXJzXCI6e1wiI2tleXNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIGBTZXRTZXF1ZW5jZWAgb2YgdGhlIGNvbGxlY3Rpb24ncyBrZXlzLCB3aGljaCBpcyBhbHNvIHN1aXRhYmxlIGZvclxcbnVzZSBhcyBhbiBlczYgaXRlcmFibGUgb3ZlciB0aGUgY29sbGVjdGlvbidzIGtleXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIlNldFNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9XX0sXCJsaW5lXCI6MTgyMH1dfSxcIiN2YWx1ZXNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIGBTZXRTZXF1ZW5jZWAgb2YgdGhlIGNvbGxlY3Rpb24ncyB2YWx1ZXMsIHdoaWNoIGlzIGFsc28gc3VpdGFibGVcXG5mb3IgdXNlIGFzIGFuIGVzNiBpdGVyYWJsZSBvdmVyIHRoZSBjb2xsZWN0aW9uJ3MgdmFsdWVzLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJTZXRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjE4MjZ9XX0sXCIjZW50cmllc1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgYEtleWVkU2VxdWVuY2VgIG9mIHRoZSBjb2xsZWN0aW9uJ3MgZW50cmllcywgd2hpY2ggaXMgYWxzbyBzdWl0YWJsZVxcbmZvciB1c2UgYXMgYW4gZXM2IGl0ZXJhYmxlIG92ZXIgdGhlIGNvbGxlY3Rpb24ncyBgW2tleSwgdmFsdWVdYCBlbnRyeSB0dXBsZXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIktleWVkU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjoxODMyfV19fX1dLFwiY29uc3RydWN0b3JcIjp7XCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJbmRleGVkU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjB9XX0sXCJsaW5lXCI6MTc3NH0se1widHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIktleWVkU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjowfV19LFwibGluZVwiOjE3NzV9LHtcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJTZXRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MH1dfSxcImxpbmVcIjoxNzc2fSx7XCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6MH1dfSxcImxpbmVcIjoxNzc3fSx7XCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTWFwXCIsXCJhcmdzXCI6W3tcImtcIjowfSx7XCJrXCI6MH1dfSxcImxpbmVcIjoxNzc4fSx7XCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiU2V0XCIsXCJhcmdzXCI6W3tcImtcIjowfV19LFwibGluZVwiOjE3Nzl9LHtcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJOYXRpdmVNYXBcIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjowfV19LFwibGluZVwiOjE3ODB9LHtcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJOYXRpdmVTZXRcIixcImFyZ3NcIjpbe1wia1wiOjB9XX0sXCJsaW5lXCI6MTc4MX0se1widHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjowfV19LFwibGluZVwiOjE3ODJ9XX19fX19LHtcInRpdGxlXCI6XCJTdWJ0eXBlc1wiLFwibWVtYmVyc1wiOntcIktleWVkXCI6e1wiaW50ZXJmYWNlXCI6e1wibGluZVwiOjE4NDQsXCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiS2V5ZWQgaXMgdXNlZCB0byBkZXNjcmliZSBDb2xsZWN0aW9ucyB3aGljaCBoYXZlIGV4cGxpY2l0IGtleXMgYW5kIHZhbHVlcy5cXG5DYWxsYmFja3MgZm9yIG1ldGhvZHMgaW4gY2xhc3NlcyBpbXBsZW1lbnRpbmcgS2V5ZWQgd2lsbCByZWNlaXZlXFxuYCh2YWx1ZSwga2V5KWAgYXMgdGhpZXIgZmlyc3QgdHdvIGFyZ3VtZW50cy5cIixcImRlc2NyaXB0aW9uXCI6XCJJdGVyYXRpbmcgb3ZlciBhIGBLZXllZGAsIHlpZWxkcyBgW0ssIFZdYCB0dXBsZXMuXCIsXCJub3Rlc1wiOltdfSxcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCJdLFwiZXh0ZW5kc1wiOlt7XCJrXCI6MTEsXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX1dLFwiZ3JvdXBzXCI6W3tcIm1lbWJlcnNcIjp7XCIjdG9KU1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJEZWVwbHkgY29udmVydHMgdGhpcyBLZXllZCBjb2xsZWN0aW9uIHRvIGVxdWl2YWxlbnQgbmF0aXZlIEphdmFTY3JpcHQgT2JqZWN0LlwiLFwiZGVzY3JpcHRpb25cIjpcIkNvbnZlcnRzIGtleXMgdG8gU3RyaW5ncy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiT2JqZWN0XCJ9LFwibGluZVwiOjE4NTB9XX0sXCIjdG9KU09OXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIEtleWVkIGNvbGxlY3Rpb24gdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdCBPYmplY3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiQ29udmVydHMga2V5cyB0byBTdHJpbmdzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6NixcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo1fX1dLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9fV19LFwibGluZVwiOjE4NTd9XX0sXCIjdG9Db25jcmV0ZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDb252ZXJ0cyB0aGlzIGNvbGxlY3Rpb24gdG8gYSBgTWFwYFwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJNYXBcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjoxODYyfV19LFwiI3RvU2VxXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgS2V5ZWRTZXF1ZW5jZS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiS2V5ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjE4Njh9XX19fSx7XCJ0aXRsZVwiOlwiU2VxdWVuY2UgZnVuY3Rpb25zXCIsXCJtZW1iZXJzXCI6e1wiI2ZsaXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBLZXllZCBvZiB0aGUgc2FtZSB0eXBlIHdoZXJlIHRoZSBrZXlzIGFuZCB2YWx1ZXNcXG5oYXZlIGJlZW4gZmxpcHBlZC5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBLZXllZFNlcXVlbmNlIH0gPSByZXF1aXJlKCdzZXF1aW5zJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5uZXcgS2V5ZWRTZXF1ZW5jZSh7IGE6ICd6JywgYjogJ3knIH0pLmZsaXAoKVxcbi8vIEtleWVkU2VxdWVuY2UgeyBcXFwielxcXCI6IFxcXCJhXFxcIiwgXFxcInlcXFwiOiBcXFwiYlxcXCIgfVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJLZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifV19LFwibGluZVwiOjE4ODR9XX0sXCIjY29uY2F0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiB3aXRoIG90aGVyIGNvbGxlY3Rpb25zIGNvbmNhdGVuYXRlZCB0byB0aGlzIG9uZS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS0NcIixcIlZDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjExLFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE2LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktDXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWQ1wifV19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIktDXCJ9XX0se1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZDXCJ9XX1dfSxcImxpbmVcIjoxODg5fSx7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo2LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjV9fV0sXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIkNcIn19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn0se1wia1wiOjV9XX0se1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIkNcIn1dfV19LFwibGluZVwiOjE4OTJ9XX0sXCIjbWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgS2V5ZWQgd2l0aCB2YWx1ZXMgcGFzc2VkIHRocm91Z2ggYVxcbmBtYXBwZXJgIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IEtleWVkU2VxdWVuY2UgfSA9IHJlcXVpcmUoJ3NlcXVpbnMnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbm5ldyBLZXllZFNlcXVlbmNlKHsgYTogMSwgYjogMiB9KS5tYXAoeCA9PiAxMCAqIHgpXFxuLy8gS2V5ZWRTZXF1ZW5jZSB7IFxcXCJhXFxcIjogMTAsIFxcXCJiXFxcIjogMjAgfVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo5LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEyfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJNXCJ9fX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6MTkwOH1dfSxcIiNtYXBLZXlzXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgS2V5ZWQgb2YgdGhlIHNhbWUgdHlwZSB3aXRoIGtleXMgcGFzc2VkIHRocm91Z2hcXG5hIGBtYXBwZXJgIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IEtleWVkU2VxdWVuY2UgfSA9IHJlcXVpcmUoJ3NlcXVpbnMnKTtcXFwiIH1cXG4tLT5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbm5ldyBLZXllZFNlcXVlbmNlKHsgYTogMSwgYjogMiB9KS5tYXBLZXlzKHggPT4geC50b1VwcGVyQ2FzZSgpKVxcbi8vIEtleWVkU2VxdWVuY2UgeyBcXFwiQVxcXCI6IDEsIFxcXCJCXFxcIjogMiB9XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTJ9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIk1cIn19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIk1cIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjoxOTIzfV19LFwiI21hcEVudHJpZXNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBLZXllZCBvZiB0aGUgc2FtZSB0eXBlIHdpdGggZW50cmllc1xcbihba2V5LCB2YWx1ZV0gdHVwbGVzKSBwYXNzZWQgdGhyb3VnaCBhIGBtYXBwZXJgIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IEtleWVkU2VxdWVuY2UgfSA9IHJlcXVpcmUoJ3NlcXVpbnMnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbm5ldyBLZXllZFNlcXVlbmNlKHsgYTogMSwgYjogMiB9KVxcbiAgLm1hcEVudHJpZXMoKFsgaywgdiBdKSA9PiBbIGsudG9VcHBlckNhc2UoKSwgdiAqIDIgXSlcXG4vLyBLZXllZFNlcXVlbmNlIHsgXFxcIkFcXFwiOiAyLCBcXFwiQlxcXCI6IDQgfVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJLTVwiLFwiVk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiZW50cnlcIixcInR5cGVcIjp7XCJrXCI6MTYsXCJ0eXBlc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19fSx7XCJuYW1lXCI6XCJpbmRleFwiLFwidHlwZVwiOntcImtcIjo0fX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMn0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTYsXCJ0eXBlc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS01cIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZNXCJ9XX19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWTVwifV19LFwibGluZVwiOjE5Mzh9XX0sXCIjZmxhdE1hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJGbGF0LW1hcHMgdGhlIENvbGxlY3Rpb24sIHJldHVybmluZyBhIENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZS5cIixcImRlc2NyaXB0aW9uXCI6XCJTaW1pbGFyIHRvIGBjb2xsZWN0aW9uLm1hcCguLi4pLmZsYXR0ZW4odHJ1ZSlgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJLTVwiLFwiVk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTJ9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE2LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWTVwifV19XX19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWTVwifV19LFwibGluZVwiOjE5NDd9XX0sXCIjZmlsdGVyXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiB3aXRoIG9ubHkgdGhlIHZhbHVlcyBmb3Igd2hpY2ggdGhlIGBwcmVkaWNhdGVgXFxuZnVuY3Rpb24gcmV0dXJucyB0cnVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJGXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo5LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEyfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjozfX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJLZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiRlwifV19LFwibGluZVwiOjE5NTV9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMn0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MH19fV0sXCJ0eXBlXCI6e1wia1wiOjEyfSxcImxpbmVcIjoxOTU4fV19LFwiI1tTeW1ib2wuaXRlcmF0b3JdXCI6e1wic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiSXRlcmFibGVJdGVyYXRvclwiLFwiYXJnc1wiOlt7XCJrXCI6MTYsXCJ0eXBlc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19XX0sXCJsaW5lXCI6MTk2MH1dfX19XX19LFwiSW5kZXhlZFwiOntcImludGVyZmFjZVwiOntcImxpbmVcIjoxOTc1LFwiZG9jXCI6e1wic3lub3BzaXNcIjpcIkluZGV4ZWQgaXMgdXNlZCB0byBkZXNjcmliZSBDb2xsZWN0aW9ucyBvZiB2YWx1ZXMgd2hlcmUgdGhlIGNvbGxlY3Rpb25zXFxuYWxzbyB0cmFjayB0aGUgaW5kZXhlcyBvZiB0aG9zZSB2YWx1ZXMuIENhbGxiYWNrcyBmb3IgbWV0aG9kcyBpbiBjbGFzc2VzXFxuaW1wbGVtZW50aW5nIEluZGV4ZWQgd2lsbCByZWNlaXZlIGAodmFsdWUsIGluZGV4KWAgYXMgdGhlaXIgZmlyc3QgdHdvXFxuYXJndW1lbnRzLlwiLFwiZGVzY3JpcHRpb25cIjpcIkl0ZXJhdGluZyBvdmVyIGFuIGBJbmRleGVkYCB5aWVsZHMgb25seSB2YWx1ZXMsIG5vIGluZGV4ZXMuXFxuXFxuVW5saWtlIEphdmFTY3JpcHQgYXJyYXlzLCBgSW5kZXhlZGAgY29sbGVjdGlvbnMgYXJlIGFsd2F5cyBkZW5zZS4gXFxcIlVuc2V0XFxcIlxcbmluZGljZXMgYW5kIGB1bmRlZmluZWRgIGluZGljZXMgYXJlIGluZGlzdGluZ3Vpc2hhYmxlLCBhbmQgYWxsIGluZGljZXMgZnJvbVxcbjAgdG8gYHNpemVgIGFyZSB2aXNpdGVkIHdoZW4gaXRlcmF0ZWQuXCIsXCJub3Rlc1wiOltdfSxcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwiZXh0ZW5kc1wiOlt7XCJrXCI6MTEsXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjo0fSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19XSxcImdyb3Vwc1wiOlt7XCJtZW1iZXJzXCI6e1wiI3RvSlNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRGVlcGx5IGNvbnZlcnRzIHRoaXMgSW5kZXhlZCBjb2xsZWN0aW9uIHRvIGVxdWl2YWxlbnQgbmF0aXZlIEphdmFTY3JpcHQgQXJyYXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjowfV19LFwibGluZVwiOjE5Nzl9XX0sXCIjdG9KU09OXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIEluZGV4ZWQgY29sbGVjdGlvbiB0byBlcXVpdmFsZW50IG5hdGl2ZSBKYXZhU2NyaXB0IEFycmF5LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjE5ODR9XX0sXCIjdG9Db25jcmV0ZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDb252ZXJ0cyB0aGlzIGNvbGxlY3Rpb24gdG8gYSBgTGlzdGBcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjE5ODl9XX19fSx7XCJ0aXRsZVwiOlwiUmVhZGluZyB2YWx1ZXNcIixcIm1lbWJlcnNcIjp7XCIjZ2V0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgaW5kZXgsIG9yIG5vdFNldFZhbHVlIGlmXFxudGhlIGluZGV4IGlzIGJleW9uZCB0aGUgYm91bmRzIG9mIHRoZSBDb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcImBpbmRleGAgbWF5IGJlIGEgbmVnYXRpdmUgbnVtYmVyLCB3aGljaCBpbmRleGVzIGJhY2sgZnJvbSB0aGUgZW5kIG9mIHRoZVxcbkNvbGxlY3Rpb24uIGBzLmdldCgtMSlgIGdldHMgdGhlIGxhc3QgaXRlbSBpbiB0aGUgQ29sbGVjdGlvbi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTlNWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjR9fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJOU1ZcIn19XSxcInR5cGVcIjp7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiTlNWXCJ9XX0sXCJsaW5lXCI6MjAwMH0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjR9fV0sXCJ0eXBlXCI6e1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjEzfV19LFwibGluZVwiOjIwMDF9XX19fSx7XCJ0aXRsZVwiOlwiQ29udmVyc2lvbnNcIixcIm1lbWJlcnNcIjp7XCIjdG9TZXFcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBJbmRleGVkU2VxdWVuY2UuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkluZGV4ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjIwMDl9XX19fSx7XCJ0aXRsZVwiOlwiQ29tYmluYXRpb25cIixcIm1lbWJlcnNcIjp7XCIjemlwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgXFxcInppcHBlZFxcXCIgd2l0aCB0aGUgcHJvdmlkZWRcXG5jb2xsZWN0aW9ucy5cIixcImRlc2NyaXB0aW9uXCI6XCJMaWtlIGB6aXBXaXRoYCwgYnV0IHVzaW5nIHRoZSBkZWZhdWx0IGB6aXBwZXJgOiBjcmVhdGluZyBhbiBgQXJyYXlgLlxcblxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IEluZGV4ZWRTZXF1ZW5jZSB9ID0gcmVxdWlyZSgnc2VxdWlucycpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuY29uc3QgYSA9IG5ldyBJbmRleGVkU2VxdWVuY2UoWyAxLCAyLCAzIF0pO1xcbmNvbnN0IGIgPSBuZXcgSW5kZXhlZFNlcXVlbmNlKFsgNCwgNSwgNiBdKTtcXG5jb25zdCBjID0gYS56aXAoYik7IC8vIEluZGV4ZWRTZXF1ZW5jZSBbIFsgMSwgNCBdLCBbIDIsIDUgXSwgWyAzLCA2IF0gXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJVXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQ29sbGVjdGlvbkxpa2VcIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJVXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxNixcInR5cGVzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJVXCJ9XX1dfSxcImxpbmVcIjoyMDI5fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlclwiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25MaWtlXCIsXCJhcmdzXCI6W3tcImtcIjowfSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVVwifV19fSx7XCJuYW1lXCI6XCJvdGhlcjJcIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJDb2xsZWN0aW9uTGlrZVwiLFwiYXJnc1wiOlt7XCJrXCI6MH0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjE2LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlVcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfV19LFwibGluZVwiOjIwMzB9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxMSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25MaWtlXCIsXCJhcmdzXCI6W3tcImtcIjowfSx7XCJrXCI6MH1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjowfV19LFwibGluZVwiOjIwMzR9XX0sXCIjemlwQWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBDb2xsZWN0aW9uIFxcXCJ6aXBwZWRcXFwiIHdpdGggdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb25zLlwiLFwiZGVzY3JpcHRpb25cIjpcIlVubGlrZSBgemlwYCwgYHppcEFsbGAgY29udGludWVzIHppcHBpbmcgdW50aWwgdGhlIGxvbmdlc3QgY29sbGVjdGlvbiBpc1xcbmV4aGF1c3RlZC4gTWlzc2luZyB2YWx1ZXMgZnJvbSBzaG9ydGVyIGNvbGxlY3Rpb25zIGFyZSBmaWxsZWQgd2l0aCBgdW5kZWZpbmVkYC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBJbmRleGVkU2VxdWVuY2UgfSA9IHJlcXVpcmUoJ3NlcXVpbnMnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmNvbnN0IGEgPSBuZXcgSW5kZXhlZFNlcXVlbmNlKFsgMSwgMiBdKTtcXG5jb25zdCBiID0gbmV3IEluZGV4ZWRTZXF1ZW5jZShbIDMsIDQsIDUgXSk7XFxuY29uc3QgYyA9IGEuemlwQWxsKGIpO1xcbi8vIEluZGV4ZWRTZXF1ZW5jZSBbIFsgMSwgMyBdLCBbIDIsIDQgXSwgWyB1bmRlZmluZWQsIDUgXSBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlVcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib3RoZXJcIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJDb2xsZWN0aW9uTGlrZVwiLFwiYXJnc1wiOlt7XCJrXCI6MH0se1wia1wiOjEwLFwicGFyYW1cIjpcIlVcIn1dfX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjE2LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlVcIn1dfV19LFwibGluZVwiOjIwNTJ9LHtcInR5cGVQYXJhbXNcIjpbXCJVXCIsXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQ29sbGVjdGlvbkxpa2VcIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJVXCJ9XX19LHtcIm5hbWVcIjpcIm90aGVyMlwiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25MaWtlXCIsXCJhcmdzXCI6W3tcImtcIjowfSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTYsXCJ0eXBlc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVVwifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19XX0sXCJsaW5lXCI6MjA1M30se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjExLFwibmFtZVwiOlwiQ29sbGVjdGlvbkxpa2VcIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjowfV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjB9XX0sXCJsaW5lXCI6MjA1N31dfSxcIiN6aXBXaXRoXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgXFxcInppcHBlZFxcXCIgd2l0aCB0aGUgcHJvdmlkZWRcXG5jb2xsZWN0aW9ucyBieSB1c2luZyBhIGN1c3RvbSBgemlwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBJbmRleGVkU2VxdWVuY2UgfSA9IHJlcXVpcmUoJ3NlcXVpbnMnKVxcXCIgfVxcbi0tPlxcbmBgYGpzXFxuY29uc3QgYSA9IG5ldyBJbmRleGVkU2VxdWVuY2UoWyAxLCAyLCAzIF0pO1xcbmNvbnN0IGIgPSBuZXcgSW5kZXhlZFNlcXVlbmNlKFsgNCwgNSwgNiBdKTtcXG5jb25zdCBjID0gYS56aXBXaXRoKChhLCBiKSA9PiBhICsgYiwgYik7XFxuLy8gSW5kZXhlZFNlcXVlbmNlIFsgNSwgNywgOSBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlVcIixcIlpcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiemlwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwib3RoZXJWYWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJVXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlpcIn19fSx7XCJuYW1lXCI6XCJvdGhlckNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJDb2xsZWN0aW9uTGlrZVwiLFwiYXJnc1wiOlt7XCJrXCI6MH0se1wia1wiOjEwLFwicGFyYW1cIjpcIlVcIn1dfX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlpcIn1dfSxcImxpbmVcIjoyMDczfSx7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiVlwiLFwiWlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ6aXBwZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJvdGhlclZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlVcIn19LHtcIm5hbWVcIjpcInRoaXJkVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJaXCJ9fX0se1wibmFtZVwiOlwib3RoZXJDb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQ29sbGVjdGlvbkxpa2VcIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJVXCJ9XX19LHtcIm5hbWVcIjpcInRoaXJkQ29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25MaWtlXCIsXCJhcmdzXCI6W3tcImtcIjowfSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiWlwifV19LFwibGluZVwiOjIwNzd9LHtcInR5cGVQYXJhbXNcIjpbXCJaXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInppcHBlclwiLFwidHlwZVwiOntcImtcIjo5LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImFueVwiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjowfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiWlwifX19LHtcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjExLFwibmFtZVwiOlwiQ29sbGVjdGlvbkxpa2VcIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjowfV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlpcIn1dfSxcImxpbmVcIjoyMDgyfV19fX0se1widGl0bGVcIjpcIlNlcXVlbmNlIGFsZ29yaXRobXNcIixcIm1lbWJlcnNcIjp7XCIjY29uY2F0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiB3aXRoIG90aGVyIGNvbGxlY3Rpb25zIGNvbmNhdGVuYXRlZCB0byB0aGlzIG9uZS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZXNPckNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjExLFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIkNcIn1dfSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiQ1wifV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIkNcIn1dfV19LFwibGluZVwiOjIwOTJ9XX0sXCIjbWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgSW5kZXhlZCB3aXRoIHZhbHVlcyBwYXNzZWQgdGhyb3VnaCBhXFxuYG1hcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgSW5kZXhlZFNlcXVlbmNlIH0gPSByZXF1aXJlKCdzZXF1aW5zJylcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbm5ldyBJbmRleGVkU2VxdWVuY2UoWzEsMl0pLm1hcCh4ID0+IDEwICogeClcXG4vLyBJbmRleGVkU2VxdWVuY2UgWyAxLCAyIF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6NH19XSxcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiTVwifX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6MjEwNn1dfSxcIiNmbGF0TWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkZsYXQtbWFwcyB0aGUgQ29sbGVjdGlvbiwgcmV0dXJuaW5nIGEgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlNpbWlsYXIgdG8gYGNvbGxlY3Rpb24ubWFwKC4uLikuZmxhdHRlbih0cnVlKWAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjR9fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIk1cIn1dfX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6MjExM31dfSxcIiNmaWx0ZXJcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIHdpdGggb25seSB0aGUgdmFsdWVzIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWBcXG5mdW5jdGlvbiByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6NH19XSxcInR5cGVcIjp7XCJrXCI6M319fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiRlwifV19LFwibGluZVwiOjIxMTl9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJpbmRleFwiLFwidHlwZVwiOntcImtcIjo0fX1dLFwidHlwZVwiOntcImtcIjowfX19XSxcInR5cGVcIjp7XCJrXCI6MTJ9LFwibGluZVwiOjIxMjJ9XX0sXCIjW1N5bWJvbC5pdGVyYXRvcl1cIjp7XCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJdGVyYWJsZUl0ZXJhdG9yXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MjEyNH1dfX19XX19LFwiRHVwbGljYXRlZFwiOntcImludGVyZmFjZVwiOntcImxpbmVcIjoyMTM1LFwiZG9jXCI6e1wic3lub3BzaXNcIjpcIkR1cGxpY2F0ZWQgZGVzY3JpYmVzIGNvbGxlY3Rpb25zIG9mIHZhbHVlcyB3aGVyZSBubyBpbmRleCBpcyBkZXNpcmVkLlxcbkluc3RlYWQsIGNhbGxiYWNrcyBmb3IgbWV0aG9kcyBpbiBjbGFzc2VzIGltcGxlbWVudGluZyBEdXBsaWNhdGVkIHdpbGxcXG5yZWNlaXZlIGAodmFsdWUsIHZhbHVlKWAgYXMgdGhlaXIgZmlyc3QgdHdvIGFyZ3VtZW50cywgd2hpY2ggaXMgdGhlIHNvdXJjZVxcbm9mIHRoZSBuYW1lLlwiLFwiZGVzY3JpcHRpb25cIjpcIkl0ZXJhdGluZyBvdmVyIGEgRHVwbGljYXRlZCB5aWVsZHMgb25seSB2YWx1ZXMuXCIsXCJub3Rlc1wiOltdfSxcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwiZXh0ZW5kc1wiOlt7XCJrXCI6MTEsXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX1dLFwiZ3JvdXBzXCI6W3tcIm1lbWJlcnNcIjp7XCIjdG9KU1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJEZWVwbHkgY29udmVydHMgdGhpcyBTZXQgY29sbGVjdGlvbiB0byBlcXVpdmFsZW50IG5hdGl2ZSBKYXZhU2NyaXB0IEFycmF5LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MH1dfSxcImxpbmVcIjoyMTM5fV19LFwiI3RvSlNPTlwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJTaGFsbG93bHkgY29udmVydHMgdGhpcyBTZXQgY29sbGVjdGlvbiB0byBlcXVpdmFsZW50IG5hdGl2ZSBKYXZhU2NyaXB0IEFycmF5LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjIxNDR9XX0sXCIjdG9Db25jcmV0ZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDb252ZXJ0cyB0aGlzIGNvbGxlY3Rpb24gdG8gYSBgU2V0YFwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJTZXRcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoyMTQ5fV19LFwiI3RvU2VxXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgU2V0U2VxdWVuY2UuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIlNldFNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MjE1NX1dfX19LHtcInRpdGxlXCI6XCJTZXF1ZW5jZSBhbGdvcml0aG1zXCIsXCJtZW1iZXJzXCI6e1wiI2NvbmNhdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gd2l0aCBvdGhlciBjb2xsZWN0aW9ucyBjb25jYXRlbmF0ZWQgdG8gdGhpcyBvbmUuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlVcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTEsXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVVwifV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkR1cGxpY2F0ZWRcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlVcIn1dfV19LFwibGluZVwiOjIxNjJ9XX0sXCIjbWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgRHVwbGljYXRlZCB3aXRoIHZhbHVlcyBwYXNzZWQgdGhyb3VnaCBhXFxuYG1hcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiYGBgXFxuRHVwbGljYXRlZChbIDEsIDIgXSkubWFwKHggPT4gMTAgKiB4KVxcbi8vIFNlcXVlbmNlIHsgMSwgMiB9XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn19XSxcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiTVwifX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJEdXBsaWNhdGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6MjE3M31dfSxcIiNmbGF0TWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkZsYXQtbWFwcyB0aGUgQ29sbGVjdGlvbiwgcmV0dXJuaW5nIGEgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlNpbWlsYXIgdG8gYGNvbGxlY3Rpb24ubWFwKC4uLikuZmxhdHRlbih0cnVlKWAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiTVwifV19fX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkR1cGxpY2F0ZWRcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjoyMTgwfV19LFwiI2ZpbHRlclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gd2l0aCBvbmx5IHRoZSB2YWx1ZXMgZm9yIHdoaWNoIHRoZSBgcHJlZGljYXRlYFxcbmZ1bmN0aW9uIHJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiRlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6OSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifX1dLFwidHlwZVwiOntcImtcIjozfX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJEdXBsaWNhdGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJGXCJ9XX0sXCJsaW5lXCI6MjE4Nn0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo5LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJUXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjB9fX1dLFwidHlwZVwiOntcImtcIjoxMn0sXCJsaW5lXCI6MjE4OX1dfSxcIiNbU3ltYm9sLml0ZXJhdG9yXVwiOntcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkl0ZXJhYmxlSXRlcmF0b3JcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoyMTkxfV19fX1dfX19fSx7XCJ0aXRsZVwiOlwiQ29uc3RydWN0aW9uXCIsXCJtZW1iZXJzXCI6e1wiUmFuZ2VcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBJbmRleGVkU2VxdWVuY2Ugb2YgbnVtYmVycyBmcm9tIGBzdGFydGAgKGluY2x1c2l2ZSkgdG8gYGVuZGBcXG4oZXhjbHVzaXZlKSwgYnkgYHN0ZXBgLCB3aGVyZSBgc3RhcnRgIGRlZmF1bHRzIHRvIDAsIGBzdGVwYCB0byAxLCBhbmQgYGVuZGAgdG9cXG5pbmZpbml0eS4gV2hlbiBgc3RhcnRgIGlzIGVxdWFsIHRvIGBlbmRgLCByZXR1cm5zIGVtcHR5IHJhbmdlLlwiLFwiZGVzY3JpcHRpb25cIjpcImBgYGpzXFxuUmFuZ2UoKSAvLyBbIDAsIDEsIDIsIDMsIC4uLiBdXFxuUmFuZ2UoMTApIC8vIFsgMTAsIDExLCAxMiwgMTMsIC4uLiBdXFxuUmFuZ2UoMTAsIDE1KSAvLyBbIDEwLCAxMSwgMTIsIDEzLCAxNCBdXFxuUmFuZ2UoMTAsIDMwLCA1KSAvLyBbIDEwLCAxNSwgMjAsIDI1IF1cXG5SYW5nZSgzMCwgMTAsIDUpIC8vIFsgMzAsIDI1LCAyMCwgMTUgXVxcblJhbmdlKDMwLCAzMCwgNSkgLy8gW11cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic3RhcnRcIixcInR5cGVcIjp7XCJrXCI6NH0sXCJvcHRpb25hbFwiOnRydWV9LHtcIm5hbWVcIjpcImVuZFwiLFwidHlwZVwiOntcImtcIjo0fSxcIm9wdGlvbmFsXCI6dHJ1ZX0se1wibmFtZVwiOlwic3RlcFwiLFwidHlwZVwiOntcImtcIjo0fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkluZGV4ZWRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6NH1dfSxcImxpbmVcIjoyMjEwfV19fSxcIlJlcGVhdFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIEluZGV4ZWRTZXF1ZW5jZSBvZiBgdmFsdWVgIHJlcGVhdGVkIGB0aW1lc2AgdGltZXMuIFdoZW4gYHRpbWVzYCBpc1xcbm5vdCBkZWZpbmVkLCByZXR1cm5zIGFuIGluZmluaXRlIGBTZXF1ZW5jZWAgb2YgYHZhbHVlYC5cIixcImRlc2NyaXB0aW9uXCI6XCJgYGBqc1xcblJlcGVhdCgnZm9vJykgLy8gWyAnZm9vJywgJ2ZvbycsICdmb28nLCAuLi4gXVxcblJlcGVhdCgnYmFyJywgNCkgLy8gWyAnYmFyJywgJ2JhcicsICdiYXInLCAnYmFyJyBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwidGltZXNcIixcInR5cGVcIjp7XCJrXCI6NH0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJJbmRleGVkU2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoyMjI1fV19fX19LHtcInRpdGxlXCI6XCJVdGlsaXR5XCIsXCJtZW1iZXJzXCI6e1wiaXNDb2xsZWN0aW9uXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGBtYXliZUNvbGxlY3Rpb25gIGlzIGEgQ29sbGVjdGlvbiwgb3IgYW55IG9mIGl0cyBzdWJjbGFzc2VzLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IGlzQ29sbGVjdGlvbiwgTWFwLCBMaXN0IH0gPSByZXF1aXJlKCdzZXF1aW5zJylcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmlzQ29sbGVjdGlvbihbXSk7IC8vIGZhbHNlXFxuaXNDb2xsZWN0aW9uKHt9KTsgLy8gZmFsc2VcXG5pc0NvbGxlY3Rpb24obmV3IE1hcCgpKTsgLy8gdHJ1ZVxcbmlzQ29sbGVjdGlvbihuZXcgTGlzdCgpKTsgLy8gdHJ1ZVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXliZUNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6MH19XSxcInR5cGVcIjp7XCJrXCI6M30sXCJsaW5lXCI6MjI0Mn1dfX0sXCJpc0tleWVkXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGBtYXliZUtleWVkYCBpcyBhIEtleWVkLCBvciBhbnkgb2YgaXRzIHN1YmNsYXNzZXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgaXNLZXllZCwgTWFwLCBMaXN0IH0gPSByZXF1aXJlKCdzZXF1aW5zJylcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmlzS2V5ZWQoW10pOyAvLyBmYWxzZVxcbmlzS2V5ZWQoe30pOyAvLyBmYWxzZVxcbmlzS2V5ZWQobmV3IE1hcCgpKTsgLy8gdHJ1ZVxcbmlzS2V5ZWQobmV3IExpc3QoKSk7IC8vIGZhbHNlXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlS2V5ZWRcIixcInR5cGVcIjp7XCJrXCI6MH19XSxcInR5cGVcIjp7XCJrXCI6M30sXCJsaW5lXCI6MjI1OX1dfX0sXCJpc0luZGV4ZWRcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgYG1heWJlSW5kZXhlZGAgaXMgYW4gSW5kZXhlZCwgb3IgYW55IG9mIGl0cyBzdWJjbGFzc2VzLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IGlzSW5kZXhlZCwgTWFwLCBMaXN0IH0gPSByZXF1aXJlKCdzZXF1aW5zJylcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmlzSW5kZXhlZChbXSk7IC8vIGZhbHNlXFxuaXNJbmRleGVkKHt9KTsgLy8gZmFsc2VcXG5pc0luZGV4ZWQobmV3IE1hcCgpKTsgLy8gZmFsc2VcXG5pc0luZGV4ZWQobmV3IExpc3QoKSk7IC8vIHRydWVcXG5pc0luZGV4ZWQobmV3IFNldCgpKTsgLy8gZmFsc2VcXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVJbmRleGVkXCIsXCJ0eXBlXCI6e1wia1wiOjB9fV0sXCJ0eXBlXCI6e1wia1wiOjN9LFwibGluZVwiOjIyNzV9XX19LFwiaXNBc3NvY2lhdGl2ZVwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVBc3NvY2lhdGl2ZWAgaXMgZWl0aGVyIGEgS2V5ZWQgb3IgSW5kZXhlZCBDb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IGlzQXNzb2NpYXRpdmUsIE1hcCwgTGlzdCB9ID0gcmVxdWlyZSgnc2VxdWlucycpXFxcIiB9XFxuLS0+XFxuYGBganNcXG5pc0Fzc29jaWF0aXZlKFtdKTsgLy8gZmFsc2VcXG5pc0Fzc29jaWF0aXZlKHt9KTsgLy8gZmFsc2VcXG5pc0Fzc29jaWF0aXZlKG5ldyBNYXAoKSk7IC8vIHRydWVcXG5pc0Fzc29jaWF0aXZlKG5ldyBMaXN0KCkpOyAvLyB0cnVlXFxuaXNBc3NvY2lhdGl2ZShuZXcgU2V0KCkpOyAvLyBmYWxzZVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXliZUFzc29jaWF0aXZlXCIsXCJ0eXBlXCI6e1wia1wiOjB9fV0sXCJ0eXBlXCI6e1wia1wiOjN9LFwibGluZVwiOjIyOTF9XX19LFwiaXNTZXFcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgYG1heWJlU2VxYCBpcyBhIFNlcXVlbmNlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXliZVNlcVwiLFwidHlwZVwiOntcImtcIjowfX1dLFwidHlwZVwiOntcImtcIjozfSxcImxpbmVcIjoyMjk4fV19fSxcImlzTGlzdFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVMaXN0YCBpcyBhIExpc3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlTGlzdFwiLFwidHlwZVwiOntcImtcIjowfX1dLFwidHlwZVwiOntcImtcIjozfSxcImxpbmVcIjoyMzA4fV19fSxcImlzTWFwXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGBtYXliZU1hcGAgaXMgYSBNYXAuXCIsXCJkZXNjcmlwdGlvblwiOlwiQWxzbyB0cnVlIGZvciBPcmRlcmVkTWFwcy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVNYXBcIixcInR5cGVcIjp7XCJrXCI6MH19XSxcInR5cGVcIjp7XCJrXCI6M30sXCJsaW5lXCI6MjMxNX1dfX0sXCJpc1NldFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVTZXRgIGlzIGEgU2V0LlwiLFwiZGVzY3JpcHRpb25cIjpcIkFsc28gdHJ1ZSBmb3IgT3JkZXJlZFNldHMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlU2V0XCIsXCJ0eXBlXCI6e1wia1wiOjB9fV0sXCJ0eXBlXCI6e1wia1wiOjN9LFwibGluZVwiOjIzMjJ9XX19LFwiZ2V0XCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSB2YWx1ZSB3aXRoaW4gdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoZVxcbnByb3ZpZGVkIGtleSwgb3Igbm90U2V0VmFsdWUgaWYgdGhlIGtleSBpcyBub3QgZGVmaW5lZCBpbiB0aGUgY29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJBIGZ1bmN0aW9uYWwgYWx0ZXJuYXRpdmUgdG8gYGNvbGxlY3Rpb24uZ2V0KGtleSlgIHdoaWNoIHdpbGwgYWxzbyB3b3JrIG9uXFxucGxhaW4gT2JqZWN0cyBhbmQgQXJyYXlzIGFzIGFuIGFsdGVybmF0aXZlIGZvciBgY29sbGVjdGlvbltrZXldYC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBnZXQgfSA9IHJlcXVpcmUoJ3NlcXVpbnMnKVxcXCIgfVxcbi0tPlxcbmBgYGpzXFxuZ2V0KFsgJ2RvZycsICdmcm9nJywgJ2NhdCcgXSwgMikgLy8gJ2Zyb2cnXFxuZ2V0KHsgeDogMTIzLCB5OiA0NTYgfSwgJ3gnKSAvLyAxMjNcXG5nZXQoeyB4OiAxMjMsIHk6IDQ1NiB9LCAneicsICdpZk5vdFNldCcpIC8vICdpZk5vdFNldCdcXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifX1dLFwidHlwZVwiOntcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjoxM31dfSxcImxpbmVcIjoyMzQwfSx7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiLFwiTlNWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJOU1ZcIn19XSxcInR5cGVcIjp7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiTlNWXCJ9XX0sXCJsaW5lXCI6MjM0MX0se1widHlwZVBhcmFtc1wiOltcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo0fX1dLFwidHlwZVwiOntcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjoxM31dfSxcImxpbmVcIjoyMzQ2fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiLFwiTlNWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6NH19LHtcIm5hbWVcIjpcIm5vdFNldFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIk5TVlwifX1dLFwidHlwZVwiOntcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJOU1ZcIn1dfSxcImxpbmVcIjoyMzQ3fSx7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiLFwiS1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvYmplY3RcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIm5vdFNldFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjB9fV0sXCJ0eXBlXCI6e1wia1wiOjE3LFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJDXCJ9LFwiaW5kZXhcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifX0sXCJsaW5lXCI6MjM1Mn0se1widHlwZVBhcmFtc1wiOltcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo2LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjV9fV0sXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn19XX19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo1fX1dLFwidHlwZVwiOntcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjoxM31dfSxcImxpbmVcIjoyMzU3fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiLFwiTlNWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6NixcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo1fX1dLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9fV19fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6NX19LHtcIm5hbWVcIjpcIm5vdFNldFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIk5TVlwifX1dLFwidHlwZVwiOntcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJOU1ZcIn1dfSxcImxpbmVcIjoyMzYxfV19fSxcImhhc1wiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyB0cnVlIGlmIHRoZSBrZXkgaXMgZGVmaW5lZCBpbiB0aGUgcHJvdmlkZWQgY29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJBIGZ1bmN0aW9uYWwgYWx0ZXJuYXRpdmUgdG8gYGNvbGxlY3Rpb24uaGFzKGtleSlgIHdoaWNoIHdpbGwgYWxzbyB3b3JrIHdpdGhcXG5wbGFpbiBPYmplY3RzIGFuZCBBcnJheXMgYXMgYW4gYWx0ZXJuYXRpdmUgZm9yXFxuYGNvbGxlY3Rpb24uaGFzT3duUHJvcGVydHkoa2V5KWAuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgaGFzIH0gPSByZXF1aXJlKCdzZXF1aW5zJylcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmhhcyhbICdkb2cnLCAnZnJvZycsICdjYXQnIF0sIDIpIC8vIHRydWVcXG5oYXMoWyAnZG9nJywgJ2Zyb2cnLCAnY2F0JyBdLCA1KSAvLyBmYWxzZVxcbmhhcyh7IHg6IDEyMywgeTogNDU2IH0sICd4JykgLy8gdHJ1ZVxcbmhhcyh7IHg6IDEyMywgeTogNDU2IH0sICd6JykgLy8gZmFsc2VcXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIk9iamVjdFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjB9fV0sXCJ0eXBlXCI6e1wia1wiOjN9LFwibGluZVwiOjIzODR9XX19LFwicmVtb3ZlXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZW1vdmVzIHRoZSBrZXkgYXQgdmFsdWVcIixcImRlc2NyaXB0aW9uXCI6XCJBIGZ1bmN0aW9uYWwgYWx0ZXJuYXRpdmUgdG8gYGNvbGxlY3Rpb24ucmVtb3ZlKGtleSlgIHdoaWNoIHdpbGwgYWxzbyB3b3JrXFxud2l0aCBwbGFpbiBPYmplY3RzIGFuZCBBcnJheXMgYXMgYW4gYWx0ZXJuYXRpdmUgZm9yXFxuYGRlbGV0ZSBjb2xsZWN0aW9uQ29weVtrZXldYC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyByZW1vdmUgfSA9IHJlcXVpcmUoJ3NlcXVpbnMnKVxcXCIgfVxcbi0tPlxcbmBgYGpzXFxuY29uc3QgYXJyYXkgPSBbICdkb2cnLCAnZnJvZycsICdjYXQnIF1cXG5yZW1vdmUoYXJyYXksIDEpXFxuY29uc29sZS5sb2coYXJyYXkpIC8vIFsgJ2RvZycsICdjYXQnIF1cXG5cXG5jb25zdCBvYmplY3QgPSB7IHg6IDEyMywgeTogNDU2IH1cXG5yZW1vdmUob2JqZWN0LCAneCcpXFxuY29uc29sZS5sb2cob2JqZWN0KSAvLyB7IHk6IDQ1NiB9XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktcIixcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifX1dLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjI0MDZ9LHtcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjR9fV0sXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIkNcIn0sXCJsaW5lXCI6MjQxMH0se1widHlwZVBhcmFtc1wiOltcIkNcIixcIktcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifX1dLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjI0MTF9LHtcInR5cGVQYXJhbXNcIjpbXCJDXCIsXCJLXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn19XSxcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjoyNDEyfV19fSxcInNldFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiU2V0cyBrZXkgdG8gdmFsdWVcIixcImRlc2NyaXB0aW9uXCI6XCJBIGZ1bmN0aW9uYWwgYWx0ZXJuYXRpdmUgdG8gYGNvbGxlY3Rpb24uc2V0KGtleSwgdmFsdWUpYCB3aGljaCB3aWxsIGFsc29cXG53b3JrIHdpdGggcGxhaW4gT2JqZWN0cyBhbmQgQXJyYXlzIGFzIGFuIGFsdGVybmF0aXZlIGZvclxcbmBjb2xsZWN0aW9uQ29weVtrZXldID0gdmFsdWVgLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IHNldCB9ID0gcmVxdWlyZSgnc2VxdWlucycpXFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBhcnJheSA9IFsgJ2RvZycsICdmcm9nJywgJ2NhdCcgXVxcbnNldChhcnJheSwgMSwgJ2NvdycpXFxuY29uc29sZS5sb2coYXJyYXkpIC8vIFsgJ2RvZycsICdjb3cnLCAnY2F0JyBdXFxuXFxuY29uc3Qgb2JqZWN0ID0geyB4OiAxMjMsIHk6IDQ1NiB9XFxuc2V0KG9iamVjdCwgJ3gnLCA3ODkpXFxuY29uc29sZS5sb2cob2JqZWN0KSAvLyB7IHg6IDEyMywgeTogNDU2IH1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiLFwiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIkNcIn0sXCJsaW5lXCI6MjQzN30se1widHlwZVBhcmFtc1wiOltcIlZcIixcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6NH19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjoyNDQyfSx7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiLFwiS1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvYmplY3RcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE3LFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJDXCJ9LFwiaW5kZXhcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifX19XSxcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjoyNDQ3fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiLFwiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjEwLFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo1fX0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjI0NDh9XX19LFwia2V5c1wiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiR2V0cyB0aGUga2V5cyBvZiBhIENvbGxlY3Rpb24sIE9iamVjdCwgb3IgQXJyYXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInNoYXBlXCIsXCJ0eXBlXCI6e1wia1wiOjYsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6NX19XSxcInR5cGVcIjp7XCJrXCI6MH19XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJTZXRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6NX1dfSxcImxpbmVcIjoyNDU3fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic2hhcGVcIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MH1dfX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIlNldFNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjo0fV19LFwibGluZVwiOjI0NTh9LHtcInR5cGVQYXJhbXNcIjpbXCJLXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInNoYXBlXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTmF0aXZlTWFwXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjowfV19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiU2V0U2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn1dfSxcImxpbmVcIjoyNDU5fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzaGFwZVwiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIk5hdGl2ZVNldFwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiU2V0U2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjoyNDYwfSx7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzaGFwZVwiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn0se1wia1wiOjB9XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJTZXRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifV19LFwibGluZVwiOjI0NjF9XX19LFwidmFsdWVzXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJHZXRzIHRoZSB2YWx1ZSBvZiBhIENvbGxlY3Rpb24sIE9iamVjdCwgb3IgQXJyYXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic2hhcGVcIixcInR5cGVcIjp7XCJrXCI6NixcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo1fX1dLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9fV19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiU2V0U2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjoyNDY2fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzaGFwZVwiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJTZXRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjI0Njd9LHtcInR5cGVQYXJhbXNcIjpbXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInNoYXBlXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTmF0aXZlTWFwXCIsXCJhcmdzXCI6W3tcImtcIjowfSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiU2V0U2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjoyNDY4fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzaGFwZVwiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIk5hdGl2ZVNldFwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiU2V0U2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjoyNDY5fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzaGFwZVwiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjB9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJTZXRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjI0NzB9XX19LFwiZW50cmllc1wiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiR2V0cyB0aGUgZW50cmllcyBvZiBhIENvbGxlY3Rpb24sIE9iamVjdCwgb3IgQXJyYXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic2hhcGVcIixcInR5cGVcIjp7XCJrXCI6NixcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo1fX1dLFwidHlwZVwiOntcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9fV19fV0sXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiU2V0U2VxdWVuY2VcIixcImFyZ3NcIjpbe1wia1wiOjE2LFwidHlwZXNcIjpbe1wia1wiOjV9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX1dfSxcImxpbmVcIjoyNDc1fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzaGFwZVwiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJTZXRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTYsXCJ0eXBlc1wiOlt7XCJrXCI6NH0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfV19LFwibGluZVwiOjI0NzZ9LHtcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInNoYXBlXCIsXCJ0eXBlXCI6e1wia1wiOjExLFwibmFtZVwiOlwiTmF0aXZlTWFwXCIsXCJhcmdzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJTZXRTZXF1ZW5jZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTYsXCJ0eXBlc1wiOlt7XCJrXCI6MTAsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTAsXCJwYXJhbVwiOlwiVlwifV19XX0sXCJsaW5lXCI6MjQ3N30se1widHlwZVBhcmFtc1wiOltcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic2hhcGVcIixcInR5cGVcIjp7XCJrXCI6MTEsXCJuYW1lXCI6XCJOYXRpdmVTZXRcIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIlNldFNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjoxNixcInR5cGVzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX1dfSxcImxpbmVcIjoyNDc4fSx7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzaGFwZVwiLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjEwLFwicGFyYW1cIjpcIktcIn0se1wia1wiOjEwLFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjoxMSxcIm5hbWVcIjpcIlNldFNlcXVlbmNlXCIsXCJhcmdzXCI6W3tcImtcIjoxNixcInR5cGVzXCI6W3tcImtcIjoxMCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjoxMCxcInBhcmFtXCI6XCJWXCJ9XX1dfSxcImxpbmVcIjoyNDc5fV19fX19XX0iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBUeXBlS2luZCA9IHtcbiAgQW55OiAwLFxuXG4gIE51bGw6IDEsXG4gIFZvaWQ6IDIsXG4gIEJvb2xlYW46IDMsXG4gIE51bWJlcjogNCxcbiAgU3RyaW5nOiA1LFxuICBPYmplY3Q6IDYsXG4gIEFycmF5OiA3LFxuICBOZXZlcjogOCxcbiAgRnVuY3Rpb246IDksXG5cbiAgUGFyYW06IDEwLFxuICBUeXBlOiAxMSxcblxuICBUaGlzOiAxMixcbiAgVW5kZWZpbmVkOiAxMyxcbiAgVW5pb246IDE0LFxuICBJbnRlcnNlY3Rpb246IDE1LFxuICBUdXBsZTogMTYsXG4gIEluZGV4ZWQ6IDE3LFxuICBPcGVyYXRvcjogMThcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZUtpbmQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciAkX18wPSAgICByZXF1aXJlKFwiLi4vLi5cIiksU2VxPSRfXzAuU2VxO1xudmFyIGdldERlZkJ5UGF0aCA9IHJlcXVpcmUoXCIuL2dldERlZkJ5UGF0aFwiKTtcblxuZnVuY3Rpb24gY29sbGVjdE1lbWJlckdyb3VwcyhpbnRlcmZhY2VEZWYsIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgbWVtYmVycyA9IHt9O1xuXG4gIGlmIChpbnRlcmZhY2VEZWYpIHtcbiAgICBjb2xsZWN0RnJvbURlZihpbnRlcmZhY2VEZWYpO1xuICB9XG5cbiAgdmFyIGdyb3VwcyA9IHsgXCJcIjogW10gfTtcblxuICBpZiAob3B0aW9ucy5zaG93SW5Hcm91cHMpIHtcbiAgICBTZXEobWVtYmVycykuZm9yRWFjaChmdW5jdGlvbihtZW1iZXIpICB7XG4gICAgICAoZ3JvdXBzW21lbWJlci5ncm91cF0gfHwgKGdyb3Vwc1ttZW1iZXIuZ3JvdXBdID0gW10pKS5wdXNoKG1lbWJlcik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZ3JvdXBzW1wiXCJdID0gU2VxKG1lbWJlcnMpXG4gICAgICAuc29ydEJ5KGZ1bmN0aW9uKG1lbWJlcikgIHtyZXR1cm4gbWVtYmVyLm1lbWJlck5hbWU7fSlcbiAgICAgIC50byhBcnJheSk7XG4gIH1cblxuICByZXR1cm4gZ3JvdXBzO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3RGcm9tRGVmKGRlZiwgbmFtZSkge1xuICAgIGRlZi5leHRlbmRzICYmXG4gICAgICBkZWYuZXh0ZW5kcy5mb3JFYWNoKGZ1bmN0aW9uKGUpICB7XG4gICAgICAgIHZhciBzdXBlck1vZHVsZSA9IGdldERlZkJ5UGF0aChlLm5hbWUpO1xuICAgICAgICB2YXIgc3VwZXJJbnRlcmZhY2UgPSBzdXBlck1vZHVsZSAmJiBzdXBlck1vZHVsZS5pbnRlcmZhY2U7XG4gICAgICAgIGlmIChzdXBlckludGVyZmFjZSkge1xuICAgICAgICAgIGNvbGxlY3RGcm9tRGVmKHN1cGVySW50ZXJmYWNlLCBlLm5hbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIGRlZi5ncm91cHMgJiZcbiAgICAgIGRlZi5ncm91cHMuZm9yRWFjaChmdW5jdGlvbihnKSAge1xuICAgICAgICBTZXEoZy5tZW1iZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG1lbWJlckRlZiwgbWVtYmVyTmFtZSkgIHtcbiAgICAgICAgICBjb2xsZWN0TWVtYmVyKGcudGl0bGUgfHwgXCJcIiwgbWVtYmVyTmFtZSwgbWVtYmVyRGVmKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGNvbGxlY3RNZW1iZXIoZ3JvdXAsIG1lbWJlck5hbWUsIG1lbWJlckRlZikge1xuICAgICAgdmFyIG1lbWJlciA9IG1lbWJlcnNbbWVtYmVyTmFtZV07XG4gICAgICBpZiAobWVtYmVyKSB7XG4gICAgICAgIGlmICghbWVtYmVyLmluaGVyaXRlZCkge1xuICAgICAgICAgIG1lbWJlci5vdmVycmlkZXMgPSB7IG5hbWU6bmFtZSwgZGVmOmRlZiwgbWVtYmVyRGVmOm1lbWJlckRlZiB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWVtYmVyLmdyb3VwICYmIGdyb3VwKSB7XG4gICAgICAgICAgbWVtYmVyLmdyb3VwID0gZ3JvdXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lbWJlciA9IHtcbiAgICAgICAgICBncm91cDpncm91cCxcbiAgICAgICAgICBtZW1iZXJOYW1lOiBtZW1iZXJOYW1lLnN1YnN0cigxKSxcbiAgICAgICAgICBtZW1iZXJEZWY6bWVtYmVyRGVmXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkZWYgIT09IGludGVyZmFjZURlZikge1xuICAgICAgICAgIG1lbWJlci5pbmhlcml0ZWQgPSB7IG5hbWU6bmFtZSwgZGVmOmRlZiB9O1xuICAgICAgICB9XG4gICAgICAgIG1lbWJlcnNbbWVtYmVyTmFtZV0gPSBtZW1iZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29sbGVjdE1lbWJlckdyb3VwcztcbiIsIi8vIE5vdGU6IGludGVudGlvbmFsbHkgdXNpbmcgcmF3IGRlZnMsIG5vdCBnZXRUeXBlRGVmcyB0byBhdm9pZCBjaXJjdWxhciByZWYuXG52YXIgZGVmcyA9IHJlcXVpcmUoXCIuLi9nZW5lcmF0ZWQvc2VxdWlucy5kLmpzb25cIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0QnlQYXRoKHBhdGgpIHtcbiAgaWYgKCFwYXRoKSB7XG4gICAgcmV0dXJuIGRlZnM7XG4gIH1cblxuICB2YXIgcGF0aFNlZ21lbnRzO1xuICBpZiAodHlwZW9mIHBhdGggPT09IFwic3RyaW5nXCIpIHtcbiAgICBwYXRoU2VnbWVudHMgPSBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgfSBlbHNlIHtcbiAgICBwYXRoU2VnbWVudHMgPSBwYXRoO1xuICB9XG5cbiAgdmFyIGRlZiA9IGRlZnMuZ3JvdXBzLmZpbmQoZnVuY3Rpb24oZ3JvdXApICB7cmV0dXJuIGdyb3VwLm1lbWJlcnNbcGF0aFNlZ21lbnRzWzBdXTt9KS5tZW1iZXJzW1xuICAgIHBhdGhTZWdtZW50c1swXVxuICBdO1xuXG4gIHBhdGhTZWdtZW50cy5zbGljZSgxKS5mb3JFYWNoKGZ1bmN0aW9uKHBhcnQpICB7XG4gICAgZGVmID1cbiAgICAgIGRlZiAmJlxuICAgICAgZGVmLm1vZHVsZSAmJlxuICAgICAgZGVmLm1vZHVsZS5ncm91cHMuZmluZChmdW5jdGlvbihncm91cCkgIHtyZXR1cm4gZ3JvdXAubWVtYmVyc1twYXJ0XTt9KS5tZW1iZXJzW3BhcnRdO1xuICB9KTtcblxuICByZXR1cm4gZGVmO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIG1hcmtkb3duRG9jcyA9IHJlcXVpcmUoXCIuL21hcmtkb3duRG9jc1wiKTtcbnZhciBkZWZzID0gcmVxdWlyZShcIi4uL2dlbmVyYXRlZC9zZXF1aW5zLmQuanNvblwiKTtcblxubWFya2Rvd25Eb2NzKGRlZnMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZnM7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciAkX18wPSAgICByZXF1aXJlKFwiLi4vLi5cIiksU2VxPSRfXzAuU2VxO1xudmFyIG1hcmtlZCA9IHJlcXVpcmUoXCJtYXJrZWRcIik7XG52YXIgcHJpc20gPSByZXF1aXJlKFwiLi9wcmlzbVwiKTtcbnZhciBjb2xsZWN0TWVtYmVyR3JvdXBzID0gcmVxdWlyZShcIi4vY29sbGVjdE1lbWJlckdyb3Vwc1wiKTtcbi8vIE5vdGU6IGludGVudGlvbmFsbHkgdXNpbmcgcmF3IGRlZnMsIG5vdCBnZXRUeXBlRGVmcyB0byBhdm9pZCBjaXJjdWxhciByZWYuXG52YXIgZGVmcyA9IHJlcXVpcmUoXCIuLi9nZW5lcmF0ZWQvc2VxdWlucy5kLmpzb25cIik7XG5cbmZ1bmN0aW9uIGNvbGxlY3RBbGxNZW1iZXJzRm9yQWxsVHlwZXMoZGVmcykge1xuICB2YXIgYWxsTWVtYmVycyA9IG5ldyBXZWFrTWFwKCk7XG4gIF9jb2xsZWN0QWxsTWVtYmVyc0ZvckFsbFR5cGVzKGRlZnMpO1xuICByZXR1cm4gYWxsTWVtYmVycztcbiAgZnVuY3Rpb24gX2NvbGxlY3RBbGxNZW1iZXJzRm9yQWxsVHlwZXMoZGVmcykge1xuICAgIFNlcShkZWZzKS5mb3JFYWNoKGZ1bmN0aW9uKGRlZikgIHtcbiAgICAgIGlmIChkZWYuaW50ZXJmYWNlKSB7XG4gICAgICAgIHZhciBncm91cHMgPSBjb2xsZWN0TWVtYmVyR3JvdXBzKGRlZi5pbnRlcmZhY2UpO1xuICAgICAgICBhbGxNZW1iZXJzLnNldChcbiAgICAgICAgICBkZWYuaW50ZXJmYWNlLFxuICAgICAgICAgIFNlcS5LZXllZChcbiAgICAgICAgICAgIGdyb3Vwc1tcIlwiXS5tYXAoZnVuY3Rpb24obWVtYmVyKSAge3JldHVybiBbbWVtYmVyLm1lbWJlck5hbWUsIG1lbWJlci5tZW1iZXJEZWZdO30pXG4gICAgICAgICAgKS50byhPYmplY3QpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZGVmLm1vZHVsZSkge1xuICAgICAgICBfY29sbGVjdEFsbE1lbWJlcnNGb3JBbGxUeXBlcyhkZWYubW9kdWxlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYWxsTWVtYmVycztcbiAgfVxufVxuXG52YXIgYWxsTWVtYmVycyA9IGNvbGxlY3RBbGxNZW1iZXJzRm9yQWxsVHlwZXMoZGVmcyk7XG5cbi8vIGZ1bmN0aW9ucyBjb21lIGJlZm9yZSBrZXl3b3Jkc1xucHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZShcImphdmFzY3JpcHRcIiwgXCJrZXl3b3JkXCIsIHtcbiAgdmFyOiAvXFxiKHRoaXMpXFxiL2csXG4gIFwiYmxvY2sta2V5d29yZFwiOiAvXFxiKGlmfGVsc2V8d2hpbGV8Zm9yfGZ1bmN0aW9uKVxcYi9nLFxuICBwcmltaXRpdmU6IC9cXGIodHJ1ZXxmYWxzZXxudWxsfHVuZGVmaW5lZClcXGIvZyxcbiAgZnVuY3Rpb246IHByaXNtLmxhbmd1YWdlcy5mdW5jdGlvblxufSk7XG5cbm1hcmtlZC5zZXRPcHRpb25zKHtcbiAgeGh0bWw6IHRydWUsXG4gIGhpZ2hsaWdodDogZnVuY3Rpb24oY29kZSkgIHtyZXR1cm4gcHJpc20uaGlnaGxpZ2h0KGNvZGUsIHByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0KTt9XG59KTtcblxudmFyIHJlbmRlcmVyID0gbmV3IG1hcmtlZC5SZW5kZXJlcigpO1xuXG5jb25zdCBydW5raXRSZWdFeHAgPSAvXjwhLS1cXHMqcnVua2l0OmFjdGl2YXRlKCgufFxcbikqKS0tPigufFxcbikqJC87XG5jb25zdCBydW5raXRDb250ZXh0ID0geyBvcHRpb25zOiBcInt9XCIsIGFjdGl2YXRlZDogZmFsc2UgfTtcblxucmVuZGVyZXIuaHRtbCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgY29uc3QgcmVzdWx0ID0gcnVua2l0UmVnRXhwLmV4ZWModGV4dCk7XG5cbiAgaWYgKCFyZXN1bHQpIHJldHVybiB0ZXh0O1xuXG4gIHJ1bmtpdENvbnRleHQuYWN0aXZhdGVkID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICBydW5raXRDb250ZXh0Lm9wdGlvbnMgPSByZXN1bHRbMV0gPyBKU09OLnBhcnNlKHJlc3VsdFsxXSkgOiB7fTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJ1bmtpdENvbnRleHQub3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB0ZXh0O1xufTtcblxucmVuZGVyZXIuY29kZSA9IGZ1bmN0aW9uKGNvZGUsIGxhbmcsIGVzY2FwZWQpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICB2YXIgb3V0ID0gdGhpcy5vcHRpb25zLmhpZ2hsaWdodChjb2RlLCBsYW5nKTtcbiAgICBpZiAob3V0ICE9IG51bGwgJiYgb3V0ICE9PSBjb2RlKSB7XG4gICAgICBlc2NhcGVkID0gdHJ1ZTtcbiAgICAgIGNvZGUgPSBvdXQ7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcnVuSXRCdXR0b24gPSBydW5raXRDb250ZXh0LmFjdGl2YXRlZFxuICAgID8gJzxhIGNsYXNzPVwidHJ5LWl0XCIgZGF0YS1vcHRpb25zPVwiJyArXG4gICAgICBlc2NhcGUoSlNPTi5zdHJpbmdpZnkocnVua2l0Q29udGV4dC5vcHRpb25zKSkgK1xuICAgICAgJ1wiIG9uQ2xpY2s9XCJydW5JdCh0aGlzKVwiPnJ1biBpdDwvYT4nXG4gICAgOiBcIlwiO1xuXG4gIHJ1bmtpdENvbnRleHQuYWN0aXZhdGVkID0gZmFsc2U7XG4gIHJ1bmtpdENvbnRleHQub3B0aW9ucyA9IFwie31cIjtcblxuICByZXR1cm4gKFxuICAgICc8Y29kZSBjbGFzcz1cImNvZGVCbG9ja1wiPicgK1xuICAgIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZUNvZGUoY29kZSwgdHJ1ZSkpICtcbiAgICBydW5JdEJ1dHRvbiArXG4gICAgXCI8L2NvZGU+XCJcbiAgKTtcbn07XG5cbnZhciBNRVRIT0RfUlggPSAvXihcXHcrKSg/OlsjLl0oXFx3KykpPyg/OlxcKFxcKSk/JC87XG52YXIgUEFSQU1fUlggPSAvXlxcdyskLztcbnZhciBNRE5fVFlQRVMgPSB7XG4gIEFycmF5OiB0cnVlLFxuICBPYmplY3Q6IHRydWUsXG4gIEpTT046IHRydWVcbn07XG52YXIgTUROX0JBU0VfVVJMID1cbiAgXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9cIjtcblxucmVuZGVyZXIuY29kZXNwYW4gPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiBcIjxjb2RlPlwiICsgZGVjb3JhdGVDb2RlU3Bhbih0ZXh0LCB0aGlzLm9wdGlvbnMpICsgXCI8L2NvZGU+XCI7XG59O1xuXG5mdW5jdGlvbiBkZWNvcmF0ZUNvZGVTcGFuKHRleHQsIG9wdGlvbnMpIHtcbiAgdmFyIGNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQ7XG5cbiAgaWYgKFxuICAgIGNvbnRleHQuc2lnbmF0dXJlcyAmJlxuICAgIFBBUkFNX1JYLnRlc3QodGV4dCkgJiZcbiAgICBjb250ZXh0LnNpZ25hdHVyZXMuc29tZShcbiAgICAgIGZ1bmN0aW9uKHNpZykgIHtyZXR1cm4gc2lnLnBhcmFtcyAmJiBzaWcucGFyYW1zLnNvbWUoZnVuY3Rpb24ocGFyYW0pICB7cmV0dXJuIHBhcmFtLm5hbWUgPT09IHRleHQ7fSk7fVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuICc8c3BhbiBjbGFzcz1cInQgcGFyYW1cIj4nICsgdGV4dCArIFwiPC9zcGFuPlwiO1xuICB9XG5cbiAgdmFyIG1ldGhvZCA9IE1FVEhPRF9SWC5leGVjKHRleHQpO1xuICBpZiAobWV0aG9kKSB7XG4gICAgbWV0aG9kID0gbWV0aG9kLnNsaWNlKDEpLmZpbHRlcihCb29sZWFuKTtcbiAgICBpZiAoTUROX1RZUEVTW21ldGhvZFswXV0pIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgICc8YSBocmVmPVwiJyArIE1ETl9CQVNFX1VSTCArIG1ldGhvZC5qb2luKFwiL1wiKSArICdcIj4nICsgdGV4dCArIFwiPC9hPlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBjb250ZXh0LnR5cGVQYXRoICYmXG4gICAgICAhYXJyRW5kc1dpdGgoY29udGV4dC50eXBlUGF0aCwgbWV0aG9kKSAmJlxuICAgICAgIWFyckVuZHNXaXRoKGNvbnRleHQudHlwZVBhdGguc2xpY2UoMCwgLTEpLCBtZXRob2QpXG4gICAgKSB7XG4gICAgICB2YXIgcGF0aCA9IGZpbmRQYXRoKGNvbnRleHQsIG1ldGhvZCk7XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICB2YXIgcmVsUGF0aCA9IGNvbnRleHQucmVsUGF0aCB8fCBcIlwiO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICc8YSB0YXJnZXQ9XCJfc2VsZlwiIGhyZWY9XCInICtcbiAgICAgICAgICByZWxQYXRoICtcbiAgICAgICAgICBcIiMvXCIgK1xuICAgICAgICAgIHBhdGguc2xpY2UoMSkuam9pbihcIi9cIikgK1xuICAgICAgICAgICdcIj4nICtcbiAgICAgICAgICB0ZXh0ICtcbiAgICAgICAgICBcIjwvYT5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zLmhpZ2hsaWdodCkge1xuICAgIHJldHVybiBvcHRpb25zLmhpZ2hsaWdodCh1bmVzY2FwZUNvZGUodGV4dCksIHByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0KTtcbiAgfVxuXG4gIHJldHVybiB0ZXh0O1xufVxuXG5mdW5jdGlvbiBhcnJFbmRzV2l0aChhcnIxLCBhcnIyKSB7XG4gIGZvciAodmFyIGlpID0gMTsgaWkgPD0gYXJyMi5sZW5ndGg7IGlpKyspIHtcbiAgICBpZiAoYXJyMlthcnIyLmxlbmd0aCAtIGlpXSAhPT0gYXJyMVthcnIxLmxlbmd0aCAtIGlpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZmluZFBhdGgoY29udGV4dCwgc2VhcmNoKSB7XG4gIHZhciByZWxhdGl2ZSA9IGNvbnRleHQudHlwZVBhdGg7XG5cbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8PSByZWxhdGl2ZS5sZW5ndGg7IGlpKyspIHtcbiAgICB2YXIgcGF0aCA9IHJlbGF0aXZlLnNsaWNlKDAsIHJlbGF0aXZlLmxlbmd0aCAtIGlpKS5jb25jYXQoc2VhcmNoKTtcbiAgICBpZiAoXG4gICAgICBwYXRoLnJlZHVjZShcbiAgICAgICAgZnVuY3Rpb24oZGVmLCBuYW1lKSBcbiAgICAgICAgICB7cmV0dXJuIGRlZiAmJlxuICAgICAgICAgICgoZGVmLm1vZHVsZSAmJiBkZWYubW9kdWxlW25hbWVdKSB8fFxuICAgICAgICAgICAgKGRlZi5pbnRlcmZhY2UgJiZcbiAgICAgICAgICAgICAgYWxsTWVtYmVycyAmJlxuICAgICAgICAgICAgICBhbGxNZW1iZXJzLmdldChkZWYuaW50ZXJmYWNlKVtuYW1lXSkgfHxcbiAgICAgICAgICAgIHVuZGVmaW5lZCk7fSxcbiAgICAgICAgeyBtb2R1bGU6IGRlZnMgfVxuICAgICAgKVxuICAgICkge1xuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUNvZGUoY29kZSkge1xuICByZXR1cm4gY29kZVxuICAgIC5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIilcbiAgICAucmVwbGFjZSgvPC9nLCBcIiZsdDtcIilcbiAgICAucmVwbGFjZSgvPi9nLCBcIiZndDtcIilcbiAgICAucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIilcbiAgICAucmVwbGFjZSgvJy9nLCBcIiYjMzk7XCIpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZUNvZGUoY29kZSkge1xuICByZXR1cm4gY29kZVxuICAgIC5yZXBsYWNlKC8mbHQ7L2csIFwiPFwiKVxuICAgIC5yZXBsYWNlKC8mZ3Q7L2csIFwiPlwiKVxuICAgIC5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJylcbiAgICAucmVwbGFjZSgvJiMzOTsvZywgXCInXCIpXG4gICAgLnJlcGxhY2UoLyZhbXA7L2csIFwiJlwiKTtcbn1cblxuZnVuY3Rpb24gbWFya2Rvd24oY29udGVudCwgY29udGV4dCkge1xuICBjb250ZXh0IHx8IChjb250ZXh0ID0ge30pO1xuICByZXR1cm4gY29udGVudCA/IG1hcmtlZChjb250ZW50LCB7IHJlbmRlcmVyOnJlbmRlcmVyLCBjb250ZXh0OmNvbnRleHQgfSkgOiBjb250ZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcmtkb3duO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgJF9fMD0gICAgcmVxdWlyZShcIi4uLy4uXCIpLFNlcT0kX18wLlNlcTtcbnZhciBtYXJrZG93biA9IHJlcXVpcmUoXCIuL21hcmtkb3duXCIpO1xuXG52YXIgbm90ZVR5cGVzVG9QcmVzZXJ2ZSA9IFtcImFsaWFzXCIsIFwibWVtYmVyb2ZcIiwgXCJwcmFnbWFcIl07XG5cbmZ1bmN0aW9uIG1hcmtkb3duRG9jcyhkZWZzKSB7XG4gIG1hcmtkb3duVHlwZXMoZGVmcywgW10pO1xuXG4gIGZ1bmN0aW9uIG1hcmtkb3duVHlwZSh0eXBlRGVmLCB0eXBlTmFtZSwgdHlwZVBhdGgpIHtcbiAgICBtYXJrZG93bkRvYyh0eXBlRGVmLmRvYywgeyB0eXBlUGF0aDp0eXBlUGF0aCB9KTtcbiAgICB0eXBlRGVmLmNhbGwgJiZcbiAgICAgIG1hcmtkb3duRG9jKHR5cGVEZWYuY2FsbC5kb2MsIHtcbiAgICAgICAgdHlwZVBhdGg6dHlwZVBhdGgsXG4gICAgICAgIHNpZ25hdHVyZXM6IHR5cGVEZWYuY2FsbC5zaWduYXR1cmVzXG4gICAgICB9KTtcbiAgICB2YXIgY2xhc3NMaWtlRG9jID0gdHlwZURlZi5jbGFzcyB8fCB0eXBlRGVmLmludGVyZmFjZTtcbiAgICBpZiAoY2xhc3NMaWtlRG9jKSB7XG4gICAgICBtYXJrZG93bkRvYyhjbGFzc0xpa2VEb2MuZG9jLCB7IGRlZnM6ZGVmcywgdHlwZVBhdGg6dHlwZVBhdGggfSk7XG4gICAgICBTZXEoY2xhc3NMaWtlRG9jLmdyb3VwcykuZm9yRWFjaChmdW5jdGlvbihncm91cCkgXG4gICAgICAgIHtyZXR1cm4gU2VxKGdyb3VwLm1lbWJlcnMpLmZvckVhY2goZnVuY3Rpb24obWVtYmVyLCBtZW1iZXJOYW1lKSBcbiAgICAgICAgICB7cmV0dXJuIG1hcmtkb3duRG9jKG1lbWJlci5kb2MsIHtcbiAgICAgICAgICAgIHR5cGVQYXRoOiB0eXBlUGF0aC5jb25jYXQobWVtYmVyTmFtZS5zbGljZSgxKSksXG4gICAgICAgICAgICBzaWduYXR1cmVzOiBtZW1iZXIuc2lnbmF0dXJlc1xuICAgICAgICAgIH0pO31cbiAgICAgICAgKTt9XG4gICAgICApO1xuICAgIH1cbiAgICB0eXBlRGVmLm1vZHVsZSAmJiBtYXJrZG93blR5cGVzKHR5cGVEZWYubW9kdWxlLCB0eXBlUGF0aCk7XG4gICAgdHlwZURlZi5jbGFzcyAmJlxuICAgICAgdHlwZURlZi5jbGFzcy5zdGF0aWNzICYmXG4gICAgICBtYXJrZG93blR5cGVzKHR5cGVEZWYuY2xhc3Muc3RhdGljcywgdHlwZVBhdGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFya2Rvd25UeXBlcyh0eXBlRGVmcywgcGF0aCkge1xuICAgIGlmICh0eXBlRGVmcy5ncm91cHMpIHtcbiAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgdHlwZURlZnMuZ3JvdXBzKSB7XG4gICAgICAgIFNlcShncm91cC5tZW1iZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG1lbWJlckRlZiwgbWVtYmVyTmFtZSkgIHtcbiAgICAgICAgICBtYXJrZG93blR5cGUobWVtYmVyRGVmLCBtZW1iZXJOYW1lLCBwYXRoLmNvbmNhdChtZW1iZXJOYW1lKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBTZXEodHlwZURlZnMpLmZvckVhY2goZnVuY3Rpb24odHlwZURlZiwgdHlwZU5hbWUpICB7XG4gICAgICAgIG1hcmtkb3duVHlwZSh0eXBlRGVmLCB0eXBlTmFtZSwgcGF0aC5jb25jYXQodHlwZU5hbWUpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrZG93bkRvYyhkb2MsIGNvbnRleHQpIHtcbiAgaWYgKCFkb2MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZG9jLnN5bm9wc2lzICYmIChkb2Muc3lub3BzaXMgPSBtYXJrZG93bihkb2Muc3lub3BzaXMsIGNvbnRleHQpKTtcbiAgZG9jLmRlc2NyaXB0aW9uICYmIChkb2MuZGVzY3JpcHRpb24gPSBtYXJrZG93bihkb2MuZGVzY3JpcHRpb24sIGNvbnRleHQpKTtcbiAgZG9jLm5vdGVzICYmXG4gICAgZG9jLm5vdGVzLmZvckVhY2goZnVuY3Rpb24obm90ZSkgIHtcbiAgICAgIGlmICghbm90ZVR5cGVzVG9QcmVzZXJ2ZS5pbmNsdWRlcyhub3RlLm5hbWUpKSB7XG4gICAgICAgIG5vdGUuYm9keSA9IG1hcmtkb3duKG5vdGUuYm9keSwgY29udGV4dCk7XG4gICAgICB9XG4gICAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFya2Rvd25Eb2NzO1xuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1jb3JlLmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbnNlbGYgPVxuICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiXG4gICAgPyB3aW5kb3cgLy8gaWYgaW4gYnJvd3NlclxuICAgIDogdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGVcbiAgICA/IHNlbGYgLy8gaWYgaW4gd29ya2VyXG4gICAgOiB7fTsgLy8gaWYgaW4gbm9kZSBqc1xuXG4vKipcbiAqIFByaXNtOiBMaWdodHdlaWdodCwgcm9idXN0LCBlbGVnYW50IHN5bnRheCBoaWdobGlnaHRpbmdcbiAqIE1JVCBsaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwL1xuICogQGF1dGhvciBMZWEgVmVyb3UgaHR0cDovL2xlYS52ZXJvdS5tZVxuICovXG5cbnZhciBQcmlzbSA9IChmdW5jdGlvbigpIHtcbiAgLy8gUHJpdmF0ZSBoZWxwZXIgdmFyc1xuICB2YXIgbGFuZyA9IC9cXGJsYW5nKD86dWFnZSk/LSg/IVxcKikoXFx3KylcXGIvaTtcblxuICB2YXIgXyA9IChzZWxmLlByaXNtID0ge1xuICAgIHV0aWw6IHtcbiAgICAgIGVuY29kZTogZnVuY3Rpb24odG9rZW5zKSB7XG4gICAgICAgIGlmICh0b2tlbnMgaW5zdGFuY2VvZiBUb2tlbikge1xuICAgICAgICAgIHJldHVybiBuZXcgVG9rZW4oXG4gICAgICAgICAgICB0b2tlbnMudHlwZSxcbiAgICAgICAgICAgIF8udXRpbC5lbmNvZGUodG9rZW5zLmNvbnRlbnQpLFxuICAgICAgICAgICAgdG9rZW5zLmFsaWFzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChfLnV0aWwudHlwZSh0b2tlbnMpID09PSBcIkFycmF5XCIpIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW5zLm1hcChfLnV0aWwuZW5jb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW5zXG4gICAgICAgICAgICAucmVwbGFjZSgvJi9nLCBcIiZhbXA7XCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvPC9nLCBcIiZsdDtcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHUwMGEwL2csIFwiIFwiKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdHlwZTogZnVuY3Rpb24obykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLm1hdGNoKC9cXFtvYmplY3QgKFxcdyspXFxdLylbMV07XG4gICAgICB9LFxuXG4gICAgICAvLyBEZWVwIGNsb25lIGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiAoZS5nLiB0byBleHRlbmQgaXQpXG4gICAgICBjbG9uZTogZnVuY3Rpb24obykge1xuICAgICAgICB2YXIgdHlwZSA9IF8udXRpbC50eXBlKG8pO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJPYmplY3RcIjpcbiAgICAgICAgICAgIHZhciBjbG9uZSA9IHt9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbykge1xuICAgICAgICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgY2xvbmVba2V5XSA9IF8udXRpbC5jbG9uZShvW2tleV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblxuICAgICAgICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgICAgICAgcmV0dXJuIG8uc2xpY2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBsYW5ndWFnZXM6IHtcbiAgICAgIGV4dGVuZDogZnVuY3Rpb24oaWQsIHJlZGVmKSB7XG4gICAgICAgIHZhciBsYW5nID0gXy51dGlsLmNsb25lKF8ubGFuZ3VhZ2VzW2lkXSk7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHJlZGVmKSB7XG4gICAgICAgICAgbGFuZ1trZXldID0gcmVkZWZba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYW5nO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBJbnNlcnQgYSB0b2tlbiBiZWZvcmUgYW5vdGhlciB0b2tlbiBpbiBhIGxhbmd1YWdlIGxpdGVyYWxcbiAgICAgICAqIEFzIHRoaXMgbmVlZHMgdG8gcmVjcmVhdGUgdGhlIG9iamVjdCAod2UgY2Fubm90IGFjdHVhbGx5IGluc2VydCBiZWZvcmUga2V5cyBpbiBvYmplY3QgbGl0ZXJhbHMpLFxuICAgICAgICogd2UgY2Fubm90IGp1c3QgcHJvdmlkZSBhbiBvYmplY3QsIHdlIG5lZWQgYW5vYmplY3QgYW5kIGEga2V5LlxuICAgICAgICogQHBhcmFtIGluc2lkZSBUaGUga2V5IChvciBsYW5ndWFnZSBpZCkgb2YgdGhlIHBhcmVudFxuICAgICAgICogQHBhcmFtIGJlZm9yZSBUaGUga2V5IHRvIGluc2VydCBiZWZvcmUuIElmIG5vdCBwcm92aWRlZCwgdGhlIGZ1bmN0aW9uIGFwcGVuZHMgaW5zdGVhZC5cbiAgICAgICAqIEBwYXJhbSBpbnNlcnQgT2JqZWN0IHdpdGggdGhlIGtleS92YWx1ZSBwYWlycyB0byBpbnNlcnRcbiAgICAgICAqIEBwYXJhbSByb290IFRoZSBvYmplY3QgdGhhdCBjb250YWlucyBgaW5zaWRlYC4gSWYgZXF1YWwgdG8gUHJpc20ubGFuZ3VhZ2VzLCBpdCBjYW4gYmUgb21pdHRlZC5cbiAgICAgICAqL1xuICAgICAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbihpbnNpZGUsIGJlZm9yZSwgaW5zZXJ0LCByb290KSB7XG4gICAgICAgIHJvb3QgPSByb290IHx8IF8ubGFuZ3VhZ2VzO1xuICAgICAgICB2YXIgZ3JhbW1hciA9IHJvb3RbaW5zaWRlXTtcblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgaW5zZXJ0ID0gYXJndW1lbnRzWzFdO1xuXG4gICAgICAgICAgZm9yICh2YXIgbmV3VG9rZW4gaW4gaW5zZXJ0KSB7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0Lmhhc093blByb3BlcnR5KG5ld1Rva2VuKSkge1xuICAgICAgICAgICAgICBncmFtbWFyW25ld1Rva2VuXSA9IGluc2VydFtuZXdUb2tlbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGdyYW1tYXI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmV0ID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgdG9rZW4gaW4gZ3JhbW1hcikge1xuICAgICAgICAgIGlmIChncmFtbWFyLmhhc093blByb3BlcnR5KHRva2VuKSkge1xuICAgICAgICAgICAgaWYgKHRva2VuID09IGJlZm9yZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBuZXdUb2tlbiBpbiBpbnNlcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0Lmhhc093blByb3BlcnR5KG5ld1Rva2VuKSkge1xuICAgICAgICAgICAgICAgICAgcmV0W25ld1Rva2VuXSA9IGluc2VydFtuZXdUb2tlbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldFt0b2tlbl0gPSBncmFtbWFyW3Rva2VuXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgcmVmZXJlbmNlcyBpbiBvdGhlciBsYW5ndWFnZSBkZWZpbml0aW9uc1xuICAgICAgICBfLmxhbmd1YWdlcy5ERlMoXy5sYW5ndWFnZXMsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPT09IHJvb3RbaW5zaWRlXSAmJiBrZXkgIT0gaW5zaWRlKSB7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSByZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gKHJvb3RbaW5zaWRlXSA9IHJldCk7XG4gICAgICB9LFxuXG4gICAgICAvLyBUcmF2ZXJzZSBhIGxhbmd1YWdlIGRlZmluaXRpb24gd2l0aCBEZXB0aCBGaXJzdCBTZWFyY2hcbiAgICAgIERGUzogZnVuY3Rpb24obywgY2FsbGJhY2ssIHR5cGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBvKSB7XG4gICAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwobywgaSwgb1tpXSwgdHlwZSB8fCBpKTtcblxuICAgICAgICAgICAgaWYgKF8udXRpbC50eXBlKG9baV0pID09PSBcIk9iamVjdFwiKSB7XG4gICAgICAgICAgICAgIF8ubGFuZ3VhZ2VzLkRGUyhvW2ldLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF8udXRpbC50eXBlKG9baV0pID09PSBcIkFycmF5XCIpIHtcbiAgICAgICAgICAgICAgXy5sYW5ndWFnZXMuREZTKG9baV0sIGNhbGxiYWNrLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGlnaGxpZ2h0QWxsOiBmdW5jdGlvbihhc3luYywgY2FsbGJhY2spIHtcbiAgICAgIHZhciBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICdjb2RlW2NsYXNzKj1cImxhbmd1YWdlLVwiXSwgW2NsYXNzKj1cImxhbmd1YWdlLVwiXSBjb2RlLCBjb2RlW2NsYXNzKj1cImxhbmctXCJdLCBbY2xhc3MqPVwibGFuZy1cIl0gY29kZSdcbiAgICAgICk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBlbGVtZW50OyAoZWxlbWVudCA9IGVsZW1lbnRzW2krK10pOyApIHtcbiAgICAgICAgXy5oaWdobGlnaHRFbGVtZW50KGVsZW1lbnQsIGFzeW5jID09PSB0cnVlLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhpZ2hsaWdodEVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIGFzeW5jLCBjYWxsYmFjaykge1xuICAgICAgLy8gRmluZCBsYW5ndWFnZVxuICAgICAgdmFyIGxhbmd1YWdlLFxuICAgICAgICBncmFtbWFyLFxuICAgICAgICBwYXJlbnQgPSBlbGVtZW50O1xuXG4gICAgICB3aGlsZSAocGFyZW50ICYmICFsYW5nLnRlc3QocGFyZW50LmNsYXNzTmFtZSkpIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgbGFuZ3VhZ2UgPSAocGFyZW50LmNsYXNzTmFtZS5tYXRjaChsYW5nKSB8fCBbLCBcIlwiXSlbMV07XG4gICAgICAgIGdyYW1tYXIgPSBfLmxhbmd1YWdlc1tsYW5ndWFnZV07XG4gICAgICB9XG5cbiAgICAgIGlmICghZ3JhbW1hcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCBsYW5ndWFnZSBvbiB0aGUgZWxlbWVudCwgaWYgbm90IHByZXNlbnRcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID1cbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZShsYW5nLCBcIlwiKS5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKSArXG4gICAgICAgIFwiIGxhbmd1YWdlLVwiICtcbiAgICAgICAgbGFuZ3VhZ2U7XG5cbiAgICAgIC8vIFNldCBsYW5ndWFnZSBvbiB0aGUgcGFyZW50LCBmb3Igc3R5bGluZ1xuICAgICAgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuXG4gICAgICBpZiAoL3ByZS9pLnRlc3QocGFyZW50Lm5vZGVOYW1lKSkge1xuICAgICAgICBwYXJlbnQuY2xhc3NOYW1lID1cbiAgICAgICAgICBwYXJlbnQuY2xhc3NOYW1lLnJlcGxhY2UobGFuZywgXCJcIikucmVwbGFjZSgvXFxzKy9nLCBcIiBcIikgK1xuICAgICAgICAgIFwiIGxhbmd1YWdlLVwiICtcbiAgICAgICAgICBsYW5ndWFnZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvZGUgPSBlbGVtZW50LnRleHRDb250ZW50O1xuXG4gICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZW52ID0ge1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBsYW5ndWFnZTogbGFuZ3VhZ2UsXG4gICAgICAgIGdyYW1tYXI6IGdyYW1tYXIsXG4gICAgICAgIGNvZGU6IGNvZGVcbiAgICAgIH07XG5cbiAgICAgIF8uaG9va3MucnVuKFwiYmVmb3JlLWhpZ2hsaWdodFwiLCBlbnYpO1xuXG4gICAgICBpZiAoYXN5bmMgJiYgc2VsZi5Xb3JrZXIpIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIoXy5maWxlbmFtZSk7XG5cbiAgICAgICAgd29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgIGVudi5oaWdobGlnaHRlZENvZGUgPSBUb2tlbi5zdHJpbmdpZnkoSlNPTi5wYXJzZShldnQuZGF0YSksIGxhbmd1YWdlKTtcblxuICAgICAgICAgIF8uaG9va3MucnVuKFwiYmVmb3JlLWluc2VydFwiLCBlbnYpO1xuXG4gICAgICAgICAgZW52LmVsZW1lbnQuaW5uZXJIVE1MID0gZW52LmhpZ2hsaWdodGVkQ29kZTtcblxuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoZW52LmVsZW1lbnQpO1xuICAgICAgICAgIF8uaG9va3MucnVuKFwiYWZ0ZXItaGlnaGxpZ2h0XCIsIGVudik7XG4gICAgICAgIH07XG5cbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKFxuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGxhbmd1YWdlOiBlbnYubGFuZ3VhZ2UsXG4gICAgICAgICAgICBjb2RlOiBlbnYuY29kZVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnYuaGlnaGxpZ2h0ZWRDb2RlID0gXy5oaWdobGlnaHQoZW52LmNvZGUsIGVudi5ncmFtbWFyLCBlbnYubGFuZ3VhZ2UpO1xuXG4gICAgICAgIF8uaG9va3MucnVuKFwiYmVmb3JlLWluc2VydFwiLCBlbnYpO1xuXG4gICAgICAgIGVudi5lbGVtZW50LmlubmVySFRNTCA9IGVudi5oaWdobGlnaHRlZENvZGU7XG5cbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChlbGVtZW50KTtcblxuICAgICAgICBfLmhvb2tzLnJ1bihcImFmdGVyLWhpZ2hsaWdodFwiLCBlbnYpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBoaWdobGlnaHQ6IGZ1bmN0aW9uKHRleHQsIGdyYW1tYXIsIGxhbmd1YWdlKSB7XG4gICAgICB2YXIgdG9rZW5zID0gXy50b2tlbml6ZSh0ZXh0LCBncmFtbWFyKTtcbiAgICAgIHJldHVybiBUb2tlbi5zdHJpbmdpZnkoXy51dGlsLmVuY29kZSh0b2tlbnMpLCBsYW5ndWFnZSk7XG4gICAgfSxcblxuICAgIHRva2VuaXplOiBmdW5jdGlvbih0ZXh0LCBncmFtbWFyLCBsYW5ndWFnZSkge1xuICAgICAgdmFyIFRva2VuID0gXy5Ub2tlbjtcblxuICAgICAgdmFyIHN0cmFyciA9IFt0ZXh0XTtcblxuICAgICAgdmFyIHJlc3QgPSBncmFtbWFyLnJlc3Q7XG5cbiAgICAgIGlmIChyZXN0KSB7XG4gICAgICAgIGZvciAodmFyIHRva2VuIGluIHJlc3QpIHtcbiAgICAgICAgICBncmFtbWFyW3Rva2VuXSA9IHJlc3RbdG9rZW5dO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIGdyYW1tYXIucmVzdDtcbiAgICAgIH1cblxuICAgICAgdG9rZW5sb29wOiBmb3IgKHZhciB0b2tlbiBpbiBncmFtbWFyKSB7XG4gICAgICAgIGlmICghZ3JhbW1hci5oYXNPd25Qcm9wZXJ0eSh0b2tlbikgfHwgIWdyYW1tYXJbdG9rZW5dKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF0dGVybnMgPSBncmFtbWFyW3Rva2VuXTtcbiAgICAgICAgcGF0dGVybnMgPSBfLnV0aWwudHlwZShwYXR0ZXJucykgPT09IFwiQXJyYXlcIiA/IHBhdHRlcm5zIDogW3BhdHRlcm5zXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhdHRlcm5zLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgdmFyIHBhdHRlcm4gPSBwYXR0ZXJuc1tqXSxcbiAgICAgICAgICAgIGluc2lkZSA9IHBhdHRlcm4uaW5zaWRlLFxuICAgICAgICAgICAgbG9va2JlaGluZCA9ICEhcGF0dGVybi5sb29rYmVoaW5kLFxuICAgICAgICAgICAgbG9va2JlaGluZExlbmd0aCA9IDAsXG4gICAgICAgICAgICBhbGlhcyA9IHBhdHRlcm4uYWxpYXM7XG5cbiAgICAgICAgICBwYXR0ZXJuID0gcGF0dGVybi5wYXR0ZXJuIHx8IHBhdHRlcm47XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gRG9u4oCZdCBjYWNoZSBsZW5ndGggYXMgaXQgY2hhbmdlcyBkdXJpbmcgdGhlIGxvb3BcblxuICAgICAgICAgICAgdmFyIHN0ciA9IHN0cmFycltpXTtcblxuICAgICAgICAgICAgaWYgKHN0cmFyci5sZW5ndGggPiB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgd2VudCB0ZXJyaWJseSB3cm9uZywgQUJPUlQsIEFCT1JUIVxuICAgICAgICAgICAgICBicmVhayB0b2tlbmxvb3A7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdHIgaW5zdGFuY2VvZiBUb2tlbikge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGF0dGVybi5sYXN0SW5kZXggPSAwO1xuXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc3RyKTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgIGlmIChsb29rYmVoaW5kKSB7XG4gICAgICAgICAgICAgICAgbG9va2JlaGluZExlbmd0aCA9IG1hdGNoWzFdLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBmcm9tID0gbWF0Y2guaW5kZXggLSAxICsgbG9va2JlaGluZExlbmd0aCxcbiAgICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoWzBdLnNsaWNlKGxvb2tiZWhpbmRMZW5ndGgpLFxuICAgICAgICAgICAgICAgIGxlbiA9IG1hdGNoLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB0byA9IGZyb20gKyBsZW4sXG4gICAgICAgICAgICAgICAgYmVmb3JlID0gc3RyLnNsaWNlKDAsIGZyb20gKyAxKSxcbiAgICAgICAgICAgICAgICBhZnRlciA9IHN0ci5zbGljZSh0byArIDEpO1xuXG4gICAgICAgICAgICAgIHZhciBhcmdzID0gW2ksIDFdO1xuXG4gICAgICAgICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goYmVmb3JlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciB3cmFwcGVkID0gbmV3IFRva2VuKFxuICAgICAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgICAgIGluc2lkZSA/IF8udG9rZW5pemUobWF0Y2gsIGluc2lkZSkgOiBtYXRjaCxcbiAgICAgICAgICAgICAgICBhbGlhc1xuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIGFyZ3MucHVzaCh3cmFwcGVkKTtcblxuICAgICAgICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goYWZ0ZXIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseShzdHJhcnIsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyYXJyO1xuICAgIH0sXG5cbiAgICBob29rczoge1xuICAgICAgYWxsOiB7fSxcblxuICAgICAgYWRkOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaG9va3MgPSBfLmhvb2tzLmFsbDtcblxuICAgICAgICBob29rc1tuYW1lXSA9IGhvb2tzW25hbWVdIHx8IFtdO1xuXG4gICAgICAgIGhvb2tzW25hbWVdLnB1c2goY2FsbGJhY2spO1xuICAgICAgfSxcblxuICAgICAgcnVuOiBmdW5jdGlvbihuYW1lLCBlbnYpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IF8uaG9va3MuYWxsW25hbWVdO1xuXG4gICAgICAgIGlmICghY2FsbGJhY2tzIHx8ICFjYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGNhbGxiYWNrOyAoY2FsbGJhY2sgPSBjYWxsYmFja3NbaSsrXSk7ICkge1xuICAgICAgICAgIGNhbGxiYWNrKGVudik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBUb2tlbiA9IChfLlRva2VuID0gZnVuY3Rpb24odHlwZSwgY29udGVudCwgYWxpYXMpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgdGhpcy5hbGlhcyA9IGFsaWFzO1xuICB9KTtcblxuICBUb2tlbi5zdHJpbmdpZnkgPSBmdW5jdGlvbihvLCBsYW5ndWFnZSwgcGFyZW50KSB7XG4gICAgaWYgKHR5cGVvZiBvID09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBvO1xuICAgIH1cblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICByZXR1cm4gb1xuICAgICAgICAubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gVG9rZW4uc3RyaW5naWZ5KGVsZW1lbnQsIGxhbmd1YWdlLCBvKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oXCJcIik7XG4gICAgfVxuXG4gICAgdmFyIGVudiA9IHtcbiAgICAgIHR5cGU6IG8udHlwZSxcbiAgICAgIGNvbnRlbnQ6IFRva2VuLnN0cmluZ2lmeShvLmNvbnRlbnQsIGxhbmd1YWdlLCBwYXJlbnQpLFxuICAgICAgdGFnOiBcInNwYW5cIixcbiAgICAgIGNsYXNzZXM6IFtcInRva2VuXCIsIG8udHlwZV0sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZSxcbiAgICAgIHBhcmVudDogcGFyZW50XG4gICAgfTtcblxuICAgIGlmIChlbnYudHlwZSA9PSBcImNvbW1lbnRcIikge1xuICAgICAgZW52LmF0dHJpYnV0ZXNbXCJzcGVsbGNoZWNrXCJdID0gXCJ0cnVlXCI7XG4gICAgfVxuXG4gICAgaWYgKG8uYWxpYXMpIHtcbiAgICAgIHZhciBhbGlhc2VzID0gXy51dGlsLnR5cGUoby5hbGlhcykgPT09IFwiQXJyYXlcIiA/IG8uYWxpYXMgOiBbby5hbGlhc107XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbnYuY2xhc3NlcywgYWxpYXNlcyk7XG4gICAgfVxuXG4gICAgXy5ob29rcy5ydW4oXCJ3cmFwXCIsIGVudik7XG5cbiAgICB2YXIgYXR0cmlidXRlcyA9IFwiXCI7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIGVudi5hdHRyaWJ1dGVzKSB7XG4gICAgICBhdHRyaWJ1dGVzICs9IG5hbWUgKyAnPVwiJyArIChlbnYuYXR0cmlidXRlc1tuYW1lXSB8fCBcIlwiKSArICdcIic7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIFwiPFwiICtcbiAgICAgIGVudi50YWcgK1xuICAgICAgJyBjbGFzcz1cIicgK1xuICAgICAgZW52LmNsYXNzZXMuam9pbihcIiBcIikgK1xuICAgICAgJ1wiICcgK1xuICAgICAgYXR0cmlidXRlcyArXG4gICAgICBcIj5cIiArXG4gICAgICBlbnYuY29udGVudCArXG4gICAgICBcIjwvXCIgK1xuICAgICAgZW52LnRhZyArXG4gICAgICBcIj5cIlxuICAgICk7XG4gIH07XG5cbiAgaWYgKCFzZWxmLmRvY3VtZW50KSB7XG4gICAgaWYgKCFzZWxmLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIC8vIGluIE5vZGUuanNcbiAgICAgIHJldHVybiBzZWxmLlByaXNtO1xuICAgIH1cbiAgICAvLyBJbiB3b3JrZXJcbiAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcIm1lc3NhZ2VcIixcbiAgICAgIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IEpTT04ucGFyc2UoZXZ0LmRhdGEpLFxuICAgICAgICAgIGxhbmcgPSBtZXNzYWdlLmxhbmd1YWdlLFxuICAgICAgICAgIGNvZGUgPSBtZXNzYWdlLmNvZGU7XG5cbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZShcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShfLnV0aWwuZW5jb2RlKF8udG9rZW5pemUoY29kZSwgXy5sYW5ndWFnZXNbbGFuZ10pKSlcbiAgICAgICAgKTtcbiAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgfSxcbiAgICAgIGZhbHNlXG4gICAgKTtcblxuICAgIHJldHVybiBzZWxmLlByaXNtO1xuICB9XG5cbiAgLy8gR2V0IGN1cnJlbnQgc2NyaXB0IGFuZCBoaWdobGlnaHRcbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXG4gIHNjcmlwdCA9IHNjcmlwdFtzY3JpcHQubGVuZ3RoIC0gMV07XG5cbiAgaWYgKHNjcmlwdCkge1xuICAgIF8uZmlsZW5hbWUgPSBzY3JpcHQuc3JjO1xuXG4gICAgaWYgKGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgJiYgIXNjcmlwdC5oYXNBdHRyaWJ1dGUoXCJkYXRhLW1hbnVhbFwiKSkge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgXy5oaWdobGlnaHRBbGwpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmLlByaXNtO1xufSkoKTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBQcmlzbTtcbn1cblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1tYXJrdXAuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cCA9IHtcbiAgY29tbWVudDogLzwhLS1bXFx3XFxXXSo/LS0+L2csXG4gIHByb2xvZzogLzxcXD8uKz9cXD8+LyxcbiAgZG9jdHlwZTogLzwhRE9DVFlQRS4rPz4vLFxuICBjZGF0YTogLzwhXFxbQ0RBVEFcXFtbXFx3XFxXXSo/XV0+L2ksXG4gIHRhZzoge1xuICAgIHBhdHRlcm46IC88XFwvP1tcXHc6LV0rXFxzKig/OlxccytbXFx3Oi1dKyg/Oj0oPzooXCJ8JykoXFxcXD9bXFx3XFxXXSkqP1xcMXxbXlxccydcIj49XSspKT9cXHMqKSpcXC8/Pi9naSxcbiAgICBpbnNpZGU6IHtcbiAgICAgIHRhZzoge1xuICAgICAgICBwYXR0ZXJuOiAvXjxcXC8/W1xcdzotXSsvaSxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgcHVuY3R1YXRpb246IC9ePFxcLz8vLFxuICAgICAgICAgIG5hbWVzcGFjZTogL15bXFx3LV0rPzovXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImF0dHItdmFsdWVcIjoge1xuICAgICAgICBwYXR0ZXJuOiAvPSg/OignfFwiKVtcXHdcXFddKj8oXFwxKXxbXlxccz5dKykvZ2ksXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgIHB1bmN0dWF0aW9uOiAvPXw+fFwiL2dcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHB1bmN0dWF0aW9uOiAvXFwvPz4vZyxcbiAgICAgIFwiYXR0ci1uYW1lXCI6IHtcbiAgICAgICAgcGF0dGVybjogL1tcXHc6LV0rL2csXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgIG5hbWVzcGFjZTogL15bXFx3LV0rPzovXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGVudGl0eTogL1xcJiM/W1xcZGEtel17MSw4fTsvZ2lcbn07XG5cbi8vIFBsdWdpbiB0byBtYWtlIGVudGl0eSB0aXRsZSBzaG93IHRoZSByZWFsIGVudGl0eSwgaWRlYSBieSBSb21hbiBLb21hcm92XG5QcmlzbS5ob29rcy5hZGQoXCJ3cmFwXCIsIGZ1bmN0aW9uKGVudikge1xuICBpZiAoZW52LnR5cGUgPT09IFwiZW50aXR5XCIpIHtcbiAgICBlbnYuYXR0cmlidXRlc1tcInRpdGxlXCJdID0gZW52LmNvbnRlbnQucmVwbGFjZSgvJmFtcDsvLCBcIiZcIik7XG4gIH1cbn0pO1xuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLWNzcy5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMuY3NzID0ge1xuICBjb21tZW50OiAvXFwvXFwqW1xcd1xcV10qP1xcKlxcLy9nLFxuICBhdHJ1bGU6IHtcbiAgICBwYXR0ZXJuOiAvQFtcXHctXSs/Lio/KDt8KD89XFxzKnspKS9naSxcbiAgICBpbnNpZGU6IHtcbiAgICAgIHB1bmN0dWF0aW9uOiAvWzs6XS9nXG4gICAgfVxuICB9LFxuICB1cmw6IC91cmxcXCgoW1wiJ10/KS4qP1xcMVxcKS9naSxcbiAgc2VsZWN0b3I6IC9bXlxce1xcfVxcc11bXlxce1xcfTtdKig/PVxccypcXHspL2csXG4gIHByb3BlcnR5OiAvKFxcYnxcXEIpW1xcdy1dKyg/PVxccyo6KS9naSxcbiAgc3RyaW5nOiAvKFwifCcpKFxcXFw/LikqP1xcMS9nLFxuICBpbXBvcnRhbnQ6IC9cXEIhaW1wb3J0YW50XFxiL2dpLFxuICBwdW5jdHVhdGlvbjogL1tcXHtcXH07Ol0vZyxcbiAgZnVuY3Rpb246IC9bLWEtejAtOV0rKD89XFwoKS9naVxufTtcblxuaWYgKFByaXNtLmxhbmd1YWdlcy5tYXJrdXApIHtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZShcIm1hcmt1cFwiLCBcInRhZ1wiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIHBhdHRlcm46IC88c3R5bGVbXFx3XFxXXSo/PltcXHdcXFddKj88XFwvc3R5bGU+L2dpLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgIHRhZzoge1xuICAgICAgICAgIHBhdHRlcm46IC88c3R5bGVbXFx3XFxXXSo/Pnw8XFwvc3R5bGU+L2dpLFxuICAgICAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuaW5zaWRlXG4gICAgICAgIH0sXG4gICAgICAgIHJlc3Q6IFByaXNtLmxhbmd1YWdlcy5jc3NcbiAgICAgIH0sXG4gICAgICBhbGlhczogXCJsYW5ndWFnZS1jc3NcIlxuICAgIH1cbiAgfSk7XG5cbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZShcbiAgICBcImluc2lkZVwiLFxuICAgIFwiYXR0ci12YWx1ZVwiLFxuICAgIHtcbiAgICAgIFwic3R5bGUtYXR0clwiOiB7XG4gICAgICAgIHBhdHRlcm46IC9cXHMqc3R5bGU9KFwifCcpLis/XFwxL2dpLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICBcImF0dHItbmFtZVwiOiB7XG4gICAgICAgICAgICBwYXR0ZXJuOiAvXlxccypzdHlsZS9naSxcbiAgICAgICAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuaW5zaWRlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwdW5jdHVhdGlvbjogL15cXHMqPVxccypbJ1wiXXxbJ1wiXVxccyokLyxcbiAgICAgICAgICBcImF0dHItdmFsdWVcIjoge1xuICAgICAgICAgICAgcGF0dGVybjogLy4rL2dpLFxuICAgICAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuY3NzXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhbGlhczogXCJsYW5ndWFnZS1jc3NcIlxuICAgICAgfVxuICAgIH0sXG4gICAgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWdcbiAgKTtcbn1cblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1jbGlrZS5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMuY2xpa2UgPSB7XG4gIGNvbW1lbnQ6IFtcbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSlcXC9cXCpbXFx3XFxXXSo/XFwqXFwvL2csXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvKF58W15cXFxcOl0pXFwvXFwvLio/KFxccj9cXG58JCkvZyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9XG4gIF0sXG4gIHN0cmluZzogLyhcInwnKShcXFxcPy4pKj9cXDEvZyxcbiAgXCJjbGFzcy1uYW1lXCI6IHtcbiAgICBwYXR0ZXJuOiAvKCg/Oig/OmNsYXNzfGludGVyZmFjZXxleHRlbmRzfGltcGxlbWVudHN8dHJhaXR8aW5zdGFuY2VvZnxuZXcpXFxzKyl8KD86Y2F0Y2hcXHMrXFwoKSlbYS16MC05X1xcLlxcXFxdKy9naSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgcHVuY3R1YXRpb246IC8oXFwufFxcXFwpL1xuICAgIH1cbiAgfSxcbiAga2V5d29yZDogL1xcYihpZnxlbHNlfHdoaWxlfGRvfGZvcnxyZXR1cm58aW58aW5zdGFuY2VvZnxmdW5jdGlvbnxuZXd8dHJ5fHRocm93fGNhdGNofGZpbmFsbHl8bnVsbHxicmVha3xjb250aW51ZSlcXGIvZyxcbiAgYm9vbGVhbjogL1xcYih0cnVlfGZhbHNlKVxcYi9nLFxuICBmdW5jdGlvbjoge1xuICAgIHBhdHRlcm46IC9bYS16MC05X10rXFwoL2dpLFxuICAgIGluc2lkZToge1xuICAgICAgcHVuY3R1YXRpb246IC9cXCgvXG4gICAgfVxuICB9LFxuICBudW1iZXI6IC9cXGItPygweFtcXGRBLUZhLWZdK3xcXGQqXFwuP1xcZCsoW0VlXS0/XFxkKyk/KVxcYi9nLFxuICBvcGVyYXRvcjogL1stK117MSwyfXwhfDw9P3w+PT98PXsxLDN9fCZ7MSwyfXxcXHw/XFx8fFxcP3xcXCp8XFwvfFxcfnxcXF58XFwlL2csXG4gIGlnbm9yZTogLyYobHR8Z3R8YW1wKTsvZ2ksXG4gIHB1bmN0dWF0aW9uOiAvW3t9W1xcXTsoKSwuOl0vZ1xufTtcblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1qYXZhc2NyaXB0LmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cblByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0ID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZChcImNsaWtlXCIsIHtcbiAga2V5d29yZDogL1xcYihicmVha3xjYXNlfGNhdGNofGNsYXNzfGNvbnN0fGNvbnRpbnVlfGRlYnVnZ2VyfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZW51bXxleHBvcnR8ZXh0ZW5kc3xmYWxzZXxmaW5hbGx5fGZvcnxmdW5jdGlvbnxnZXR8aWZ8aW1wbGVtZW50c3xpbXBvcnR8aW58aW5zdGFuY2VvZnxpbnRlcmZhY2V8bGV0fG5ld3xudWxsfHBhY2thZ2V8cHJpdmF0ZXxwcm90ZWN0ZWR8cHVibGljfHJldHVybnxzZXR8c3RhdGljfHN1cGVyfHN3aXRjaHx0aGlzfHRocm93fHRydWV8dHJ5fHR5cGVvZnx2YXJ8dm9pZHx3aGlsZXx3aXRofHlpZWxkKVxcYi9nLFxuICBudW1iZXI6IC9cXGItPygweFtcXGRBLUZhLWZdK3xcXGQqXFwuP1xcZCsoW0VlXS0/XFxkKyk/fE5hTnwtP0luZmluaXR5KVxcYi9nXG59KTtcblxuUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZShcImphdmFzY3JpcHRcIiwgXCJrZXl3b3JkXCIsIHtcbiAgcmVnZXg6IHtcbiAgICBwYXR0ZXJuOiAvKF58W14vXSlcXC8oPyFcXC8pKFxcWy4rP118XFxcXC58W14vXFxyXFxuXSkrXFwvW2dpbV17MCwzfSg/PVxccyooJHxbXFxyXFxuLC47fSldKSkvZyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH1cbn0pO1xuXG5pZiAoUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cCkge1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKFwibWFya3VwXCIsIFwidGFnXCIsIHtcbiAgICBzY3JpcHQ6IHtcbiAgICAgIHBhdHRlcm46IC88c2NyaXB0W1xcd1xcV10qPz5bXFx3XFxXXSo/PFxcL3NjcmlwdD4vZ2ksXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgdGFnOiB7XG4gICAgICAgICAgcGF0dGVybjogLzxzY3JpcHRbXFx3XFxXXSo/Pnw8XFwvc2NyaXB0Pi9naSxcbiAgICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLmluc2lkZVxuICAgICAgICB9LFxuICAgICAgICByZXN0OiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuICAgICAgfSxcbiAgICAgIGFsaWFzOiBcImxhbmd1YWdlLWphdmFzY3JpcHRcIlxuICAgIH1cbiAgfSk7XG59XG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tZmlsZS1oaWdobGlnaHQuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuKGZ1bmN0aW9uKCkge1xuICBpZiAoIXNlbGYuUHJpc20gfHwgIXNlbGYuZG9jdW1lbnQgfHwgIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgRXh0ZW5zaW9ucyA9IHtcbiAgICBqczogXCJqYXZhc2NyaXB0XCIsXG4gICAgaHRtbDogXCJtYXJrdXBcIixcbiAgICBzdmc6IFwibWFya3VwXCIsXG4gICAgeG1sOiBcIm1hcmt1cFwiLFxuICAgIHB5OiBcInB5dGhvblwiLFxuICAgIHJiOiBcInJ1YnlcIlxuICB9O1xuXG4gIEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgIC5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJwcmVbZGF0YS1zcmNdXCIpKVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKHByZSkge1xuICAgICAgdmFyIHNyYyA9IHByZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXNyY1wiKTtcbiAgICAgIHZhciBleHRlbnNpb24gPSAoc3JjLm1hdGNoKC9cXC4oXFx3KykkLykgfHwgWywgXCJcIl0pWzFdO1xuICAgICAgdmFyIGxhbmd1YWdlID0gRXh0ZW5zaW9uc1tleHRlbnNpb25dIHx8IGV4dGVuc2lvbjtcblxuICAgICAgdmFyIGNvZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY29kZVwiKTtcbiAgICAgIGNvZGUuY2xhc3NOYW1lID0gXCJsYW5ndWFnZS1cIiArIGxhbmd1YWdlO1xuXG4gICAgICBwcmUudGV4dENvbnRlbnQgPSBcIlwiO1xuXG4gICAgICBjb2RlLnRleHRDb250ZW50ID0gXCJMb2FkaW5n4oCmXCI7XG5cbiAgICAgIHByZS5hcHBlbmRDaGlsZChjb2RlKTtcblxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICB4aHIub3BlbihcIkdFVFwiLCBzcmMsIHRydWUpO1xuXG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICAgICAgaWYgKHhoci5zdGF0dXMgPCA0MDAgJiYgeGhyLnJlc3BvbnNlVGV4dCkge1xuICAgICAgICAgICAgY29kZS50ZXh0Q29udGVudCA9IHhoci5yZXNwb25zZVRleHQ7XG5cbiAgICAgICAgICAgIFByaXNtLmhpZ2hsaWdodEVsZW1lbnQoY29kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh4aHIuc3RhdHVzID49IDQwMCkge1xuICAgICAgICAgICAgY29kZS50ZXh0Q29udGVudCA9XG4gICAgICAgICAgICAgIFwi4pyWIEVycm9yIFwiICtcbiAgICAgICAgICAgICAgeGhyLnN0YXR1cyArXG4gICAgICAgICAgICAgIFwiIHdoaWxlIGZldGNoaW5nIGZpbGU6IFwiICtcbiAgICAgICAgICAgICAgeGhyLnN0YXR1c1RleHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvZGUudGV4dENvbnRlbnQgPSBcIuKcliBFcnJvcjogRmlsZSBkb2VzIG5vdCBleGlzdCBvciBpcyBlbXB0eVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgfSk7XG59KSgpO1xuIiwiZ2xvYmFsLnJ1bkl0ID0gZnVuY3Rpb24gcnVuSXQoYnV0dG9uKSB7XG4gIGlmICghZ2xvYmFsLlJ1bktpdCkgcmV0dXJuO1xuXG4gIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICB2YXIgY29kZUVsZW1lbnQgPSBidXR0b24ucGFyZW50Tm9kZTtcbiAgdmFyIHBhcmVudCA9IGNvZGVFbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgcGFyZW50Lmluc2VydEJlZm9yZShjb250YWluZXIsIGNvZGVFbGVtZW50KTtcbiAgcGFyZW50LnJlbW92ZUNoaWxkKGNvZGVFbGVtZW50KTtcbiAgY29kZUVsZW1lbnQucmVtb3ZlQ2hpbGQoYnV0dG9uKTtcblxuICBjb25zdCBvcHRpb25zID0gSlNPTi5wYXJzZSh1bmVzY2FwZShidXR0b24uZGF0YXNldC5vcHRpb25zKSk7XG5cbiAgZnVuY3Rpb24gd2l0aENvcnJlY3RWZXJzaW9uKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZTtcbiAgICAvLyByZXR1cm4gY29kZS5yZXBsYWNlKFxuICAgIC8vICAgL3JlcXVpcmVcXCgnc2VxdWlucydcXCkvZyxcbiAgICAvLyAgIFwicmVxdWlyZSgnc2VxdWluc0BWRVJTSU9OJylcIlxuICAgIC8vICk7XG4gIH1cblxuICBnbG9iYWwuUnVuS2l0LmNyZWF0ZU5vdGVib29rKHtcbiAgICBlbGVtZW50OiBjb250YWluZXIsXG4gICAgbm9kZVZlcnNpb246IG9wdGlvbnMubm9kZVZlcnNpb24gfHwgXCIqXCIsXG4gICAgcHJlYW1ibGU6IHdpdGhDb3JyZWN0VmVyc2lvbihcbiAgICAgIFwiY29uc3QgYXNzZXJ0ID0gKFwiICtcbiAgICAgICAgbWFrZUFzc2VydCArXG4gICAgICAgIFwiKShyZXF1aXJlKCdzZXF1aW5zJykpO1wiICtcbiAgICAgICAgKG9wdGlvbnMucHJlYW1ibGUgfHwgXCJcIilcbiAgICApLFxuICAgIHNvdXJjZTogd2l0aENvcnJlY3RWZXJzaW9uKFxuICAgICAgY29kZUVsZW1lbnQudGV4dENvbnRlbnQucmVwbGFjZSgvXFxuKD5bXlxcbl0qXFxuPykrJC9nLCBcIlwiKVxuICAgICksXG4gICAgbWluSGVpZ2h0OiBcIjUycHhcIixcbiAgICBvbkxvYWQ6IGZ1bmN0aW9uKG5vdGVib29rKSB7XG4gICAgICBub3RlYm9vay5ldmFsdWF0ZSgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBtYWtlQXNzZXJ0KFNlcXVpbnMpIHtcbiAgdmFyIGlzQ29sbGVjdGlvbiA9IFNlcXVpbnMuaXNDb2xsZWN0aW9uO1xuICB2YXIgaHRtbCA9IChcIlxcbiAgICA8c3R5bGU+XFxuICAgICAgKiB7XFxuICAgICAgICBmb250LXNpemU6IDE0cHg7XFxuICAgICAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb2RlIHtcXG4gICAgICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxuICAgICAgICBjb2xvcjogIzQxODNDNDtcXG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICAgIGJhY2tncm91bmQ6IHJnYmEoNjUsIDEzMSwgMTk2LCAwLjEpO1xcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMnB4O1xcbiAgICAgICAgcGFkZGluZzogMnB4O1xcbiAgICB9XFxuXFxuICAgICAgLnN1Y2Nlc3Mge1xcbiAgICAgICAgY29sb3I6IHJnYmEoODQsMTg0LDU0LDEuMCk7XFxuICAgICAgfVxcblxcbiAgICAgIC5zdWNjZXNzOmJlZm9yZSB7XFxuICAgICAgICBjb250ZW50OiBcXFwi4pyFXFxcIjtcXG4gICAgICB9XFxuXFxuICAgICAgLmZhaWx1cmUge1xcbiAgICAgICAgY29sb3I6IHJnYmEoMjIwLDQ3LDMzLDEuMCk7XFxuICAgICAgfVxcblxcbiAgICAgIC5mYWlsdXJlIGkge1xcbiAgICAgICAgY29sb3I6IHJnYmEoMjEwLDQ0LDMxLDEuMCk7XFxuICAgICAgfVxcblxcbiAgICAgIC5mYWlsdXJlOmJlZm9yZSB7XFxuICAgICAgICBjb250ZW50OiBcXFwi4p2MXFxcIjtcXG4gICAgICB9XFxuICAgIDwvc3R5bGU+XCJcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4pO1xuXG4gIGZ1bmN0aW9uIGNvbXBhcmUobGhzLCByaHMsIHNhbWUsIGlkZW50aWNhbCkge1xuICAgIHZhciBib3RoID0gIWlkZW50aWNhbCAmJiBpc0NvbGxlY3Rpb24obGhzKSAmJiBpc0NvbGxlY3Rpb24ocmhzKTtcblxuICAgIGlmIChib3RoKSByZXR1cm4gbGhzLmVxdWFscyhyaHMpO1xuXG4gICAgcmV0dXJuIGxocyA9PT0gcmhzO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVzc2FnZShsaHMsIHJocywgc2FtZSwgaWRlbnRpY2FsKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNvbXBhcmUobGhzLCByaHMsIHNhbWUsIGlkZW50aWNhbCk7XG4gICAgdmFyIGNvbXBhcmlzb24gPSByZXN1bHRcbiAgICAgID8gaWRlbnRpY2FsXG4gICAgICAgID8gXCJzdHJpY3QgZXF1YWwgdG9cIlxuICAgICAgICA6IFwiZG9lcyBlcXVhbFwiXG4gICAgICA6IGlkZW50aWNhbFxuICAgICAgPyBcIm5vdCBzdHJpY3QgZXF1YWwgdG9cIlxuICAgICAgOiBcImRvZXMgbm90IGVxdWFsXCI7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHJlc3VsdCA9PT0gc2FtZSA/IFwic3VjY2Vzc1wiIDogXCJmYWlsdXJlXCI7XG4gICAgdmFyIGxoc1N0cmluZyA9IGlzQ29sbGVjdGlvbihsaHMpID8gbGhzICsgXCJcIiA6IEpTT04uc3RyaW5naWZ5KGxocyk7XG4gICAgdmFyIHJoc1N0cmluZyA9IGlzQ29sbGVjdGlvbihyaHMpID8gcmhzICsgXCJcIiA6IEpTT04uc3RyaW5naWZ5KHJocyk7XG5cbiAgICByZXR1cm4gKGh0bWwgKz0gKFwiXFxuICAgICAgPHNwYW4gY2xhc3M9XFxcIlwiICsgXG5jbGFzc05hbWUgKyBcIlxcXCI+XFxuICAgICAgICA8Y29kZT5cIiArIFxubGhzU3RyaW5nICsgXCI8L2NvZGU+XFxuICAgICAgICBcIiArIFxuY29tcGFyaXNvbiArIFwiXFxuICAgICAgICA8Y29kZT5cIiArIFxucmhzU3RyaW5nICsgXCI8L2NvZGU+XFxuICAgICAgPC9zcGFuPjxici8+XCJcbikpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXF1YWwobGhzLCByaHMpIHtcbiAgICByZXR1cm4gbWVzc2FnZShsaHMsIHJocywgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBub3RFcXVhbChsaHMsIHJocykge1xuICAgIHJldHVybiBtZXNzYWdlKGxocywgcmhzLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpY3RFcXVhbChsaHMsIHJocykge1xuICAgIHJldHVybiBtZXNzYWdlKGxocywgcmhzLCB0cnVlLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGxocywgcmhzKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UobGhzLCByaHMsIGZhbHNlLCB0cnVlKTtcbiAgfVxuXG4gIHJldHVybiB7IGVxdWFsOmVxdWFsLCBub3RFcXVhbDpub3RFcXVhbCwgc3RyaWN0RXF1YWw6c3RyaWN0RXF1YWwsIG5vdFN0cmljdEVxdWFsOm5vdFN0cmljdEVxdWFsIH07XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBDU1NDb3JlID0gcmVxdWlyZShcInJlYWN0L2xpYi9DU1NDb3JlXCIpO1xudmFyIFJvdXRlciA9IHJlcXVpcmUoXCJyZWFjdC1yb3V0ZXJcIik7XG52YXIgJF9fMD0gICAgcmVxdWlyZShcIi4uLy4uLy4uLy4uXCIpLFNlcT0kX18wLlNlcTtcbnZhciBUeXBlS2luZCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvVHlwZUtpbmRcIik7XG52YXIgZGVmcyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvZ2V0VHlwZURlZnNcIik7XG5cbnZhciBJbnRlcmZhY2VEZWYgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiSW50ZXJmYWNlRGVmXCIsXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICBjb25zdCAkX18wPSAgICAgdGhpcy5wcm9wcyxuYW1lPSRfXzAubmFtZSxkZWY9JF9fMC5kZWY7XG5cbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogXCJ0IGludGVyZmFjZURlZlwifSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCBrZXl3b3JkXCJ9LCBkZWYuaXNDbGFzcyA/IFwiY2xhc3NcIiA6IFwidHlwZVwiLCBcIiBcIiksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7Y2xhc3NOYW1lOiBcInQgdHlwZU5hbWVcIn0sIG5hbWUpLCBcbiAgICAgICAgZGVmLnR5cGVQYXJhbXMgJiYgW1xuICAgICAgICAgIFwiPFwiLFxuICAgICAgICAgIFNlcShkZWYudHlwZVBhcmFtcylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24odCwgaykgIFxuICAgICAgICAgICAgICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCB0eXBlUGFyYW1cIiwga2V5OiBrfSwgXG4gICAgICAgICAgICAgICAgdFxuICAgICAgICAgICAgICApO31cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5pbnRlcnBvc2UoXCIsIFwiKVxuICAgICAgICAgICAgLnRvKEFycmF5KSxcbiAgICAgICAgICBcIj5cIlxuICAgICAgICBdLCBcbiAgICAgICAgZGVmLmV4dGVuZHMgJiYgZGVmLmV4dGVuZHMubGVuZ3RoXG4gICAgICAgICAgPyBbXG4gICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCBrZXl3b3JkXCJ9LCBcIiBleHRlbmRzIFwiKSxcbiAgICAgICAgICAgICAgU2VxKGRlZi5leHRlbmRzKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZSwgaSkgIHtyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChUeXBlRGVmLCB7a2V5OiBpLCB0eXBlOiBlfSk7fSlcbiAgICAgICAgICAgICAgICAuaW50ZXJwb3NlKFwiLCBcIilcbiAgICAgICAgICAgICAgICAudG8oQXJyYXkpXG4gICAgICAgICAgICBdXG4gICAgICAgICAgOiBudWxsLCBcbiAgICAgICAgZGVmLmltcGxlbWVudHMgJiYgZGVmLmltcGxlbWVudHMubGVuZ3RoXG4gICAgICAgICAgPyBbXG4gICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCBrZXl3b3JkXCJ9LCBcIiBpbXBsZW1lbnRzIFwiKSxcbiAgICAgICAgICAgICAgU2VxKGRlZi5pbXBsZW1lbnRzKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZSwgaSkgIHtyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChUeXBlRGVmLCB7a2V5OiBpLCB0eXBlOiBlfSk7fSlcbiAgICAgICAgICAgICAgICAuaW50ZXJwb3NlKFwiLCBcIilcbiAgICAgICAgICAgICAgICAudG8oQXJyYXkpXG4gICAgICAgICAgICBdXG4gICAgICAgICAgOiBudWxsLCBcbiAgICAgICAgZGVmLmlzQ2xhc3MgJiYgKFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIFxuICAgICAgICAgICAgXCIge1wiLCBcIiBcIiwgUmVhY3QuY3JlYXRlRWxlbWVudChcImJyXCIsIG51bGwpLCBcbiAgICAgICAgICAgIFNlcShkZWYuY29uc3RydWN0b3Iuc2lnbmF0dXJlcylcbiAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihjb25zdHJ1Y3RTaWcsIGkpICBcbiAgICAgICAgICAgICAgICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FsbFNpZ0RlZiwge25hbWU6IFwiY29uc3RydWN0b3JcIiwgY2FsbFNpZzogY29uc3RydWN0U2lnLCBrZXk6IGl9KTt9XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgLmNvbmNhdChbbnVsbF0pXG4gICAgICAgICAgICAgIC5pbnRlcnBvc2UoUmVhY3QuY3JlYXRlRWxlbWVudChcImJyXCIsIG51bGwpKVxuICAgICAgICAgICAgICAudG8oQXJyYXkpLCBcbiAgICAgICAgICAgIFwifVwiXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfVxufSk7XG5cbmV4cG9ydHMuSW50ZXJmYWNlRGVmID0gSW50ZXJmYWNlRGVmO1xuXG52YXIgQ2FsbFNpZ0RlZiA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJDYWxsU2lnRGVmXCIsXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5mbyA9IHRoaXMucHJvcHMuaW5mbztcbiAgICB2YXIgbW9kdWxlID0gdGhpcy5wcm9wcy5tb2R1bGU7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnByb3BzLm5hbWU7XG4gICAgdmFyIGNhbGxTaWcgPSB0aGlzLnByb3BzLmNhbGxTaWcgfHwge307XG5cbiAgICB2YXIgc2hvdWxkV3JhcCA9IGNhbGxTaWdMZW5ndGgoaW5mbywgbW9kdWxlLCBuYW1lLCBjYWxsU2lnKSA+IDgwO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCBjYWxsU2lnXCJ9LCBcbiAgICAgICAgbW9kdWxlICYmIFtSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7Y2xhc3NOYW1lOiBcInQgZm5RdWFsaWZpZXJcIn0sIG1vZHVsZSksIFwiLlwiXSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCBmbk5hbWVcIn0sIG5hbWUpLCBcbiAgICAgICAgY2FsbFNpZy50eXBlUGFyYW1zICYmIFtcbiAgICAgICAgICBcIjxcIixcbiAgICAgICAgICBTZXEoY2FsbFNpZy50eXBlUGFyYW1zKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbih0KSAge3JldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7Y2xhc3NOYW1lOiBcInQgdHlwZVBhcmFtXCJ9LCB0KTt9KVxuICAgICAgICAgICAgLmludGVycG9zZShcIiwgXCIpXG4gICAgICAgICAgICAudG8oQXJyYXkpLFxuICAgICAgICAgIFwiPlwiXG4gICAgICAgIF0sIFxuICAgICAgICBcIihcIiwgXG4gICAgICAgIGNhbGxTaWcgJiYgZnVuY3Rpb25QYXJhbXMoaW5mbywgY2FsbFNpZy5wYXJhbXMsIHNob3VsZFdyYXApLCBcbiAgICAgICAgXCIpXCIsIFxuICAgICAgICBjYWxsU2lnLnR5cGUgJiYgW1wiOiBcIiwgUmVhY3QuY3JlYXRlRWxlbWVudChUeXBlRGVmLCB7aW5mbzogaW5mbywgdHlwZTogY2FsbFNpZy50eXBlfSldXG4gICAgICApXG4gICAgKTtcbiAgfVxufSk7XG5cbmV4cG9ydHMuQ2FsbFNpZ0RlZiA9IENhbGxTaWdEZWY7XG5cbnZhciBUeXBlRGVmID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiBcIlR5cGVEZWZcIixcbiAgcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgIHZhciBpbmZvID0gdGhpcy5wcm9wcy5pbmZvO1xuICAgIHZhciB0eXBlID0gdGhpcy5wcm9wcy50eXBlO1xuICAgIHZhciBwcmVmaXggPSB0aGlzLnByb3BzLnByZWZpeDtcbiAgICBzd2l0Y2ggKHR5cGUuaykge1xuICAgICAgY2FzZSBUeXBlS2luZC5OZXZlcjpcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcChcInByaW1pdGl2ZVwiLCBcIm5ldmVyXCIpO1xuICAgICAgY2FzZSBUeXBlS2luZC5OdWxsOlxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKFwicHJpbWl0aXZlXCIsIFwibnVsbFwiKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuVm9pZDpcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcChcInByaW1pdGl2ZVwiLCBcInZvaWRcIik7XG4gICAgICBjYXNlIFR5cGVLaW5kLkFueTpcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcChcInByaW1pdGl2ZVwiLCBcImFueVwiKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuVGhpczpcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcChcInByaW1pdGl2ZVwiLCBcInRoaXNcIik7XG4gICAgICBjYXNlIFR5cGVLaW5kLlVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcChcInByaW1pdGl2ZVwiLCBcInVuZGVmaW5lZFwiKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuQm9vbGVhbjpcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcChcInByaW1pdGl2ZVwiLCBcImJvb2xlYW5cIik7XG4gICAgICBjYXNlIFR5cGVLaW5kLk51bWJlcjpcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcChcInByaW1pdGl2ZVwiLCBcIm51bWJlclwiKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuU3RyaW5nOlxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKFwicHJpbWl0aXZlXCIsIFwic3RyaW5nXCIpO1xuICAgICAgY2FzZSBUeXBlS2luZC5VbmlvbjpcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcChcInVuaW9uXCIsIFtcbiAgICAgICAgICBTZXEodHlwZS50eXBlcylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24odCkgIHtyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChUeXBlRGVmLCB7aW5mbzogaW5mbywgdHlwZTogdH0pO30pXG4gICAgICAgICAgICAuaW50ZXJwb3NlKFwiIHwgXCIpXG4gICAgICAgICAgICAudG8oQXJyYXkpXG4gICAgICAgIF0pO1xuICAgICAgY2FzZSBUeXBlS2luZC5JbnRlcnNlY3Rpb246XG4gICAgICAgIHJldHVybiB0aGlzLndyYXAoXCJpbnRlcnNlY3Rpb25cIiwgW1xuICAgICAgICAgIFNlcSh0eXBlLnR5cGVzKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbih0KSAge3JldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHtpbmZvOiBpbmZvLCB0eXBlOiB0fSk7fSlcbiAgICAgICAgICAgIC5pbnRlcnBvc2UoXCIgJiBcIilcbiAgICAgICAgICAgIC50byhBcnJheSlcbiAgICAgICAgXSk7XG4gICAgICBjYXNlIFR5cGVLaW5kLlR1cGxlOlxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKFwidHVwbGVcIiwgW1xuICAgICAgICAgIFwiW1wiLFxuICAgICAgICAgIFNlcSh0eXBlLnR5cGVzKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbih0KSAge3JldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHtpbmZvOiBpbmZvLCB0eXBlOiB0fSk7fSlcbiAgICAgICAgICAgIC5pbnRlcnBvc2UoXCIsIFwiKVxuICAgICAgICAgICAgLnRvKEFycmF5KSxcbiAgICAgICAgICBcIl1cIlxuICAgICAgICBdKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuT2JqZWN0OlxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKFwib2JqZWN0XCIsIFtcbiAgICAgICAgICBcIntcIixcbiAgICAgICAgICBTZXEodHlwZS5tZW1iZXJzKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbih0KSAge3JldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE1lbWJlckRlZiwge21lbWJlcjogdH0pO30pXG4gICAgICAgICAgICAuaW50ZXJwb3NlKFwiLCBcIilcbiAgICAgICAgICAgIC50byhBcnJheSksXG4gICAgICAgICAgXCJ9XCJcbiAgICAgICAgXSk7XG4gICAgICBjYXNlIFR5cGVLaW5kLkluZGV4ZWQ6XG4gICAgICAgIHJldHVybiB0aGlzLndyYXAoXCJpbmRleGVkXCIsIFtcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHtpbmZvOiBpbmZvLCB0eXBlOiB0eXBlLnR5cGV9KSxcbiAgICAgICAgICBcIltcIixcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHtpbmZvOiBpbmZvLCB0eXBlOiB0eXBlLmluZGV4fSksXG4gICAgICAgICAgXCJdXCJcbiAgICAgICAgXSk7XG4gICAgICBjYXNlIFR5cGVLaW5kLk9wZXJhdG9yOlxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKFwib3BlcmF0b3JcIiwgW1xuICAgICAgICAgIHRoaXMud3JhcChcInByaW1pdGl2ZVwiLCB0eXBlLm9wZXJhdG9yKSxcbiAgICAgICAgICBcIiBcIixcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHtpbmZvOiBpbmZvLCB0eXBlOiB0eXBlLnR5cGV9KVxuICAgICAgICBdKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuQXJyYXk6XG4gICAgICAgIHJldHVybiB0aGlzLndyYXAoXCJhcnJheVwiLCBbXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChUeXBlRGVmLCB7aW5mbzogaW5mbywgdHlwZTogdHlwZS50eXBlfSksXG4gICAgICAgICAgXCJbXVwiXG4gICAgICAgIF0pO1xuICAgICAgY2FzZSBUeXBlS2luZC5GdW5jdGlvbjpcbiAgICAgICAgdmFyIHNob3VsZFdyYXAgPSAocHJlZml4IHx8IDApICsgZnVuY0xlbmd0aChpbmZvLCB0eXBlKSA+IDc4O1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwKFwiZnVuY3Rpb25cIiwgW1xuICAgICAgICAgIHR5cGUudHlwZVBhcmFtcyAmJiBbXG4gICAgICAgICAgICBcIjxcIixcbiAgICAgICAgICAgIFNlcSh0eXBlLnR5cGVQYXJhbXMpXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24odCwgaykgIFxuICAgICAgICAgICAgICAgIHtyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogXCJ0IHR5cGVQYXJhbVwiLCBrZXk6IGt9LCBcbiAgICAgICAgICAgICAgICAgIHRcbiAgICAgICAgICAgICAgICApO31cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAuaW50ZXJwb3NlKFwiLCBcIilcbiAgICAgICAgICAgICAgLnRvKEFycmF5KSxcbiAgICAgICAgICAgIFwiPlwiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcIihcIixcbiAgICAgICAgICBmdW5jdGlvblBhcmFtcyhpbmZvLCB0eXBlLnBhcmFtcywgc2hvdWxkV3JhcCksXG4gICAgICAgICAgXCIpID0+IFwiLFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVHlwZURlZiwge2luZm86IGluZm8sIHR5cGU6IHR5cGUudHlwZX0pXG4gICAgICAgIF0pO1xuICAgICAgY2FzZSBUeXBlS2luZC5QYXJhbTpcbiAgICAgICAgcmV0dXJuIGluZm8gJiYgaW5mby5wcm9wTWFwW2luZm8uZGVmaW5pbmcgKyBcIjxcIiArIHR5cGUucGFyYW1dID8gKFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVHlwZURlZiwge3R5cGU6IGluZm8ucHJvcE1hcFtpbmZvLmRlZmluaW5nICsgXCI8XCIgKyB0eXBlLnBhcmFtXX0pXG4gICAgICAgICkgOiAoXG4gICAgICAgICAgdGhpcy53cmFwKFwidHlwZVBhcmFtXCIsIHR5cGUucGFyYW0pXG4gICAgICAgICk7XG4gICAgICBjYXNlIFR5cGVLaW5kLlR5cGU6XG4gICAgICAgIHZhciBkZWYgPSBkZWZzW3R5cGUubmFtZV07XG5cbiAgICAgICAgdmFyIHR5cGVOYW1lRWxlbWVudCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCB0eXBlTmFtZVwifSwgdHlwZS5uYW1lKTtcbiAgICAgICAgaWYgKGRlZikge1xuICAgICAgICAgIHR5cGVOYW1lRWxlbWVudCA9IChcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLkxpbmssIHt0bzogXCIvXCIgKyB0eXBlLm5hbWV9LCB0eXBlTmFtZUVsZW1lbnQpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKFwidHlwZVwiLCBbXG4gICAgICAgICAgdHlwZU5hbWVFbGVtZW50LFxuICAgICAgICAgIHR5cGUuYXJncyAmJiBbXG4gICAgICAgICAgICBcIjxcIixcbiAgICAgICAgICAgIFNlcSh0eXBlLmFyZ3MpXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oYSkgIHtyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChUeXBlRGVmLCB7aW5mbzogaW5mbywgdHlwZTogYX0pO30pXG4gICAgICAgICAgICAgIC5pbnRlcnBvc2UoXCIsIFwiKVxuICAgICAgICAgICAgICAudG8oQXJyYXkpLFxuICAgICAgICAgICAgXCI+XCJcbiAgICAgICAgICBdXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGtpbmQgXCIgKyB0eXBlLmspO1xuICB9LFxuXG4gIG1vdXNlT3ZlcjpmdW5jdGlvbihldmVudCkge1xuICAgIENTU0NvcmUuYWRkQ2xhc3ModGhpcy5nZXRET01Ob2RlKCksIFwib3ZlclwiKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSxcblxuICBtb3VzZU91dDpmdW5jdGlvbigpIHtcbiAgICBDU1NDb3JlLnJlbW92ZUNsYXNzKHRoaXMuZ2V0RE9NTm9kZSgpLCBcIm92ZXJcIik7XG4gIH0sXG5cbiAgd3JhcDpmdW5jdGlvbihjbGFzc05hbWUsIGNoaWxkKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInQgXCIgKyBjbGFzc05hbWUsIFxuICAgICAgICBvbk1vdXNlT3ZlcjogdGhpcy5tb3VzZU92ZXIsIFxuICAgICAgICBvbkZvY3VzOiB0aGlzLm1vdXNlT3ZlciwgXG4gICAgICAgIG9uTW91c2VPdXQ6IHRoaXMubW91c2VPdXQsIFxuICAgICAgICBvbkJsdXI6IHRoaXMubW91c2VPdXRcbiAgICAgIH0sIFxuICAgICAgICBjaGlsZFxuICAgICAgKVxuICAgICk7XG4gIH1cbn0pO1xuXG5leHBvcnRzLlR5cGVEZWYgPSBUeXBlRGVmO1xuXG52YXIgTWVtYmVyRGVmID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiBcIk1lbWJlckRlZlwiLFxuICByZW5kZXI6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1vZHVsZSA9IHRoaXMucHJvcHMubW9kdWxlO1xuICAgIHZhciBtZW1iZXIgPSB0aGlzLnByb3BzLm1lbWJlcjtcbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogXCJ0IG1lbWJlclwifSwgXG4gICAgICAgIG1vZHVsZSAmJiBbUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogXCJ0IGZuUXVhbGlmaWVyXCJ9LCBtb2R1bGUpLCBcIi5cIl0sIFxuICAgICAgICBtZW1iZXIuaW5kZXggPyAoXG4gICAgICAgICAgW1wiW1wiLCBmdW5jdGlvblBhcmFtcyhudWxsLCBtZW1iZXIucGFyYW1zKSwgXCJdXCJdXG4gICAgICAgICkgOiAoXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogXCJ0IG1lbWJlck5hbWVcIn0sIG1lbWJlci5uYW1lKVxuICAgICAgICApLCBcbiAgICAgICAgbWVtYmVyLmNvbnN0cnVjdCA/IFwiKClcIiA6IFwiXCIsIFxuICAgICAgICBtZW1iZXIudHlwZSAmJiBbXCI6IFwiLCBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHt0eXBlOiBtZW1iZXIudHlwZX0pXVxuICAgICAgKVxuICAgICk7XG4gIH1cbn0pO1xuXG5leHBvcnRzLk1lbWJlckRlZiA9IE1lbWJlckRlZjtcblxuZnVuY3Rpb24gZnVuY3Rpb25QYXJhbXMoaW5mbywgcGFyYW1zLCBzaG91bGRXcmFwKSB7XG4gIHZhciBlbGVtZW50cyA9IFNlcShwYXJhbXMpXG4gICAgLm1hcChmdW5jdGlvbih0KSAge3JldHVybiBbXG4gICAgICB0LnZhckFyZ3MgPyBcIi4uLlwiIDogbnVsbCxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCBwYXJhbVwifSwgdC5uYW1lKSxcbiAgICAgIHQub3B0aW9uYWwgPyBcIj86IFwiIDogXCI6IFwiLFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChUeXBlRGVmLCB7XG4gICAgICAgIHByZWZpeDogdC5uYW1lLmxlbmd0aCArICh0LnZhckFyZ3MgPyAzIDogMCkgKyAodC5vcHRpb25hbCA/IDMgOiAyKSwgXG4gICAgICAgIGluZm86IGluZm8sIFxuICAgICAgICB0eXBlOiB0LnR5cGV9XG4gICAgICApXG4gICAgXTt9KVxuICAgIC5pbnRlcnBvc2Uoc2hvdWxkV3JhcCA/IFtcIixcIiwgUmVhY3QuY3JlYXRlRWxlbWVudChcImJyXCIsIG51bGwpXSA6IFwiLCBcIilcbiAgICAudG8oQXJyYXkpO1xuICByZXR1cm4gc2hvdWxkV3JhcCA/IChcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtjbGFzc05hbWU6IFwidCBibG9ja1BhcmFtc1wifSwgZWxlbWVudHMpXG4gICkgOiAoXG4gICAgZWxlbWVudHNcbiAgKTtcbn1cblxuZnVuY3Rpb24gY2FsbFNpZ0xlbmd0aChpbmZvLCBtb2R1bGUsIG5hbWUsIHNpZykge1xuICByZXR1cm4gKG1vZHVsZSA/IG1vZHVsZS5sZW5ndGggKyAxIDogMCkgKyBuYW1lLmxlbmd0aCArIGZ1bmNMZW5ndGgoaW5mbywgc2lnKTtcbn1cblxuZnVuY3Rpb24gZnVuY0xlbmd0aChpbmZvLCBzaWcpIHtcbiAgcmV0dXJuIChcbiAgICAoc2lnLnR5cGVQYXJhbXMgPyAyICsgc2lnLnR5cGVQYXJhbXMuam9pbihcIiwgXCIpLmxlbmd0aCA6IDApICtcbiAgICAyICtcbiAgICAoc2lnLnBhcmFtcyA/IHBhcmFtTGVuZ3RoKGluZm8sIHNpZy5wYXJhbXMpIDogMCkgK1xuICAgIChzaWcudHlwZSA/IDIgKyB0eXBlTGVuZ3RoKGluZm8sIHNpZy50eXBlKSA6IDApXG4gICk7XG59XG5cbmZ1bmN0aW9uIHBhcmFtTGVuZ3RoKGluZm8sIHBhcmFtcykge1xuICByZXR1cm4gcGFyYW1zLnJlZHVjZShcbiAgICBmdW5jdGlvbihzLCBwKSBcbiAgICAgIHtyZXR1cm4gcyArXG4gICAgICAocC52YXJBcmdzID8gMyA6IDApICtcbiAgICAgIHAubmFtZS5sZW5ndGggK1xuICAgICAgKHAub3B0aW9uYWwgPyAzIDogMikgK1xuICAgICAgdHlwZUxlbmd0aChpbmZvLCBwLnR5cGUpO30sXG4gICAgKHBhcmFtcy5sZW5ndGggLSAxKSAqIDJcbiAgKTtcbn1cblxuZnVuY3Rpb24gbWVtYmVyTGVuZ3RoKGluZm8sIG1lbWJlcnMpIHtcbiAgcmV0dXJuIG1lbWJlcnMucmVkdWNlKFxuICAgIGZ1bmN0aW9uKHMsIG0pIFxuICAgICAge3JldHVybiBzICtcbiAgICAgIChtLmluZGV4ID8gcGFyYW1MZW5ndGgoaW5mbywgbS5wYXJhbXMpICsgNCA6IG0ubmFtZSArIDIpICtcbiAgICAgIHR5cGVMZW5ndGgoaW5mbywgbS50eXBlKTt9LFxuICAgIChtZW1iZXJzLmxlbmd0aCAtIDEpICogMlxuICApO1xufVxuXG5mdW5jdGlvbiB0eXBlTGVuZ3RoKGluZm8sIHR5cGUpIHtcbiAgaWYgKCF0eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgdHlwZVwiKTtcbiAgfVxuICBzd2l0Y2ggKHR5cGUuaykge1xuICAgIGNhc2UgVHlwZUtpbmQuTmV2ZXI6XG4gICAgICByZXR1cm4gNTtcbiAgICBjYXNlIFR5cGVLaW5kLk51bGw6XG4gICAgICByZXR1cm4gNDtcbiAgICBjYXNlIFR5cGVLaW5kLlZvaWQ6XG4gICAgICByZXR1cm4gNDtcbiAgICBjYXNlIFR5cGVLaW5kLkFueTpcbiAgICAgIHJldHVybiAzO1xuICAgIGNhc2UgVHlwZUtpbmQuVGhpczpcbiAgICAgIHJldHVybiA0O1xuICAgIGNhc2UgVHlwZUtpbmQuVW5kZWZpbmVkOlxuICAgICAgcmV0dXJuIDk7XG4gICAgY2FzZSBUeXBlS2luZC5Cb29sZWFuOlxuICAgICAgcmV0dXJuIDc7XG4gICAgY2FzZSBUeXBlS2luZC5OdW1iZXI6XG4gICAgICByZXR1cm4gNjtcbiAgICBjYXNlIFR5cGVLaW5kLlN0cmluZzpcbiAgICAgIHJldHVybiA2O1xuICAgIGNhc2UgVHlwZUtpbmQuVW5pb246XG4gICAgY2FzZSBUeXBlS2luZC5JbnRlcnNlY3Rpb246XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0eXBlLnR5cGVzLnJlZHVjZShmdW5jdGlvbihzLCB0KSAge3JldHVybiBzICsgdHlwZUxlbmd0aChpbmZvLCB0KTt9LCAwKSArXG4gICAgICAgICh0eXBlLnR5cGVzLmxlbmd0aCAtIDEpICogM1xuICAgICAgKTtcbiAgICBjYXNlIFR5cGVLaW5kLlR1cGxlOlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgMiArXG4gICAgICAgIHR5cGUudHlwZXMucmVkdWNlKGZ1bmN0aW9uKHMsIHQpICB7cmV0dXJuIHMgKyB0eXBlTGVuZ3RoKGluZm8sIHQpO30sIDApICtcbiAgICAgICAgKHR5cGUudHlwZXMubGVuZ3RoIC0gMSkgKiAyXG4gICAgICApO1xuICAgIGNhc2UgVHlwZUtpbmQuT2JqZWN0OlxuICAgICAgcmV0dXJuIDIgKyBtZW1iZXJMZW5ndGgoaW5mbywgdHlwZS5tZW1iZXJzKTtcbiAgICBjYXNlIFR5cGVLaW5kLkluZGV4ZWQ6XG4gICAgICByZXR1cm4gMiArIHR5cGVMZW5ndGgoaW5mbywgdHlwZS50eXBlKSArIHR5cGVMZW5ndGgoaW5mbywgdHlwZS5pbmRleCk7XG4gICAgY2FzZSBUeXBlS2luZC5PcGVyYXRvcjpcbiAgICAgIHJldHVybiAxICsgdHlwZS5vcGVyYXRvci5sZW5ndGggKyB0eXBlTGVuZ3RoKGluZm8sIHR5cGUudHlwZSk7XG4gICAgY2FzZSBUeXBlS2luZC5BcnJheTpcbiAgICAgIHJldHVybiB0eXBlTGVuZ3RoKGluZm8sIHR5cGUudHlwZSkgKyAyO1xuICAgIGNhc2UgVHlwZUtpbmQuRnVuY3Rpb246XG4gICAgICByZXR1cm4gMiArIGZ1bmNMZW5ndGgoaW5mbywgdHlwZSk7XG4gICAgY2FzZSBUeXBlS2luZC5QYXJhbTpcbiAgICAgIHJldHVybiBpbmZvICYmIGluZm8ucHJvcE1hcFtpbmZvLmRlZmluaW5nICsgXCI8XCIgKyB0eXBlLnBhcmFtXVxuICAgICAgICA/IHR5cGVMZW5ndGgobnVsbCwgaW5mby5wcm9wTWFwW2luZm8uZGVmaW5pbmcgKyBcIjxcIiArIHR5cGUucGFyYW1dKVxuICAgICAgICA6IHR5cGUucGFyYW0ubGVuZ3RoO1xuICAgIGNhc2UgVHlwZUtpbmQuVHlwZTpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHR5cGUubmFtZS5sZW5ndGggK1xuICAgICAgICAoIXR5cGUuYXJnc1xuICAgICAgICAgID8gMFxuICAgICAgICAgIDogdHlwZS5hcmdzLnJlZHVjZShcbiAgICAgICAgICAgICAgZnVuY3Rpb24ocywgYSkgIHtyZXR1cm4gcyArIHR5cGVMZW5ndGgoaW5mbywgYSk7fSxcbiAgICAgICAgICAgICAgdHlwZS5hcmdzLmxlbmd0aCAqIDJcbiAgICAgICAgICAgICkpXG4gICAgICApO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlR5cGUgd2l0aCB1bmtub3duIGtpbmQgXCIgKyBKU09OLnN0cmluZ2lmeSh0eXBlKSk7XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBwYWNrYWdlSnNvbiA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9wYWNrYWdlLmpzb25cIik7XG5cbnZhciBEb2NIZWFkZXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiRG9jSGVhZGVyXCIsXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcImhlYWRlclwifSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2NsYXNzTmFtZTogXCJtaW5pSGVhZGVyXCJ9LCBcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtjbGFzc05hbWU6IFwibWluaUhlYWRlck1hc2tcIn0sIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcIm1pbmlIZWFkZXJCb2R5XCJ9LCBcbiAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcIm1pbmlIZWFkZXJDb250ZW50c1wifSwgXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwge2hyZWY6IFwiLi9cIiwgdGFyZ2V0OiBcIl9zZWxmXCIsIGNsYXNzTmFtZTogXCJtaW5pTG9nb1wifSwgXG4gICAgICAgICAgICAgICAgICBcInNlcXVpbnNcIlxuICAgICAgICAgICAgICAgICksIFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHtocmVmOiBcIi4vXCIsIHRhcmdldDogXCJfc2VsZlwifSwgXG4gICAgICAgICAgICAgICAgICBcIkRvY3MgKHZcIiwgXG4gICAgICAgICAgICAgICAgICBwYWNrYWdlSnNvbi52ZXJzaW9uLCBcIilcIlxuICAgICAgICAgICAgICAgICksIFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHtocmVmOiBcImh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zL3RhZ2dlZC9zZXF1aW5zP3NvcnQ9dm90ZXNcIn0sIFxuICAgICAgICAgICAgICAgICAgXCJRdWVzdGlvbnNcIlxuICAgICAgICAgICAgICAgICksIFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHtocmVmOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9jb25hcnRpc3Q2L3NlcXVpbnMvXCJ9LCBcIkdpdGh1YlwiKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSwgXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcIm1pbmlIZWFkZXJCb2R5XCJ9LCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2NsYXNzTmFtZTogXCJtaW5pSGVhZGVyQ29udGVudHNcIn0sIFxuICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtjbGFzc05hbWU6IFwibWluaUxvZ28gaW52ZXJ0ZWRcIn0sIFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwiaGlkZGVuXCJ9LCBcInNlXCIpLCBcInFcIiwgXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogXCJoaWRkZW5cIn0sIFwidWluc1wiKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRG9jSGVhZGVyO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgUm91dGVyID0gcmVxdWlyZShcInJlYWN0LXJvdXRlclwiKTtcbnZhciAkX18wPSAgICByZXF1aXJlKFwiLi4vLi4vLi4vLi5cIiksU2VxPSRfXzAuU2VxO1xudmFyIE1hcmtkb3duID0gcmVxdWlyZShcIi4vTWFya0Rvd25cIik7XG5cbnZhciBEb2NPdmVydmlldyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJEb2NPdmVydmlld1wiLFxuICByZW5kZXI6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlZiA9IHRoaXMucHJvcHMuZGVmO1xuICAgIHZhciBkb2MgPSBkZWYuZG9jO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgXG4gICAgICAgIGRvYyAmJiAoXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwgbnVsbCwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1hcmtkb3duLCB7Y29udGVudHM6IGRvYy5zeW5vcHNpc30pLCBcbiAgICAgICAgICAgIGRvYy5kZXNjcmlwdGlvbiAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KE1hcmtkb3duLCB7Y29udGVudHM6IGRvYy5kZXNjcmlwdGlvbn0pXG4gICAgICAgICAgKVxuICAgICAgICApLCBcbiAgICAgICAgU2VxKGRlZi5ncm91cHMpXG4gICAgICAgICAgLm1hcChmdW5jdGlvbihncm91cCkgIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIsIG51bGwsIFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImdyb3VwVGl0bGVcIn0sIGdyb3VwLnRpdGxlKSwgXG4gICAgICAgICAgICAgICAgU2VxKGdyb3VwLm1lbWJlcnMpXG4gICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHQsIG5hbWUpICB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpc0Z1bmN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0LmNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdCA9IHQuY2xhc3M7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodC5pbnRlcmZhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0ID0gdC5pbnRlcmZhY2U7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXQubW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaXNGdW5jdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgdCA9IHQuY2FsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwge2tleTogbmFtZSwgY2xhc3NOYW1lOiBcImludGVyZmFjZU1lbWJlclwifSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDNcIiwge2NsYXNzTmFtZTogXCJtZW1iZXJMYWJlbFwifSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLkxpbmssIHt0bzogXCIvXCIgKyBuYW1lfSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSArIChpc0Z1bmN0aW9uID8gXCIoKVwiIDogXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICB0LmRvYyAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFya2Rvd24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiZGV0YWlsXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzOiB0LmRvYy5zeW5vcHNpc31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAudmFsdWVzKClcbiAgICAgICAgICAgICAgICAgIC50byhBcnJheSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50byhBcnJheSlcbiAgICAgIClcbiAgICApO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEb2NPdmVydmlldztcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuXG52YXIgTWFya0Rvd24gPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiTWFya0Rvd25cIixcbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOmZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICByZW5kZXI6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIGh0bWwgPSB0aGlzLnByb3BzLmNvbnRlbnRzO1xuICAgIHJldHVybiAoXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiB0aGlzLnByb3BzLmNsYXNzTmFtZSwgXG4gICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7IF9faHRtbDogaHRtbH19XG4gICAgICApXG4gICAgKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFya0Rvd247XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBSZWFjdFRyYW5zaXRpb25FdmVudHMgPSByZXF1aXJlKFwicmVhY3QvbGliL1JlYWN0VHJhbnNpdGlvbkV2ZW50c1wiKTtcbnZhciBSb3V0ZXIgPSByZXF1aXJlKFwicmVhY3Qtcm91dGVyXCIpO1xudmFyICRfXzA9ICAgICByZXF1aXJlKFwiLi9EZWZzXCIpLENhbGxTaWdEZWY9JF9fMC5DYWxsU2lnRGVmLE1lbWJlckRlZj0kX18wLk1lbWJlckRlZjtcbnZhciBQYWdlRGF0YU1peGluID0gcmVxdWlyZShcIi4vUGFnZURhdGFNaXhpblwiKTtcbnZhciBpc01vYmlsZSA9IHJlcXVpcmUoXCIuL2lzTW9iaWxlXCIpO1xudmFyIE1hcmtEb3duID0gcmVxdWlyZShcIi4vTWFya0Rvd25cIik7XG52YXIgJF9fMT0gICAgcmVxdWlyZShcIi4vdXRpbHNcIiksZ2V0RGlzcGxheVR5cGVOYW1lPSRfXzEuZ2V0RGlzcGxheVR5cGVOYW1lO1xuXG52YXIgJF9fMj0gICAgUmVhY3QuYWRkb25zLFRyYW5zaXRpb25Hcm91cD0kX18yLlRyYW5zaXRpb25Hcm91cDtcblxudmFyIGlnbm9yZWROb3RlcyA9IFtcImNvbnN0cnVjdHNcIiwgXCJwcmFnbWFcIl07XG5cbnZhciBNZW1iZXJEb2MgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiTWVtYmVyRG9jXCIsXG4gIG1peGluczogW1BhZ2VEYXRhTWl4aW4sIFJvdXRlci5OYXZpZ2F0aW9uXSxcblxuICBnZXRJbml0aWFsU3RhdGU6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNob3dEZXRhaWwgPSB0aGlzLnByb3BzLnNob3dEZXRhaWw7XG4gICAgcmV0dXJuIHsgZGV0YWlsOiBzaG93RGV0YWlsIH07XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6ZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuc2hvd0RldGFpbCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldERPTU5vZGUoKTtcbiAgICAgIHZhciBuYXZUeXBlID0gdGhpcy5nZXRQYWdlRGF0YSgpLnR5cGU7XG4gICAgICBpZiAobmF2VHlwZSA9PT0gXCJpbml0XCIgfHwgbmF2VHlwZSA9PT0gXCJwdXNoXCIpIHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKHdpbmRvdy5zY3JvbGxYLCBvZmZzZXRUb3Aobm9kZSkgLSBGSVhFRF9IRUFERVJfSEVJR0hUKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczpmdW5jdGlvbihuZXh0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLnNob3dEZXRhaWwgJiYgIXRoaXMucHJvcHMuc2hvd0RldGFpbCkge1xuICAgICAgdGhpcy5zY3JvbGxUbyA9IHRydWU7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgZGV0YWlsOiB0cnVlIH0pO1xuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnREaWRVcGRhdGU6ZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuc2Nyb2xsVG8pIHtcbiAgICAgIHRoaXMuc2Nyb2xsVG8gPSBmYWxzZTtcbiAgICAgIHZhciBub2RlID0gdGhpcy5nZXRET01Ob2RlKCk7XG4gICAgICB2YXIgbmF2VHlwZSA9IHRoaXMuZ2V0UGFnZURhdGEoKS50eXBlO1xuICAgICAgaWYgKG5hdlR5cGUgPT09IFwiaW5pdFwiIHx8IG5hdlR5cGUgPT09IFwicHVzaFwiKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbyh3aW5kb3cuc2Nyb2xsWCwgb2Zmc2V0VG9wKG5vZGUpIC0gRklYRURfSEVBREVSX0hFSUdIVCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHRvZ2dsZURldGFpbDpmdW5jdGlvbigpIHtcbiAgICAvLyBOb3RlOiByZW1vdmVkIHRoaXMgYmVjYXVzZSBpdCBkcm9wcyB0aGUgVVJMIGJhciBvbiBtb2JpbGUsIGFuZCB0aGF0J3NcbiAgICAvLyB0aGUgb25seSBwbGFjZSBpdCdzIGN1cnJlbnRseSBiZWluZyB1c2VkLlxuICAgIC8vIHZhciBtZW1iZXIgPSB0aGlzLnByb3BzLm1lbWJlcjtcbiAgICAvLyB2YXIgbmFtZSA9IG1lbWJlci5tZW1iZXJOYW1lO1xuICAgIC8vIHZhciB0eXBlTmFtZSA9IHRoaXMucHJvcHMucGFyZW50TmFtZTtcbiAgICAvLyB2YXIgc2hvd0RldGFpbCA9IHRoaXMucHJvcHMuc2hvd0RldGFpbDtcbiAgICAvLyBpZiAoIXRoaXMuc3RhdGUuZGV0YWlsKSB7XG4gICAgLy8gICB0aGlzLnJlcGxhY2VXaXRoKCcvJyArICh0eXBlTmFtZSA/IHR5cGVOYW1lICsgJy8nIDogJycpICsgbmFtZSApO1xuICAgIC8vIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5kZXRhaWwgJiYgc2hvd0RldGFpbCkge1xuICAgIC8vICAgdGhpcy5yZXBsYWNlV2l0aCgnLycgKyAodHlwZU5hbWUgfHwgJycpICk7XG4gICAgLy8gfVxuICAgIHRoaXMuc2V0U3RhdGUoeyBkZXRhaWw6ICF0aGlzLnN0YXRlLmRldGFpbCB9KTtcbiAgfSxcblxuICByZW5kZXI6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIHR5cGVQcm9wTWFwID0gdGhpcy5wcm9wcy50eXBlUHJvcE1hcDtcbiAgICB2YXIgbWVtYmVyID0gdGhpcy5wcm9wcy5tZW1iZXI7XG4gICAgdmFyIG1vZHVsZSA9IG1lbWJlci5pc1N0YXRpYyA/IHRoaXMucHJvcHMucGFyZW50TmFtZSA6IG51bGw7XG4gICAgdmFyIG5hbWUgPSBtZW1iZXIubWVtYmVyTmFtZTtcbiAgICB2YXIgZGVmID0gbWVtYmVyLm1lbWJlckRlZjtcbiAgICB2YXIgZG9jID0gZGVmLmRvYyB8fCB7fTtcbiAgICB2YXIgaXNQcm9wID0gIWRlZi5zaWduYXR1cmVzO1xuXG4gICAgdmFyIHR5cGVJbmZvID0gbWVtYmVyLmluaGVyaXRlZCAmJiB7XG4gICAgICBwcm9wTWFwOiB0eXBlUHJvcE1hcCxcbiAgICAgIGRlZmluaW5nOiBtZW1iZXIuaW5oZXJpdGVkLm5hbWVcbiAgICB9O1xuXG4gICAgdmFyIHNob3dEZXRhaWwgPSBpc01vYmlsZSA/IHRoaXMuc3RhdGUuZGV0YWlsIDogdHJ1ZTtcblxuICAgIHZhciBtZW1iZXJBbmNob3JMaW5rID0gdGhpcy5wcm9wcy5wYXJlbnROYW1lICsgXCIvXCIgKyBuYW1lO1xuXG4gICAgdmFyIHR5cGVEZWYgPSBpc1Byb3AgPyAoXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCB7a2V5OiBcInR5cGVEZWZcIiwgY2xhc3NOYW1lOiBcImNvZGVCbG9jayBtZW1iZXJTaWduYXR1cmVcIn0sIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1lbWJlckRlZiwge21vZHVsZTogbW9kdWxlLCBtZW1iZXI6IHsgbmFtZTpuYW1lLCB0eXBlOiBkZWYudHlwZX19KVxuICAgICAgKVxuICAgICkgOiAoXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCB7a2V5OiBcInR5cGVEZWZcIiwgY2xhc3NOYW1lOiBcImNvZGVCbG9jayBtZW1iZXJTaWduYXR1cmVcIn0sIFxuICAgICAgICBkZWYuc2lnbmF0dXJlcy5tYXAoZnVuY3Rpb24oY2FsbFNpZywgaSkgIHtyZXR1cm4gW1xuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FsbFNpZ0RlZiwge1xuICAgICAgICAgICAga2V5OiBpLCBcbiAgICAgICAgICAgIGluZm86IHR5cGVJbmZvLCBcbiAgICAgICAgICAgIG1vZHVsZTogbW9kdWxlLCBcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsIFxuICAgICAgICAgICAgY2FsbFNpZzogY2FsbFNpZ31cbiAgICAgICAgICApLFxuICAgICAgICAgIFwiXFxuXCJcbiAgICAgICAgXTt9KVxuICAgICAgKVxuICAgICk7XG5cbiAgICB2YXIgbWV0YWRhdGEgPSBbXG4gICAgICBtZW1iZXIuaW5oZXJpdGVkICYmIChcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwge2tleTogXCJpbmhlcml0ZWRcIn0sIFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImluZm9IZWFkZXJcIn0sIFwiSW5oZXJpdGVkIGZyb21cIiksIFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIG51bGwsIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIuTGluaywge3RvOiBcIi9cIiArIG1lbWJlci5pbmhlcml0ZWQubmFtZSArIFwiL1wiICsgbmFtZX0sIFxuICAgICAgICAgICAgICBtZW1iZXIuaW5oZXJpdGVkLm5hbWUgKyBcIiNcIiArIG5hbWVcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICBtZW1iZXIub3ZlcnJpZGVzICYmIChcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwge2tleTogXCJvdmVycmlkZXNcIn0sIFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImluZm9IZWFkZXJcIn0sIFwiT3ZlcnJpZGVzXCIpLCBcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCBudWxsLCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLkxpbmssIHt0bzogXCIvXCIgKyBtZW1iZXIub3ZlcnJpZGVzLm5hbWUgKyBcIi9cIiArIG5hbWV9LCBcbiAgICAgICAgICAgICAgbWVtYmVyLm92ZXJyaWRlcy5uYW1lICsgXCIjXCIgKyBuYW1lXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApLFxuICAgICAgLi4uKGRvYy5ub3Rlc1xuICAgICAgICA/IGRvYy5ub3Rlc1xuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihub3RlKSAge3JldHVybiAhaWdub3JlZE5vdGVzLmluY2x1ZGVzKG5vdGUubmFtZSk7fSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24obm90ZSwgaSkgIFxuICAgICAgICAgICAgICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIsIHtrZXk6IChcIm5vdGVfXCIgKyBpKX0sIFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImluZm9IZWFkZXJcIn0sIG5vdGUubmFtZSksIFxuICAgICAgICAgICAgICAgIG5vdGUubmFtZSA9PT0gXCJhbGlhc1wiID8gKFxuICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImNvZGVcIiwgbnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FsbFNpZ0RlZiwge25hbWU6IG5vdGUuYm9keX0pXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFya0Rvd24sIHtjbGFzc05hbWU6IFwiZGlzY3Vzc2lvblwiLCBjb250ZW50czogbm90ZS5ib2R5fSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7fVxuICAgICAgICAgICAgKVxuICAgICAgICA6IFtdKVxuICAgIF0uZmlsdGVyKEJvb2xlYW4pO1xuXG4gICAgdmFyIGRlc2NyaXB0aW9uID0gZG9jLmRlc2NyaXB0aW9uICYmIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIsIHtrZXk6IFwiZGVzY3JpcHRpb25cIn0sIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDRcIiwge2NsYXNzTmFtZTogXCJpbmZvSGVhZGVyXCJ9LCBcbiAgICAgICAgICBkb2MuZGVzY3JpcHRpb24uc3Vic3RyKDAsIDUpID09PSBcIjxjb2RlXCIgPyBcIkV4YW1wbGVcIiA6IFwiRGlzY3Vzc2lvblwiXG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1hcmtEb3duLCB7Y2xhc3NOYW1lOiBcImRpc2N1c3Npb25cIiwgY29udGVudHM6IGRvYy5kZXNjcmlwdGlvbn0pXG4gICAgICApXG4gICAgKTtcblxuICAgIHZhciBkZXRhaWwgPVxuICAgICAgZG9jLm5vdGVzICYmXG4gICAgICBkb2Mubm90ZXMuZmluZChcbiAgICAgICAgZnVuY3Rpb24obm90ZSkgXG4gICAgICAgICAge3JldHVybiBub3RlLm5hbWUgPT09IFwicHJhZ21hXCIgJiYgbm90ZS5ib2R5LnRyaW0oKSA9PT0gXCJzaG93RXhhbXBsZUFib3ZlVHlwZVwiO31cbiAgICAgIClcbiAgICAgICAgPyBbZGVzY3JpcHRpb24sIHR5cGVEZWYsIG1ldGFkYXRhXVxuICAgICAgICA6IFt0eXBlRGVmLCBtZXRhZGF0YSwgZGVzY3JpcHRpb25dO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2NsYXNzTmFtZTogXCJpbnRlcmZhY2VNZW1iZXJcIn0sIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDNcIiwge2NsYXNzTmFtZTogXCJtZW1iZXJMYWJlbFwifSwgXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIuTGluaywge1xuICAgICAgICAgICAgdG86IFwiL1wiICsgbWVtYmVyQW5jaG9yTGluaywgXG4gICAgICAgICAgICBvbkNsaWNrOiBpc01vYmlsZSA/IHRoaXMudG9nZ2xlRGV0YWlsIDogbnVsbFxuICAgICAgICAgIH0sIFxuICAgICAgICAgICAgKG1vZHVsZSA/IG1vZHVsZSArIFwiLlwiIDogXCJcIikgKyBuYW1lICsgKGlzUHJvcCA/IFwiXCIgOiBcIigpXCIpXG4gICAgICAgICAgKVxuICAgICAgICApLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChUcmFuc2l0aW9uR3JvdXAsIHtjaGlsZEZhY3Rvcnk6IG1ha2VTbGlkZURvd259LCBcbiAgICAgICAgICBzaG93RGV0YWlsICYmIChcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2tleTogXCJkZXRhaWxcIiwgY2xhc3NOYW1lOiBcImRldGFpbFwifSwgXG4gICAgICAgICAgICAgIGRvYy5zeW5vcHNpcyAmJiAoXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChNYXJrRG93biwge2NsYXNzTmFtZTogXCJzeW5vcHNpc1wiLCBjb250ZW50czogZG9jLnN5bm9wc2lzfSlcbiAgICAgICAgICAgICAgKSwgXG4gICAgICAgICAgICAgIGRldGFpbFxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBtYWtlU2xpZGVEb3duKGNoaWxkKSB7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFNsaWRlRG93biwgbnVsbCwgY2hpbGQpO1xufVxuXG52YXIgU2xpZGVEb3duID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiBcIlNsaWRlRG93blwiLFxuICBjb21wb25lbnRXaWxsRW50ZXI6ZnVuY3Rpb24oZG9uZSkge1xuICAgIHRoaXMuc2xpZGUoZmFsc2UsIGRvbmUpO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxMZWF2ZTpmdW5jdGlvbihkb25lKSB7XG4gICAgdGhpcy5zbGlkZSh0cnVlLCBkb25lKTtcbiAgfSxcblxuICBzbGlkZTpmdW5jdGlvbihzbGlkaW5nVXAsIGRvbmUpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0RE9NTm9kZSgpO1xuICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCI7XG4gICAgdmFyIGhlaWdodCA9IGdldENvbXB1dGVkU3R5bGUobm9kZSkuaGVpZ2h0O1xuICAgIHZhciBzdGFydCA9IHNsaWRpbmdVcCA/IGhlaWdodCA6IDA7XG4gICAgdmFyIGVuZCA9IHNsaWRpbmdVcCA/IDAgOiBoZWlnaHQ7XG4gICAgbm9kZS5zdHlsZS50cmFuc2l0aW9uID0gXCJcIjtcbiAgICBub2RlLnN0eWxlLmhlaWdodCA9IHN0YXJ0O1xuICAgIG5vZGUuc3R5bGUudHJhbnNpdGlvbiA9IFwiaGVpZ2h0IDAuMzVzIGVhc2UtaW4tb3V0XCI7XG4gICAgdmFyIGVuZExpc3RlbmVyID0gZnVuY3Rpb24oKSAge1xuICAgICAgUmVhY3RUcmFuc2l0aW9uRXZlbnRzLnJlbW92ZUVuZEV2ZW50TGlzdGVuZXIobm9kZSwgZW5kTGlzdGVuZXIpO1xuICAgICAgZG9uZSgpO1xuICAgIH07XG4gICAgUmVhY3RUcmFuc2l0aW9uRXZlbnRzLmFkZEVuZEV2ZW50TGlzdGVuZXIobm9kZSwgZW5kTGlzdGVuZXIpO1xuICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSAge1xuICAgICAgbm9kZS5zdHlsZS5oZWlnaHQgPSBlbmQ7XG4gICAgfSwgMTcpO1xuICB9LFxuXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfVxufSk7XG5cbnZhciBGSVhFRF9IRUFERVJfSEVJR0hUID0gNzU7XG5cbmZ1bmN0aW9uIG9mZnNldFRvcChub2RlKSB7XG4gIHZhciB0b3AgPSAwO1xuICBkbyB7XG4gICAgdG9wICs9IG5vZGUub2Zmc2V0VG9wO1xuICB9IHdoaWxlICgobm9kZSA9IG5vZGUub2Zmc2V0UGFyZW50KSk7XG4gIHJldHVybiB0b3A7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWVtYmVyRG9jO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb250ZXh0VHlwZXM6IHtcbiAgICBnZXRQYWdlRGF0YTogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtb3N0IHJlY2VudCBjaGFuZ2UgZXZlbnQuXG4gICAqL1xuICBnZXRQYWdlRGF0YTpmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LmdldFBhZ2VEYXRhKCk7XG4gIH1cbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBSb3V0ZXIgPSByZXF1aXJlKFwicmVhY3Qtcm91dGVyXCIpO1xudmFyICRfXzA9ICAgIHJlcXVpcmUoXCIuLi8uLi8uLi8uLlwiKSxTZXE9JF9fMC5TZXE7XG52YXIgZGVmcyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvZ2V0VHlwZURlZnNcIik7XG52YXIgJF9fMT0gICAgIHJlcXVpcmUoXCIuL3V0aWxzXCIpLGZsYXR0ZW5EZWY9JF9fMS5mbGF0dGVuRGVmLGdldERpc3BsYXlUeXBlTmFtZT0kX18xLmdldERpc3BsYXlUeXBlTmFtZTtcblxudmFyIFNpZGVCYXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiU2lkZUJhclwiLFxuICByZW5kZXI6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIHR5cGUgPSBkZWZzO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2NsYXNzTmFtZTogXCJzaWRlQmFyXCJ9LCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcInRvb2xCYXJcIn0sIFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgICAgb25DbGljazogdGhpcy5wcm9wcy50b2dnbGVTaG93SW5Hcm91cHMsIFxuICAgICAgICAgICAgb25LZXlQcmVzczogdGhpcy5wcm9wcy50b2dnbGVTaG93SW5Hcm91cHNcbiAgICAgICAgICB9LCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IHRoaXMucHJvcHMuc2hvd0luR3JvdXBzICYmIFwic2VsZWN0ZWRcIn0sIFxuICAgICAgICAgICAgICBcIkdyb3VwZWRcIlxuICAgICAgICAgICAgKSwgXG4gICAgICAgICAgICBcIiDigKIgXCIsIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogdGhpcy5wcm9wcy5zaG93SW5Hcm91cHMgfHwgXCJzZWxlY3RlZFwifSwgXG4gICAgICAgICAgICAgIFwiQWxwaGFiZXRpemVkXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtjbGFzc05hbWU6IFwic2Nyb2xsQ29udGVudFwifSwgXG4gICAgICAgICAgU2VxKHR5cGUuZ3JvdXBzKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihncm91cCkgIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCBudWxsLCBcbiAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImdyb3VwVGl0bGVcIn0sIGdyb3VwLnRpdGxlKSwgXG4gICAgICAgICAgICAgICAgICBTZXEoZ3JvdXAubWVtYmVycylcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbih0LCBuYW1lKSAge3JldHVybiB0aGlzLnJlbmRlclNpZGVCYXJUeXBlKG5hbWUsIHQpO30uYmluZCh0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgLnZhbHVlcygpXG4gICAgICAgICAgICAgICAgICAgIC50byhBcnJheSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgICAgICAudG8oQXJyYXkpXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9LFxuXG4gIHJlbmRlclNpZGVCYXJUeXBlOmZ1bmN0aW9uKHR5cGVOYW1lLCBkZWYpIHtcbiAgICB2YXIgaXNGb2N1cyA9IHRoaXMucHJvcHMuZm9jdXMgPT09IHR5cGVOYW1lO1xuICAgIHZhciBpc0Z1bmN0aW9uID0gIWRlZi5pbnRlcmZhY2UgJiYgIWRlZi5jbGFzcyAmJiAhZGVmLm1vZHVsZTtcbiAgICBkZWYgPSBmbGF0dGVuRGVmKGRlZiwgdHlwZU5hbWUpO1xuICAgIHZhciBjYWxscyA9IFNlcShkZWYuY29uc3RydWN0b3JzKTtcbiAgICB2YXIgZnVuY3Rpb25zID0gU2VxKChkZWYuY2xhc3MgJiYgZGVmLmNsYXNzLnN0YXRpY3MpIHx8IGRlZi5mdW5jdGlvbnMpO1xuXG4gICAgdmFyIGxhYmVsID0gdHlwZU5hbWUgKyAoaXNGdW5jdGlvbiA/IFwiKClcIiA6IFwiXCIpO1xuXG4gICAgaWYgKCFpc0ZvY3VzKSB7XG4gICAgICBsYWJlbCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLkxpbmssIHt0bzogXCIvXCIgKyB0eXBlTmFtZX0sIGxhYmVsKTtcbiAgICB9XG5cbiAgICB2YXIgbWVtYmVyR3JvdXBzID0gdGhpcy5wcm9wcy5tZW1iZXJHcm91cHM7XG5cbiAgICBjb25zdCBmbGF0ID0gU2VxKG1lbWJlckdyb3VwcylcbiAgICAgIC5tYXAoZnVuY3Rpb24obWVtYmVycywgdGl0bGUpIFxuICAgICAgICB7cmV0dXJuIG1lbWJlcnMubGVuZ3RoID09PSAwXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiBTZXEoW1xuICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDRcIiwge2tleTogdGl0bGUgfHwgXCJNZW1iZXJzXCIsIGNsYXNzTmFtZTogXCJncm91cFRpdGxlXCJ9LCBcbiAgICAgICAgICAgICAgICB0aXRsZSB8fCBcIk1lbWJlcnNcIlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBTZXEobWVtYmVycykubWFwKGZ1bmN0aW9uKG1lbWJlcikgIFxuICAgICAgICAgICAgICAgIHtyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7a2V5OiBtZW1iZXIubWVtYmVyTmFtZX0sIFxuICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIuTGluaywge3RvOiBcIi9cIiArIHR5cGVOYW1lICsgXCIvXCIgKyBtZW1iZXIubWVtYmVyTmFtZX0sIFxuICAgICAgICAgICAgICAgICAgICBtZW1iZXIubWVtYmVyTmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgKG1lbWJlci5tZW1iZXJEZWYuc2lnbmF0dXJlcyA/IFwiKClcIiA6IFwiXCIpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTt9XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF0pO31cbiAgICAgIClcbiAgICAgIC5mbGF0dGVuKClcbiAgICAgIC52YWx1ZXMoKVxuICAgICAgLnRvKEFycmF5KTtcblxuICAgIHZhciBtZW1iZXJzID1cbiAgICAgICFpc0ZvY3VzIHx8IGlzRnVuY3Rpb24gPyBudWxsIDogKFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtjbGFzc05hbWU6IFwibWVtYmVyc1wifSwgXG4gICAgICAgICAgY2FsbHMuY291bnQoKSA+IDAgJiYgKFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwgbnVsbCwgXG4gICAgICAgICAgICAgIGNhbGxzXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihjYWxsLCBuYW1lKSAgXG4gICAgICAgICAgICAgICAgICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2tleTogbmFtZX0sIFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlci5MaW5rLCB7dG86IFwiL1wiICsgdHlwZU5hbWUgKyBcIi9cIiArIG5hbWV9LCBcbiAgICAgICAgICAgICAgICAgICAgICBnZXREaXNwbGF5VHlwZU5hbWUobmFtZSwgdHlwZU5hbWUpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICk7fVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAudmFsdWVzKClcbiAgICAgICAgICAgICAgICAudG8oQXJyYXkpXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSwgXG5cbiAgICAgICAgICBmdW5jdGlvbnMuY291bnQoKSA+IDAgJiYgKFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwgbnVsbCwgXG4gICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImdyb3VwVGl0bGVcIn0sIFwiU3RhdGljIE1ldGhvZHNcIiksIFxuICAgICAgICAgICAgICBmdW5jdGlvbnNcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHQsIG5hbWUpICBcbiAgICAgICAgICAgICAgICAgIHtyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7a2V5OiBuYW1lfSwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLkxpbmssIHt0bzogXCIvXCIgKyB0eXBlTmFtZSArIFwiL1wiICsgbmFtZX0sIFxuICAgICAgICAgICAgICAgICAgICAgIGdldERpc3BsYXlUeXBlTmFtZShuYW1lLCB0eXBlTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKTt9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC52YWx1ZXMoKVxuICAgICAgICAgICAgICAgIC50byhBcnJheSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICApLCBcblxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIsIG51bGwsIFxuICAgICAgICAgICAgU2VxKG1lbWJlckdyb3VwcylcbiAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihtZW1iZXJzLCB0aXRsZSkgXG4gICAgICAgICAgICAgICAge3JldHVybiBtZW1iZXJzLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICA6IFNlcShbXG4gICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg0XCIsIHtrZXk6IHRpdGxlIHx8IFwiTWVtYmVyc1wiLCBjbGFzc05hbWU6IFwiZ3JvdXBUaXRsZVwifSwgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSB8fCBcIk1lbWJlcnNcIlxuICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgU2VxKG1lbWJlcnMpLm1hcChmdW5jdGlvbihtZW1iZXIpICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHtyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7a2V5OiBtZW1iZXIubWVtYmVyTmFtZX0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlci5MaW5rLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IFwiL1wiICsgdHlwZU5hbWUgKyBcIi9cIiArIG1lbWJlci5tZW1iZXJOYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lbWJlci5tZW1iZXJOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtZW1iZXIubWVtYmVyRGVmLnNpZ25hdHVyZXMgPyBcIigpXCIgOiBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApO31cbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIF0pO31cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAuZmxhdHRlbigpXG4gICAgICAgICAgICAgIC52YWx1ZXMoKVxuICAgICAgICAgICAgICAudG8oQXJyYXkpXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2tleTogdHlwZU5hbWV9LCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImgyXCIsIG51bGwsIGxhYmVsKSwgXG4gICAgICAgIG1lbWJlcnNcbiAgICAgIClcbiAgICApO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaWRlQmFyO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgUm91dGVyID0gcmVxdWlyZShcInJlYWN0LXJvdXRlclwiKTtcbnZhciAkX18wPSAgICAgcmVxdWlyZShcIi4uLy4uLy4uLy4uXCIpLFNlcT0kX18wLlNlcSxLZXllZFNlcXVlbmNlPSRfXzAuS2V5ZWRTZXF1ZW5jZTtcbnZhciAkX18xPSAgICAgcmVxdWlyZShcIi4vRGVmc1wiKSxJbnRlcmZhY2VEZWY9JF9fMS5JbnRlcmZhY2VEZWYsQ2FsbFNpZ0RlZj0kX18xLkNhbGxTaWdEZWY7XG52YXIgTWVtYmVyRG9jID0gcmVxdWlyZShcIi4vTWVtYmVyRG9jXCIpO1xudmFyIGlzTW9iaWxlID0gcmVxdWlyZShcIi4vaXNNb2JpbGVcIik7XG52YXIgU2lkZUJhciA9IHJlcXVpcmUoXCIuL1NpZGVCYXJcIik7XG52YXIgTWFya0Rvd24gPSByZXF1aXJlKFwiLi9NYXJrRG93blwiKTtcbnZhciBEb2NPdmVydmlldyA9IHJlcXVpcmUoXCIuL0RvY092ZXJ2aWV3XCIpO1xudmFyIGNvbGxlY3RNZW1iZXJHcm91cHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL2NvbGxlY3RNZW1iZXJHcm91cHNcIik7XG52YXIgVHlwZUtpbmQgPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL1R5cGVLaW5kXCIpO1xudmFyIGdldERlZkJ5UGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvZ2V0RGVmQnlQYXRoXCIpO1xudmFyICRfXzI9ICAgIHJlcXVpcmUoXCIuL3V0aWxzXCIpLGZsYXR0ZW5EZWY9JF9fMi5mbGF0dGVuRGVmO1xuXG52YXIgdHlwZURlZlVSTCA9XG4gIFwiaHR0cHM6Ly9naXRodWIuY29tL2NvbmFydGlzdDYvc2VxdWlucy9ibG9iL21hc3Rlci90eXBlLWRlZmluaXRpb25zL3NlcXVpbnMuZC50c1wiO1xudmFyIGlzc3Vlc1VSTCA9IFwiaHR0cHM6Ly9naXRodWIuY29tL2NvbmFydGlzdDYvc2VxdWlucy9pc3N1ZXNcIjtcblxudmFyIERpc2NsYWltZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCB7Y2xhc3NOYW1lOiBcImRpc2NsYWltZXJcIn0sIFxuICAgICAgXCJUaGlzIGRvY3VtZW50YXRpb24gaXMgZ2VuZXJhdGVkIGZyb20gXCIsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHtocmVmOiB0eXBlRGVmVVJMfSwgXCJzZXF1aW5zLmQudHNcIiksIFxuICAgICAgXCIuIFB1bGwgcmVxdWVzdHMgYW5kIFwiLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7aHJlZjogaXNzdWVzVVJMfSwgXCJJc3N1ZXNcIiksIFwiIHdlbGNvbWUuXCJcbiAgICApXG4gICk7XG59O1xuXG52YXIgVHlwZURvY3VtZW50YXRpb24gPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiVHlwZURvY3VtZW50YXRpb25cIixcbiAgZ2V0SW5pdGlhbFN0YXRlOmZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzaG93SW5Hcm91cHM6IHRydWVcbiAgICB9O1xuICB9LFxuXG4gIHRvZ2dsZVNob3dJbkdyb3VwczpmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldFN0YXRlKHsgc2hvd0luR3JvdXBzOiAhdGhpcy5zdGF0ZS5zaG93SW5Hcm91cHMgfSk7XG4gIH0sXG5cbiAgcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgIHZhciBuYW1lID0gdGhpcy5wcm9wcy5uYW1lO1xuICAgIHZhciBtZW1iZXJOYW1lID0gdGhpcy5wcm9wcy5tZW1iZXJOYW1lO1xuICAgIHZhciBkZWYgPSB0aGlzLnByb3BzLmRlZjtcblxuICAgIHZhciBtZW1iZXJHcm91cHMgPSBjb2xsZWN0TWVtYmVyR3JvdXBzKFxuICAgICAgZGVmICYmIChkZWYuY2xhc3MgfHwgZGVmLmludGVyZmFjZSksXG4gICAgICB7XG4gICAgICAgIHNob3dJbkdyb3VwczogdGhpcy5zdGF0ZS5zaG93SW5Hcm91cHNcbiAgICAgIH1cbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgXG4gICAgICAgIGlzTW9iaWxlIHx8IChcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFNpZGVCYXIsIHtcbiAgICAgICAgICAgIGZvY3VzOiBuYW1lLCBcbiAgICAgICAgICAgIG1lbWJlckdyb3VwczogbWVtYmVyR3JvdXBzLCBcbiAgICAgICAgICAgIHRvZ2dsZVNob3dJbmhlcml0ZWQ6IHRoaXMudG9nZ2xlU2hvd0luaGVyaXRlZCwgXG4gICAgICAgICAgICB0b2dnbGVTaG93SW5Hcm91cHM6IHRoaXMudG9nZ2xlU2hvd0luR3JvdXBzLCBcbiAgICAgICAgICAgIHNob3dJbkdyb3VwczogdGhpcy5zdGF0ZS5zaG93SW5Hcm91cHN9XG4gICAgICAgICAgKVxuICAgICAgICApLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7a2V5OiBuYW1lLCBjbGFzc05hbWU6IFwiZG9jQ29udGVudHNcIn0sIFxuICAgICAgICAgICFkZWYgPyAoXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE5vdEZvdW5kLCBudWxsKVxuICAgICAgICAgICkgOiAhbmFtZSA/IChcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRG9jT3ZlcnZpZXcsIHtkZWY6IGRlZn0pXG4gICAgICAgICAgKSA6ICFkZWYuaW50ZXJmYWNlICYmICFkZWYuY2xhc3MgJiYgIWRlZi5tb2R1bGUgPyAoXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEZ1bmN0aW9uRG9jLCB7bmFtZTogbmFtZSwgZGVmOiBkZWYuY2FsbH0pXG4gICAgICAgICAgKSA6IChcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVHlwZURvYywge1xuICAgICAgICAgICAgICBuYW1lOiBuYW1lLCBcbiAgICAgICAgICAgICAgZGVmOiBkZWYsIFxuICAgICAgICAgICAgICBtZW1iZXJOYW1lOiBtZW1iZXJOYW1lLCBcbiAgICAgICAgICAgICAgbWVtYmVyR3JvdXBzOiBtZW1iZXJHcm91cHN9XG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIE5vdEZvdW5kKCkge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBcIk5vdCBmb3VuZFwiKTtcbn1cblxudmFyIEZ1bmN0aW9uRG9jID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiBcIkZ1bmN0aW9uRG9jXCIsXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcbiAgICB2YXIgZGVmID0gdGhpcy5wcm9wcy5kZWY7XG4gICAgdmFyIGRvYyA9IGRlZi5kb2MgfHwge307XG5cbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImgxXCIsIHtjbGFzc05hbWU6IFwidHlwZUhlYWRlclwifSwgbmFtZSArIFwiKClcIiksIFxuICAgICAgICBkb2Muc3lub3BzaXMgJiYgKFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFya0Rvd24sIHtjbGFzc05hbWU6IFwic3lub3BzaXNcIiwgY29udGVudHM6IGRvYy5zeW5vcHNpc30pXG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCB7Y2xhc3NOYW1lOiBcImNvZGVCbG9jayBtZW1iZXJTaWduYXR1cmVcIn0sIFxuICAgICAgICAgIGRlZi5zaWduYXR1cmVzLm1hcChmdW5jdGlvbihjYWxsU2lnLCBpKSAge3JldHVybiBbXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENhbGxTaWdEZWYsIHtrZXk6IGksIG5hbWU6IG5hbWUsIGNhbGxTaWc6IGNhbGxTaWd9KSxcbiAgICAgICAgICAgIFwiXFxuXCJcbiAgICAgICAgICBdO30pXG4gICAgICAgICksIFxuICAgICAgICBkb2Mubm90ZXMgJiZcbiAgICAgICAgICBkb2Mubm90ZXMubWFwKGZ1bmN0aW9uKG5vdGUsIGkpICBcbiAgICAgICAgICAgIHtyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwge2tleTogaX0sIFxuICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDRcIiwge2NsYXNzTmFtZTogXCJpbmZvSGVhZGVyXCJ9LCBub3RlLm5hbWUpLCBcbiAgICAgICAgICAgICAgbm90ZS5uYW1lID09PSBcImFsaWFzXCIgPyAoXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDYWxsU2lnRGVmLCB7bmFtZTogbm90ZS5ib2R5fSlcbiAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICBub3RlLmJvZHlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTt9XG4gICAgICAgICAgKSwgXG4gICAgICAgIGRvYy5kZXNjcmlwdGlvbiAmJiAoXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwgbnVsbCwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDRcIiwge2NsYXNzTmFtZTogXCJpbmZvSGVhZGVyXCJ9LCBcbiAgICAgICAgICAgICAgZG9jLmRlc2NyaXB0aW9uLnN1YnN0cigwLCA1KSA9PT0gXCI8Y29kZVwiXG4gICAgICAgICAgICAgICAgPyBcIkV4YW1wbGVcIlxuICAgICAgICAgICAgICAgIDogXCJEaXNjdXNzaW9uXCJcbiAgICAgICAgICAgICksIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChNYXJrRG93biwge2NsYXNzTmFtZTogXCJkaXNjdXNzaW9uXCIsIGNvbnRlbnRzOiBkb2MuZGVzY3JpcHRpb259KVxuICAgICAgICAgIClcbiAgICAgICAgKSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRGlzY2xhaW1lciwgbnVsbClcbiAgICAgIClcbiAgICApO1xuICB9XG59KTtcblxudmFyIFR5cGVEb2MgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiVHlwZURvY1wiLFxuICByZW5kZXI6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnByb3BzLm5hbWU7XG4gICAgdmFyIGRlZiA9IHRoaXMucHJvcHMuZGVmO1xuICAgIHZhciBtZW1iZXJOYW1lID0gdGhpcy5wcm9wcy5tZW1iZXJOYW1lO1xuICAgIHZhciBtZW1iZXJHcm91cHMgPSB0aGlzLnByb3BzLm1lbWJlckdyb3VwcztcblxuICAgIHZhciBmbGF0RGVmID0gZmxhdHRlbkRlZihkZWYsIG5hbWUpO1xuXG4gICAgdmFyIGNhbGxzID0gU2VxKGZsYXREZWYuY29uc3RydWN0b3JzKTtcblxuICAgIHZhciBpbnRlcmZhY2VEZWYgPSBkZWYuY2xhc3MgfHwgZGVmLmludGVyZmFjZTtcbiAgICB2YXIgZnVuY3Rpb25zID0gU2VxKChkZWYuY2xhc3MgJiYgZGVmLmNsYXNzLnN0YXRpY3MpIHx8IGZsYXREZWYuZnVuY3Rpb25zKTtcbiAgICB2YXIgdHlwZXMgPSBTZXEoZGVmLm1vZHVsZSkuZmlsdGVyKGZ1bmN0aW9uKHQpICB7cmV0dXJuIHQuaW50ZXJmYWNlIHx8IHQuY2xhc3MgfHwgdC5tb2R1bGU7fSk7XG5cbiAgICB2YXIgdHlwZVByb3BNYXAgPSBnZXRUeXBlUHJvcE1hcChpbnRlcmZhY2VEZWYpO1xuXG4gICAgdmFyIGRvYyA9IChpbnRlcmZhY2VEZWYgPyBpbnRlcmZhY2VEZWYuZG9jIDogZGVmLmRvYykgfHwge307XG5cbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImgxXCIsIHtjbGFzc05hbWU6IFwidHlwZUhlYWRlclwifSwgbmFtZSksIFxuICAgICAgICBkb2Muc3lub3BzaXMgJiYgKFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFya0Rvd24sIHtjbGFzc05hbWU6IFwic3lub3BzaXNcIiwgY29udGVudHM6IGRvYy5zeW5vcHNpc30pXG4gICAgICAgICksIFxuICAgICAgICBpbnRlcmZhY2VEZWYgJiYgKFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIHtjbGFzc05hbWU6IFwiY29kZUJsb2NrIG1lbWJlclNpZ25hdHVyZVwifSwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEludGVyZmFjZURlZiwge25hbWU6IG5hbWUsIGRlZjogaW50ZXJmYWNlRGVmfSlcbiAgICAgICAgICApXG4gICAgICAgICksIFxuXG4gICAgICAgIGRvYy5ub3RlcyAmJlxuICAgICAgICAgIGRvYy5ub3Rlcy5tYXAoZnVuY3Rpb24obm90ZSwgaSkgIFxuICAgICAgICAgICAge3JldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCB7a2V5OiBpfSwgXG4gICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImluZm9IZWFkZXJcIn0sIG5vdGUubmFtZSksIFxuICAgICAgICAgICAgICBub3RlLm5hbWUgPT09IFwiYWxpYXNcIiA/IChcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENhbGxTaWdEZWYsIHtuYW1lOiBub3RlLmJvZHl9KVxuICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgIG5vdGUuYm9keVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO31cbiAgICAgICAgICApLCBcblxuICAgICAgICBkb2MuZGVzY3JpcHRpb24gJiYgKFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIsIG51bGwsIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg0XCIsIHtjbGFzc05hbWU6IFwiaW5mb0hlYWRlclwifSwgXG4gICAgICAgICAgICAgIGRvYy5kZXNjcmlwdGlvbi5zdWJzdHIoMCwgNSkgPT09IFwiPGNvZGVcIlxuICAgICAgICAgICAgICAgID8gXCJFeGFtcGxlXCJcbiAgICAgICAgICAgICAgICA6IFwiRGlzY3Vzc2lvblwiXG4gICAgICAgICAgICApLCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFya0Rvd24sIHtjbGFzc05hbWU6IFwiZGlzY3Vzc2lvblwiLCBjb250ZW50czogZG9jLmRlc2NyaXB0aW9ufSlcbiAgICAgICAgICApXG4gICAgICAgICksIFxuXG4gICAgICAgIHR5cGVzLnNpemUgPiAwICYmIChcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCBudWxsLCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImdyb3VwVGl0bGVcIn0sIFwiU3ViLXR5cGVzXCIpLCBcbiAgICAgICAgICAgIHR5cGVzXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24odCwgdHlwZU5hbWUpICBcbiAgICAgICAgICAgICAgICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2tleTogdHlwZU5hbWV9LCBcbiAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgdG86IFwiL1wiICsgKG5hbWUgPyBuYW1lICsgXCIuXCIgKyB0eXBlTmFtZSA6IHR5cGVOYW1lKVxuICAgICAgICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPyBuYW1lICsgXCIuXCIgKyB0eXBlTmFtZSA6IHR5cGVOYW1lXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTt9XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgLnZhbHVlcygpXG4gICAgICAgICAgICAgIC50byhBcnJheSlcbiAgICAgICAgICApXG4gICAgICAgICksIFxuXG4gICAgICAgIGNhbGxzLmNvdW50KCkgPiAwICYmIChcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCBudWxsLCBcbiAgICAgICAgICAgIGNhbGxzXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oY2FsbCwgY2FsbE5hbWUpICBcbiAgICAgICAgICAgICAgICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtYmVyRG9jLCB7XG4gICAgICAgICAgICAgICAgICBrZXk6IGNhbGxOYW1lLCBcbiAgICAgICAgICAgICAgICAgIHNob3dEZXRhaWw6IGNhbGxOYW1lID09PSBtZW1iZXJOYW1lLCBcbiAgICAgICAgICAgICAgICAgIHBhcmVudE5hbWU6IG5hbWUsIFxuICAgICAgICAgICAgICAgICAgbWVtYmVyOiB7XG4gICAgICAgICAgICAgICAgICAgIG1lbWJlck5hbWU6IGNhbGxOYW1lLFxuICAgICAgICAgICAgICAgICAgICBtZW1iZXJEZWY6IGNhbGwsXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhdGljOiBjYWxsTmFtZSAhPT0gbmFtZVxuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICApO31cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAudmFsdWVzKClcbiAgICAgICAgICAgICAgLnRvKEFycmF5KVxuICAgICAgICAgIClcbiAgICAgICAgKSwgXG5cbiAgICAgICAgZnVuY3Rpb25zLmNvdW50KCkgPiAwICYmIChcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCBudWxsLCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImdyb3VwVGl0bGVcIn0sIFwiU3RhdGljIG1ldGhvZHNcIiksIFxuICAgICAgICAgICAgZnVuY3Rpb25zXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZGVmLCBmbk5hbWUpICBcbiAgICAgICAgICAgICAgICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtYmVyRG9jLCB7XG4gICAgICAgICAgICAgICAgICBrZXk6IGZuTmFtZSwgXG4gICAgICAgICAgICAgICAgICBzaG93RGV0YWlsOiBmbk5hbWUgPT09IG1lbWJlck5hbWUsIFxuICAgICAgICAgICAgICAgICAgcGFyZW50TmFtZTogbmFtZSwgXG4gICAgICAgICAgICAgICAgICBtZW1iZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyTmFtZTogZm5OYW1lLFxuICAgICAgICAgICAgICAgICAgICBtZW1iZXJEZWY6IGRlZixcbiAgICAgICAgICAgICAgICAgICAgaXNTdGF0aWM6IHRydWVcbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgKTt9XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgLnZhbHVlcygpXG4gICAgICAgICAgICAgIC50byhBcnJheSlcbiAgICAgICAgICApXG4gICAgICAgICksIFxuXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIsIG51bGwsIFxuICAgICAgICAgIFNlcShtZW1iZXJHcm91cHMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKG1lbWJlcnMsIHRpdGxlKSBcbiAgICAgICAgICAgICAge3JldHVybiBtZW1iZXJzLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgIDogU2VxKFtcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg0XCIsIHtrZXk6IHRpdGxlIHx8IFwiTWVtYmVyc1wiLCBjbGFzc05hbWU6IFwiZ3JvdXBUaXRsZVwifSwgXG4gICAgICAgICAgICAgICAgICAgICAgdGl0bGUgfHwgXCJNZW1iZXJzXCJcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgU2VxKG1lbWJlcnMpLm1hcChmdW5jdGlvbihtZW1iZXIpICBcbiAgICAgICAgICAgICAgICAgICAgICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtYmVyRG9jLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlUHJvcE1hcDogdHlwZVByb3BNYXAsIFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBtZW1iZXIubWVtYmVyTmFtZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93RGV0YWlsOiBtZW1iZXIubWVtYmVyTmFtZSA9PT0gbWVtYmVyTmFtZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROYW1lOiBuYW1lLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbWJlcjogbWVtYmVyfVxuICAgICAgICAgICAgICAgICAgICAgICk7fVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICBdKTt9XG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuZmxhdHRlbigpXG4gICAgICAgICAgICAudmFsdWVzKClcbiAgICAgICAgICAgIC50byhBcnJheSlcbiAgICAgICAgKSwgXG5cbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEaXNjbGFpbWVyLCBudWxsKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEdldCBhIG1hcCBmcm9tIHN1cGVyIHR5cGUgcGFyYW1ldGVyIHRvIGNvbmNyZXRlIHR5cGUgZGVmaW5pdGlvbi4gVGhpcyBpc1xuICogdXNlZCB3aGVuIHJlbmRlcmluZyBpbmhlcml0ZWQgdHlwZSBkZWZpbml0aW9ucyB0byBlbnN1cmUgY29udGV4dHVhbGx5XG4gKiByZWxldmFudCBpbmZvcm1hdGlvbi5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgdHlwZSBBPFQ+IGltcGxlbWVudHMgQjxudW1iZXIsIFQ+XG4gKiAgIHR5cGUgQjxLLCBWPiBpbXBsZW1lbnRzIEM8SywgViwgVj5cbiAqICAgdHlwZSBDPFgsIFksIFo+XG4gKlxuICogcGFyc2UgQzpcbiAqICAge31cbiAqXG4gKiBwYXJzZSBCOlxuICogICB7IEM8WDogS1xuICogICAgIEM8WTogVlxuICogICAgIEM8WjogViB9XG4gKlxuICogcGFyc2UgQTpcbiAqICAgeyBCPEs6IG51bWJlclxuICogICAgIEI8VjogVFxuICogICAgIEM8WDogbnVtYmVyXG4gKiAgICAgQzxZOiBUXG4gKiAgICAgQzxaOiBUIH1cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZVByb3BNYXAoZGVmKSB7XG4gIHZhciBtYXAgPSB7fTtcbiAgZGVmICYmXG4gICAgZGVmLmV4dGVuZHMgJiZcbiAgICBkZWYuZXh0ZW5kcy5mb3JFYWNoKGZ1bmN0aW9uKGUpICB7XG4gICAgICB2YXIgc3VwZXJNb2R1bGUgPSBnZXREZWZCeVBhdGgoZS5uYW1lKTtcbiAgICAgIHZhciBzdXBlckludGVyZmFjZSA9XG4gICAgICAgIChzdXBlck1vZHVsZSAmJiBzdXBlck1vZHVsZS5jbGFzcykgfHwgc3VwZXJNb2R1bGUuaW50ZXJmYWNlO1xuICAgICAgaWYgKHN1cGVySW50ZXJmYWNlKSB7XG4gICAgICAgIHZhciBpbnRlcmZhY2VNYXAgPSBTZXEoc3VwZXJJbnRlcmZhY2UudHlwZVBhcmFtcylcbiAgICAgICAgICAudG8oS2V5ZWRTZXF1ZW5jZSlcbiAgICAgICAgICAuZmxpcCgpXG4gICAgICAgICAgLm1hcChmdW5jdGlvbihpKSAge3JldHVybiBlLmFyZ3NbaV07fSlcbiAgICAgICAgICAudG8oT2JqZWN0KTtcbiAgICAgICAgU2VxKGludGVyZmFjZU1hcCkuZm9yRWFjaChmdW5jdGlvbih2LCBrKSAge1xuICAgICAgICAgIG1hcFtlLm5hbWUgKyBcIjxcIiArIGtdID0gdjtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzdXBlck1hcCA9IGdldFR5cGVQcm9wTWFwKHN1cGVySW50ZXJmYWNlKTtcbiAgICAgICAgU2VxKHN1cGVyTWFwKS5mb3JFYWNoKGZ1bmN0aW9uKHYsIGspICB7XG4gICAgICAgICAgbWFwW2tdID0gdi5rID09PSBUeXBlS2luZC5QYXJhbSA/IGludGVyZmFjZU1hcFt2LnBhcmFtXSA6IHY7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICByZXR1cm4gbWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGVEb2N1bWVudGF0aW9uO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgYXNzaWduID0gcmVxdWlyZShcInJlYWN0L2xpYi9PYmplY3QuYXNzaWduXCIpO1xudmFyIFJvdXRlciA9IHJlcXVpcmUoXCJyZWFjdC1yb3V0ZXJcIik7XG52YXIgRG9jSGVhZGVyID0gcmVxdWlyZShcIi4vRG9jSGVhZGVyXCIpO1xudmFyIFR5cGVEb2N1bWVudGF0aW9uID0gcmVxdWlyZShcIi4vVHlwZURvY3VtZW50YXRpb25cIik7XG52YXIgZ2V0RGVmQnlQYXRoID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYi9nZXREZWZCeVBhdGhcIik7XG52YXIgU2VxdWlucyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLlwiKTtcblxud2luZG93LlNlcXVpbnMgPSBTZXF1aW5zO1xuY29uc29sZS5sb2coXCJGZWVsIGZyZWUgdG8gdHJ5IFNlcXVpbnMhXCIpO1xuY29uc29sZS5sb2coU2VxdWlucyk7XG5cbnZhciAkX18wPSAgICAgIFJvdXRlcixSb3V0ZT0kX18wLlJvdXRlLERlZmF1bHRSb3V0ZT0kX18wLkRlZmF1bHRSb3V0ZSxSb3V0ZUhhbmRsZXI9JF9fMC5Sb3V0ZUhhbmRsZXI7XG5cbnJlcXVpcmUoXCIuLi8uLi8uLi9saWIvcnVua2l0LWVtYmVkXCIpO1xuXG52YXIgRG9jdW1lbnRhdGlvbiA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJEb2N1bWVudGF0aW9uXCIsXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEb2NIZWFkZXIsIG51bGwpLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcInBhZ2VCb2R5XCIsIGlkOiBcImJvZHlcIn0sIFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2NsYXNzTmFtZTogXCJjb250ZW50c1wifSwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlSGFuZGxlciwgbnVsbClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9XG59KTtcblxudmFyIERvY0RldGVybWluZXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiRG9jRGV0ZXJtaW5lclwiLFxuICBtaXhpbnM6IFtSb3V0ZXIuU3RhdGVdLFxuXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICB2YXIgJF9fMD0gICAgICBkZXRlcm1pbmVEb2ModGhpcy5nZXRQYXRoKCkpLGRlZj0kX18wLmRlZixuYW1lPSRfXzAubmFtZSxtZW1iZXJOYW1lPSRfXzAubWVtYmVyTmFtZTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChUeXBlRG9jdW1lbnRhdGlvbiwge2RlZjogZGVmLCBuYW1lOiBuYW1lLCBtZW1iZXJOYW1lOiBtZW1iZXJOYW1lfSk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBkZXRlcm1pbmVEb2MocGF0aCkge1xuICB2YXIgJF9fMD0gICAgcGF0aC5zcGxpdChcIi9cIiksbmFtZT0kX18wWzFdLG1lbWJlck5hbWU9JF9fMFsyXTtcblxuICB2YXIgZGVmID0gZ2V0RGVmQnlQYXRoKG5hbWUpO1xuXG4gIHJldHVybiB7IGRlZjpkZWYsIG5hbWU6bmFtZSwgbWVtYmVyTmFtZTptZW1iZXJOYW1lIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiBcImV4cG9ydHNcIixcbiAgY2hpbGRDb250ZXh0VHlwZXM6IHtcbiAgICBnZXRQYWdlRGF0YTogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICB9LFxuXG4gIGdldENoaWxkQ29udGV4dDpmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0UGFnZURhdGE6IHRoaXMuZ2V0UGFnZURhdGFcbiAgICB9O1xuICB9LFxuXG4gIGdldFBhZ2VEYXRhOmZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBhZ2VEYXRhO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxNb3VudDpmdW5jdGlvbigpIHtcbiAgICB2YXIgbG9jYXRpb247XG4gICAgdmFyIHNjcm9sbEJlaGF2aW9yO1xuXG4gICAgaWYgKHdpbmRvdy5kb2N1bWVudCkge1xuICAgICAgbG9jYXRpb24gPSBSb3V0ZXIuSGFzaExvY2F0aW9uO1xuICAgICAgbG9jYXRpb24uYWRkQ2hhbmdlTGlzdGVuZXIoZnVuY3Rpb24oY2hhbmdlKSAge1xuICAgICAgICB0aGlzLnBhZ2VEYXRhID0gYXNzaWduKHt9LCBjaGFuZ2UsIGRldGVybWluZURvYyhjaGFuZ2UucGF0aCkpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgdGhpcy5wYWdlRGF0YSA9ICF3aW5kb3cuZG9jdW1lbnRcbiAgICAgICAgPyB7fVxuICAgICAgICA6IGFzc2lnbihcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcGF0aDogbG9jYXRpb24uZ2V0Q3VycmVudFBhdGgoKSxcbiAgICAgICAgICAgICAgdHlwZTogXCJpbml0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXRlcm1pbmVEb2MobG9jYXRpb24uZ2V0Q3VycmVudFBhdGgoKSlcbiAgICAgICAgICApO1xuXG4gICAgICBzY3JvbGxCZWhhdmlvciA9IHtcbiAgICAgICAgdXBkYXRlU2Nyb2xsUG9zaXRpb246IGZ1bmN0aW9uKHBvc2l0aW9uLCBhY3Rpb25UeXBlKSAge1xuICAgICAgICAgIHN3aXRjaCAoYWN0aW9uVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInB1c2hcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFnZURhdGEoKS5tZW1iZXJOYW1lXG4gICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgOiB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAgICAgICAgICBjYXNlIFwicG9wXCI6XG4gICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuc2Nyb2xsVG8oXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPyBwb3NpdGlvbi54IDogMCxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA/IHBvc2l0aW9uLnkgOiAwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgIH07XG4gICAgfVxuXG4gICAgUm91dGVyLmNyZWF0ZSh7XG4gICAgICByb3V0ZXM6IChcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZSwge2hhbmRsZXI6IERvY3VtZW50YXRpb24sIHBhdGg6IFwiL1wifSwgXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEZWZhdWx0Um91dGUsIHtoYW5kbGVyOiBEb2NEZXRlcm1pbmVyfSksIFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGUsIHtuYW1lOiBcInR5cGVcIiwgcGF0aDogXCIvOm5hbWVcIiwgaGFuZGxlcjogRG9jRGV0ZXJtaW5lcn0pLCBcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlLCB7XG4gICAgICAgICAgICBuYW1lOiBcIm1ldGhvZFwiLCBcbiAgICAgICAgICAgIHBhdGg6IFwiLzpuYW1lLzptZW1iZXJOYW1lXCIsIFxuICAgICAgICAgICAgaGFuZGxlcjogRG9jRGV0ZXJtaW5lcn1cbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICBzY3JvbGxCZWhhdmlvcjogc2Nyb2xsQmVoYXZpb3JcbiAgICB9KS5ydW4oZnVuY3Rpb24oSGFuZGxlcikgIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBoYW5kbGVyOiBIYW5kbGVyIH0pO1xuICAgICAgaWYgKHdpbmRvdy5kb2N1bWVudCkge1xuICAgICAgICB3aW5kb3cuZG9jdW1lbnQudGl0bGUgPSB0aGlzLnBhZ2VEYXRhLm5hbWVcbiAgICAgICAgICA/ICh0aGlzLnBhZ2VEYXRhLm5hbWUgKyBcIiDigJQgU2VxdWluc1wiKVxuICAgICAgICAgIDogXCJTZXF1aW5zIOKAlCBBUElcIjtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuICB9LFxuXG4gIC8vIFRPRE86IHJlcGxhY2UgdGhpcy4gdGhpcyBpcyBoYWNreSBhbmQgcHJvYmFibHkgd3JvbmdcblxuICBjb21wb25lbnREaWRNb3VudDpmdW5jdGlvbigpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgIHtcbiAgICAgIHRoaXMucGFnZURhdGEudHlwZSA9IFwiXCI7XG4gICAgfS5iaW5kKHRoaXMpLCAwKTtcbiAgfSxcblxuICBjb21wb25lbnREaWRVcGRhdGU6ZnVuY3Rpb24oKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpICB7XG4gICAgICB0aGlzLnBhZ2VEYXRhLnR5cGUgPSBcIlwiO1xuICAgIH0uYmluZCh0aGlzKSwgMCk7XG4gIH0sXG5cbiAgcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgIHZhciBIYW5kbGVyID0gdGhpcy5zdGF0ZS5oYW5kbGVyO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEhhbmRsZXIsIG51bGwpO1xuICB9XG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIGlzTW9iaWxlID1cbiAgd2luZG93Lm1hdGNoTWVkaWEgJiYgd2luZG93Lm1hdGNoTWVkaWEoXCIobWF4LWRldmljZS13aWR0aDogNjgwcHgpXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmYWxzZSAmJiAhIShpc01vYmlsZSAmJiBpc01vYmlsZS5tYXRjaGVzKTtcbiIsInZhciAkX18wPSAgICAgIHJlcXVpcmUoXCJpbW11dGFibGVcIiksU2VxPSRfXzAuU2VxLG1lcmdlPSRfXzAubWVyZ2UsbWVyZ2VXaXRoPSRfXzAubWVyZ2VXaXRoO1xuXG5mdW5jdGlvbiBtYWtlS2V5KHJvb3ROYW1lLCBuYW1lLCBrZXkpIHtcbiAgcmV0dXJuIG5hbWUgPT09IHJvb3ROYW1lID8ga2V5IDogKG5hbWUgKyBcIi5cIiArIGtleSk7XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5EZWYoZGVmLCBuYW1lLCByb290TmFtZSA9IG5hbWUpIHtcbiAgdmFyIGZsYXREZWYgPSBPYmplY3QuYXNzaWduKHt9LCBkZWYpO1xuICBpZiAoZmxhdERlZi5jYWxsKSB7XG4gICAgZmxhdERlZi5jb25zdHJ1Y3RvcnMgPSB7IFtuYW1lXTogZmxhdERlZi5jYWxsIH07XG4gICAgZGVsZXRlIGZsYXREZWYuY2FsbDtcbiAgfVxuXG4gIGRlbGV0ZSBmbGF0RGVmLm1vZHVsZTtcblxuICByZXR1cm4gbWVyZ2VXaXRoLmFwcGx5KG51bGwsIFtmdW5jdGlvbihhLCBiKSAge3JldHVybiBtZXJnZShhLCBiKTt9LFxuICAgIGZsYXREZWZdLmNvbmNhdChTZXEoZGVmLm1vZHVsZSlcbiAgICAgIC5tYXAoZnVuY3Rpb24oZGVmLCBrZXkpICB7XG4gICAgICAgIGNvbnN0IGZsYXREZWYgPSB7fTtcbiAgICAgICAgaWYgKGRlZi5jYWxsKSB7XG4gICAgICAgICAgaWYgKGRlZi5jYWxsLmRvYy5ub3Rlcy5maW5kKGZ1bmN0aW9uKG5vdGUpICB7cmV0dXJuIG5vdGUubmFtZSA9PT0gXCJjb25zdHJ1Y3RzXCI7fSkpIHtcbiAgICAgICAgICAgIGZsYXREZWYuY29uc3RydWN0b3JzID0geyBbbWFrZUtleShyb290TmFtZSwgbmFtZSwga2V5KV06IGRlZi5jYWxsIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZsYXREZWYuZnVuY3Rpb25zID0geyBbbWFrZUtleShyb290TmFtZSwgbmFtZSwga2V5KV06IGRlZi5jYWxsIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGF0RGVmO1xuICAgICAgfSlcbiAgICAgIC5jb25jYXQoXG4gICAgICAgIFNlcShkZWYubW9kdWxlKVxuICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oZGVmKSAge3JldHVybiBkZWYubW9kdWxlO30pXG4gICAgICAgICAgLm1hcChmdW5jdGlvbihkZWYsIGtleSkgXG4gICAgICAgICAgICB7cmV0dXJuIGZsYXR0ZW5EZWYoZGVmLCBtYWtlS2V5KHJvb3ROYW1lLCBuYW1lLCBrZXkpLCByb290TmFtZSk7fVxuICAgICAgICAgIClcbiAgICAgIClcbiAgICAgIC52YWx1ZVNlcSgpXG4gICAgICAudG9BcnJheSgpKSk7XG59XG5cbmZ1bmN0aW9uIGdldERpc3BsYXlUeXBlTmFtZShuYW1lLCB0eXBlTmFtZSkge1xuICByZXR1cm4gKG5hbWUgPT09IHR5cGVOYW1lID8gbmFtZSA6ICh0eXBlTmFtZSArIFwiLlwiICsgbmFtZSkpICsgXCIoKVwiO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZmxhdHRlbkRlZjpmbGF0dGVuRGVmLFxuICBnZXREaXNwbGF5VHlwZU5hbWU6Z2V0RGlzcGxheVR5cGVOYW1lXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5SZWFjdDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuU2VxdWlucztcbiJdfQ==
